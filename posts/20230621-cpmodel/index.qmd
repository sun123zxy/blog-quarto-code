---
title: "算法 & 数学碎碎念"
abstract: "现场赛公式模板库，亦可作为小而精的总结性学习材料参考．无需单独成文或暂不完善的内容会放在这里．"
author: "sun123zxy"
date: "2023/06/21"
date-modified: "2023/06/27"

categories:
  - OI
  - 数学

number-sections: true
---

::::: {.hidden}
::: {.content-hidden unless-format="html"}
$$
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\inv}{\operatorname{inv}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\Id}{\operatorname{Id}}
\newcommand{\card}{\operatorname{card}}
\newcommand{\diff}{\operatorname{d}\!}
$$
:::
::: {.content-hidden when-format="html"}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\inv}{\operatorname{inv}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\Id}{\operatorname{Id}}
\newcommand{\card}{\operatorname{card}}
\newcommand{\diff}{\operatorname{d}\!}
:::
:::::

## 数论

### ExGCD

:::{#thm-exgcd}

## ExGCD

给定线性方程组 $ax+by=\gcd(a,b)$，其解可递归地由下式求得
$$
a y_1 + b \left( x_1 - \floor{\frac a b} y_1 \right) = \gcd(b, a \bmod b)
$$
其中 $x_1, y_1$ 是 $b x + (a \bmod b) y = \gcd(b, a \bmod b)$ 的一组解．
:::

### CRT

:::{#thm-crt}

## CRT

给定 $n$ 个同余方程
$$
x \equiv a_i \pmod{m_i} \pod{i = 1, \dots, n}
$$

其中各 $m_i$ 两两互质，则上式等价于
$$
x \equiv \sum_{i=1}^n a_i M_i \inv_{m_i}(M_i) \pmod M
$$
其中 $M = \sum_{i=1}^n m_i$，$M_i = \frac{M}{m_i}$．
:::

::: {.remark}
$$
M_i \inv_{m_i}(M_i) \mod m_j = [i = j]
$$
:::

#### ExCRT

对一般的情况，考虑合并两个同余方程．给定 $2$ 个同余方程
$$
\left\{
\begin{aligned}
  x &\equiv a_1 \pmod{m_1} \\
  x &\equiv a_2 \pmod{m_2}
\end{aligned}
\right.
$$
考虑化为不定方程形式
$$
\begin{aligned}
  x = k_1 m_1 + a_1 \\
  x = k_2 m_2 + a_2
\end{aligned}
$$
合并得到
$$
k_1 m_1 + a_1 = k_2 m_2 + a_2
$$
即
$$
k_1 m_1 + k_2 m_2 = a_2 - a_1
$$
此即关于 $k_1, k_2$ 的不定方程．若 $\gcd(m_1, m_2) \mid a_2 - a_1$，则可应用 ExGCD 求得方程的一组解，带回即得
$$
x \equiv k_1 m_1 + a_1 \pmod{\lcm(m_1, m_2)}
$$
否则同余方程组无解．

:::{.remark}
若一组同余方程两两可合并，则全部均可合并．当判断大规模同余方程组是否有解时可能用到．
:::

### BSGS

求 $a^x \equiv b \pmod{p}$ 的一个特解，其中 $\gcd(a,p) = 1$．

实质是非常暴力的根号分治．时间复杂度 $O(\sqrt p)$．

```c++
ll BSGS(ll a,ll b){
    map<ll,bool> mp;
	ll cur=1,sqrtM=ceil(sqrt(MOD));
	for(ll bi=1;bi<=sqrtM;bi++){
		cur=cur*a%MOD;
		mp[b*cur%MOD]=bi;
	}
	ll nw=cur;
	for(ll ai=1;ai<=sqrtM;ai++){
		if(mp[nw]) return ai*sqrtM-mp[nw];
		nw=nw*cur%MOD;
	}
	return -1;
}
```

## 积性函数

### 整除分块

```c++
ll ans=0;
for(ll l=1,r,d;l<=N;l=r+1){
    d=N/l, r=N/d;
    ans+=(S_mu(r)-S_mu(l-1))*d;
}
```

#### 上取整整除分块

```c++
ll cdiv(ll a,ll b){ //ceil(a/b)
	return (a<0||a%b==0)?a/b:a/b+1;
}
ll ans=0;
for(ll l,r=N,d;r>=1;r=l-1){
    d=cdiv(N,r), l=cdiv(N,d);
    ans+=(S_mu(r)-S_mu(l-1))*d;
}
```

### 杜教筛

设 $f$ 为一数论函数，我们希望快速求得其前缀和 $\hat f (n) = \sum_{i=1}^n f(i)$. 考虑数论函数 $g$ 和 $h = g * f$，
$$
h(n) = \sum_{d \mid n} g(d) f(\frac n d)
$$
两端做前缀和得
$$
\begin{aligned}
\hat h (n)
&= \sum_{i=1}^n h(i) \\
&= \sum_{i=1}^n \sum_{d \mid i} g(d) f(\frac i d) \\
&= \sum_{d=1}^n g(d) \sum_{i=1}^{\floor{\frac n d}} f(i) \\
&= \sum_{d=1}^n g(d) \hat f (\floor{\frac n d}) \\
&= g(1) \hat f (n) + \sum_{d=2}^n g(d) \hat f (\floor{\frac n d})
\end{aligned}
$$
因此
$$
\hat f (n) = \frac 1 {g(1)} \left( \hat h (n) - \sum_{d=2}^n g(d) \hat f (\floor{\frac n d}) \right)
$$

故若 $g$、$h$ 的前缀和可 $O(1)$ 算得，根据上式整除分块即可递归地计算出 $f$ 的前缀和．预处理前 $O(n^{2/3})$ 项并记忆化得到的时间复杂度为 $O(n^{2/3})$．外层整除分块不会增加时间复杂度．

关于时间复杂度证明可参考 [sun123zxy’s blog - OI 数论中的上界估计与时间复杂度证明 # 杜教筛](https://blog.sun123zxy.top/posts/20230418-complexity/#%E6%9D%9C%E6%95%99%E7%AD%9B)．

$$
\begin{aligned}
&f = \mu, g = I, h = \varepsilon \\
&f = \varphi, g = I, h = \Id
\end{aligned}
$$

```c++
unordered_map<ll,ll> s_mu;
ll S_mu(ll n){
	if(n<=MXG){
		return mu[n]; // already accumulated
	}else if(s_mu.count(n)){
		return s_mu[n];
	}
	ll ans=0;
	for(ll l=2,r,d;l<=n;l=r+1){
		d=n/l,r=n/d;
		ans+=S_mu(d)*(r-l+1);
	}
	return s_mu[n]=1-ans;
}
```

## 组合

### 容斥 / 二项式反演

#### 形式一

容斥原理的第一种形式给出了“子集和变换”的逆变换．

::: {#thm-inex-first-set}

## 容斥原理，形式一，集合

$$
g(S) = \sum_{T \subset S} f(T) \iff f(S) = \sum_{T \subset S} (-1)^{|S| - |T|} g(T)
$$
:::

证明的关键是 $\sum_{k=0}^n \binom n k (-1)^k = (1-1)^n = [n=0]$．

::: {#thm-inex-first-binomial}

## 容斥原理，形式一，二项式

$$
g(n) = \sum_{k=0}^n \binom n k f(k) \iff f(n) = \sum_{k=0}^n (-1)^{n-k} \binom n k g(k)
$$

若设 $F(x)$ 和 $G(x)$ 分别为 $f(n)$ 和 $g(n)$ 的指数型生成函数（EGF），则结论可等价地表示为

$$
G(x) = e^x F(x) \iff F(x) = e^{-x} G(x)
$$
:::

#### 形式二

形式一的补集形式，给出了全集 $U$ 下“超集和变换”的逆变换．通常在“至少选若干个指定元素的方案数”易求的情况下使用．

::: {#thm-inex-second-set}

## 容斥原理，形式二，集合

$$
g(S) = \sum_{S \subset T \subset U} f(T) \iff f(S) = \sum_{S \subset T \subset U} (-1)^{|T| - |S|} g(T)
$$
:::

我们最常见到的“容斥原理”
$$
\card \left( \bigcup_{i \in U} A_i \right) = \sum_{k=1}^{|U|} (-1)^{k-1} \sum_{i_1 < \dots < i_k} \card \left( A_{i_1} \cap \dots \cap A_{i_k} \right)
$$
就是该形式的一个应用．只需令
$$
\begin{gathered}
f(S) = \card \left( \left( \bigcap_{i \in S} A_i \right) - \left( \bigcup_{i \notin S} A_i \right) \right) \\
g(S) = \card \left( \left( \bigcup_{i \in U} A_i \right) \cap \left( \bigcap_{i \in S} A_i \right)\right)
= \begin{cases}
\card \left( \bigcup_{i \in U} A_i \right) & S = \varnothing \\
\card \left( \bigcap_{i \in S} A_i \right) & \text{otherwise}
\end{cases}
\end{gathered}
$$
容易验证 @thm-inex-second-set 的 LHS 成立，故 RHS 亦成立．取 RHS 中 $S=\varnothing$，就有
$$
\begin{aligned}
0 = f(\varnothing) &= \sum_{T \subset U} (-1)^{|T|} g(T) \\
&= g(\varnothing) + \sum_{k=1}^{|U|} (-1)^k \sum_{|T|=k} g(T) \\
&= \card \left( \bigcup_{i \in U} A_i \right) + \sum_{k=1}^{|U|} (-1)^k \sum_{i_1 < \dots < i_k} \card \left( A_{i_1} \cap \dots \cap A_{i_k} \right)
\end{aligned}
$$
移项即得到常见的“容斥原理”．

::: {#thm-inex-second-binomal}

## 容斥原理，形式二，二项式
$$
g(n) = \sum_{k=0}^{N-n} \binom {N-n} k f(n+k) \iff f(n) = \sum_{k=0}^{N-n} (-1)^k \binom {N-n} k g(n+k)
$$
:::

### Lucas 定理

::: {#thm-lucas}

## Lucas 定理

$$
\binom{n}{m} \equiv \prod_{i} \binom{n_i}{m_i} \equiv \binom{\floor{n/p}}{\floor{m/p}} \binom{n \bmod p}{n \bmod p} \pmod p
$$

其中 $p$ 是质数，$n_i$ 和 $m_i$ 是 $n$ 和 $m$ 的 $p$ 进制表示各数位．
:::

证明的要点在于 $\binom {p^i} m \bmod {p} = [m = 0 \land m = p^i]$ 和 Vandermonde 卷积，生成函数食用风味更佳．

参考：

- [卢卡斯定理 - OI Wiki](https://oi-wiki.org/math/number-theory/lucas/)
- [Lucas's theorem - Wikipedia](https://en.wikipedia.org/wiki/Lucas%27s_theorem)

### 矩阵树定理

#### 无向图的情形

对无向图，度数矩阵 $D = \operatorname{diag} \{ \operatorname{deg}(i) \}$，邻接矩阵 $A$ 定义为
$$
A_{i,j} = \begin{cases}
0 & i=j \\
e(i,j) & i \neq j
\end{cases}
$$
其中 $e(i,j)$ 表示点 $i$ 到点 $j$ 的边的数量（对无向图，$e(i,j) = e(j,i)$）．

定义 Laplace 矩阵（Kirchhoff 矩阵）$L=D-A$．

Laplace 矩阵有性质 $L= B B^T$，其中关联矩阵 $B$ 按如下方式定义
$$
B_{i,j} = \begin{cases}
1 & \text{node $i$ is the ID-smaller endpoint of edge $j$} \\
-1 & \text{node $i$ is the ID-larger endpoint of edge $j$} \\
0 & \text{otherwise}
\end{cases}
$$

这里 $1$ 与 $-1$ 的引入完成了一种对边的“手动定向”，其用途将在后文介绍．

:::{#thm-mattree-nondirected}

## 矩阵树定理，无向图

$n$ 点无向图的生成树的个数与该图的 Laplace 矩阵 $L$ 的任意主子式的值相等．其也与 $L$ 所有 $n-1$ 个非零特征值乘积的 $\frac 1 n$ 倍相等．
:::

Laplace 矩阵同行的代数余子式均相等（这性质由行和为 $0$ 得到），因此去掉任意一行一列均可得到正确的无向图生成树计数．此外，由于 $L = B B^T$ 至少半正定，$L$ 的所有特征值非负．

证明的要点在于对 $L = B B^T$ 的某个主子式（一般选择去掉第一行第一列）应用 Cauchy-Binet 公式，随后说明行列式的组合意义中，环的情况一定相互抵消．关于特征值的结论可从特征多项式、各 $n-1$ 阶主子式与韦达定理的关系中得到（依此方法能进一步得到有关 $k$ - 生成森林的一些结论）．

事实上，去掉第 $i$ 行第 $i$ 列，即是统计以 $i$ 为根的根向生成树的数量．先前定义关联矩阵 $B$ 时“手动定向”，是为了使换向过程中环的情况相互抵消，只留下树的唯一一种情况．当然，因为是无向图，这里树的朝向和根的具体位置并不重要．

#### 有向图的情形

对有向图，我们明确统计的对象为根向（或叶向）生成树的数量．根向树形图与出度 Laplace 矩阵相关，$L^{out} = D^{out} - A$，其中 $D^{out}$ 是出度矩阵．

为体现有向图的要求，出度 Laplace 矩阵对应的关联矩阵需要一些修改．令矩阵 $B$ 满足
$$
B_{i,j} = \begin{cases}
1 & \text{node $i$ is the head of edge $j$} \\
0 & \text{otherwise}
\end{cases}
$$
矩阵 $C$ 满足
$$
C_{i,j} = \begin{cases}
1 & \text{node $i$ is the head of edge $j$} \\
-1 & \text{node $i$ is the tail of edge $j$} \\
0 & \text{otherwise}
\end{cases}
$$
则出度 Laplace 矩阵满足性质 $L^{out} = B C^T$．我们构造的矩阵 $B$ 体现了对出边方向的要求，在此基础上矩阵 $C$ 进一步完成了“手动定向”的工作．

:::{#thm-mattree-rootwise}

## 矩阵树定理，根向树形图

$n$ 点有向图以 $i$ 为根的生成根向树形图的数量与该图出度 Laplace 矩阵 $L^{out}$ 去掉第 $i$ 行第 $i$ 列的 $n-1$ 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 $L^{out}$ 的所有 $n-1$ 个非零特征值的乘积相等．
:::

由于 $L^{out}$ 的行和仍为 $0$，其同行代数余子式仍然相等．

关于叶向树形图，我们有类似的结论：

:::{#thm-mattree-leafwise}

## 矩阵树定理，叶向树形图

$n$ 点有向图以 $i$ 为根的生成叶向树形图的数量与该图入度 Laplace 矩阵 $L^{in}$ 去掉第 $i$ 行第 $i$ 列的 $n-1$ 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 $L^{in}$ 的所有 $n-1$ 个非零特征值的乘积相等．
:::

由于 $L^{in}$ 的列和（而非行和）为 $0$，其同列（而非同行）代数余子式均相等．

更多内容，参考

- [Laplacian matrix - Wikipedia](https://en.wikipedia.org/wiki/Laplacian_matrix)
- [矩阵树定理 - OI Wiki](https://oi-wiki.org/graph/matrix-tree/)
- [Kirchhoff's theorem - Wikipedia](https://en.wikipedia.org/wiki/Kirchhoff's_theorem)

## 多项式

### 通用

```c++
// polynomial universal, 2023/06/27
const ll MOD=998244353,PR=3;
#define _ %MOD
// ... (MOD, qpow, inv, etc.)
vector<ll> rev;
void spawn_rev(ll n){ // n=log2(N)
	rev.resize(1<<n);
	rev[0]=0; for(ll i=1;i<(1<<n);i++) rev[i]=(rev[i>>1]>>1)+((i&1)<<(n-1));
}
class Poly : public vector<ll>{ public:
    using vector<ll>::vector; // constructor
    ll len() const {return size();} // to avoid strange glitches caused by size_t
	ll get(ll idx) const {return *(cbegin()+idx);} // const version of operator []
	Poly subpoly(ll pos = 0,ll count = -1) const { // imitate std::string::substr with resize
		if(count==-1) return Poly(begin()+pos,end());
		Poly B(begin()+min(pos,len()),begin()+min(pos+count,len()));
		B.resize(pos+count); return B;
	}
	void debug() const {cout<<len()<<": "; for(ll i=0;i<len();i++) cout<<at(i)<<","; cout<<endl;}
};
Poly operator + (Poly A,Poly B){
	ll n=max(A.len(),B.len()); A.resize(n); B.resize(n);
	for(ll i=0;i<n;i++) lmodp(A[i]+=B.get(i));
	return A;
}
Poly operator - (Poly A){
	for(ll i=0;i<A.len();i++) A[i]=lmodv(-A[i]);
	return A;
}Poly operator - (const Poly& A,const Poly &B){return A+(-B);}
Poly operator * (Poly A,ll c){
	for(ll i=0;i<A.len();i++) A[i]=A[i]*c _;
	return A;
}
Poly operator << (Poly A,ll shift){
	ll n=A.len(); A.resize(n+shift);
	for(ll i=n-1;i>=0;i--) A[i+shift]=A[i];
	for(ll i=shift-1;i>=0;i--) A[i]=0;
	return A;
}
Poly operator >> (Poly A,ll shift){
	ll n=A.len()-shift; if(n<=0) return Poly(1,0);
	for(ll i=0;i<n;i++) A[i]=A[i+shift];
	A.resize(n); return A;
}
Poly drv(Poly A){ // derivative
	for(ll i=0;i<A.len();i++) A[i]=(i+1)*A[i+1]_;
	A.pop_back(); return A;
}
Poly itg(Poly A,ll c){ // integral
	A.push_back(0);
	for(ll i=A.len();i>=1;i--) A[i]=A[i-1]*inv(i)_;
	A[0]=c; return A;
}
```

### FFT / FNTT / 卷积

- DFT：（本原）单位根构造 $\omega_n = e^{\frac {2 \pi}{n}i}$．

- NTT：$P=998244353 = 7 \times 17 \times 2^{23} + 1$，$\mathrm{PR} = 3$ 是它的一个原根．（本原）单位根构造 $\omega_{n} = \mathrm{PR}^{\frac{P-1}{n}} \bmod P$．

考虑将待变换多项式
$$
A(x) = \sum_{k=0}^{2n} a_k x^k
$$
奇偶分项为两个多项式
$$
A(x) = A_0 (x^2) + x A_1(x^2)
$$
其中
$$
\begin{aligned}
A_0 (x) &= \sum_{k=0}^n a_{2k} x^k \\
A_1 (x) &= \sum_{k=0}^n a_{2k+1} x^k
\end{aligned}
$$
代入 $x = \omega_{2n}^k \pod{k = 0,\dots, 2n-1}$，用单位根折半性质（$\omega_{2n}^{2k} = \omega_n^k$）
$$
A(\omega_{2n}^k) = A_0 (\omega_{n}^k) + \omega_{2n}^k A_1 (\omega_{n}^k)
$$
再用单位根消去性质（$\omega_{2n}^{n+k} = - \omega_{2n}^k$）
$$
\begin{aligned}
A(\omega_{2n}^k) &= A_0 (\omega_n^k) + \omega_{2n}^k A_1 (\omega_n^k) \\
A(\omega_{2n}^{n+k}) &= A_0 (\omega_n^k) - \omega_{2n}^k A_1(\omega_n^k) 
\end{aligned}
\pod{k = 0, \dots, n-1}
$$
即得 FFT/FNTT 递归算法．用单位根求和性质
$$
\frac 1 n \sum_{k=0}^{n-1} \omega^{ik} = [i \mid n]
$$
可知 DFT/NTT 变换矩阵 $F = \begin{pmatrix}\omega_{n}^{ij}\end{pmatrix}_{(i,j) \in n \times n}$ 满足 $F F^H = F^H F = n I_n$，故 $F^{-1} = \frac 1 n F^H = \begin{pmatrix} \frac 1 n \omega_{n}^{-ij}\end{pmatrix}_{(i,j) \in n \times n}$，此即 DFT/NTT 逆变换矩阵．

#### 蝶形运算与迭代算法

为使用迭代算法，需要快速得到递归算法向下深入过程中 $\{ a_n \}$ 置换后的最终结果．观察知该置换是位逆序置换，可线性求出．故可实现如下迭代算法（连带实现卷积运算）

```c++
vector<ll> rev;
void spawn_rev(ll n){ // n=log2(N)
	rev.resize(1<<n);
	rev[0]=0; for(ll i=1;i<(1<<n);i++) rev[i]=(rev[i>>1]>>1)+((i&1)<<(n-1));
}
class Poly : public vector<ll>{ public:
	// ... (Poly defaults)
	void DFT(ll typ){ // to be called by operator * only (with proper length and rev array)
		ll n=len();
		for(ll i=0;i<n;i++) if(i<rev[i]) std::swap(at(i),at(rev[i]));
		for(ll hf=1;hf<n;hf*=2){
			ll w=qpow(PR,(MOD-1)/(hf*2));
			if(typ==-1) w=inv(w);
			for(ll i=0;i<n;i+=hf*2){
				ll wk=1;
				for(ll k=0;k<hf;k++){
					ll x=at(i+k),y=wk*at(i+hf+k)_;
					at(i+k)=lmodv(x+y);
					at(i+hf+k)=lmodv(x-y);
					wk=wk*w _;
				}
			}
		}
		if(typ==-1){
			ll inv_n=inv(n); for(ll i=0;i<n;i++) at(i)=at(i)*inv_n _;
		}
	}
};
Poly operator * (Poly A,Poly B){
	ll c_len=A.len()+B.len()-1;
	ll n=ceil(log2(c_len)); spawn_rev(n); n=1<<n;
	Poly C(n); A.resize(n); B.resize(n);
	A.DFT(1); B.DFT(1);
	for(ll i=0;i<n;i++) C[i]=A[i]*B[i]_;
	C.DFT(-1); C.resize(c_len);
	return C;
}
```

### 多项式方程求解（Newton 迭代法）【TODO】

给定一多项式 $A(x)$，求解满足 $A(B(x)) = 0 \pmod{x^n}$ 的多项式 $B(x)$．

显然 $B(x)$ 只有前 $n$ 项有效．目前我们尚不清楚解的存在性、唯一性等性质，但注意到
$$
A(B(x)) = 0 \pmod{x^{2n}} \implies A(B(x)) = 0 \pmod{x^n}
$$
故考虑递推求解．首先，边界条件 $A(b_0) = 0$ 需要单独求解．在这些解的基础上，我们开始递推．考虑已经获得 $A(B(x)) = 0 \pmod{x^n}$ 的一个解 $B(x) = B_0(x)$，我们尝试得到方程 $A(B(x)) = 0 \pmod{x^{2n}}$ 的解．

将待求解方程 $A(B(x)) = 0 \pmod{x^{2n}}$ 左式多项式 $A$ 在 $B_0$ 处 Taylor 展开
$$
\begin{multline}
A(B(x)) = A(B_0(x)) + A'(B_0(x)) (B(x)-B_0(x)) \\ + \frac{A''(B_0(x))}{2!} (B(x)-B_0(x))^2 + \dots
= 0 \pmod{x^{2n}}
\end{multline}
$$
注意到 $B(x)-B_0(x)$ 任意项的次数都不低于 $x^n$，故模 $x^{2n}$ 意义下二次方以上的项可以舍去，故上式化为
$$
A(B_0(x)) + A'(B_0(x)) (B(x)-B_0(x)) = 0 \pmod{x^{2n}}
$$
移项即可解出待求 $B(x)$
$$
B(x) =  B_0(x) - \frac{A(B_0(x))}{A'(B_0(x))} \pmod{x^{2n}}
$$
这里要求 $A'(B_0(x))$ 需在 $x^{2n}$ 意义下可逆，即
$$
\begin{multline}
[x^0] A'(B_0(x)) = [x^0] A'(b_0) = \\ \sum_{k=0}^\infty \left( [x^k] A' \right) b_0^k = \sum_{k=0}^\infty (k+1) a_{k+1} b_0^k \neq 0 \pmod{x^{2n}}
\end{multline}
$$
若上述要求得到满足，根据递推过程，在边界条件 $b_0$ 确定的情况下，满足方程的 $B(x)$ 在模意义下唯一．【TODO：详细讨论边界条件不友好的情况】

Newton 迭代法作为通用求解框架，可涵盖几乎所有多项式初等运算．【TODO】

### 多项式求逆

给定一多项式 $A(x)$，求解满足 $A(x) B(x) = 1 \pmod{x^{n}}$ 的多项式 $B(x)$．

多项式逆元存在的充分必要条件是其常数项非零（这是因为边界条件 $b_0 = \frac 1 {a_0}$），若存在则在模意义下一定唯一．这结论可直接由下述求解方法得到．不失一般性，我们只研究 $A(x)$ 的次数为奇数 $2n-1$ 的情况．设
$$
\begin{aligned}
A(x) &= A_0(x) + x^n A_1(x) \\
B(x) &= B_0(x) + x^n B_1(x)
\end{aligned}
$$
下述两种方法均递归地在已知
$$
A(x) B_0(x) = A_0(x) B_0(x) = 1 \pmod{x^n}
$$
的基础上求解 $A(x)$ 的逆元．时间复杂度均为
$$
T(n) = T(\frac n 2) + O(n \log n) = O(n \log n)
$$

以下简记 $A(x)$ 为 $A$，其它多项式同理．

#### 倍增法一（原创）

$$
\begin{aligned}
& A B = 1 \pmod{x^{2n}} \\
\iff& (A_0 + x^n A_1)(B_0 + x^n B_1) = 1 \pmod{x^{2n}} \\
\iff& x^n(A_1 B_0 + A_0 B_1) + A_0 B_0 = 1 \pmod{x^{2n}} \\
\iff& A_1 B_0 + A_0 B_1 + \floor{\frac{A_0 B_0}{x^n}} = 0 \pmod{x^{n}} \\
\iff&  A_0 B_1 = -\floor{\frac{A_0 B_0}{x^n}} - A_1 B_0 \pmod{x^{n}} \\
\iff&  B_1 = - B_0 \left( \floor{\frac{A_0 B_0}{x^n}} + A_1 B_0 \right) \pmod{x^{n}}
\end{aligned}
$$

常数偏大．

```c++
Poly inv(const Poly &A){
	ll n=A.len(); Poly B(1); B[0]=inv(A[0]);
	for(ll hf=1;hf<n;hf<<=1){
		const Poly &A0=A.subpoly(0,hf),&A1=A.subpoly(hf,hf);
		const Poly &B0=B; Poly B1=-B0*((A1*B0).subpoly(0,hf)+(A0*B0).subpoly(hf,hf));
		B.insert(B.end(),B1.begin(),B1.begin()+hf);
	} B.resize(n);
	return B;
}
```

#### 倍增法二

注意到
$$
\begin{cases}
A B_0 = 1 \pmod{x^n} \\
A B = 1 \pmod{x^n}
\end{cases} \implies A (B-B_0) = 0 \pmod{x^n}
$$
由于 $A \bmod{x^n}$ 非零，故
$$
B-B_0 = 0 \pmod{x^n}
$$
（这证明了逆元在不同模数下的前缀保持一致）

两边平方得
$$
B^2 - 2 B B_0 + B_0^2 = 0 \pmod{x^{2n}}
$$
两侧同乘 $A$ 并移项得
$$
B = 2 B_0 - A B_0^2 \pmod{x^{2n}}
$$

```c++
Poly inv(const Poly &A){
	ll n=A.len(); Poly B(1); B[0]=inv(A[0]);
	for(ll hf=1;hf<n;hf<<=1){
		B=B*2-B*B*A.subpoly(0,hf*2); B.resize(hf*2);
	} B.resize(n);
	return B;
}
```

### 多项式开方【TODO】

和多项式求逆类似的推导可得递推方程
$$
B = \frac 1 2 \left(\frac A {B_0} + B_0 \right) \pmod{x^{2n}}
$$
有一些和 Newton 法一样麻烦的边界条件讨论，也会出现复杂的多解情况．$a_0 = 1$ 时 $b_0 = \pm 1$，按 $b_0 = 1$ 的实现如下．

```c++
Poly sqrt(const Poly &A){
	ll n=A.len(); Poly B(1); B[0]=1; // assume a_0 = 1 and b_0 positive
	for(ll hf=1;hf<n;hf<<=1){
		B=(A.subpoly(0,2*hf)*inv(B.subpoly(0,2*hf))+B)*inv(2); B.resize(hf*2);
	} B.resize(n);
	return B;
}
```

亦可 $\sqrt A = \exp \left( \frac 1 2 \ln A \right)$，此法可处理多项式任意幂指数运算．

### 多项式 $\ln$

给定一多项式 $A(x)$，求解满足 $B(x) = \ln A(x) \pmod{x^{n}}$ 的多项式 $B(x)$．

次数为 $+\infty$ 的多项式 $\ln$ 存在的充分必要条件为其常数项非零（这是因为边界条件 $b_0 = \ln a_0$），同样一旦存在则唯一．注意到仅整数 $a_0=1$ 时，$\ln a_0$ 可取得整数，故合理的 $a_0$ 只能是 $1$．另一种解释参见[多项式初等函数 - OI Wiki # 多项式对数函数 & 指数函数](https://oi-wiki.org/math/poly/elementary-func/#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0--%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0)．

推导是容易的．方程两侧同时求导得
$$
B'(x) = \frac{A'(x)}{A(x)} \pmod{x^{n-1}}
$$
两侧再积分得
$$
B(x) = \int \frac{A'(x)}{A(x)} \diff x + C \pmod{x^{n}}
$$
其中 $C= \ln a_0$．多项式求逆、求导、积分即可．时间复杂度 $O(n \log n)$．

```c++
Poly ln(const Poly &A){
	return itg((drv(A)*inv(A)).subpoly(0,A.len()-1),1/*log(A[0])*/);
}
```

### 多项式 $\exp$ 【TODO】

Newton 迭代法可推出
$$
B = B(1 - \ln B_0 + A) \pmod{x^{2n}}
$$
时间复杂度
$$
T(n) = T(\frac n 2) + O(n \log n) = O(n \log n)
$$

```c++
Poly exp(const Poly &A){
	ll n=A.len(); Poly B(1); B[0]=1/*exp(A[0])*/;
	for(ll hf=1;hf<n;hf<<=1){
		B=B*(Poly(1,1)-ln(B.subpoly(0,hf*2))+A.subpoly(0,hf*2)); B.resize(hf*2);
	} B.resize(n);
	return B;
}
```

## 集合幂级数【TODO】

## 矩阵【TODO】

## 通用

### 基础模板

```c++
//general model 2023/06/26
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

namespace safe{
    ll rd(){
        ll ans=0; bool sgn=0; char c=getchar();
        while(c<'0'||c>'9'){if(c=='-') sgn=1; c=getchar();}
        while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
        if(sgn) ans=-ans; return ans;
    }
    const ll MOD=;
    #define _ %MOD
    ll lmodv(ll x){
        if(x<0) x+=MOD;
        else if(x>=MOD) x-=MOD;
        return x;
    }void lmodp(ll &x){x=lmodv(x);}
    ll mmodv(ll x){
        return x%MOD;
    }void mmodp(ll &x){x=mmodv(x);}
    ll hmodv(ll x){
        return (x%MOD+MOD)%MOD;
    }void hmodp(ll &x){x=hmodv(x);}
    ll qpow(ll x,ll up){
        hmodp(x); ll ans=1;
        while(up){
            if(up&1) ans=ans*x _;
            x=x*x _; up>>=1;
        }return ans;
    }
    ll inv(ll x){return qpow(x,MOD-2);}
    
    void entry(){}
}
int main(){
    //freopen("t1.in","r",stdin);
    //freopen("t1.out","w",stdout);
    //ll T=safe::rd(); while(T--){
    safe::entry();
    //}
    return 0;
}
```

### 对拍

```batch
:loop
    make.exe>data.in
    my.exe<data.in>my.out
    std.exe<data.in>std.out
    fc my.out std.out
    if not errorlevel 1 goto loop
pause
```
