<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>sun123zxy&#39;s blog</title>
<link>https://blog.sun123zxy.top/index.html</link>
<atom:link href="https://blog.sun123zxy.top/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.3.450</generator>
<lastBuildDate>Sat, 20 Jan 2024 16:00:00 GMT</lastBuildDate>
<item>
  <title>矩阵代数的 Burnside 定理</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20240121-burnside/index.html</link>
  <description><![CDATA[ 



<p>我们详细重述并证明 <span class="citation" data-cites="radjavi_simultaneous_2000">[1, Sec. 1.2]</span> 中的 Burnside 定理及其相关推论．</p>
<p>下面设 <img src="https://latex.codecogs.com/png.latex?V"> 是复数域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20C"> 上的有限维线性空间，<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 是 <img src="https://latex.codecogs.com/png.latex?V"> 上的线性变换代数；<img src="https://latex.codecogs.com/png.latex?I"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的单位元．</p>
<p>Burnside 定理证明较长．为使逻辑顺畅，先做一些准备工作．</p>
<div id="lem-cyclic-vector" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1 </strong></span>设 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的乘法半群，若 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 不可约，则对任意非零的 <img src="https://latex.codecogs.com/png.latex?x%20%5Cin%20V">，都有 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20x%20:=%20%5C%7B%20Ax%20:%20A%20%5Cin%20%5Cmathcal%20A%20%5C%7D%20=%20V">（此时称 <img src="https://latex.codecogs.com/png.latex?x"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 的循环向量）．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>首先 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20%5Cneq%20%5C%7B%200%20%5C%7D">，因为任何 <img src="https://latex.codecogs.com/png.latex?V"> 的子空间都是后者的不变子空间．</p>
<ul>
<li>注意到 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BKer%7D%5Cmathcal%20A%20:=%20%5Cbigcap_%7BA%20%5Cin%20%5Cmathcal%20A%7D%20%5Coperatorname%7BKer%7DA"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 的一个不变子空间，而 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 不可约，故 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BKer%7D%5Cmathcal%20A%20=%20%5C%7B%200%20%5C%7D"> 或 <img src="https://latex.codecogs.com/png.latex?V">．因为 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20%5Cneq%20%5C%7B0%5C%7D">，后者不可能发生，故 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BKer%7D%5Cmathcal%20A%20=%20%5C%7B%200%20%5C%7D">．</li>
<li>注意到 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20x%20:=%20%5C%7B%20A%20x%20:%20A%20%5Cin%20%5Cmathcal%20A%20%5C%7D"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 的一个不变子空间，而 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 不可约，故 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20x%20=%20%5C%7B%200%20%5C%7D"> 或 <img src="https://latex.codecogs.com/png.latex?V">．由 <img src="https://latex.codecogs.com/png.latex?x%20%5Cneq%200"> 和 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BKer%7D%5Cmathcal%20A%20=%20%5C%7B%200%20%5C%7D">，前者不可能发生，故 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20x%20=%20V">．</li>
</ul>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>事实上 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上半群的可约性等价于其线性生成的代数的可约性，见 <span class="citation" data-cites="radjavi_simultaneous_2000">[1], Definition 2.1.1</span>．</p>
</div>
<div id="cor-cyclic-vector-dual" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 </strong></span>设 <img src="https://latex.codecogs.com/png.latex?V%5E*"> 是 <img src="https://latex.codecogs.com/png.latex?V"> 的对偶空间．设 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的乘法半群，<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%5E*%20:=%20%5C%7BA%5E*%20:%20A%20%5Cin%20%5Cmathcal%20A%20%5C%7D"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 的对偶线性变换构成的集合（显然它也是个半群）．若 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 不可约，则对任意非零的线性函数 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi%20%5Cin%20V%5E*">，都有 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%5E*%20%5Cvarphi%20:=%20%5C%7B%20A%5E*%20%5Cvarphi%20:%20A%5E*%20%5Cin%20%5Cmathcal%20A%5E*%20%5C%7D%20=%20%5C%7B%20%5Cvarphi%20A%20:%20A%20%5Cin%20%5Cmathcal%20A%20%5C%7D%20=%20V%5E*">．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>定义 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%5E*%20%5Cvarphi"> 的 annihilator <img src="https://latex.codecogs.com/png.latex?(%5Cmathcal%20A%5E*%20%5Cvarphi)%5E0%20:=%20%5C%7B%20x%5E%7B**%7D%20%5Cin%20V%5E%7B**%7D%20:%20(%5Cmathcal%20A%5E*%20%5Cvarphi)(x)%20=%200%20%5C%7D">．由 <img src="https://latex.codecogs.com/png.latex?%5Cdim%20(A%5E*%20%5Cvarphi)%5E0%20=%20%5Cdim%20V%5E*%20-%20%5Cdim%20(A%5E*%20%5Cvarphi)"> <span class="citation" data-cites="axler_linear_2015">见 [2, Sec. 3F]</span>， <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathcal%20A%5E*%20%5Cvarphi%20=%20V%5E*%0A&amp;%5Ciff%20%5Cdim%20(%5Cmathcal%20A%5E*%20%5Cvarphi)%20=%20%5Cdim%20V%5E*%20%5C%5C%0A&amp;%5Ciff%20%5Cdim%20(%5Cmathcal%20A%5E*%20%5Cvarphi)%5E0%20=%200%20%5C%5C%0A&amp;%5Ciff%20(%5Cmathcal%20A%5E*%20%5Cvarphi)%5E0%20=%20%5C%7B0%5C%7D%0A%5Cend%7Baligned%7D%0A"> 由 annihilator 的定义和 Lemma&nbsp;1， <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A(%5Cmathcal%20A%5E*%20%5Cvarphi)%5E0%20=%20%5C%7B0%5C%7D%0A&amp;%5Ciff%20(%5Cmathcal%20A%5E*%20%5Cvarphi)%20x%20%5Cneq%20%5C%7B0%5C%7D,%5Cquad%20%5Cforall%20x%20%5Cneq%200%20%5C%5C%0A&amp;%5Ciff%20%5Cvarphi%20%5Cmathcal%20A%20x%20%20%5Cneq%20%5C%7B0%5C%7D,%5Cquad%20%5Cforall%20x%20%5Cneq%200%20%5C%5C%0A&amp;%5Ciff%20%5Cvarphi%20V%20%5Cneq%20%5C%7B0%5C%7D%20%5C%5C%0A&amp;%5Ciff%20%5Cvarphi%20%5Cneq%200%0A%5Cend%7Baligned%7D%0A"> 故最终我们得到 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%5E*%20%5Cvarphi%20=%20V%5E*%20%5Ciff%20%5Cvarphi%20%5Cneq%200">．</p>
</div>
<p>若下面的猜想成立，则上述推论将具有更简单的推导．</p>
<div id="cnj-cyclic-vector-dual" class="theorem conjecture">
<p><span class="theorem-title"><strong>Conjecture 1 </strong></span>若 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 不可约，则 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%5E*"> 也不可约．</p>
</div>
<p>我们暂未找到证明或证伪上述猜想的方法．</p>
<p>下面来证明 Burnside 定理．</p>
<div id="thm-burnside" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Burnside 定理) </strong></span><img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的不可约子代数有且只有 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)">．</p>
</div>
<p>首先说明 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的不可约性．因为 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)%20M%20=%20V"> 对任意非零不变子空间 <img src="https://latex.codecogs.com/png.latex?M"> 成立，故 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 不可约．下面设 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 是一任意给定的 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的一个不可约子代数．显然 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20%5Cneq%20%5C%7B%200%20%5C%7D">，原因在 Lemma&nbsp;1 中已述．我们的证明分三步进行：</p>
<ol type="1">
<li>证明 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 中存在一个秩为 <img src="https://latex.codecogs.com/png.latex?1"> 的线性变换 <img src="https://latex.codecogs.com/png.latex?T_0">．</li>
<li>证明所有 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 中秩为 <img src="https://latex.codecogs.com/png.latex?1"> 的线性变换都在 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 中．</li>
<li>证明任何 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 中的线性变换都可被分解为若干个秩不超过 <img src="https://latex.codecogs.com/png.latex?1"> 的线性变换的和，从而（利用代数对加法的封闭性）<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20=%20%5Cmathcal%20B(V)">．</li>
</ol>
<div class="proof">
<p><span class="proof-title"><em>Proof</em> (第一部分). </span>由 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A%20%5Cneq%20%5C%7B%200%20%5C%7D">，可以取 <img src="https://latex.codecogs.com/png.latex?T_0"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 中的一个秩最小的非零线性变换，<img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Brank%7DT_0%20%5Cgeq%201">．考虑反证，假设 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Brank%7DT_0%20%5Cgeq%202">，只要构造出一个非零线性变换 <img src="https://latex.codecogs.com/png.latex?S_*%20%5Cin%20%5Cmathcal%20A"> 使得 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DS_*%20%5Csubsetneq%20%5Coperatorname%7BIm%7DT_0">，就能推出矛盾．</p>
<p>由 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Brank%7DT_0%20%5Cgeq%202">，可设 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DT_0"> 中存在两个线性无关的非零向量 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20T_0%20x_1,T_0%20x_2%20%5C%7D">（因此 <img src="https://latex.codecogs.com/png.latex?x_1"> 与 <img src="https://latex.codecogs.com/png.latex?x_2"> 也线性无关）．由 Lemma&nbsp;1，存在线性变换 <img src="https://latex.codecogs.com/png.latex?A_0%20%5Cin%20%5Cmathcal%20A"> 使得 <img src="https://latex.codecogs.com/png.latex?A_0%20T_0%20x_1%20=%20x_2">，于是 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20T_0%20x_1,T_0%20x_2%20%5C%7D%20=%20%5C%7B%20T_0%20x_1,%20T_0%20A%20T_0%20x_1%20%5C%7D"> 线性无关．这意味着 <img src="https://latex.codecogs.com/png.latex?(%5Clambda%20T_0%20-%20T_0%20A_0%20T_0)x_1%20%5Cneq%200"> 对任意 <img src="https://latex.codecogs.com/png.latex?%5Clambda%20%5Cin%20%5Cmathbb%20C"> 成立，即线性变换 <img src="https://latex.codecogs.com/png.latex?S_%5Clambda%20:=%20%5Clambda%20T_0%20-%20T_0%20A_0%20T_0%20%5Cin%20%5Cmathcal%20A"> 非零．下面尝试从这些 <img src="https://latex.codecogs.com/png.latex?S_%5Clambda"> 中找到我们想要的 <img src="https://latex.codecogs.com/png.latex?S_*">．</p>
<ul>
<li>注意到 <img src="https://latex.codecogs.com/png.latex?S_%5Clambda%20=%20T_0(%5Clambda%20I%20-%20A_0%20T_0)">，故 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DS_%5Clambda%20%5Csubset%20%5Coperatorname%7BIm%7DT_0">．</li>
<li>注意到 <img src="https://latex.codecogs.com/png.latex?S_%5Clambda%20=%20(%5Clambda%20I%20-%20T_0%20A_0)%20T_0">，而 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DT_0"> 是 <img src="https://latex.codecogs.com/png.latex?T_0%20A_0"> 的一个不变子空间．故可以取 <img src="https://latex.codecogs.com/png.latex?T_0%20A_0"> 在 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DT_0"> 上的限制 <img src="https://latex.codecogs.com/png.latex?T_0%20A_0%20%7C_%7B%5Coperatorname%7BIm%7DT_0%7D">．设 <img src="https://latex.codecogs.com/png.latex?T_0%20A_0%20%7C_%7B%5Coperatorname%7BIm%7DT_0%7D"> 有一特征值 <img src="https://latex.codecogs.com/png.latex?%5Clambda_0">（由于 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DT_0"> 是复数域上有限维线性空间），这样 <img src="https://latex.codecogs.com/png.latex?%5Clambda_0%20I%20-%20T_0%20A_0%20%7C_%7B%5Coperatorname%7BIm%7DT_0%7D"> 就不是单射，因此也不是满射（由于 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DT_0"> 是有限维线性空间），即 <img src="https://latex.codecogs.com/png.latex?S_%7B%5Clambda_0%7D%20=%20(%5Clambda_0%20I%20-%20T_0%20A_0)%20T_0"> 不能映满 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DT_0">．</li>
</ul>
<p>综上 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7DS_%7B%5Clambda_0%7D%20%5Csubsetneq%20%5Coperatorname%7BIm%7DT_0"> 且 <img src="https://latex.codecogs.com/png.latex?0%20%5Cneq%20S_%7B%5Clambda_0%7D%20%5Cin%20%5Cmathcal%20A">，故 <img src="https://latex.codecogs.com/png.latex?S_%7B%5Clambda_0%7D"> 就是我们想要的 <img src="https://latex.codecogs.com/png.latex?S_*">．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em> (第二部分). </span>对任意给定的某一秩为 <img src="https://latex.codecogs.com/png.latex?1"> 的线性变换 <img src="https://latex.codecogs.com/png.latex?T%20%5Cin%20%5Cmathcal%20B(V)">，任取非零的 <img src="https://latex.codecogs.com/png.latex?y%20%5Cin%20%5Coperatorname%7BIm%7DT">，存在线性函数 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi%20%5Cin%20V%5E*"> 使得 <img src="https://latex.codecogs.com/png.latex?T%20x%20=%20%5Cvarphi(x)%20y,%5C,%20%5Cforall%20x%20%5Cin%20V">．已经知道 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20A"> 中存在一个秩为 <img src="https://latex.codecogs.com/png.latex?1"> 的线性变换 <img src="https://latex.codecogs.com/png.latex?T_0">，则任取非零的 <img src="https://latex.codecogs.com/png.latex?y_0%20%5Cin%20%5Coperatorname%7BIm%7DT_0">，存在线性函数 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi_0%20%5Cin%20V%5E*"> 使得 <img src="https://latex.codecogs.com/png.latex?T_0%20x%20=%20%5Cvarphi_0(x)%20y_0,%5C,%20%5Cforall%20x%20%5Cin%20V">．</p>
<ul>
<li>由 Lemma&nbsp;1，存在 <img src="https://latex.codecogs.com/png.latex?A%20%5Cin%20%5Cmathcal%20A"> 使得 <img src="https://latex.codecogs.com/png.latex?A%20y_0%20=%20y">．</li>
<li>由 Corollary&nbsp;1，存在 <img src="https://latex.codecogs.com/png.latex?B%20%5Cin%20%5Cmathcal%20A"> 使得 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi_0%20B%20=%20%5Cvarphi">．</li>
</ul>
<p>综上， <img src="https://latex.codecogs.com/png.latex?%0AT%20x%20=%20%5Cvarphi(x)%20y%20=%20%5Cvarphi_0(Bx)%20A%20y_0%20=%20A(%5Cvarphi_0(Bx)%20y_0)%20=%20A%20T_0%20B%20x,%5Cquad%20%5Cforall%20x%20%5Cin%20V%0A"> 故 <img src="https://latex.codecogs.com/png.latex?T%20=%20A%20T_0%20B%20%5Cin%20%5Cmathcal%20A">．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em> (第三部分). </span>设 <img src="https://latex.codecogs.com/png.latex?A%20%5Cin%20%5Cmathcal%20B(V)"> 是任一给定的线性变换，任取 <img src="https://latex.codecogs.com/png.latex?V"> 中的一组基 <img src="https://latex.codecogs.com/png.latex?b_1,%5Cdots,b_n">，设其对偶基为 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi_1,%5Cdots,%5Cvarphi_n">．定义关于基 <img src="https://latex.codecogs.com/png.latex?b_1,%5Cdots,b_n"> 的 <img src="https://latex.codecogs.com/png.latex?n"> 个投影变换 <img src="https://latex.codecogs.com/png.latex?P_k:%20x%20%5Cmapsto%20%5Cvarphi_k(x)%20b_k">，由对偶基性质，显然有 <img src="https://latex.codecogs.com/png.latex?I%20=%20%5Csum_%7Bk=1%7D%5En%20P_k">，于是 <img src="https://latex.codecogs.com/png.latex?%0AA%20=%20A%20I%20=%20A%20%5Csum_%7Bk=1%7D%5En%20P_k%20=%20%5Csum_%7Bk=1%7D%5En%20A%20P_k%0A"> 其中每一个 <img src="https://latex.codecogs.com/png.latex?A%20P_k"> 都是秩不超过 <img src="https://latex.codecogs.com/png.latex?1"> 的线性变换．</p>
</div>
<p>至此，Theorem&nbsp;1 得到完整证明．</p>
<p>Burnside 定理可以为下面的定理提供一个较为简单的证明．</p>
<div id="thm-bv-simple" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 </strong></span><img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 是单代数，即 <img src="https://latex.codecogs.com/png.latex?%5C%7B%200%20%5C%7D"> 和 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 是代数 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上唯二的双边理想．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>显然 <img src="https://latex.codecogs.com/png.latex?%5C%7B%200%20%5C%7D"> 和 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20%5Cmathcal%20B(V)%20%5C%7D"> 都是双边理想．下面任取一 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的双边理想 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20I%20%5Cneq%20%5C%7B%200%20%5C%7D">，我们证明它不可约．任取 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20I"> 的一个非零不变子空间 <img src="https://latex.codecogs.com/png.latex?M">，由 <img src="https://latex.codecogs.com/png.latex?M,%5C,%20%5Cmathcal%20I"> 的非零性和 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20I%20V"> 的非零性， <img src="https://latex.codecogs.com/png.latex?%0AM%20%5Csupset%20%5Cmathcal%20I%20M%20%5Csupset%20%5Cmathcal%20B(V)%20%5Cmathcal%20I%20%5Cmathcal%20B(V)%20M%20=%20%5Cmathcal%20B(V)%20%5Cmathcal%20I%20V%20=%20%5Cmathcal%20B(V)%20(%5Cmathcal%20I%20V)%20=%20V%0A"> 故只能有 <img src="https://latex.codecogs.com/png.latex?M%20=%20V">，因此 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20I"> 确不可约．现在 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20I"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的不可约理想，理想一定是子代数，根据 Theorem&nbsp;1 就有 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20I%20=%20%5Cmathcal%20B(V)">．</p>
</div>
<p>下面的定理为 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的全体代数自同构提供了表示方法．</p>
<div id="thm-bv-inner-aut" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 </strong></span><img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的全体代数自同构均为内自同构．即，任意 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的自同构 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi:%20%5Cmathcal%20B(V)%20%5Cto%20%5Cmathcal%20B(V)"> 都可写为 <img src="https://latex.codecogs.com/png.latex?A%20%5Cmapsto%20S%20A%20S%5E%7B-1%7D"> 的形式，其中 <img src="https://latex.codecogs.com/png.latex?S%20%5Cin%20%5Cmathcal%20B(V)"> 为与 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi"> 相关的某一可逆线性变换．</p>
</div>
<p>将矩阵表示和线性空间的语言相结合，可以为该定理提供思路更清晰的证明．</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>取定 <img src="https://latex.codecogs.com/png.latex?V"> 上的一组基 <img src="https://latex.codecogs.com/png.latex?x_1,%5Cdots,x_n">，定义 <img src="https://latex.codecogs.com/png.latex?%0AE_%7Bi,j%7D(x_1,%5Cdots,x_n)%20:=%20(x_1,%5Cdots,x_n)%20%5Chat%20E_%7Bi,j%7D%20%5Cpod%7Bi=1,2,%5Cdots,n;%5C;%20j=1,2,%5Cdots,n%7D%0A"> 其中全体 <img src="https://latex.codecogs.com/png.latex?%5Chat%20E_%7Bi,j%7D%20%5Cin%20%5Cmathrm%20M_n(%5Cmathbb%20C)"> 代表 <img src="https://latex.codecogs.com/png.latex?n"> 阶矩阵空间的一组自然基．于是全体 <img src="https://latex.codecogs.com/png.latex?E_%7Bi,j%7D"> 自然也是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的一组基．现在只需研究自同构 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi"> 将 <img src="https://latex.codecogs.com/png.latex?E_%7Bi,j%7D"> 映至何处．为显式地将 <img src="https://latex.codecogs.com/png.latex?S"> 确定出来，不妨先考虑 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D)"> 的性质．</p>
<p>首先指出，<img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D)"> 仍然是秩为 <img src="https://latex.codecogs.com/png.latex?1"> 的投影变换，因为：</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?E_%7Bi,i%7D"> 是投影变换，根据其幂等性和代数自同构保持乘法，<img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D)"> 也是投影变换．</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?E_%7Bi,i%7D%20%5Cmathcal%20B(V)%20E_%7Bi,i%7D"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的 <img src="https://latex.codecogs.com/png.latex?1"> 维子空间（从矩阵表示角度考虑），因此 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D%20%5Cmathcal%20B(V)%20E_%7Bi,i%7D)%20=%20%5Cvarphi(E_%7Bi,i%7D)%20%5Cmathcal%20B(V)%20%5Cvarphi(E_%7Bi,i%7D)"> 也是 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 的 <img src="https://latex.codecogs.com/png.latex?1"> 维子空间．考虑到 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D)"> 还是投影变换，故其秩只能为 <img src="https://latex.codecogs.com/png.latex?1">（同样从矩阵表示角度考虑）．</p></li>
</ul>
<p>现在设 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7BIm%7D%5Cvarphi(E_%7Bi,i%7D)%20=%20%5Coperatorname%7Bspan%7D%5C%7By_i%5C%7D">．因为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csum_%7Bi=1%7D%5En%20%5Coperatorname%7Bspan%7D%5C%7By_i%5C%7D%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20%5Cvarphi(E_%7Bi,i%7D)%20V%20%5C%5C%0A&amp;%5Csupset%20%5Cleft(%20%5Csum_%7Bi=1%7D%5En%20%5Cvarphi(E_%7Bi,i%7D)%20%5Cright)%20V%20%5C%5C%0A&amp;=%20%5Cvarphi%20%5Cleft(%5Csum_%7Bi=1%7D%5En%20E_%7Bi,i%7D%20%5Cright)%20V%20%5C%5C%0A&amp;=%20%5Cvarphi(I)%20V%20=%20I%20V%20=%20V%0A%5Cend%7Baligned%7D%0A"> 故 <img src="https://latex.codecogs.com/png.latex?y_1,%5Cdots,y_n"> 仍是 <img src="https://latex.codecogs.com/png.latex?V"> 的一组基．定义可逆线性变换 <img src="https://latex.codecogs.com/png.latex?S(x_1,%5Cdots,x_n)%20:=%20(y_1,%5Cdots,y_n)">．至此，断言 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi"> 就是 <img src="https://latex.codecogs.com/png.latex?A%20%5Cmapsto%20S%20A%20S%5E%7B-1%7D">，为此下面证明 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,j%7D)%20=%20S%20E_%7Bi,j%7D%20S%5E%7B-1%7D">．</p>
<p>仍然先看 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D)">．已经知道 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D)"> 是秩为 <img src="https://latex.codecogs.com/png.latex?1"> 的投影变换，故 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A&amp;%5Cphantom%7B%5Cimplies%20.%7D%20%5Cvarphi(E_%7Bi,i%7D)%20y_i%20=%20y_i%20%5C%5C%0A&amp;%5Cimplies%20%5Cvarphi(E_%7Bi,i%7D)%20S%20x_i%20=%20S%20x_i%20%5C%5C%0A&amp;%5Cimplies%20S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,i%7D)%20S%20x_i%20=%20x_i%0A%5Cend%7Baligned%7D%0A"> 容易验证 <img src="https://latex.codecogs.com/png.latex?S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,i%7D)%20S"> 幂等且秩为 <img src="https://latex.codecogs.com/png.latex?1">，因此只能有 <img src="https://latex.codecogs.com/png.latex?S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,i%7D)%20S%20=%20E_%7Bi,i%7D">，即 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,i%7D)%20=%20S%20E_%7Bi,i%7D%20S%5E%7B-1%7D">．</p>
<p>现在看 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,j%7D)">．事实上 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A&amp;%5Cphantom%7B%5Cimplies%20.%7D%20%5Cvarphi(E_%7Bi,j%7D)%20%5Cvarphi(E_%7Bj,j%7D)%20=%20%5Cvarphi(E_%7Bi,j%7D%20E_%7Bj,j%7D)%20=%20%5Cvarphi(E_%7Bi,i%7D)%20%5C%5C%0A&amp;%5Cimplies%20%5Cvarphi(E_%7Bi,j%7D)%20S%20E_%7Bj,j%7D%20S%5E%7B-1%7D%20=%20S%20E_%7Bi,i%7D%20S%5E%7B-1%7D%5C%5C%0A&amp;%5Cimplies%20S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D)%20S%20E_%7Bj,j%7D%20=%20E_%7Bi,i%7D%5C%5C%0A&amp;%5Cimplies%20S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D)%20S%20x_j%20=%20x_i%0A%5Cend%7Baligned%7D%0A"> 现在 <img src="https://latex.codecogs.com/png.latex?S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D)%20S"> 秩为 <img src="https://latex.codecogs.com/png.latex?1">，且对任何 <img src="https://latex.codecogs.com/png.latex?k%20%5Cneq%20j">， <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A(S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D)%20S)%20x_k%0A&amp;=%20S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D)%20y_k%20%5C%5C%0A&amp;=%20S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D%20E_%7Bj,j%7D)%20y_k%20%5C%5C%0A&amp;=%20S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D)%20(%5Cvarphi(E_%7Bj,j%7D)%20y_k)%20%5C%5C%0A&amp;=%200%0A%5Cend%7Baligned%7D%0A"> 故可以断定 <img src="https://latex.codecogs.com/png.latex?S%5E%7B-1%7D%20%5Cvarphi(E_%7Bi,j%7D)%20S%20=%20E_%7Bi,j%7D">，即 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(E_%7Bi,j%7D)%20=%20S%5E%7B-1%7D%20E_%7Bi,j%7D%20S">．</p>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>研究 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的自同态时，可能在应用线性变换关于其作用域 <img src="https://latex.codecogs.com/png.latex?V"> 的性质时遇到困难．这时需要将其合理转化为 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的代数性质，如考虑投影变换的幂等性，将投影变换秩为 <img src="https://latex.codecogs.com/png.latex?1"> 转化为 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20B(V)"> 上的 <img src="https://latex.codecogs.com/png.latex?1"> 维子空间等．这些技巧在证明中多次使用．</p>
</div>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-radjavi_simultaneous_2000" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">H. Radjavi and P. Rosenthal, <em>Simultaneous <span>Triangularization</span></em>. in Universitext. New York, NY: Springer, 2000. doi: <a href="https://doi.org/10.1007/978-1-4612-1200-3">10.1007/978-1-4612-1200-3</a>.</div>
</div>
<div id="ref-axler_linear_2015" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">S. Axler, <em>Linear <span>Algebra</span> <span>Done</span> <span>Right</span></em>. in Undergraduate <span>Texts</span> in <span>Mathematics</span>. Cham: Springer International Publishing, 2015. doi: <a href="https://doi.org/10.1007/978-3-319-11080-6">10.1007/978-3-319-11080-6</a>.</div>
</div>
</div></section></div> ]]></description>
  <category>数学</category>
  <guid>https://blog.sun123zxy.top/posts/20240121-burnside/index.html</guid>
  <pubDate>Sat, 20 Jan 2024 16:00:00 GMT</pubDate>
</item>
<item>
  <title>一元多项式的 Delta 判别式</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20231018-discriminant/index.html</link>
  <description><![CDATA[ 



<section id="e-基m-基与-p-基" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> <img src="https://latex.codecogs.com/png.latex?e">-基、<img src="https://latex.codecogs.com/png.latex?m">-基与 <img src="https://latex.codecogs.com/png.latex?p">-基</h1>
<section id="整数分拆" class="level3">
<h3 class="anchored" data-anchor-id="整数分拆">整数分拆</h3>
<p>设非负整数数列 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda%20:=%20(%5Clambda_1,%20%5Clambda_2,%20%5Cdots)"> 只有有限项非零且（不严格）单调递减．定义长度 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20L(%5Cboldsymbol%5Clambda)"> 为其非零项元素个数；定义 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20S(%5Cboldsymbol%5Clambda)"> 为其非零项元素之和．此时称 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda"> 是整数 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20S(%5Cboldsymbol%5Clambda)"> 的一个长度为 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20L(%5Cboldsymbol%5Clambda)"> 的<em>分拆</em>．</p>
<p>由于分拆只有有限项非零，对大于等于 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20L(%5Cboldsymbol%5Clambda)"> 的非负整数 <img src="https://latex.codecogs.com/png.latex?k">，我们也常省略从第 <img src="https://latex.codecogs.com/png.latex?k+1"> 项开始的全为 <img src="https://latex.codecogs.com/png.latex?0"> 的项，将 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda"> 直接记为长度为 <img src="https://latex.codecogs.com/png.latex?k"> 的非负整数数组 <img src="https://latex.codecogs.com/png.latex?(%5Clambda_1,%20%5Clambda_2,%20%5Cdots,%20%5Clambda_k)">．</p>
<p>Ferrers diagram 和 Young diagram 是图示分拆的常见方法．</p>
<p>通过沿主对角线翻转分拆的 Ferrers diagram 或 Young diagram，可以定义<em>分拆的转置</em>．分拆 <img src="https://latex.codecogs.com/png.latex?%5Clambda"> 的转置记为 <img src="https://latex.codecogs.com/png.latex?%5Clambda%5E%5Cmathrm%7BT%7D">．转置后分拆的长度变为原分拆的首项，而首项变为原分拆的长度．</p>
</section>
<section id="单项对称多项式" class="level3">
<h3 class="anchored" data-anchor-id="单项对称多项式">单项对称多项式</h3>
<p>设 <img src="https://latex.codecogs.com/png.latex?n"> 是正整数，<img src="https://latex.codecogs.com/png.latex?K"> 是一个域．记 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20x%20:=%20(x_1,%5Cdots,x_n)">．设 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda%20:=%20(%5Clambda_1,%20%5Clambda_2,%20%5Cdots%20%5Clambda_n)"> 是长度不超过 <img src="https://latex.codecogs.com/png.latex?n"> 的一个分拆．</p>
<p>定义 <img src="https://latex.codecogs.com/png.latex?n"> 元多项式环 <img src="https://latex.codecogs.com/png.latex?K%5B%5Cboldsymbol%20x%5D"> 上的关于分拆 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda"> 的<em>单项对称多项式</em>（monomial symmetric polynomial）<img src="https://latex.codecogs.com/png.latex?m_%7B%5Cboldsymbol%5Clambda%7D(%5Cboldsymbol%20x)"> 为各项系数为 <img src="https://latex.codecogs.com/png.latex?1"> 的含有单项式 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20x%5E%7B%5Cboldsymbol%5Clambda%7D%20:=%20x_1%5E%7B%5Clambda_1%7D%20x_2%5E%7B%5Clambda_2%7D%20%5Cdots%20x_n%5E%7B%5Clambda_n%7D"> 的项数最少的对称多项式．</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?m_%7B(2,1,0)%7D(x_1,x_2,x_3)%20=%20x_1%5E2%20x_2%20+%20x_1%5E2%20x_3%20+%20x_1%20x_2%5E2%20+%20x_1%20x_3%5E2%20+%20x_2%5E2%20x_3%20+%20x_2%20x_3%5E2"></li>
<li><img src="https://latex.codecogs.com/png.latex?m_%7B(2,2,1)%7D(x_1,x_2,x_3)%20=%20x_1%5E2%20x_2%5E2%20x_3%20+%20x_1%5E2%20x_2%20x_3%5E2%20+%20x_1%20x_2%5E2%20x_3%5E2"></li>
</ul>
<p>易见 <img src="https://latex.codecogs.com/png.latex?m_%7B%5Cboldsymbol%5Clambda%7D(%5Cboldsymbol%20x)"> 是次数为 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20S(%5Cboldsymbol%5Clambda)"> 的齐次（homogeneous）多项式．全体单项对称多项式构成 <img src="https://latex.codecogs.com/png.latex?n"> 元对称多项式环 <img src="https://latex.codecogs.com/png.latex?%5CLambda_n%20%5Csubset%20K%5B%5Cboldsymbol%20x%5D"> 作为 <img src="https://latex.codecogs.com/png.latex?K"> 上线性空间的一组基底．</p>
</section>
<section id="单项对称多项式-1" class="level3">
<h3 class="anchored" data-anchor-id="单项对称多项式-1">单项对称多项式</h3>
<div id="exr-mono-term-count" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1 </strong></span>对一给定的长度不超过 <img src="https://latex.codecogs.com/png.latex?n"> 的分拆 <img src="https://latex.codecogs.com/png.latex?%5Clambda%20:=%20(%5Clambda_1,%20%5Clambda_2,%20%5Cdots%20%5Clambda_n)">，<img src="https://latex.codecogs.com/png.latex?n"> 元单项对称多项式 <img src="https://latex.codecogs.com/png.latex?m_%5Clambda(%5Cboldsymbol%20x)"> 共有多少项？</p>
</div>
<p>在计数时根据分拆中重复项的分布情况进行消序．</p>
<div id="exr-lambda-dim" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2 </strong></span><img src="https://latex.codecogs.com/png.latex?n"> 元 <img src="https://latex.codecogs.com/png.latex?d"> 次单项对称多项式共有多少种可能的构型？设 <img src="https://latex.codecogs.com/png.latex?%5CLambda_n%5E%7B(d)%7D%20%5Csubset%20%5CLambda_n"> 由全体至多 <img src="https://latex.codecogs.com/png.latex?d"> 次的 <img src="https://latex.codecogs.com/png.latex?n"> 元对称多项式构成，其作为 <img src="https://latex.codecogs.com/png.latex?K"> 上线性空间的维数是多少？</p>
</div>
<p>该问题等价于求满足 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20S(%5Cboldsymbol%5Clambda)%20=%20d">，<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%20L(%5Cboldsymbol%5Clambda)%20%5Cleq%20n"> 的所有可能分拆 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda"> 的数量，也即“将 <img src="https://latex.codecogs.com/png.latex?d"> 个无标号球放入 <img src="https://latex.codecogs.com/png.latex?n"> 个可空置的无标号盒”的可行方案数．</p>
</section>
<section id="基本对称多项式" class="level3">
<h3 class="anchored" data-anchor-id="基本对称多项式">基本对称多项式</h3>
<p><img src="https://latex.codecogs.com/png.latex?n"> 元多项式环 <img src="https://latex.codecogs.com/png.latex?K%5B%5Cboldsymbol%20x%5D"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 个<em>基本对称多项式</em>（elementary symmetric polynomial）定义为 <img src="https://latex.codecogs.com/png.latex?%0Ae_k(x_1,%5Cdots,x_n)%20:=%20%5Csum_%7B1%20%5Cleq%20i_1%20%3C%20i_2%20%5Cdots%20%3C%20i_k%20%5Cleq%20n%7D%20x_%7Bi_1%7D%20x_%7Bi_2%7D%20%5Cdots%20x_%7Bi_k%7D,%20%5Cquad%20k%20=%201,2,%5Cdots,%20n%0A"> 使用单项对称多项式的记号，也可记为 <img src="https://latex.codecogs.com/png.latex?%0Ae_k(%5Cboldsymbol%20x)%20:=%20m_%7B%5Cboldsymbol%5Clambda_k%7D%20(%5Cboldsymbol%20x)%0A"> 其中分拆 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda_k%20:=%20(1,%5Cdots,1,0,%5Cdots)"> 的前 <img src="https://latex.codecogs.com/png.latex?k"> 项为 <img src="https://latex.codecogs.com/png.latex?1">，其余项皆为 <img src="https://latex.codecogs.com/png.latex?0">．</p>
<p>设分拆 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda%20:=%20(%5Clambda_1,%5Clambda_2,%5Cdots)"> 满足 <img src="https://latex.codecogs.com/png.latex?%5Clambda_i%20%5Cleq%20n,%20%5Cquad%20%5Cforall%20i%20%5Cin%20%5Cmathbb%20N_+">．我们记 <img src="https://latex.codecogs.com/png.latex?e_%7B%5Cboldsymbol%5Clambda%7D(%5Cboldsymbol%20x)%20:=%20e_%7B%5Clambda_1%7D(%5Cboldsymbol%20x)%20e_%7B%5Clambda_2%7D(%5Cboldsymbol%20x)%20%5Cdots%20e_%7B%5Clambda_%7B%5Cmathcal%20L(%5Cboldsymbol%5Clambda)%7D%7D(%5Cboldsymbol%20x)">．</p>
</section>
<section id="基本对称多项式-1" class="level3">
<h3 class="anchored" data-anchor-id="基本对称多项式-1">基本对称多项式</h3>
<div id="thm-e-decomp" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (对称多项式基本定理) </strong></span>设 <img src="https://latex.codecogs.com/png.latex?f(%5Cboldsymbol%20x)"> 是域 <img src="https://latex.codecogs.com/png.latex?K"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 元对称多项式，则存在唯一的 <img src="https://latex.codecogs.com/png.latex?g(%5Cboldsymbol%20x)%20%5Cin%20K%5B%5Cboldsymbol%20x%5D">，使得 <img src="https://latex.codecogs.com/png.latex?%0Af(%5Cboldsymbol%20x)%20=%20g(e_1(%5Cboldsymbol%20x),%5Cdots,e_n(%5Cboldsymbol%20x))%0A"></p>
</div>
<p>该定理对交换环上的对称多项式仍然成立．这意味着若 <img src="https://latex.codecogs.com/png.latex?f"> 是整系数对称多项式，则 <img src="https://latex.codecogs.com/png.latex?g"> 也是整系数多项式．</p>
<p>在定理的存在性证明中，为消去首项对应的单项对称多项式 <img src="https://latex.codecogs.com/png.latex?m_%7B%5Cboldsymbol%5Clambda%7D(%5Cboldsymbol%20x)">，我们构造的若干个基本对称多项式的乘积恰为 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20e_%7B%5Cboldsymbol%5Clambda%5E%5Cmathrm%7BT%7D%7D">．</p>
<p>考察全体满足 <img src="https://latex.codecogs.com/png.latex?%5Clambda_i%20%5Cleq%20n,%20%5Cquad%20%5Cforall%20i%20%5Cin%20%5Cmathbb%20N_+"> 的分拆 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%5Clambda"> 对应的 <img src="https://latex.codecogs.com/png.latex?e_%7B%5Cboldsymbol%5Clambda%7D(%5Cboldsymbol%20x)">，它们构成了 <img src="https://latex.codecogs.com/png.latex?n"> 元对称多项式环 <img src="https://latex.codecogs.com/png.latex?%5CLambda_n"> 作为 <img src="https://latex.codecogs.com/png.latex?K"> 上线性空间的另一组基底．</p>
</section>
<section id="幂和对称多项式" class="level3">
<h3 class="anchored" data-anchor-id="幂和对称多项式">幂和对称多项式</h3>
<p><img src="https://latex.codecogs.com/png.latex?n"> 元多项式环 <img src="https://latex.codecogs.com/png.latex?K%5B%5Cboldsymbol%20x%5D"> 上的<em>幂和对称多项式</em>（power sum symmetric polynomial）定义为 <img src="https://latex.codecogs.com/png.latex?%0Ap_k(x_1,%5Cdots,x_n)%20:=%20x_1%5Ek%20+%20x_2%5Ek%20+%20%5Cdots%20+%20x_n%5Ek,%5Cquad%20k%20%5Cin%20%5Cmathbb%20N%0A"> 使用单项对称多项式的记号，也可记为 <img src="https://latex.codecogs.com/png.latex?%0Ap_k(%5Cboldsymbol%20x)%20:=%20m_%7B(k,0,0,%5Cdots)%7D%0A"> 特别的，<img src="https://latex.codecogs.com/png.latex?p_0(%5Cboldsymbol%20x)%20=%20n">．</p>
<div id="thm-p-decomp" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 </strong></span>设 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Q%20%5Csubset%20K%20%5Csubset%20%5Cmathbb%20C"> 是数域，设 <img src="https://latex.codecogs.com/png.latex?f(%5Cboldsymbol%20x)"> 是域 <img src="https://latex.codecogs.com/png.latex?K"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 元对称多项式，则存在唯一的 <img src="https://latex.codecogs.com/png.latex?g(%5Cboldsymbol%20x)%20%5Cin%20K%5B%5Cboldsymbol%20x%5D">，使得 <img src="https://latex.codecogs.com/png.latex?f(%5Cboldsymbol%20x)%20=%20g(p_1(%5Cboldsymbol%20x),%5Cdots,p_n(%5Cboldsymbol%20x))">．</p>
</div>
<p>一般地，结论对特征为 <img src="https://latex.codecogs.com/png.latex?0"> 的域 <img src="https://latex.codecogs.com/png.latex?K"> 也成立．</p>
</section>
<section id="幂和对称多项式-1" class="level3">
<h3 class="anchored" data-anchor-id="幂和对称多项式-1">幂和对称多项式</h3>
<p>以下定理递推地给出了幂和对称多项式 <img src="https://latex.codecogs.com/png.latex?p_1,%5Cdots,p_n"> 与基本对称多项式 <img src="https://latex.codecogs.com/png.latex?e_1,%5Cdots,e_n"> 间的关系．Theorem&nbsp;2 的存在性部分可由这一定理给出．</p>
<div id="thm-newton" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (Newton’s Identities) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0Ap_k%20&amp;=%20%5Csum_%7Bi=1%7D%5E%7Bk-1%7D%20(-1)%5E%7Bi-1%7D%20e_i%20p_%7Bk-i%7D%20+%20(-1)%5E%7Bk-1%7D%20k%20e_k%20&amp;%20k%20&amp;=%201,2,%5Cdots,n%20%5C%5C%0Ap_k%20&amp;=%20%5Csum_%7Bi=1%7D%5En%20(-1)%5E%7Bi-1%7D%20e_i%20p_%7Bk-i%7D%20&amp;%20k&amp;%3En%20%5C%5C%0Ak%20e_k%20&amp;=%20%5Csum_%7Bi=1%7D%5Ek%20(-1)%5E%7Bi-1%7D%20p_%7Bi%7D%20e_%7Bk-i%7D%20&amp;%20k%20&amp;=%201,2,%5Cdots,n%20%5C%5C%0A0%20&amp;=%20%5Csum_%7Bi=1%7D%5En%20(-1)%5E%7Bi-1%7D%20p_%7Bi%7D%20e_%7Bk-i%7D%20&amp;%20k%20&amp;%3E%20n%0A%5Cend%7Baligned%7D%0A"></p>
</div>
</section>
<section id="其它基底" class="level3">
<h3 class="anchored" data-anchor-id="其它基底">其它基底</h3>
<p>完全齐次对称多项式（Complete homogeneous symmetric polynomials）、Schur 多项式……</p>
<p>本节主要参考 <span class="citation" data-cites="wp_sympoly wp_e-basis wp_p-basis wp_newton">[1]–[4]</span>．</p>
</section>
</section>
<section id="delta-判别式" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Delta 判别式</h1>
<section id="vietas-formulas" class="level3">
<h3 class="anchored" data-anchor-id="vietas-formulas">Vieta’s formulas</h3>
<div id="thm-vieta" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4 (Vieta’s formulas) </strong></span>设数域 <img src="https://latex.codecogs.com/png.latex?K%20%5Csubset%20%5Cmathbb%20C"> 上 <img src="https://latex.codecogs.com/png.latex?n"> 次首一多项式（monic polynomial） <img src="https://latex.codecogs.com/png.latex?%0AA(x)%20:=%20x%5En%20+%20a_%7Bn-1%7D%20x%5E%7Bn-1%7D%20+%20%5Cdots%20+%20a_0%20=%20(x-c_1)(x-c_2)%5Cdots(x-c_n)%0A"> 其 <img src="https://latex.codecogs.com/png.latex?n"> 个复根分别为 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20c%20:=%20(c_1,%20c_2,%5Cdots,c_n)">，则 <img src="https://latex.codecogs.com/png.latex?A(x)"> 的系数可由关于根的 <img src="https://latex.codecogs.com/png.latex?n"> 个 <img src="https://latex.codecogs.com/png.latex?n"> 元基本对称多项式表示 <img src="https://latex.codecogs.com/png.latex?%0Aa_%7Bn-k%7D%20=%20e_k(-%5Cboldsymbol%20c)%20=%20(-1)%5Ek%20%5Csum_%7B1%20%5Cleq%20i_1%20%3C%20%5Cdots%20%3C%20i_k%20%5Cleq%20n%7D%20c_%7Bi_1%7D%20c_%7Bi_2%7D%20%5Cdots%20c_%7Bi_k%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?k%20=%201,2,%5Cdots,n">．特别的 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0Aa_0%20&amp;=%20e_n(-%5Cboldsymbol%20c)%20=%20(-1)%5En%20c_1%20c_2%20%5Cdots%20c_n%20%5C%5C%0Aa_%7Bn-1%7D%20&amp;=%20e_1(-%5Cboldsymbol%20c)%20=%20-(c_1%20+%20c_2%20+%20%5Cdots%20+%20c_n)%0A%5Cend%7Baligned%7D%0A"></p>
</div>
</section>
<section id="vieta-定理与对称多项式基本定理" class="level3">
<h3 class="anchored" data-anchor-id="vieta-定理与对称多项式基本定理">Vieta 定理与对称多项式基本定理</h3>
<ul>
<li><p>即使尚未获知多项式 <img src="https://latex.codecogs.com/png.latex?n"> 个复根 <img src="https://latex.codecogs.com/png.latex?c_1,%5Cdots,c_n"> 的具体取值，我们也能通过已知的多项式系数 <img src="https://latex.codecogs.com/png.latex?a_0,%5Cdots,a_%7Bn-1%7D"> 获知 <img src="https://latex.codecogs.com/png.latex?n"> 个 <img src="https://latex.codecogs.com/png.latex?n"> 元基本对称多项式在根处的取值．</p></li>
<li><p>对称多项式基本定理指出，任何对称多项式都可被（唯一）表示为关于 <img src="https://latex.codecogs.com/png.latex?n"> 个基本对称多项式的一个多项式．</p></li>
<li><p>仅需知晓多项式的系数，就可获得任意给定对称多项式在根处的取值．</p></li>
<li><p>目标：构造一个（数域 <img src="https://latex.codecogs.com/png.latex?K%20%5Csubset%20%5Cmathbb%20C"> 上的）<img src="https://latex.codecogs.com/png.latex?n"> 元对称多项式，使得能通过代入求值的方式，快速检测 <img src="https://latex.codecogs.com/png.latex?n"> 个复数是否两两不同．</p></li>
</ul>
</section>
<section id="vandermonde-行列式" class="level3">
<h3 class="anchored" data-anchor-id="vandermonde-行列式">Vandermonde 行列式</h3>
<p>考察作为（数域 <img src="https://latex.codecogs.com/png.latex?K%20%5Csubset%20%5Cmathbb%20C"> 上）<img src="https://latex.codecogs.com/png.latex?n"> 元多项式的 Vandermonde 行列式 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bsplit%7D%0A%5Cdet%20V%20&amp;:=%20%5Cdet%20%5Cbegin%7Bpmatrix%7D%20x_j%5E%7Bi-1%7D%20%5Cend%7Bpmatrix%7D_%7Bi=1,j=1%7D%5E%7Bn,n%7D%20%5C%5C%0A&amp;=%0A%5Cdet%20%5Cbegin%7Bpmatrix%7D%0A1%20%20%20%20%20%20%20&amp;%201%20%20%20%20%20&amp;%20%5Cdots%20&amp;%201%20%20%20%20%20%5C%5C%0Ax_1%20%20%20%20%20&amp;%20x_2%20%20%20&amp;%20%5Cdots%20&amp;%20x_n%20%20%20%5C%5C%0A%5Cvdots%20%20&amp;%20%5Cvdots&amp;%20%5Cddots&amp;%20%5Cvdots%5C%5C%0Ax_1%5E%7Bn-1%7D%20&amp;%20x_2%5E%7Bn-1%7D%20&amp;%20%5Cdots%20&amp;%20x_n%5E%7Bn-1%7D%20%20%20%0A%5Cend%7Bpmatrix%7D%20=%20%5Cprod_%7B1%20%5Cleq%20i%20%3C%20j%20%5Cleq%20n%7D%20(x_j%20-%20x_i)%0A%5Cend%7Bsplit%7D%0A"> 它是否可用于判定重根？它是对称多项式吗？</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span><img src="https://latex.codecogs.com/png.latex?%5Cdet%20V"> 是一个斜对称多项式．事实上，<img src="https://latex.codecogs.com/png.latex?%5Cdet%20V"> 与所有对称多项式的乘积构成了全体斜对称多项式（alternating polynomials）．</p>
</div>
</section>
<section id="判别式" class="level3">
<h3 class="anchored" data-anchor-id="判别式">判别式</h3>
<p>设（数域 <img src="https://latex.codecogs.com/png.latex?K%20%5Csubset%20%5Cmathbb%20C"> 上的）<img src="https://latex.codecogs.com/png.latex?n"> 元对称多项式 <img src="https://latex.codecogs.com/png.latex?%0AD(x_1,%5Cdots,x_n)%20:=%20(%5Cdet%20V)%5E2%20=%20%5Cprod_%7B1%20%5Cleq%20i%20%3C%20j%20%5Cleq%20n%7D%20(x_j%20-%20x_i)%5E2%0A"> 称其为（数域 <img src="https://latex.codecogs.com/png.latex?K"> 上）一元 <img src="https://latex.codecogs.com/png.latex?n"> 次首一多项式的<em>判别式</em>（Discriminant）．当代入的 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20x%20:=%20(x_1,%5Cdots,x_n)%20%5Csubset%20%5Cmathbb%20C"> 互不相同时，<img src="https://latex.codecogs.com/png.latex?D(%5Cboldsymbol%20x)%20%5Cneq%200">；否则 <img src="https://latex.codecogs.com/png.latex?D(%5Cboldsymbol%20x)%20=%200">．</p>
<p>根据对称多项式基本定理，存在唯一数域 <img src="https://latex.codecogs.com/png.latex?K"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 元多项式 <img src="https://latex.codecogs.com/png.latex?d">，使得 <img src="https://latex.codecogs.com/png.latex?d(e_1(%5Cboldsymbol%20x),%5Cdots,e_n(%5Cboldsymbol%20x))%20=%20D(%5Cboldsymbol%20x)">．</p>
<div id="prp-discriminant" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 </strong></span>数域 <img src="https://latex.codecogs.com/png.latex?K%20%5Csubset%20%5Cmathbb%20C"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 次首一多项式 <img src="https://latex.codecogs.com/png.latex?f(x)%20:=%20x%5En%20+%20a_%7Bn-1%7D%20x%5E%7Bn-1%7D%20+%20%5Cdots%20+%20a_0"> 在复数域中有重根的充分必要条件是 <img src="https://latex.codecogs.com/png.latex?d(a_%7Bn-1%7D,%5Cdots,a_0)%20=%200">．</p>
</div>
<p>这是因为 <img src="https://latex.codecogs.com/png.latex?f(x)"> 的 <img src="https://latex.codecogs.com/png.latex?n"> 个复根 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20c%20:=%20(c_1,%5Cdots,c_n)"> 满足 <img src="https://latex.codecogs.com/png.latex?%0AD(-%5Cboldsymbol%20c)%20=%20d(e_1(-%5Cboldsymbol%20c),%5Cdots,e_n(-%5Cboldsymbol%20c))%20=%20d(a_%7Bn-1%7D,%5Cdots,a_0)%0A"></p>
</section>
<section id="判别式-1" class="level3">
<h3 class="anchored" data-anchor-id="判别式-1">判别式</h3>
<div id="exr-2-discriminant" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 3 </strong></span>写出数域 <img src="https://latex.codecogs.com/png.latex?K%20%5Csubset%20%5Cmathbb%20C"> 上一元二次多项式 <img src="https://latex.codecogs.com/png.latex?x%5E2%20+%20bx%20+%20c"> 的判别式．</p>
</div>
<p>对次数更高的方程，直接使用消首项方法求解判别式 <img src="https://latex.codecogs.com/png.latex?D(%5Cboldsymbol%20x)"> 在基本对称多项式下的表示 <img src="https://latex.codecogs.com/png.latex?d(e_1,%5Cdots,e_n)"> 将变得相当繁琐．下面利用判别式与 Vandermonde 行列式的关系得到另一种分解方法．</p>
</section>
<section id="另一分解方法" class="level3">
<h3 class="anchored" data-anchor-id="另一分解方法">另一分解方法</h3>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AD(%5Cboldsymbol%20x)%20&amp;=%20(%5Cdet%20V)%5E2%20=%20%5Cdet(V%20V%5ET)%20%5C%5C%0A&amp;=%20%5Cdet%20(%5Cbegin%7Bpmatrix%7D%0A1%20%20%20%20%20%20%20&amp;%201%20%20%20%20%20&amp;%20%5Cdots%20&amp;%201%20%20%20%20%20%5C%5C%0Ax_1%20%20%20%20%20&amp;%20x_2%20%20%20&amp;%20%5Cdots%20&amp;%20x_n%20%20%20%5C%5C%0A%5Cvdots%20%20&amp;%20%5Cvdots&amp;%20%5Cddots&amp;%20%5Cvdots%5C%5C%0Ax_1%5E%7Bn-1%7D%20&amp;%20x_2%5E%7Bn-1%7D%20&amp;%20%5Cdots%20&amp;%20x_n%5E%7Bn-1%7D%20%20%20%0A%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%0A1%20%20%20%20%20%20%20&amp;%20x_1%20%20%20&amp;%20%5Cdots%20%20%20%20%20&amp;%20x_1%5E%7Bn-1%7D%20%5C%5C%0A1%20%20%20%20%20%20%20&amp;%20x_2%20%20%20&amp;%20%5Cdots%20%20%20%20%20&amp;%20x_2%5E%7Bn-1%7D%20%5C%5C%0A%5Cvdots%20%20&amp;%20%5Cvdots&amp;%20%5Cddots%20%20%20%20&amp;%20%5Cvdots%20%20%20%20%5C%5C%0A1%20%20%20%20%20%20%20&amp;%20x_n%20%20%20&amp;%20%5Cdots%20%20%20%20%20&amp;%20x_n%5E%7Bn-1%7D%0A%5Cend%7Bpmatrix%7D)%20%5C%5C%0A&amp;=%20%5Cdet%20%5Cbegin%7Bpmatrix%7D%0An%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20&amp;%20p_1(%5Cboldsymbol%20x)%20%20%20&amp;%20%5Cdots%20%20%20%20%20&amp;%20p_%7Bn-1%7D(%5Cboldsymbol%20x)%20%20%20%5C%5C%0Ap_1(%5Cboldsymbol%20x)%20%20%20%20%20&amp;%20p_2(%5Cboldsymbol%20x)%20%20%20&amp;%20%5Cdots%20%20%20%20%20&amp;%20p_n(%5Cboldsymbol%20x)%20%20%20%20%20%20%20%5C%5C%0A%5Cvdots%20%20%20%20%20%20%20%20%20%20&amp;%20%5Cvdots%20%20%20%20%20%20%20%20&amp;%20%5Cddots%20%20%20%20&amp;%20%5Cvdots%20%20%20%20%20%20%20%20%20%20%20%20%5C%5C%0Ap_%7Bn-1%7D(%5Cboldsymbol%20x)%20&amp;%20p_n(%5Cboldsymbol%20x)%20%20%20&amp;%20%5Cdots%20%20%20%20%20&amp;%20p_%7B2n-2%7D(%5Cboldsymbol%20x)%0A%5Cend%7Bpmatrix%7D%0A=%20%5Cdet%20%5Cbegin%7Bpmatrix%7D%20p_%7Bi+j-2%7D(%5Cboldsymbol%20x)%20%5Cend%7Bpmatrix%7D_%7Bi=1,j=1%7D%5E%7Bn,n%7D%0A%5Cend%7Baligned%7D%0A"> 而由 Newton’s Identities，幂和对称多项式 <img src="https://latex.codecogs.com/png.latex?p_k(%5Cboldsymbol%20x)"> 可较容易地递推分解为基本对称多项式的多项式组合，故我们找到了分解 <img src="https://latex.codecogs.com/png.latex?D(%5Cboldsymbol%20x)"> 的一种更易操作的方法．</p>
</section>
<section id="另一分解方法-1" class="level3">
<h3 class="anchored" data-anchor-id="另一分解方法-1">另一分解方法</h3>
<div id="exr-3-discriminant" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 4 </strong></span>写出数域 <img src="https://latex.codecogs.com/png.latex?K%20%5Csubset%20%5Cmathbb%20C"> 上不完全三次多项式 <img src="https://latex.codecogs.com/png.latex?x%5E3%20+%20bx%20+%20c"> 的判别式．</p>
</div>
<p>本节主要参考 <span class="citation" data-cites="qiu-algebra lan-algebra wp_partition wp_alternating">[5]–[8]</span>．</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-wp_sympoly" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">Wikipedia, <span>“Symmetric polynomial.”</span> <a href="https://en.wikipedia.org/wiki/Symmetric_polynomial" class="uri">https://en.wikipedia.org/wiki/Symmetric_polynomial</a>.</div>
</div>
<div id="ref-wp_e-basis" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">Wikipedia, <span>“Elementary symmetric polynomial.”</span> <a href="https://en.wikipedia.org/wiki/Elementary_symmetric_polynomial" class="uri">https://en.wikipedia.org/wiki/Elementary_symmetric_polynomial</a>.</div>
</div>
<div id="ref-wp_p-basis" class="csl-entry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">Wikipedia, <span>“Power sum symmetric polynomial.”</span> <a href="https://en.wikipedia.org/wiki/Power_sum_symmetric_polynomial" class="uri">https://en.wikipedia.org/wiki/Power_sum_symmetric_polynomial</a>.</div>
</div>
<div id="ref-wp_newton" class="csl-entry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">Wikipedia, <span>“Newton’s identities.”</span> <a href="https://en.wikipedia.org/wiki/Newton%27s_identities" class="uri">https://en.wikipedia.org/wiki/Newton%27s_identities</a>.</div>
</div>
<div id="ref-qiu-algebra" class="csl-entry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">丘维声, <span>“高等代数&nbsp;下册,”</span> 3rd ed.北京: 高等教育出版社, 2015, pp. 57–66.</div>
</div>
<div id="ref-lan-algebra" class="csl-entry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">蓝以中, <span>“高等代数简明教程（下册）,”</span> 2nd ed.北京: 北京大学出版社, 2007, pp. 213–217.</div>
</div>
<div id="ref-wp_partition" class="csl-entry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">Wikipedia, <span>“Partition (number theory).”</span> <a href="https://en.wikipedia.org/wiki/Partition_(number_theory)" class="uri">https://en.wikipedia.org/wiki/Partition_(number_theory)</a>.</div>
</div>
<div id="ref-wp_alternating" class="csl-entry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">Wikipedia, <span>“Alternating polynomial.”</span> <a href="https://en.wikipedia.org/wiki/Alternating_polynomial" class="uri">https://en.wikipedia.org/wiki/Alternating_polynomial</a>.</div>
</div>
</div></section></div> ]]></description>
  <category>数学</category>
  <category>讲稿</category>
  <category>slide</category>
  <guid>https://blog.sun123zxy.top/posts/20231018-discriminant/index.html</guid>
  <pubDate>Tue, 17 Oct 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>A Convolution-Oriented FFT Tutorial</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230928-dft/index.html</link>
  <description><![CDATA[ 



<section id="forewords" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Forewords</h1>
<section id="卷积但不止卷积---fft-漫谈" class="level3">
<h3 class="anchored" data-anchor-id="卷积但不止卷积---fft-漫谈">卷积，但不止卷积 - FFT 漫谈</h3>
<ul>
<li>先有 FT，再有 DFT，才有 FFT</li>
<li>时频转换是最初的用途</li>
<li>发现单位根优秀性质，James Cooley, John Tukey 发明现代 FFT 加速 DFT，但此前相似的发现早已有之</li>
<li>后来将 DFT 与卷积定理联系，FFT 才被用于计算多项式乘法</li>
<li>复数运算精度误差推动了 NTT 的发展</li>
<li>应用：任何需要频率和卷积的地方．频谱、滤波器、音乐、雷达、图像处理……</li>
<li>OI/XCPC 中主要关心卷积</li>
</ul>
</section>
<section id="推荐食用方法" class="level3">
<h3 class="anchored" data-anchor-id="推荐食用方法">推荐食用方法</h3>
<ul>
<li><p>初步要求</p>
<ul>
<li>知道 DFT、FFT 可用于快速计算多项式卷积</li>
<li>掌握 FFT 加速 DFT 计算的原理和实现</li>
<li>会应用结论改动 FFT 加速 NTT 计算</li>
<li>见识一些卷积解决的基本问题，初步了解生成函数在组合计数中的应用</li>
<li>题目可选择性完成，请多花时间消化原理和思想</li>
</ul></li>
<li><p>学有余力 / 集训后继续消化</p>
<ul>
<li>系统学习生成函数</li>
<li>实现多项式全家桶</li>
<li>对原理感兴趣的同学可对数学部分做进一步研究．本讲内容是线性代数、抽象代数、数论等多领域的综合应用．欢迎讨论．</li>
<li>学习集合幂级数相关知识点（FMT，FWT，……），体会其思想与 FFT 的同与异</li>
<li>学习 FFT 在信号、频谱等非算法竞赛向实际问题中的应用</li>
</ul></li>
<li><p>Learn for fun :)</p></li>
</ul>
</section>
<section id="记号说明" class="level3">
<h3 class="anchored" data-anchor-id="记号说明">记号说明</h3>
<ul>
<li><p>记 <img src="https://latex.codecogs.com/png.latex?%5Bn%5D%20=%20%5C%7B%200,1,%5Cdots,n-1%20%5C%7D">，此时可用 <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20%5Bn%5D"> 代替下标取值范围 <img src="https://latex.codecogs.com/png.latex?k=0,1,%5Cdots,n-1"> 的记法．</p>
<ul>
<li>集合论中已定义 <img src="https://latex.codecogs.com/png.latex?n%20=%20%5C%7B%200,1,%5Cdots,n-1%20%5C%7D">，这里的中括号是为了强调其集合含义．</li>
</ul></li>
<li><p>使用 Iverson 括号约定：设 <img src="https://latex.codecogs.com/png.latex?P"> 是一个命题，记 <img src="https://latex.codecogs.com/png.latex?%0A%5BP%5D%20:=%20%5Cbegin%7Bcases%7D%0A%20%20%20%20%20%20%20%201%20&amp;%20%5Ctext%7B$P$%20is%20true%7D%20%5C%5C%0A%20%20%20%20%20%20%20%200%20&amp;%20%5Ctext%7Botherwise%7D%0A%20%20%20%20%20%20%20%20%5Cend%7Bcases%7D%0A"></p></li>
<li><p>多项式的规模定义为多项式的次数加一．特别的，零多项式的规模为 <img src="https://latex.codecogs.com/png.latex?0">．</p>
<ul>
<li>以后会混用 <img src="https://latex.codecogs.com/png.latex?n-1"> 次多项式和规模为 <img src="https://latex.codecogs.com/png.latex?n"> 的多项式的说法．</li>
</ul></li>
</ul>
</section>
</section>
<section id="fftntt-in-a-nutshell" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> FFT/NTT in a nutshell</h1>
<section id="fft" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="fft"><span class="header-section-number">2.1</span> FFT</h2>
<section id="多项式卷积" class="level3">
<h3 class="anchored" data-anchor-id="多项式卷积">多项式卷积</h3>
<p>给定两个至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式 <img src="https://latex.codecogs.com/png.latex?%0AA(x)%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_k%20x%5Ek,%5Cquad%20B(x)%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20b_k%20x%5Ek%0A"> 如何快速计算两者的卷积，即它们相乘得到的多项式的系数？ <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20(A*B)(x)%20=%20A(x)B(x)%20&amp;=%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20a_i%20x%5Ei%20%5Csum_%7Bj=0%7D%5E%7Bn-1%7D%20b_j%20x%5Ej%20%5C%5C%0A%20%20%20%20%20%20%20%20&amp;=%20%5Csum_%7Bk=0%7D%5E%7B2n-2%7D%20x%5Ek%20%5Csum_%7Bi+j=k%7D%20a_i%20b_j%0A%20%20%20%20%5Cend%7Baligned%7D%0A"> 上式给出了 <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> 的朴素做法．</p>
</section>
<section id="系数---点值---系数" class="level3">
<h3 class="anchored" data-anchor-id="系数---点值---系数">系数 - 点值 - 系数</h3>
<ul>
<li><p>代入任意 <img src="https://latex.codecogs.com/png.latex?x"> 可得到多项式在 <img src="https://latex.codecogs.com/png.latex?x"> 处的点值</p></li>
<li><p>点值意义下的多项式乘法是 <img src="https://latex.codecogs.com/png.latex?O(n)"> 的 <img src="https://latex.codecogs.com/png.latex?%0A(A*B)(x)%20=%20A(x)B(x)%0A"></p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?n"> 点确定一个至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式<sup>1</sup></p></li>
</ul>
<p>若计算至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式的某 <img src="https://latex.codecogs.com/png.latex?n"> 个点值存在快速算法，而通过多项式的某 <img src="https://latex.codecogs.com/png.latex?n"> 个点值确定原多项式系数亦存在快速算法，就有通过 <img src="https://latex.codecogs.com/png.latex?O(n)"> 的点值乘法加速多项式乘法计算的可能．</p>
</section>
<section id="系数---点值---系数---快速转换" class="level3">
<h3 class="anchored" data-anchor-id="系数---点值---系数---快速转换">系数 - 点值 - 系数 - 快速转换？</h3>
<ul>
<li><p>朴素计算任意指定 <img src="https://latex.codecogs.com/png.latex?n"> 个位置点值需要 <img src="https://latex.codecogs.com/png.latex?O(n%5E2)">．</p></li>
<li><p>Lagrange<span class="citation" data-cites="oiwiki-lagrange">[1]</span> 插值给出了 <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> 将任意位置 <img src="https://latex.codecogs.com/png.latex?n"> 个点值还原为多项式系数的算法．</p></li>
<li><p>能否选取 <img src="https://latex.codecogs.com/png.latex?n"> 个特殊的点值使系数 - 点值、点值 - 系数的变换支持快速计算？</p></li>
</ul>
</section>
<section id="discrete-fourier-transform" class="level3">
<h3 class="anchored" data-anchor-id="discrete-fourier-transform">Discrete Fourier Transform</h3>
<p>离散傅里叶变换（Discrete Fourier Transform, DFT）接受一个至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式的 <img src="https://latex.codecogs.com/png.latex?n"> 个系数，将复数域上的 <img src="https://latex.codecogs.com/png.latex?n"> 个 <img src="https://latex.codecogs.com/png.latex?n"> 次单位根代入系数表达式以得到给定多项式的 <img src="https://latex.codecogs.com/png.latex?n"> 个点值． <img src="https://latex.codecogs.com/png.latex?%0Aa_0,a_1,%5Cdots,a_%7Bn-1%7D%20%5Clongrightarrow%20A(1),A(%5Comega_n),%5Cdots,A(%5Comega_n%5E%7Bn-1%7D)%0A"></p>
<p>得益于单位根的特殊运算性质，二者均有被称为快速傅里叶变换（Fast Fourier Transform, FFT）的快速算法．</p>
</section>
<section id="复数域单位根" class="level3">
<h3 class="anchored" data-anchor-id="复数域单位根">复数域单位根</h3>
<p>复数域上的 <img src="https://latex.codecogs.com/png.latex?n"> 个 <img src="https://latex.codecogs.com/png.latex?n"> 次单位根<sup>2</sup> <img src="https://latex.codecogs.com/png.latex?%0A%5Comega_n%5Ek%20:=%20e%5E%7B%5Cfrac%20%7B2%20%5Cpi%20k%7D%7Bn%7D%20i%7D%20=%20%5Ccos%20%5Cfrac%7B2%20%5Cpi%20k%7D%7Bn%7D%20+%20i%20%5Csin%20%5Cfrac%7B2%20%5Cpi%20k%7D%7Bn%7D,%5Cquad%20k%20%5Cin%20%5Bn%5D%0A"> 是复平面单位圆上的 <img src="https://latex.codecogs.com/png.latex?n"> 等分点，易验证它们是复数域中唯一满足方程 <img src="https://latex.codecogs.com/png.latex?z%5En%20=%201"> 的解．</p>
<p>所有单位根模长均为 <img src="https://latex.codecogs.com/png.latex?1">．第 <img src="https://latex.codecogs.com/png.latex?k"> 个单位根的辐角为 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%20%7B2%20%5Cpi%20k%7D%7Bn%7D">．复数乘法”模长相乘，辐角相加”的性质告诉我们 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%5Ei%20%5Comega_n%5Ej%20=%20%5Comega_n%5E%7Bi+j%7D">．</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em> (Euler’s formula for nerds). </span>Euler 公式 <img src="https://latex.codecogs.com/png.latex?e%5E%7Bit%7D%20=%20%5Ccos%20t%20+%20i%20%5Csin%20t"> 的一种证明可用指数函数的另一定义 <img src="https://latex.codecogs.com/png.latex?%5Cexp%20z%20=%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20(1+%5Cfrac%20z%20n)%5En"> 分析复数处极坐标的极限 <span class="citation" data-cites="euler-formula">[2]</span>．严格来讲，如果三角函数和指数函数都由级数定义 <span class="citation" data-cites="trigonometry">[3]</span>，Euler 公式几乎是显然的．总之，这里仅将 Euler 公式作为一种紧凑的记号使用，细节不做要求．</p>
</div>
</section>
<section id="复数域单位根---三个重要性质" class="level3">
<h3 class="anchored" data-anchor-id="复数域单位根---三个重要性质">复数域单位根 - 三个重要性质<sup>3</sup></h3>
<div id="thm-cancel" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (消去引理) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Comega_%7Bdn%7D%5E%7Bdk%7D%20=%20%5Comega_n%5Ek,%5Cquad%20%5Cforall%20d%20%5Cin%20%5Cmathbb%20N_+%0A"></p>
</div>
<div id="thm-half" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 (折半引理) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%5C%7B%20%5Comega_%7B2n%7D%5E%7B2k%7D%20:%20k%20%5Cin%20%5B2n%5D%20%5Cright%5C%7D%20=%20%5Cleft%5C%7B%20%5Comega_n%5Ek%20:%20k%20%5Cin%20%5Bn%5D%20%5Cright%5C%7D%0A"></p>
</div>
<p>消去 / 折半引理将在 FFT 的推导中使用．</p>
</section>
<section id="复数域单位根---三个重要性质-1" class="level3">
<h3 class="anchored" data-anchor-id="复数域单位根---三个重要性质-1">复数域单位根 - 三个重要性质</h3>
<div id="thm-summation" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (求和引理) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%201%20n%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20%5Comega_n%5E%7Bik%7D%20=%20%5Bn%20%5Cmid%20i%5D%0A"></p>
</div>
<p>求和引理的证明使用了等比数列求和公式．将在 IDFT 的推导中用到．</p>
</section>
<section id="fast-fourier-transform" class="level3">
<h3 class="anchored" data-anchor-id="fast-fourier-transform">Fast Fourier Transform</h3>
<p>考虑将至多 <img src="https://latex.codecogs.com/png.latex?2n-1"> 次的待变换多项式 <img src="https://latex.codecogs.com/png.latex?A(x)%20=%20%5Csum_%7Bk=0%7D%5E%7B2n-1%7D%20a_k%20x%5Ek"> 奇偶分项两个至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式 <img src="https://latex.codecogs.com/png.latex?A(x)%20=%20A_0%20(x%5E2)%20+%20x%20A_1(x%5E2)">，其中 <img src="https://latex.codecogs.com/png.latex?%0AA_0%20(x)%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k%7D%20x%5Ek,%5Cquad%0AA_1%20(x)%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k+1%7D%20x%5Ek%0A"> 代入 <img src="https://latex.codecogs.com/png.latex?x%20=%20%5Comega_%7B2n%7D%5Ek,%5C,%20k%20%5Cin%20%5B2n%5D">，用单位根消去或折半引理（<img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D%5E%7B2k%7D%20=%20%5Comega_n%5Ek">）得 <img src="https://latex.codecogs.com/png.latex?%0AA(%5Comega_%7B2n%7D%5Ek)%20=%20A_0%20(%5Comega_%7Bn%7D%5Ek)%20+%20%5Comega_%7B2n%7D%5Ek%20A_1%20(%5Comega_%7Bn%7D%5Ek)%0A"> 再用 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D%5E%7Bn%7D%20=%20-1"> 得 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AA(%5Comega_%7B2n%7D%5Ek)%20&amp;=%20A_0%20(%5Comega_n%5Ek)%20+%20%5Comega_%7B2n%7D%5Ek%20A_1%20(%5Comega_n%5Ek)%20%5C%5C%0AA(%5Comega_%7B2n%7D%5E%7Bn+k%7D)%20&amp;=%20A_0%20(%5Comega_n%5Ek)%20-%20%5Comega_%7B2n%7D%5Ek%20A_1(%5Comega_n%5Ek)%0A%5Cend%7Baligned%7D%0A,%5Cquad%20k%20%5Cin%20%5Bn%5D%0A"> 原多项式 <img src="https://latex.codecogs.com/png.latex?A(x)"> 规模为 <img src="https://latex.codecogs.com/png.latex?2n"> 的 DFT 转化为规模为 <img src="https://latex.codecogs.com/png.latex?n"> 的 <img src="https://latex.codecogs.com/png.latex?A_0(x)"> 和 <img src="https://latex.codecogs.com/png.latex?A_1(x)"> 的 DFT．递归计算就可得到 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)"> 的算法．</p>
</section>
<section id="dft-的矩阵表示" class="level3">
<h3 class="anchored" data-anchor-id="dft-的矩阵表示">DFT 的矩阵表示</h3>
<p>记 <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Bgathered%7D%0A%5Cboldsymbol%20a%20=%20%20%5Cbegin%7Bpmatrix%7Da_0%20%5C%5C%20a_1%20%5C%5C%20%5Cvdots%20%5C%5C%20a_%7Bn-1%7D%5Cend%7Bpmatrix%7D,%5Cquad%0AF%20=%20%5Cleft(%20%5Comega_n%5E%7Bij%7D%20%5Cright)_%7B(i,j)%20%5Cin%20n%20%5Ctimes%20n%7D%20=%20%5Cbegin%7Bpmatrix%7D%0A1%20&amp;%201%20&amp;%20%5Cdots%20&amp;%201%20%5C%5C%0A1%20&amp;%20%5Comega_n%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7Bn-1%7D%20%5C%5C%0A%5Cvdots%20&amp;%20%5Cvdots%20&amp;%20%5Cddots%20&amp;%20%5Cvdots%20%5C%5C%0A1%20&amp;%20%5Comega_n%5E%7Bn-1%7D%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7B(n-1)(n-1)%7D%0A%5Cend%7Bpmatrix%7D%0A%5Cend%7Bgathered%7D%0A"> 则 DFT 的变换结果（给定系数 <img src="https://latex.codecogs.com/png.latex?a_0,a_1,%5Cdots,a_%7Bn-1%7D"> 的多项式在 <img src="https://latex.codecogs.com/png.latex?n"> 个 <img src="https://latex.codecogs.com/png.latex?n"> 次单位根处的点值）可表示为 <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Cboldsymbol%20a%7D%20=%20%5Cbegin%7Bpmatrix%7DA(1)%20%5C%5C%20A(%5Comega_n)%20%5C%5C%20%5Cvdots%20%5C%5C%20A(%5Comega_n%5E%7Bn-1%7D)%5Cend%7Bpmatrix%7D%20=%20F%20%5Cboldsymbol%20a%0A"></p>
</section>
<section id="idft" class="level3">
<h3 class="anchored" data-anchor-id="idft">IDFT</h3>
<p>由单位根的消去引理可证，DFT 矩阵 <img src="https://latex.codecogs.com/png.latex?F"> 的逆矩阵为<sup>4</sup> <img src="https://latex.codecogs.com/png.latex?%0AF%5E%7B-1%7D%20=%20%5Cfrac%201%20n%20%5Cleft(%20%5Comega_n%5E%7B-ij%7D%20%5Cright)_%7B(i,j)%20%5Cin%20n%20%5Ctimes%20n%7D%20=%20%5Cfrac%201%20n%20%5Cbegin%7Bpmatrix%7D%0A1%20&amp;%201%20&amp;%20%5Cdots%20&amp;%201%20%5C%5C%0A1%20&amp;%20%5Comega_n%5E%7B-1%7D%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7B-(n-1)%7D%20%5C%5C%0A%5Cvdots%20&amp;%20%5Cvdots%20&amp;%20%5Cddots%20&amp;%20%5Cvdots%20%5C%5C%0A1%20&amp;%20%5Comega_n%5E%7B-(n-1)%7D%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7B-(n-1)(n-1)%7D%0A%5Cend%7Bpmatrix%7D%0A"> 于是 IDFT 的过程可表示为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cboldsymbol%20a%20%20=%20F%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%20a%7D%0A"></p>
<p>故快速计算 IDFT 的方法与 FFT 几乎一致，只需将计算 DFT 时使用的本原单位根 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 替换为 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%5E%7B-1%7D"> 并对最终结果除以 <img src="https://latex.codecogs.com/png.latex?n"> 即可．</p>
</section>
<section id="梳理" class="level3">
<h3 class="anchored" data-anchor-id="梳理">梳理</h3>
<ul>
<li><p>怎么计算卷积？</p>
<ul>
<li>把至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式 <img src="https://latex.codecogs.com/png.latex?A(x)"> 和至多 <img src="https://latex.codecogs.com/png.latex?m-1"> 次的多项式 <img src="https://latex.codecogs.com/png.latex?B(x)"> 写成至多 <img src="https://latex.codecogs.com/png.latex?n+m-2"> 次的多项式（高位补 <img src="https://latex.codecogs.com/png.latex?0">）．为计算 FFT 方便，还要继续补 <img src="https://latex.codecogs.com/png.latex?0"> 至一个大于其次数的 <img src="https://latex.codecogs.com/png.latex?2"> 的幂．</li>
<li>对 <img src="https://latex.codecogs.com/png.latex?A(x)"> 和 <img src="https://latex.codecogs.com/png.latex?B(x)"> 多点求值．</li>
<li>把两个多项式的点值逐点相乘．</li>
<li>多点插值还原 <img src="https://latex.codecogs.com/png.latex?(A*B)(x)"> 的系数．</li>
</ul></li>
<li><p>怎么快速求值？</p>
<ul>
<li>选点选单位根就是 DFT．</li>
<li>消去引理和折半引理使我们可以用 FFT 算法递归地计算 DFT．</li>
<li>推导已经给出了递归的写法，之后还会介绍常数更优的迭代实现．</li>
</ul></li>
<li><p>怎么快速插值？</p>
<ul>
<li>求和引理给出了 DFT 矩阵的逆矩阵．</li>
<li>计算方法很相似，最后逐项除掉一个规模．</li>
</ul></li>
</ul>
</section>
<section id="fft-递归实现---dft-部分" class="level3">
<h3 class="anchored" data-anchor-id="fft-递归实现---dft-部分">FFT 递归实现 - DFT 部分</h3>
<p>方便起见，我们只处理 <img src="https://latex.codecogs.com/png.latex?n"> 为 <img src="https://latex.codecogs.com/png.latex?2"> 的幂的情形．以下 C 风格的代码实现了递归的 DFT 和 IDFT．</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">#include</span><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">#include</span><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">&lt;complex&gt;</span></span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">using</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">namespace</span> std<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">typedef</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">long</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">long</span> ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">typedef</span> complex<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">double</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> CP<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-5"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> ll MXN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">4E6</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">double</span> PI<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">3.14159265358979323846</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">l</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-6">CP tmp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>MXN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb1-7"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> _DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>CP A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[],</span>ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb1-8">    n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> tmp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">],</span>tmp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb1-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>tmp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb1-11">    _DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span> _DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb1-12">    CP w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>cos<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>PI<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)),</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>sin<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>PI<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">))),</span> wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-13">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++){</span></span>
<span id="cb1-14">        tmp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>  k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]+</span>wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb1-15">        tmp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]-</span>wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb1-16">        wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*=</span>w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-17">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>tmp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb1-18"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>CP A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[],</span>ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb1-19">    _DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]*=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.0</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">l</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-20"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</section>
<section id="fft-递归实现---卷积部分" class="level3">
<h3 class="anchored" data-anchor-id="fft-递归实现---卷积部分">FFT 递归实现 - 卷积部分</h3>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">// alternatively, use std::__lg() in GCC</span></span>
<span id="cb2-2">ll log2ceil<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span>ll cnt<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll t<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>t<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>t<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> cnt<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++;</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> cnt<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;}</span> </span>
<span id="cb2-3">CP A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>MXN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">],</span>B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>MXN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">],</span>C<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>MXN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span> ll outC<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>MXN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb2-4">ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> conv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll inA<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[],</span>ll aN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll inB<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[],</span>ll bN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb2-5">    ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">LL</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;</span>log2ceil<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>aN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>bN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb2-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>aN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>inA<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb2-7">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>bN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>inB<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb2-8">    DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span> DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb2-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> C<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]*</span>B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb2-10">    DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>C<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> outC<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>round<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>C<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">].</span>real<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">());</span></span>
<span id="cb2-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> outC<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-12"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>Drawbacks?</p>
<ul>
<li>递归实现慢</li>
<li>临时数组丑</li>
<li>封装性为零</li>
</ul>
</section>
<section id="fft-迭代" class="level3">
<h3 class="anchored" data-anchor-id="fft-迭代">FFT 迭代</h3>
<p>迭代地实现 FFT 不仅在常数上更加优秀，亦更便于使用 C++ 的容器进行封装．这并不困难，只需自底向上模拟 FFT 递归过程即可．</p>
<p>唯一的问题——最底层的顺序？</p>
<p>来观察一轮 <img src="https://latex.codecogs.com/png.latex?2%5E3">-FFT 自顶向下的置换过程 <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Bmatrix%7D%0A2%5E3%20&amp;%200/000%20&amp;%201/001%20&amp;%202/010%20&amp;%203/011%20&amp;%204/100%20&amp;%205/101%20&amp;%206/110%20&amp;%207/111%20%5C%5C%0A2%5E2%20&amp;%200/000%20&amp;%202/010%20&amp;%204/100%20&amp;%206/110%20&amp;%201/001%20&amp;%203/011%20&amp;%205/101%20&amp;%207/111%20%5C%5C%0A2%5E1%20&amp;%200/000%20&amp;%204/100%20&amp;%202/010%20&amp;%206/110%20&amp;%201/001%20&amp;%205/101%20&amp;%203/011%20&amp;%207/111%20%5C%5C%0A2%5E0%20&amp;%200/000%20&amp;%204/100%20&amp;%202/010%20&amp;%206/110%20&amp;%201/001%20&amp;%205/101%20&amp;%203/011%20&amp;%207/111%0A%5Cend%7Bmatrix%7D%0A"></p>
<p>你发现了什么？</p>
</section>
<section id="蝶形运算" class="level3">
<h3 class="anchored" data-anchor-id="蝶形运算">蝶形运算</h3>
<p>在计算点值前，<img src="https://latex.codecogs.com/png.latex?2%5En">-FFT 事实上完成了一次 <img src="https://latex.codecogs.com/png.latex?n">-位逆序置换．分解来看，规模为 <img src="https://latex.codecogs.com/png.latex?2%5Ek"> 的层的置换完成了对 <img src="https://latex.codecogs.com/png.latex?2%5E%7Bn-k%7D"> 对应二进制位的分类．</p>
<p>我们有 <img src="https://latex.codecogs.com/png.latex?O(n)"> 的递推方法获得这一置换．</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> spawnrev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb3-2">    rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb3-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span></span>
<span id="cb3-4">        rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=(</span>rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]&gt;&gt;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)+((</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)&lt;&lt;(</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span></span>
<span id="cb3-5"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</section>
<section id="fft-迭代实现" class="level3">
<h3 class="anchored" data-anchor-id="fft-迭代实现">FFT 迭代实现</h3>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> DFT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>CP A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[],</span>ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">// rev[] should be spawned in advance</span></span>
<span id="cb4-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">])</span> swap<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">],</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]]);</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">// a one-to-one permutation</span></span>
<span id="cb4-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb4-4">        CP w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>cos<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>PI<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)),</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>sin<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>PI<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">))),</span> wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-5">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb4-6">            CP wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-7">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++){</span></span>
<span id="cb4-8">                CP x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">],</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb4-9">                A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span>k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-10">                wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>wk<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-11">            <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-12">        <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-13">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-14">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]*=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.0</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">l</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-15"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>请自行实现更易用的容器封装版本．</p>
</section>
</section>
<section id="ntt" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="ntt"><span class="header-section-number">2.2</span> NTT</h2>
<section id="ntt-速成" class="level3">
<h3 class="anchored" data-anchor-id="ntt-速成">NTT 速成<sup>5</sup></h3>
<p>FFT 的缺点？浮点数带来的大常数与精度问题．</p>
<p><img src="https://latex.codecogs.com/png.latex?998244353=2%5E%7B23%7D%20%5Ctimes%207%20%5Ctimes%2017%20+%201">，同时是一个质数．</p>
<p>我们指出，在系数和点值模 <img src="https://latex.codecogs.com/png.latex?p=998244353"> 的意义下，当规模 <img src="https://latex.codecogs.com/png.latex?n%20%5Cleq%20p"> 时<sup>6</sup>，至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式仍可由其 <img src="https://latex.codecogs.com/png.latex?n"> 个点值唯一确定，故仍可使用系数-点值-系数的方法求得多项式卷积．</p>
<p>我们指出，对于满足 <img src="https://latex.codecogs.com/png.latex?n%20%5Cmid%20p-1"> 的 <img src="https://latex.codecogs.com/png.latex?n">，依 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%20:=%203%5E%7B%5Cfrac%7Bp-1%7D%7Bn%7D%7D"> 定义的 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 在模 <img src="https://latex.codecogs.com/png.latex?p"> 意义下与复数域中定义的 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 发挥相同的作用，仍可进行规模至多为 <img src="https://latex.codecogs.com/png.latex?2%5E%7B23%7D"> 的 FFT 作为模 <img src="https://latex.codecogs.com/png.latex?p=998244353"> 意义下 NTT 的快速算法．</p>
<p>只需修改单位根定义，把复数运算改为整数取模，就得到了能算 NTT 的 FFT 的实现．</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> PR<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>MOD<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">998244353</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb5-2">ll w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>qpow<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>PR<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,(</span>MOD<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)/(</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>typ<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>inv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>w<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span></code></pre></div>
</section>
<section id="fftntt-in-a-nutshell---小结概念区分" class="level3">
<h3 class="anchored" data-anchor-id="fftntt-in-a-nutshell---小结概念区分">FFT/NTT in a nutshell - 小结：概念区分</h3>
<ul>
<li><p>关于 DFT</p>
<ul>
<li>Discrete Fourier Transform, DFT, 离散傅里叶变换</li>
<li>Fast Fourier Transform, FFT, 快速傅里叶变换</li>
<li>FFT 是计算 DFT 的快速算法</li>
</ul></li>
<li><p>关于 NTT</p>
<ul>
<li>Number Theoretic Transform, NTT, 数论变换</li>
<li>FFT 在复数域上的多项式环 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BC%7D%5Bx%5D"> 中进行，而 NTT 在模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BZ%7D_p%5Bx%5D"> 上进行</li>
<li>快速计算 DFT / IDFT, NTT 都用 FFT，故一般不使用”FNTT”的说法</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="applications" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Applications</h1>
<section id="基本应用" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="基本应用"><span class="header-section-number">3.1</span> 基本应用</h2>
<section id="基本应用-1" class="level3">
<h3 class="anchored" data-anchor-id="基本应用-1">基本应用</h3>
<dl>
<dt>大整数乘法</dt>
<dd>
<p>十进制数可拆解为多项式表示，计算卷积后处理进位即可．由于数字最大只是 <img src="https://latex.codecogs.com/png.latex?9">，合理数据范围下卷起来不会爆模数，直接用 NTT 实现即可．</p>
</dd>
<dt>背包计数</dt>
<dd>
<p>两个背包的合并就是多项式卷积．</p>
</dd>
<dt>滤波器</dt>
<dd>
<p>反转多项式的系数数组再做卷积，可以快速得到两个多项式滑动窗口式的内积．</p>
</dd>
<dt>位运算</dt>
<dd>
<p>有些位运算可以写成卷积的形式．模 <img src="https://latex.codecogs.com/png.latex?2"> 意义下”异或”是加法，“与”是乘法，“或”可以通过取反转化为”与”．</p>
</dd>
<dt>字符串</dt>
<dd>
<p>通过巧妙设定字符串距离函数，FFT 可解决更广泛的字符串匹配问题．</p>
</dd>
<dt>值域次数化</dt>
<dd>
<p>当值域较小时，将待计算的值放在多项式次数上统计贡献次数，可以绕开某些极难求解的数值问题．例如 Vandermonde 行列式的快速计算．</p>
</dd>
</dl>
</section>
<section id="基本应用---分治-fft" class="level3">
<h3 class="anchored" data-anchor-id="基本应用---分治-fft">基本应用 - 分治 FFT</h3>
<p>对多个长度相同的多项式的卷积，分治地卷起来可降低时间复杂度．长度不一时，挑小的先卷也可减小常数（用堆维护）．</p>
<p>另有一种 CDQ 风格的分治 FFT．CDQ 长于处理带偏序的二元点对贡献，在处理形如 <img src="https://latex.codecogs.com/png.latex?c_k%20=%20%5Csum_%7Bi%3Ej%7D%20%5Bi+j=k%5D%20a_i%20b_j"> 的带偏序卷积时可以应用．</p>
<p>当卷积的前后项存在依赖关系时，也可使用此法保证处理顺序恰当．然而此类依赖问题往往也可通过解生成函数方程的方法求得封闭形式．</p>
<p>时间复杂度均为 <img src="https://latex.codecogs.com/png.latex?%0AT(n)%20=%202%20T%20%5Cleft(%20%5Cfrac%20n%202%20%5Cright)%20+%20O(n%20%5Clog%20n)%20=%20O(n%20%5Clog%5E2%20n)%0A"></p>
</section>
</section>
<section id="生成函数初步" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="生成函数初步"><span class="header-section-number">3.2</span> 生成函数初步</h2>
<section id="生成函数初步---导言" class="level3">
<h3 class="anchored" data-anchor-id="生成函数初步---导言">生成函数初步 - 导言</h3>
<p>生成函数是一种对数列的操作技巧．通过将数列表示为多项式或形式幂级数，数列间复杂的和式操作可用简单函数的乘法、复合等运算进行表示，从而大大降低了数列变换技巧的使用门槛．</p>
<p>生成函数在组合数学中应用广泛，且生成函数的部分操作在组合意义下也有较为直观的理解．本节将带大家初窥其中的奥妙．限于篇幅和主讲人能力，我们仅以题带点地讲解，期冀为大家建立构造生成函数的直觉．请感兴趣的同学下来做进一步研究．</p>
<p>熟悉 Taylor 展开的同学或能较快上手此部分内容．</p>
</section>
<section id="ordinary-generating-function" class="level3">
<h3 class="anchored" data-anchor-id="ordinary-generating-function">Ordinary Generating Function</h3>
<p>序列 <img src="https://latex.codecogs.com/png.latex?a_n"> 的普通生成函数（Ordinary Generating Function, OGF）定义为其对应的多项式（形式幂级数）<img src="https://latex.codecogs.com/png.latex?A(x)%20=%20%5Csum_%7Bn=0%7D%5E%7B+%5Cinfty%7D%20a_n%20x%5En">．这样书写的目的是为了便于进行数列间的卷积操作．特别的，Taylor 展开（或广义二项式定理）风格的 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%20%7B1-x%7D%20=%201%20+%20x%20+%20x%5E2%20+%20%5Cdots"> 也是常用技巧之一<sup>7</sup>．</p>
<div id="exr-ogf-basic" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1 </strong></span>写出下列数列的 OGF．下标从 <img src="https://latex.codecogs.com/png.latex?0"> 开始．</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?1,0,0,0%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,1,1,1,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,0,1,0,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,-1,1,-1,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,2,3,4,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,2,4,8,%5Cdots"></li>
</ul>
</div>
</section>
<section id="ogf-组合意义" class="level3">
<h3 class="anchored" data-anchor-id="ogf-组合意义">OGF 组合意义</h3>
<p>OGF 相乘，是背包，是卷积，是两块无标号组合对象的有序拼接．</p>
<div id="exr-ogf-comb" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2 </strong></span>写出下列计数问题的 OGF，均以 <img src="https://latex.codecogs.com/png.latex?n"> 作为数列的下标．</p>
<ul>
<li>在 <img src="https://latex.codecogs.com/png.latex?m"> 个物品中选出 <img src="https://latex.codecogs.com/png.latex?n"> 个的方案数．</li>
<li>容量为 <img src="https://latex.codecogs.com/png.latex?n"> 的背包装下体积分别为 <img src="https://latex.codecogs.com/png.latex?a_i"> 的 <img src="https://latex.codecogs.com/png.latex?m"> 个物品的方案数．</li>
<li>同上，但每个物品有无限个．</li>
<li><img src="https://latex.codecogs.com/png.latex?n"> 个无标号球放入 <img src="https://latex.codecogs.com/png.latex?r"> 个有标号盒的方案数，要求盒非空．</li>
<li>同上，但盒可空．</li>
<li>将整数 <img src="https://latex.codecogs.com/png.latex?n"> 分拆为若干正整数之和的方案数．</li>
</ul>
</div>
</section>
<section id="exponential-generating-function" class="level3">
<h3 class="anchored" data-anchor-id="exponential-generating-function">Exponential Generating Function</h3>
<p>序列 <img src="https://latex.codecogs.com/png.latex?a_n"> 的指数生成函数（Exponential Generating Function, EGF）定义为 <img src="https://latex.codecogs.com/png.latex?%0AA(x)%20=%20%5Csum_%7Bn=0%7D%5E%7B+%5Cinfty%7D%20a_n%20%5Cfrac%20%7Bx%5En%7D%7Bn!%7D%0A"></p>
<div id="exr-egf-basic" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 3 </strong></span>写出下列序列的 EGF，下标从 <img src="https://latex.codecogs.com/png.latex?0"> 开始．</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?1,0,0,0,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,1,1,1,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,2,4,8,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?0,1,0,-1,0,1,0,-1,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?1,0,-1,0,1,0,-1,0,%5Cdots"></li>
<li><img src="https://latex.codecogs.com/png.latex?0,1,-1,2!,-3!,4!,%5Cdots"></li>
</ul>
</div>
</section>
<section id="egf-组合意义" class="level3">
<h3 class="anchored" data-anchor-id="egf-组合意义">EGF 组合意义</h3>
<p>观察两个 EGF 的乘积 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AA(x)%20B(x)%20&amp;=%20%5Csum_%7Bi=0%7D%5E%7B+%5Cinfty%7D%20a_i%20%5Cfrac%7Bx%5Ei%7D%7Bi!%7D%20%5Csum_%7Bj=0%7D%5E%7B+%5Cinfty%7D%20b_j%20%5Cfrac%7Bx%5Ej%7D%7Bj!%7D%20%5C%5C%0A&amp;=%20%5Csum_%7Bi=0%7D%5E%7B+%5Cinfty%7D%20%5Csum_%7Bj=0%7D%5E%7B+%5Cinfty%7D%20a_i%20b_j%20%5Cfrac%7Bx%5E%7Bi+j%7D%7D%7Bi!%20j!%7D%20%5C%5C%0A&amp;=%20%5Csum_%7Bn=0%7D%5E%7B+%5Cinfty%7D%20%5Csum_%7Bi=0%7D%5En%20a_i%20b_%7Bn-i%7D%20%5Cfrac%7Bx%5En%7D%7Bi!%20(n-i)!%7D%20%5C%5C%0A&amp;=%20%5Csum_%7Bn=0%7D%5E%7B+%5Cinfty%7D%20%5Csum_%7Bi=0%7D%5En%20a_i%20b_%7Bn-i%7D%20%5Cbinom%20n%20i%20%5Cfrac%7Bx%5En%7D%7Bn!%7D%0A%5Cend%7Baligned%7D%0A"> EGF 的乘积，相当于两块有标号组合对象的有序拼接．</p>
</section>
<section id="egf-组合意义-1" class="level3">
<h3 class="anchored" data-anchor-id="egf-组合意义-1">EGF 组合意义</h3>
<p><img src="https://latex.codecogs.com/png.latex?%0AA(x)%20B(x)%20=%20%5Csum_%7Bi=0%7D%5E%7B+%5Cinfty%7D%20a_i%20%5Cfrac%7Bx%5Ei%7D%7Bi!%7D%20%5Csum_%7Bj=0%7D%5E%7B+%5Cinfty%7D%20b_j%20%5Cfrac%7Bx%5Ej%7D%7Bj!%7D%0A=%20%5Csum_%7Bn=0%7D%5E%7B+%5Cinfty%7D%20%5Csum_%7Bi=0%7D%5En%20a_i%20b_%7Bn-i%7D%20%5Cbinom%20n%20i%20%5Cfrac%7Bx%5En%7D%7Bn!%7D"></p>
<div id="exr-egf-comb" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 4 </strong></span>写出下列计数问题的 EGF，均以 <img src="https://latex.codecogs.com/png.latex?n"> 作为数列的下标．</p>
<ul>
<li>长度为 <img src="https://latex.codecogs.com/png.latex?n"> 的排列的构型数．</li>
<li>长度为 <img src="https://latex.codecogs.com/png.latex?n"> 的圆排列的构型数．</li>
<li>将 <img src="https://latex.codecogs.com/png.latex?n"> 个有标号球放入 <img src="https://latex.codecogs.com/png.latex?r"> 个有标号盒的方案数，要求盒非空．</li>
<li>将 <img src="https://latex.codecogs.com/png.latex?n"> 个有标号球放入 <img src="https://latex.codecogs.com/png.latex?r"> 个无标号盒的方案数，要求盒非空．</li>
<li>将 <img src="https://latex.codecogs.com/png.latex?n"> 元集合划分为 <img src="https://latex.codecogs.com/png.latex?r"> 个等价类的方案数．</li>
<li>划分 <img src="https://latex.codecogs.com/png.latex?n"> 元集合的方案数．</li>
</ul>
</div>
</section>
</section>
</section>
<section id="mathematics-behind" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Mathematics behind</h1>
<section id="ntt-原理" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="ntt-原理"><span class="header-section-number">4.1</span> NTT 原理</h2>
<section id="ntt-原理---导言" class="level3">
<h3 class="anchored" data-anchor-id="ntt-原理---导言">NTT 原理 - 导言</h3>
<p>本节介绍 NTT 的原理．</p>
<p>FFT 加速卷积算法的核心，一是多项式的求值插值原理，二是单位根带来的分治快速算法．我们将在本节中证明，模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 中，只要 <img src="https://latex.codecogs.com/png.latex?n%20%5Cleq%20p">，仍可通过 <img src="https://latex.codecogs.com/png.latex?n"> 个点值唯一确定至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 上的多项式，这保证了系数-点值-系数方法的正确性；此外，基于原根构造出的 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 上的本原单位根，使得使用与 FFT 相同的分治算法加速 NTT 的计算成为可能．</p>
<p>NTT 原理涉及原根等数论内容．本讲的目标是建立 DFT 变换和 FFT 算法的通用数学框架，而非具体研究其某一特例．故我们只讲解 NTT 所需的基础数论知识，无关的细节则略过处理．对数论感兴趣的同学可前往 OI Wiki 学习．</p>
</section>
<section id="模-p-剩余类域-mathbb-z_p" class="level3">
<h3 class="anchored" data-anchor-id="模-p-剩余类域-mathbb-z_p">模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"></h3>
<p><em>模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域</em> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 是刻画取模运算下整数加法、乘法运算规律的代数结构，其良定义性由 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bcases%7D%0A%20%20%20%20a_1%20%5Cequiv%20a_2%20%5Cpmod%7Bp%7D%20%5C%5C%0A%20%20%20%20b_1%20%5Cequiv%20b_2%20%5Cpmod%7Bp%7D%0A%5Cend%7Bcases%7D%0A%20%20%5Cimplies%0A%5Cbegin%7Bcases%7D%0A%20%20%20%20a_1%20+%20b_1%20%5Cequiv%20a_2%20+%20b_2%20%5Cpmod%7Bp%7D%20%5C%5C%0A%20%20%20%20a_1%20b_1%20%5Cequiv%20a_2%20b_2%20%5Cpmod%7Bp%7D%0A%5Cend%7Bcases%7D%0A"> 保证．</p>
<p>模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域的最大特点是其中每个元素都存在（唯一）逆元．这一点是数论中 Bézout 定理的直接应用．</p>
<p>模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域的另一优良性质是其满足消去律，即 <img src="https://latex.codecogs.com/png.latex?%0Aab%20%5Cequiv%200%20%5Cpmod%20p%20%5Cimplies%20a%20%5Cequiv%200%20%5Clor%20b%20%5Cequiv%200%20%5Cpmod%20p%0A"> 而模一般的数 <img src="https://latex.codecogs.com/png.latex?m"> 形成的代数结构则不满足此性质．</p>
</section>
<section id="mathbb-z_px-上的多点插值" class="level3">
<h3 class="anchored" data-anchor-id="mathbb-z_px-上的多点插值"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D"> 上的多点插值</h3>
<p>之后记系数均在 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 上的多项式组成的集合为 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D">．</p>
<div id="lem-zp-remainder" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1 (<img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%20%5Clbrack%20x%20%5Crbrack"> 上的多项式余式定理) </strong></span>设 <img src="https://latex.codecogs.com/png.latex?A(x)%20%5Cin%20%5Cmathbb%20Z_p%5Bx%5D">，用 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D"> 中的一次多项式 <img src="https://latex.codecogs.com/png.latex?(x-a)"> 对 <img src="https://latex.codecogs.com/png.latex?A(x)"> 进行带余除法，得到的余式为至多零次的多项式 <img src="https://latex.codecogs.com/png.latex?A(a)">．</p>
</div>
</section>
<section id="mathbb-z_px-上的多点插值-1" class="level3">
<h3 class="anchored" data-anchor-id="mathbb-z_px-上的多点插值-1"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D"> 上的多点插值</h3>
<div id="thm-lagrange" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4 (Lagrange 定理) </strong></span>设 <img src="https://latex.codecogs.com/png.latex?p"> 是一个质数，设 <img src="https://latex.codecogs.com/png.latex?A(x)%20%5Cin%20%5Cmathbb%20Z_p%5Bx%5D">．同余方程 <img src="https://latex.codecogs.com/png.latex?A(x)%20%5Cequiv%200%20%5Cpmod%7Bp%7D"> 只有至多 <img src="https://latex.codecogs.com/png.latex?%5Cdeg%20A(x)"> 个模 <img src="https://latex.codecogs.com/png.latex?p"> 意义下不同的整数解，除非这多项式的系数全为零．</p>
</div>
<div id="cor-lagrange-equal" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 </strong></span>设 <img src="https://latex.codecogs.com/png.latex?A(x),B(x)%20%5Cin%20%5Cmathbb%20Z_p%5Bx%5D"> 是至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的两个多项式．若同余方程 <img src="https://latex.codecogs.com/png.latex?A(x)%20%5Cequiv%20B(x)%20%5Cpmod%7Bp%7D"> 有 <img src="https://latex.codecogs.com/png.latex?n"> 个不同的模 <img src="https://latex.codecogs.com/png.latex?p"> 意义下的整数解，则两多项式一定相等．</p>
</div>
<p>推论告诉我们，欲确定 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 上的一个至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式，只需找到其 <img src="https://latex.codecogs.com/png.latex?n"> 个模 <img src="https://latex.codecogs.com/png.latex?p"> 意义下的点值即可．因此，使用系数 - 点值 - 系数方法加速 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D"> 上的卷积是可行的．</p>
</section>
<section id="本原单位根" class="level3">
<h3 class="anchored" data-anchor-id="本原单位根">本<strong>原</strong>单位<strong>根</strong></h3>
<p>回顾 DFT 中复数域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20C"> 上单位根的定义 <img src="https://latex.codecogs.com/png.latex?%0A%5Comega_n%5Ek%20:=%20e%5E%7B%5Cfrac%20%7B2%20%5Cpi%20k%7D%7Bn%7D%20i%7D%20=%20%5Ccos%20%5Cfrac%7B2%20%5Cpi%20k%7D%7Bn%7D%20+%20i%20%5Csin%20%5Cfrac%7B2%20%5Cpi%20k%7D%7Bn%7D,%5Cquad%20k%20%5Cin%20%5Bn%5D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 是最重要的单位根，因为它生成了所有其它的单位根．</p>
<p>事实上所有的 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%5E%7Bk%7D%20:%20%5Cgcd(n,k)=1"> 也都是重要的，它们的 <img src="https://latex.codecogs.com/png.latex?0"> 至 <img src="https://latex.codecogs.com/png.latex?n-1"> 次方也能生成所有的单位根．这也是数论中 Bézout 定理的直接应用．</p>
<p>我们把这一类重要的单位根称为<em>本原单位根</em>．抽象的来说，<img src="https://latex.codecogs.com/png.latex?n"> 次本原单位根 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 可定义如下 <img src="https://latex.codecogs.com/png.latex?%0A%5Comega_n%5En%20=%201;%5Cquad%20%5Comega_n%5Ek%20%5Cneq%201,%5Cquad%20k=1,2,%5Cdots,n-1%0A"></p>
</section>
<section id="mathbb-z_m-上的阶" class="level3">
<h3 class="anchored" data-anchor-id="mathbb-z_m-上的阶"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的阶</h3>
<p>如何定义 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的“本原单位根”呢？</p>
<p>称在模 <img src="https://latex.codecogs.com/png.latex?m"> 意义下使得 <img src="https://latex.codecogs.com/png.latex?a%5En=1"> 的最小正整数 <img src="https://latex.codecogs.com/png.latex?n"> 为 <img src="https://latex.codecogs.com/png.latex?a"> 的<em>阶</em>，记为 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bord%7D_m(a)">．在不至混淆的情况下，也简记为 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bord%7D(a)">．</p>
<ul>
<li>阶最高有多高？</li>
</ul>
<div id="thm-fermat" class="theorem">
<p><span class="theorem-title"><strong>Theorem 5 (Fermat 小定理) </strong></span>若 <img src="https://latex.codecogs.com/png.latex?p"> 是质数，<img src="https://latex.codecogs.com/png.latex?a"> 是非零数，则 <img src="https://latex.codecogs.com/png.latex?a%5E%7Bp-1%7D%20%5Cequiv%201%20%5Cpmod%7Bp%7D">．</p>
</div>
<div id="thm-euler" class="theorem">
<p><span class="theorem-title"><strong>Theorem 6 (Euler 定理) </strong></span>若 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(a,m)=1">，则 <img src="https://latex.codecogs.com/png.latex?a%5E%7B%5Cvarphi(m)%7D%20%5Cequiv%201%20%5Cpmod%7Bm%7D">，其中 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(m)"> 是数论中的 Euler 函数<sup>8</sup>．</p>
</div>
</section>
<section id="euler-定理的证明---简化剩余系" class="level3">
<h3 class="anchored" data-anchor-id="euler-定理的证明---简化剩余系">Euler 定理的证明 - 简化剩余系</h3>
<p><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m%5ER%20:=%20%5C%7Ba%20%5Cin%20%5Cmathbb%20Z_m:%20%5Cgcd(a,m)=1%20%5C%7D"> 被称为 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 的<em>简化剩余系</em>．简化剩余系对模 <img src="https://latex.codecogs.com/png.latex?m"> 乘法封闭．简化剩余系中的每个元素都具有模 <img src="https://latex.codecogs.com/png.latex?m"> 意义下的唯一逆元，且其也在 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m%5ER"> 中．此二性质易由 <img src="https://latex.codecogs.com/png.latex?%5Cgcd"> 的线性组合意义证明．</p>
<p>简化剩余系的大小即 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(m)">．这是 Euler 函数的其中一种定义．</p>
<p>设 <img src="https://latex.codecogs.com/png.latex?a%20%5Cin%20%5Cmathbb%20Z_m%5ER">，其在 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 中存在逆元，故我们有 <img src="https://latex.codecogs.com/png.latex?%0A%5Cforall%20x,y%20%5Cin%20%5Cmathbb%20Z_m,%5Cquad%20x%20%5Cequiv%20y%20%5Cpmod%7Bm%7D%20%5Ciff%20ax%20%5Cequiv%20ay%20%5Cpmod%7Bm%7D%0A"> 当限定 <img src="https://latex.codecogs.com/png.latex?x,y%20%5Cin%20%5Cmathbb%20Z_m%5ER"> 时，结合 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m%5ER"> 上述两个性质，就有 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%20Z_m%5ER%20=%20a%20%5Cmathbb%20Z_m%5ER%20=%20%5C%7B%20ax%20%5Cbmod%20m%20:%20x%20%5Cin%20%5Cmathbb%20Z_m%5ER%20%5C%7D%0A"> 故 <img src="https://latex.codecogs.com/png.latex?%0Aa%5E%7B%5Cvarphi(m)%7D%20%5Cprod_%7Bx%20%5Cin%20%5Cmathbb%20Z_m%5ER%7D%20x%20%5Cequiv%20%5Cprod_%7Bx%20%5Cin%20%5Cmathbb%20Z_m%5ER%7D%20ax%20%5Cequiv%20%5Cprod_%7Bx%20%5Cin%20a%20%5Cmathbb%20Z_m%5ER%7D%20x%20%5Cequiv%20%5Cprod_%7Bx%20%5Cin%20%5Cmathbb%20Z_m%5ER%7D%20x%20%5Cimplies%20a%5E%7B%5Cvarphi(m)%7D%20%5Cequiv%201%20%5Cpmod%7Bm%7D%0A"></p>
</section>
<section id="an-的取值---a-m-互质时" class="level3">
<h3 class="anchored" data-anchor-id="an-的取值---a-m-互质时"><img src="https://latex.codecogs.com/png.latex?a%5En"> 的取值 - <img src="https://latex.codecogs.com/png.latex?a">, <img src="https://latex.codecogs.com/png.latex?m"> 互质时</h3>
<p>补充讨论 <img src="https://latex.codecogs.com/png.latex?a%5En%20%5Cbmod%20m,%5C,%20n%20%5Cin%20%5Cmathbb%20Z_%7B+%7D"> 可取得哪些 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 中的元素．</p>
<p>当 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(a,m)=1"> 时，用 <img src="https://latex.codecogs.com/png.latex?%5Cgcd"> 的线性组合含义，有 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cgcd(a,m)=1%20&amp;%5Cimplies%20%5Cexists%20x_0,%5Cquad%20a%20x_0%20=%201%20%5Cpmod%7Bm%7D%20%5C%5C%0A&amp;%5Cimplies%20%5Cexists%20x_0,%5Cquad%20a%5En%20x_0%5En%20=%201%20%5Cpmod%7Bm%7D%20%5C%5C%0A&amp;%5Cimplies%20%5Cgcd(a%5En,m)=1%0A%5Cend%7Baligned%7D%0A"> 故此时 <img src="https://latex.codecogs.com/png.latex?a%5En%20%5Cbmod%20m"> 只可能取得 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 的简化剩余系 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m%5ER"> 中的元素．</p>
</section>
<section id="an-的取值---一般情况" class="level3">
<h3 class="anchored" data-anchor-id="an-的取值---一般情况"><img src="https://latex.codecogs.com/png.latex?a%5En"> 的取值 - 一般情况<sup>9</sup></h3>
<p>当 <img src="https://latex.codecogs.com/png.latex?d_1%20=%20%5Cgcd(a,m)%20%5Cneq%201"> 时，设 <img src="https://latex.codecogs.com/png.latex?a%20=%20d_1%20a_1,%5C,%20m%20=%20d_1%20m_1">，当 <img src="https://latex.codecogs.com/png.latex?n%20%5Cgeq%201"> 时， <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%0Aa%5En%20%5Cbmod%20m%20&amp;=%20d_1%20a_1%20a%5E%7Bn-1%7D%20%5Cbmod%20d_1%20m_1%20=%20d_1%20%5Cleft(%20a_1%20a%5E%7Bn-1%7D%20%5Cbmod%20m_1%20%5Cright)%0A%5Cend%7Baligned%7D"> 此时 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(a_1,m_1)=1">，根据线性同余方程理论，括号内表达式的取值集合仅与 <img src="https://latex.codecogs.com/png.latex?a%5E%7Bn-1%7D%20%5Cbmod%20m_1"> 有关．此时若 <img src="https://latex.codecogs.com/png.latex?d_2%20=%20%5Cgcd(a,m_1)"> 仍不等于 <img src="https://latex.codecogs.com/png.latex?1">，则令 <img src="https://latex.codecogs.com/png.latex?a_1%20=%20d_2%20a_2,%5C,%20m_1%20=%20d_2%20m_2">．类似地继续化归，最终有 <img src="https://latex.codecogs.com/png.latex?d_%7Bk+1%7D%20=%20%5Cgcd(a,m_k)%20=%201">， <img src="https://latex.codecogs.com/png.latex?%0Aa%5En%20%5Cbmod%20m%20=%20d_1%20%5Cleft(%20a_1%20d_2%20%5Cleft(%20%5Cdots%20a_%7Bk-1%7D%20d_k%20(a_k%20a%5E%7Bn-k%7D%20%5Cbmod%20m_k)%20%5Cdots%20%5Cright)%20%5Cbmod%20m_1%20%5Cright)%0A"> 故当 <img src="https://latex.codecogs.com/png.latex?n%20%5Cgeq%20k"> 时，<img src="https://latex.codecogs.com/png.latex?a%5En%20%5Cbmod%20m"> 的取值集合为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%5C%7B%20d_1%20d_2%20%5Cdots%20d_k%20(a%5Et%20%5Cbmod%20m_k)%20:%20t%20%5Cin%20%5Cmathbb%20Z_+%20%5Cright%5C%7D%20%5Csubset%20d_1%20d_2%20%5Cdots%20d_k%20%5Cmathbb%20Z_%7Bm_k%7D%5ER%0A"> 事实上，<img src="https://latex.codecogs.com/png.latex?%5Cprod_%7Bi=1%7D%5Ek%20d_i"> 恰为 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(a,m)"> 的各素因子在 <img src="https://latex.codecogs.com/png.latex?m"> 中全部成分的乘积．</p>
</section>
<section id="原根" class="level3">
<h3 class="anchored" data-anchor-id="原根">原根<sup>10</sup></h3>
<p>需要注意的是，Euler 定理只给出了 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上元素阶的一个上界．换言之，其说明 <img src="https://latex.codecogs.com/png.latex?%0A%5Cforall%20a%20%5Cin%20%5Cmathbb%20Z_m%5ER%20%5Cimplies%20%5Coperatorname%7Bord%7D_m(a)%20%5Cmid%20%5Cvarphi(m)%0A"> 而对于那些使得 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(a,m)%20%5Cneq%201"> 的元素 <img src="https://latex.codecogs.com/png.latex?a">，用 <img src="https://latex.codecogs.com/png.latex?%5Cgcd"> 的线性组合性质容易证明其永远不可能通过自乘变为 <img src="https://latex.codecogs.com/png.latex?1">．我们设定这类元素的阶为 <img src="https://latex.codecogs.com/png.latex?0">．</p>
<p>称 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上那些确能达到阶数上界 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(m)"> 的元素是 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的<em>原根</em>，用符号 <img src="https://latex.codecogs.com/png.latex?g"> 表示．</p>
<div id="thm-pr-exist" class="theorem">
<p><span class="theorem-title"><strong>Theorem 7 (原根存在定理) </strong></span><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上存在原根，当且仅当 <img src="https://latex.codecogs.com/png.latex?m=2,4,p%5E%7B%5Calpha%7D,2p%5E%7B%5Calpha%7D"> ，其中 <img src="https://latex.codecogs.com/png.latex?p"> 是一奇质数．</p>
</div>
</section>
<section id="求阶和原根" class="level3">
<h3 class="anchored" data-anchor-id="求阶和原根">求阶和原根</h3>
<ul>
<li>求阶，用定理 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bord%7D_m(a)%20%5Cmid%20%5Cvarphi(m)">，求因子 + 快速幂即可 <img src="https://latex.codecogs.com/png.latex?O(%5Csqrt%20m%20%5Clog%20m)">．</li>
<li>找原根，从小到大用上述求阶方法暴力即可．最小原根一般不会太大．</li>
<li>更快的方法请参考洛谷求原根模板题题解．</li>
</ul>
<p>下面再介绍原根的两个定理．</p>
<div id="thm-pr-check" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8 (原根判定定理) </strong></span>若 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(g,m)=1">，则 <img src="https://latex.codecogs.com/png.latex?g"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上原根的充要条件是，对 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(m)"> 的每个素因数 <img src="https://latex.codecogs.com/png.latex?p">，都有 <img src="https://latex.codecogs.com/png.latex?g%5E%7B%5Cfrac%7B%5Cvarphi(m)%7D%7Bp%7D%7D%5Cnot%5Cequiv%201%5Cpmod%20m">.</p>
</div>
<p>必要性显然．充分性，反证出所有 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(m)"> 的非平凡因子均不是 <img src="https://latex.codecogs.com/png.latex?g"> 的阶即可．</p>
<div id="thm-pr-num" class="theorem">
<p><span class="theorem-title"><strong>Theorem 9 (原根个数定理) </strong></span>若 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上存在原根，则它原根的个数为 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(%5Cvarphi(m))">.</p>
</div>
</section>
<section id="mathbb-z_m-上的本原单位根构造" class="level3">
<h3 class="anchored" data-anchor-id="mathbb-z_m-上的本原单位根构造"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的本原单位根构造</h3>
<p>设 <img src="https://latex.codecogs.com/png.latex?a"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上一元素，当 <img src="https://latex.codecogs.com/png.latex?n%20%5Cmid%20%5Coperatorname%7Bord%7D_m(a)">，令 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%20=%20a%5E%7B%5Cfrac%7B%5Coperatorname%7Bord%7D_m(a)%7D%7Bn%7D%7D">，容易发现 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 就是 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 次本原单位根．</p>
<p>使用数论中 Bézout 定理，<strong><img src="https://latex.codecogs.com/png.latex?%5Comega_n%5Ek"> 是 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%20n%20%7B%5Cgcd(n,k)%7D"> 次本原单位根</strong>．这是 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上本原单位根的<strong>消去引理</strong>．</p>
<p>遗憾的是，<strong>一般的 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 中，本原单位根不一定满足求和引理</strong><sup>11</sup> <img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%20n%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20%5Comega_%7Bn%7D%5E%7Bik%7D%20=%20%5Bn%20%5Cmid%20i%5D">．这是因为，求和引理的证明中使用了等比数列求和和消去律，但<strong>一般的 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 中消去律并不成立</strong>．</p>
</section>
<section id="mathbb-z_m-上的-ntt---m-是质数" class="level3">
<h3 class="anchored" data-anchor-id="mathbb-z_m-上的-ntt---m-是质数"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的 NTT - <img src="https://latex.codecogs.com/png.latex?m"> 是质数</h3>
<p>求和引理是保障 NTT 逆变换对应矩阵确为 <img src="https://latex.codecogs.com/png.latex?n%5E%7B-1%7D%20%5Cbegin%7Bpmatrix%7D%20%5Comega_n%5E%7B-ij%7D%20%5Cend%7Bpmatrix%7D_%7B(i,j)%5Cin%20n%20%5Ctimes%20n%7D"> 的关键性质．如果我们还想保留这一点，就必须要求 <img src="https://latex.codecogs.com/png.latex?m"> 是质数．</p>
<p>为保证 <img src="https://latex.codecogs.com/png.latex?n"> 在 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 中存在逆元，必须要求 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(n,m)=1">．已经要求 <img src="https://latex.codecogs.com/png.latex?m"> 是质数，故无需做出额外要求．</p>
<p>综上，<strong>逆变换矩阵确为 <img src="https://latex.codecogs.com/png.latex?n%5E%7B-1%7D%20%5Cbegin%7Bpmatrix%7D%20%5Comega_n%5E%7B-ij%7D%20%5Cend%7Bpmatrix%7D_%7B(i,j)%5Cin%20n%20%5Ctimes%20n%7D"> 的 <img src="https://latex.codecogs.com/png.latex?n"> 点 NTT 要求 <img src="https://latex.codecogs.com/png.latex?m"> 是质数，且 <img src="https://latex.codecogs.com/png.latex?n%20%5Cmid%20%5Coperatorname%7Bord%7D_m(a)"></strong>．已经要求 <img src="https://latex.codecogs.com/png.latex?m"> 是质数，故 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 中必存在原根，不妨直接取 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 的一个原根 <img src="https://latex.codecogs.com/png.latex?g"> 构造 <img src="https://latex.codecogs.com/png.latex?n"> 次本原单位根 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%20=%20g%5E%7B%5Cfrac%7B%5Cvarphi(m)%7D%7Bn%7D%7D%20=%20g%5E%7B%5Cfrac%7Bm-1%7D%7Bn%7D%7D">，这样的构造支持至多 <img src="https://latex.codecogs.com/png.latex?m-1"> 次单位根的存在，显然是最优的选择．</p>
</section>
<section id="mathbb-z_m-上的-fft-与卷积加速---998244353" class="level3">
<h3 class="anchored" data-anchor-id="mathbb-z_m-上的-fft-与卷积加速---998244353"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的 FFT 与卷积加速 - 998244353</h3>
<p>为满足 FFT 对 <img src="https://latex.codecogs.com/png.latex?2%5Em"> 次本原单位根的需求，只需选择 <img src="https://latex.codecogs.com/png.latex?p%20=%20k%202%5Em%20+%201"> 型的奇质数 <img src="https://latex.codecogs.com/png.latex?p">，就可以在 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 上支持规模至多为 <img src="https://latex.codecogs.com/png.latex?2%5Em"> 的 NTT/FFT 及其逆变换运行．</p>
<p><img src="https://latex.codecogs.com/png.latex?998244353=2%5E%7B23%7D%20%5Ctimes%207%20%5Ctimes%2017%20+%201">，同时是一个质数，在 <code>int</code> 型中的单次加减操作不会溢出，是 OI/XCPC 计数题中不可多得的优秀模数<sup>12</sup>．</p>
<p>结合前述关于 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D"> 上多点插值的讨论，通过 NTT/FFT 加速卷积运算的正确性得到完整证明．</p>
</section>
<section id="mathbb-z_m-上的-ntt---对一般的-m" class="level3">
<h3 class="anchored" data-anchor-id="mathbb-z_m-上的-ntt---对一般的-m"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的 NTT - 对一般的 <img src="https://latex.codecogs.com/png.latex?m"></h3>
<p>当 <img src="https://latex.codecogs.com/png.latex?m"> 不一定是质数时，NTT 逆变换不能表示为 <img src="https://latex.codecogs.com/png.latex?n%5E%7B-1%7D%20%5Cbegin%7Bpmatrix%7D%20%5Comega_n%5E%7B-ij%7D%20%5Cend%7Bpmatrix%7D_%7B(i,j)%5Cin%20n%20%5Ctimes%20n%7D"> 的形式．但这并不代表 NTT 不可逆．因此，尽管不再实用，一般 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的 NTT 变换仍有讨论价值，即研究 <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Bpmatrix%7D%20%5Comega_n%5E%7Bij%7D%20%5Cend%7Bpmatrix%7D_%7B(i,j)%5Cin%20n%20%5Ctimes%20n%7D"> 的可逆性．</p>
<p>我们找到一篇有关该问题的参考文献<span class="citation" data-cites="agarwal1974fast">[7, Secs. 3 and appendix B]</span>，但尚不确定其证明的正确性．友情提示读者：<img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 不是域，甚至不是整环，故线性空间中矩阵的性质不能直接应用于 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的矩阵，讨论可逆性时还需小心谨慎．</p>
</section>
<section id="从分析到代数" class="level3">
<h3 class="anchored" data-anchor-id="从分析到代数">从分析到代数</h3>
<p>后续数学内容导读 NTT 原理虽已非常”数学”，但也只是 DFT 在有限域上的一个实例．本节往后，我们要尝试为多项式系数位于复数域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20C"> 上的 DFT、位于模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 上的 NTT 及它们的快速算法 FFT 建立一个统一的数学框架．这需要我们剖析求值插值的基本原理，提炼出 FFT 算法成立的根本要求．</p>
<p>后续数学内容不再要求掌握．望同学们在纷繁的定理定义中抓住要旨，窥见抽象数学背后蕴藏的规律．熟悉高等代数和抽象代数的同学或会对某些内容感到熟悉．抽象地讨论 FFT 的资料并不多见，后续内容多为主讲人的新进探索，或有谬误，望不吝指正．</p>
</section>
</section>
<section id="求值与插值" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="求值与插值"><span class="header-section-number">4.2</span> 求值与插值</h2>
<section id="求值与插值---导言" class="level3">
<h3 class="anchored" data-anchor-id="求值与插值---导言">求值与插值 - 导言</h3>
<p>本节将重新审视已经熟知的多项式，把抽象的、代数的多项式和具体的、分析的多项式函数区分开来．我们指出，多项式和多项式函数不同但关联紧密，形式幂级数与幂级数亦有此类联系．这些抽象的讨论将帮助我们剖析多项式求值插值的基本原理．</p>
<p>除常见代数书目（如<span class="citation" data-cites="qiu-algebra">[8]</span>），也推荐参考 OI Wiki 的多项式基础<span class="citation" data-cites="oiwiki-polynomial">[9]</span>和 Wikipedia 的形式幂级数<span class="citation" data-cites="wikipedia-formalpowerseries">[10]</span>．</p>
</section>
<section id="多项式" class="level3">
<h3 class="anchored" data-anchor-id="多项式">多项式</h3>
<p>设（无穷）序列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20a_n%20%5C%7D"> 是一个只有有限个非零项的序列，其元素均在环 <img src="https://latex.codecogs.com/png.latex?R"> 上．环 <img src="https://latex.codecogs.com/png.latex?R"> 上的<em>多项式环</em><sup>13</sup> <img src="https://latex.codecogs.com/png.latex?R%5Bx%5D"> 是所有满足上述条件的序列构成的集合以及在它们之间定义的两种运算 <img src="https://latex.codecogs.com/png.latex?+,%20%5Ctimes"> 的合称．此语境下，我们也将构成 <img src="https://latex.codecogs.com/png.latex?R%5Bx%5D"> 的序列称为 <img src="https://latex.codecogs.com/png.latex?R"> 上的<em>多项式</em>．序列中的元素被称为多项式的系数．<strong>序列间定义的加法和乘法是普通序列升级为多项式的关键．</strong></p>
<p>多项式环上的加法、乘法的定义已经为大家所熟知．系数所处的环保证了多项式加法和乘法的良定义，而在这两种运算下，<img src="https://latex.codecogs.com/png.latex?R"> 上多项式的集合也构成一个环的结构．</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em> (群、环、域). </span>群、环、域都是常见的代数结构，其中的元素在给定运算下封闭，并满足特定的运算性质．简单来说，环<sup>14</sup>上定义了加法和可能不可逆的、不一定交换的乘法，域上定义了加减乘除所有四则运算．交换环中的乘法满足交换律．除环中的所有元素有乘法逆元．域是交换除环．</p>
</div>
</section>
<section id="多项式-1" class="level3">
<h3 class="anchored" data-anchor-id="多项式-1">多项式</h3>
<p>习惯上也会将多项式 <img src="https://latex.codecogs.com/png.latex?A"> 写为 <img src="https://latex.codecogs.com/png.latex?A(x)%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_k%20x%5Ek"> 的形式．其中未定元 <img src="https://latex.codecogs.com/png.latex?x"> 只是一个符号，仅为方便加、乘法的理解而使用，并无任何含义．</p>
<p>多项式 <img src="https://latex.codecogs.com/png.latex?A"> 的<em>次数</em> <img src="https://latex.codecogs.com/png.latex?%5Cdeg%20A"> 定义为其最高非零项所处的位置下标．特别的，定义零多项式的次数为 <img src="https://latex.codecogs.com/png.latex?-%5Cinfty">．对任意多项式 <img src="https://latex.codecogs.com/png.latex?A,B%20%5Cin%20R%5Bx%5D">，<img src="https://latex.codecogs.com/png.latex?%5Cdeg(A+B)%20%5Cleq%20%5Cmax%5C%7B%20%5Cdeg%20A,%20%5Cdeg%20B%20%5C%7D">．当 <img src="https://latex.codecogs.com/png.latex?R"> 是整环<sup>15</sup>时，<img src="https://latex.codecogs.com/png.latex?A,B"> 的首项乘积非零，故 <img src="https://latex.codecogs.com/png.latex?%5Cdeg(A*B)%20=%20%5Cdeg%20A%20+%20%5Cdeg%20B">．</p>
<p>下面额外为多项式定义一种新的运算．多项式 <img src="https://latex.codecogs.com/png.latex?A"> 和多项式 <img src="https://latex.codecogs.com/png.latex?B"> 的<em>复合</em> <img src="https://latex.codecogs.com/png.latex?A%20%5Ccirc%20B"> 定义为 <img src="https://latex.codecogs.com/png.latex?%0AA%20%5Ccirc%20B%20:=%20%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20a_k%20B%5Ek%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?B%5Ek"> 代表 <img src="https://latex.codecogs.com/png.latex?k"> 个多项式 <img src="https://latex.codecogs.com/png.latex?B"> 的乘积．习惯上也会将多项式 <img src="https://latex.codecogs.com/png.latex?A"> 和多项式 <img src="https://latex.codecogs.com/png.latex?B"> 的复合写为 <img src="https://latex.codecogs.com/png.latex?A(B(x))%20=%20%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20a_k%20B%5Ek(x)"> 的形式．由于多项式的次数有限，复合运算中仅包含了有限次多项式加法和乘法．</p>
</section>
<section id="形式幂级数" class="level3">
<h3 class="anchored" data-anchor-id="形式幂级数">形式幂级数</h3>
<p><em>形式幂级数</em>定义与多项式的唯一区别是其不要求 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20a_n%20%5C%7D"> 只有有限项非零．类似的，<img src="https://latex.codecogs.com/png.latex?R"> 上的形式幂级数环记为 <img src="https://latex.codecogs.com/png.latex?R%5B%5Bx%5D%5D">．</p>
<p>由于涉及无限次运算，形式幂级数的复合运算需考虑环 <img src="https://latex.codecogs.com/png.latex?R"> 上的收敛问题．为回避此问题，一般规定复合右侧函数的常数项须为零．</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>DFT, NTT 与多项式环 DFT/FFT 加速的多项式卷积在复数域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20C"> 上的多项式环 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20C%5Bx%5D"> 中进行，NTT/FFT 加速的多项式卷积在模 <img src="https://latex.codecogs.com/png.latex?p"> 剩余类域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 上的多项式环 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D"> 中进行．</p>
</div>
</section>
<section id="带余除法" class="level3">
<h3 class="anchored" data-anchor-id="带余除法">带余除法</h3>
<p><em>整环</em>是无零因子的交换幺环．所谓无零因子，即环中任意元素 <img src="https://latex.codecogs.com/png.latex?a,b"> 满足 <img src="https://latex.codecogs.com/png.latex?ab%20=%200%20%5Cimplies%20a=0%20%5Clor%20b=0">．所有域都是整环．当 <img src="https://latex.codecogs.com/png.latex?R"> 是整环时，<img src="https://latex.codecogs.com/png.latex?R%5Bx%5D"> 也是整环<sup>16</sup>．整环上可以定义整除相关理论．</p>
<p>定义有带余除法的环被称为 <em>Euclid 整环</em>．域上的多项式环都是 Euclid 整环<span class="citation" data-cites="qiu-algebra">[8, 第 7 章第 2 节定理 3, p.&nbsp;11]</span>．值得注意的是，<img src="https://latex.codecogs.com/png.latex?R"> 的 Euclid 性不可传递至 <img src="https://latex.codecogs.com/png.latex?R%5Bx%5D"><sup>17</sup>．</p>
<p>如在带余除法中保证除式是首一多项式<sup>18</sup>，则带余除法的良定义和进行过程也均可在整环上实现．</p>
</section>
<section id="多项式函数-幂级数" class="level3">
<h3 class="anchored" data-anchor-id="多项式函数-幂级数">多项式函数 / 幂级数</h3>
<p>刚刚强调，多项式 / 形式幂级数只是定义了加法和乘法的序列．现在介绍多项式函数和幂级数．它们不是序列，而是映射<sup>19</sup>．</p>
<p>多项式 <img src="https://latex.codecogs.com/png.latex?A"> 对应的环 <img src="https://latex.codecogs.com/png.latex?R"> 上的<em>多项式函数</em> <img src="https://latex.codecogs.com/png.latex?A(x)"> 定义为映射<sup>20</sup> <img src="https://latex.codecogs.com/png.latex?%0AA:%20R%20%5Cto%20R,%5Cquad%20x%20%5Cmapsto%20%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20a_k%20x%5Ek%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20a_n%20%5C%7D"> 只有有限项非零．环 <img src="https://latex.codecogs.com/png.latex?R"> 上的幂级数则无此限制<sup>21</sup>．</p>
<p>与多项式 / 形式幂级数不同，这里的 <img src="https://latex.codecogs.com/png.latex?x%20%5Cin%20R"> 代表函数的自变量，是会按环 <img src="https://latex.codecogs.com/png.latex?R"> 上运算法则参与运算的有意义的变量．</p>
<p>多项式函数的加法和乘法定义为函数的加法和乘法，即 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AA+B:%20x%20&amp;%5Cmapsto%20A(x)+B(x)%20%5C%5C%0AA%20%5Cotimes%20B:%20x%20&amp;%5Cmapsto%20A(x)B(x)%0A%5Cend%7Baligned%7D%0A"></p>
</section>
<section id="求值" class="level3">
<h3 class="anchored" data-anchor-id="求值">求值</h3>
<p>多项式和多项式函数似乎在许多情况下有着平行的关系．下面介绍一个较直观的结论．</p>
<p><strong>若环 <img src="https://latex.codecogs.com/png.latex?R"> 是交换环，则环 <img src="https://latex.codecogs.com/png.latex?R"> 上每个多项式都唯一确定一个 <img src="https://latex.codecogs.com/png.latex?R"> 上的多项式函数，且该映射保持加法和乘法运算</strong><sup>22</sup>．形式化地可以记为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%20%20%20%20(A+B)(x)%20&amp;=%20A(x)+B(x)%20%5C%5C%0A%20%20%20%20(A*B)(x)%20&amp;=%20A(x)B(x)%0A%20%20%20%20%5Cend%7Baligned%7D%0A"> 可用于证明上述结论的定理证明见<span class="citation" data-cites="qiu-algebra">[8, 第 7 章第 1 节定理 4, p.&nbsp;7]</span><sup>23</sup>．由于多项式的复合由多项式加法和乘法组成，而多项式函数的复合（定义为函数的复合）亦可在环上平行地展开，故上述映射也保持了复合运算．</p>
<p>多项式和多项式函数的这一关系为多项式在任意点的求值操作提供了理论基础．在多项式函数的 <img src="https://latex.codecogs.com/png.latex?t"> 处求值也被称为用 <img src="https://latex.codecogs.com/png.latex?t"> 代入多项式 <img src="https://latex.codecogs.com/png.latex?A">，记为 <img src="https://latex.codecogs.com/png.latex?A(t)">．</p>
</section>
<section id="插值" class="level3">
<h3 class="anchored" data-anchor-id="插值">插值</h3>
<p>需要注意的是，前述结论的逆命题不一定成立，即<strong>环 <img src="https://latex.codecogs.com/png.latex?R"> 上的一个多项式函数不一定与 <img src="https://latex.codecogs.com/png.latex?R"> 上多项式一一对应</strong>．一个经典反例是有限域上多项式环 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p%5Bx%5D"> 上的 <img src="https://latex.codecogs.com/png.latex?(x+1)%5Ep%20%5Cequiv%20x%5Ep%20+%201%20%5Cpmod%7Bp%7D">．我们指出其成立的一个充分条件是 <strong><img src="https://latex.codecogs.com/png.latex?R"> 是无限整环</strong><sup>24</sup>．</p>
<p>该逆命题的本质是通过多项式函数的所有函数值反过来确定多项式（系数）的过程．而如果在确定时只使用一部分函数值，就是所谓的多点插值过程．很多时候待求多项式的次数是已知的，这在相当程度上缩小了待定多项式的范围．我们指出，<strong>只要 <img src="https://latex.codecogs.com/png.latex?R"> 是整环，就可以通过多项式任意 <img src="https://latex.codecogs.com/png.latex?n"> 个不同位置的点值确定一个至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式．</strong></p>
<p>证明的关键是用带余除法<sup>25</sup>讨论多项式根与其一次因式的关系，即多项式余式定理或小 Bézout 定理<span class="citation" data-cites="qiu-algebra">[8, 第 7 章第 6 节定理 6, p.&nbsp;35]</span>．</p>
<p>需要强调，上述结论只能说明，只有那些确实可通过多项式 <img src="https://latex.codecogs.com/png.latex?n"> 点求值得到的点值组，才能与多项式建立保持加法和乘法运算的双射．对于任取的 <img src="https://latex.codecogs.com/png.latex?R"> 中的一个 <img src="https://latex.codecogs.com/png.latex?n"> 元组，则无法确定是否存在与之对应的多项式．</p>
</section>
<section id="求值与插值的线性表示" class="level3">
<h3 class="anchored" data-anchor-id="求值与插值的线性表示">求值与插值的线性表示</h3>
<p>到这里，多项式的求值与插值的线性表示已经呼之欲出了．若将交换环 <img src="https://latex.codecogs.com/png.latex?R"> 上的至多 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的多项式看做模<sup>26</sup> <img src="https://latex.codecogs.com/png.latex?R%5En"> 中的一个向量，则多项式多点求值的过程就是 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的一个线性变换（记为 <img src="https://latex.codecogs.com/png.latex?V">），其矩阵表示正是 Vandermonde 矩阵．由先前对求值的讨论，我们还知道其保持模 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的加法运算，并将结果不超过 <img src="https://latex.codecogs.com/png.latex?n-1"> 次的卷积运算转化为 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的逐项乘法．</p>
<p>若将对 <img src="https://latex.codecogs.com/png.latex?R"> 的要求<strong>加强到域</strong>，注意到 Vandermonde 行列式在参数互不相同时非零，故此时 <img src="https://latex.codecogs.com/png.latex?V"> 可逆．事实上，<strong>Vandermonde 矩阵求逆的过程就是 Lagrange 插值</strong>，从而给出了将任意 <img src="https://latex.codecogs.com/png.latex?R%5En"> 中向量还原为其对应多项式的构造方法<sup>27</sup>．这与数论中中国剩余定理的构造有异曲同工之妙<span class="citation" data-cites="wikipedia-lagrange">[11, section: A perspective from linear algebra]</span>．</p>
</section>
<section id="求值与插值---小结" class="level3">
<h3 class="anchored" data-anchor-id="求值与插值---小结">求值与插值 - 小结</h3>
<p>本节的核心是多项式和多项式函数的区别与联系，两个方向的”确定”分别给出了多项式多点求值和多点插值的理论基础．</p>
<p>由于多项式和多项式函数这种若即若离的关系，往往在记号上也有意无意地混淆了它们，某些情况下加大了区分的难度．本篇使用的记号体系将尽量用单个字母 <img src="https://latex.codecogs.com/png.latex?A"> 表示多项式，用 <img src="https://latex.codecogs.com/png.latex?A(x)"> 表示多项式 <img src="https://latex.codecogs.com/png.latex?A"> 对应的多项式函数，用 <img src="https://latex.codecogs.com/png.latex?A(t)"> 表示用 <img src="https://latex.codecogs.com/png.latex?t"> 代入多项式 <img src="https://latex.codecogs.com/png.latex?A">，同时在需要区分的符号前加上适当的名词．</p>
</section>
</section>
<section id="环上的-dft" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="环上的-dft"><span class="header-section-number">4.3</span> 环上的 DFT</h2>
<section id="环上的-dft---导言" class="level3">
<h3 class="anchored" data-anchor-id="环上的-dft---导言">环上的 DFT - 导言</h3>
<p>前面讨论了在多项式任意点处求值插值的基本原理，但 DFT/FFT 的运行只需在单位根处求值和插值．本节将进一步放宽对多项式环的限制，介绍定义在有主要单位根的环上的一般的 DFT 及其快速算法 FFT．</p>
<p>本节内容主要参考了 <span class="citation" data-cites="furer2009faster">[12, Secs. 2, pp.&nbsp;983–984]</span> 和 <span class="citation" data-cites="wikipedia-dft-over-ring">[13]</span>．</p>
</section>
<section id="环上的单位根---两个定义" class="level3">
<h3 class="anchored" data-anchor-id="环上的单位根---两个定义">环上的单位根 - 两个定义</h3>
<p>定义环 <img src="https://latex.codecogs.com/png.latex?R"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 次<em>主要单位根</em>（principal n-th root of unity）<img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 是满足如下条件的环 <img src="https://latex.codecogs.com/png.latex?R"> 中的一个元素： <img src="https://latex.codecogs.com/png.latex?%0A%5Comega_n%5En%20=%201;%5Cquad%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20%5Comega_n%5E%7Bik%7D%20=%200,%5Cquad%20i=1,2,%5Cdots,n-1%0A"> 由定义立得 <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20%5Comega_n%5E%7Bik%7D%20=%20%5Bn%20%5Cmid%20i%5D%20n">，可见主要单位根的定义即求和引理本身．</p>
<p>定义环 <img src="https://latex.codecogs.com/png.latex?R"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 次<em>本原单位根</em>（primitive n-th root of unity）<img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 是满足如下条件的环 <img src="https://latex.codecogs.com/png.latex?R"> 中的一个元素： <img src="https://latex.codecogs.com/png.latex?%0A%5Comega_n%5En%20=%201;%5Cquad%20%5Comega_n%5Ek%20%5Cneq%201,%5Cquad%20k=1,2,%5Cdots,n-1%0A"></p>
<p>本原单位根在许多情况下与主要单位根等价，但亦非完全相同．</p>
</section>
<section id="环上的单位根---区别与联系" class="level3">
<h3 class="anchored" data-anchor-id="环上的单位根---区别与联系">环上的单位根 - 区别与联系</h3>
<div id="prp-root-relation-1" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 </strong></span>若环 <img src="https://latex.codecogs.com/png.latex?R"> 是整环，则环上的本原单位根也是一个主要单位根．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>对任意正整数 <img src="https://latex.codecogs.com/png.latex?i%20%5Cin%20%5Bn%5D">，令 <img src="https://latex.codecogs.com/png.latex?S%20=%20%5Csum_%7Bk=0%7D%5En%20%5Comega_n%5E%7Bik%7D">，则 <img src="https://latex.codecogs.com/png.latex?(1-%5Comega_n%5Ei)%20S%20=%20S%20-%20%5Comega_n%5Ei%20S%20=%201%20-%20%5Comega_n%5En%20=%200">，由 <img src="https://latex.codecogs.com/png.latex?R"> 是整环及 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%5Ei=0"> 得 <img src="https://latex.codecogs.com/png.latex?S=0">．</p>
</div>
</section>
<section id="环上的单位根---区别与联系-1" class="level3">
<h3 class="anchored" data-anchor-id="环上的单位根---区别与联系-1">环上的单位根 - 区别与联系</h3>
<div id="prp-root-relation-2" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2 </strong></span>若环 <img src="https://latex.codecogs.com/png.latex?R"> 的特征<sup>28</sup> <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bchar%7DR"> 满足 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bchar%7DR%20%5Cnmid%20n">，则环上的主要单位根也是一个本原单位根．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>反证．若存在一正整数 <img src="https://latex.codecogs.com/png.latex?i%20%5Cin%20%5Bn%5D"> 使得 <img src="https://latex.codecogs.com/png.latex?n"> 次主要单位根 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 的某一幂次 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%5Ei=1">，则 <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20%5Comega_n%5E%7Bik%7D%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%201%5Ek%20=%20n%201%20%5Cneq%200">，与主要单位根定义矛盾．</p>
</div>
</section>
<section id="环上的单位根---其它性质" class="level3">
<h3 class="anchored" data-anchor-id="环上的单位根---其它性质">环上的单位根 - 其它性质</h3>
<p>分别根据定义和数论中的 Bézout 定理，容易证明主要单位根和本原单位根的消去引理：设 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7Bn%7D"> 是环上的 <img src="https://latex.codecogs.com/png.latex?n"> 次主要（本原）单位根，则 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7Bn%7D%5E%7Bk%7D"> 是环上的 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%20n%20%7B%5Cgcd(n,k)%7D"> 次主要（本原）单位根．</p>
<p>注意到 <img src="https://latex.codecogs.com/png.latex?%5Cleft(%5Comega_%7B2n%7D%5En%20%5Cright)%5E2=1%20%5Cimplies%20(%5Comega_%7B2n%7D%5En%20+%201)(%5Comega_%7B2n%7D%5En%20-%201)=0">，故整环上的 <img src="https://latex.codecogs.com/png.latex?2n"> 次主要单位根或本原单位根 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D"> 均满足 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D%5En%20=%20-1">．</p>
<p>环上的 <img src="https://latex.codecogs.com/png.latex?n"> 次主要单位根或本原单位根 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 都存在逆元 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%5E%7B-1%7D%20=%20%5Comega_n%5E%7Bn-1%7D">．</p>
</section>
<section id="环上的-dft-1" class="level3">
<h3 class="anchored" data-anchor-id="环上的-dft-1">环上的 DFT</h3>
<p>设 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 是环 <img src="https://latex.codecogs.com/png.latex?R"> 上的一个 <img src="https://latex.codecogs.com/png.latex?n"> 次主要单位根，其对应的 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的 <em><img src="https://latex.codecogs.com/png.latex?n"> 点 DFT</em> 定义为线性映射（或矩阵） <img src="https://latex.codecogs.com/png.latex?%0AF%20=%20%5Cleft(%20%5Comega_n%5E%7Bij%7D%20%5Cright)_%7B(i,j)%20%5Cin%20n%20%5Ctimes%20n%7D%20=%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%201%20&amp;%201%20&amp;%20%5Cdots%20&amp;%201%20%5C%5C%0A%20%20%20%201%20&amp;%20%5Comega_n%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7Bn-1%7D%20%5C%5C%0A%20%20%20%20%5Cvdots%20&amp;%20%5Cvdots%20&amp;%20%5Cddots%20&amp;%20%5Cvdots%20%5C%5C%0A%20%20%20%201%20&amp;%20%5Comega_n%5E%7Bn-1%7D%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7B(n-1)(n-1)%7D%0A%20%20%20%20%5Cend%7Bpmatrix%7D%0A"> 若 <img src="https://latex.codecogs.com/png.latex?n%201"> 在环 <img src="https://latex.codecogs.com/png.latex?R"> 中存在乘法逆元，则 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的 DFT 可逆，其逆映射为<sup>29</sup> <img src="https://latex.codecogs.com/png.latex?%0AF%5E%7B-1%7D%20=%20(n%201)%5E%7B-1%7D%20%5Cleft(%20%5Comega_n%5E%7B-ij%7D%20%5Cright)_%7B(i,j)%20%5Cin%20n%20%5Ctimes%20n%7D%20=%20(n%201)%5E%7B-1%7D%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%201%20&amp;%201%20&amp;%20%5Cdots%20&amp;%201%20%5C%5C%0A%20%20%20%201%20&amp;%20%5Comega_n%5E%7B-1%7D%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7B-(n-1)%7D%20%5C%5C%0A%20%20%20%20%5Cvdots%20&amp;%20%5Cvdots%20&amp;%20%5Cddots%20&amp;%20%5Cvdots%20%5C%5C%0A%20%20%20%201%20&amp;%20%5Comega_n%5E%7B-(n-1)%7D%20&amp;%20%5Cdots%20&amp;%20%5Comega_n%5E%7B-(n-1)(n-1)%7D%0A%20%20%20%20%5Cend%7Bpmatrix%7D%0A"></p>
</section>
<section id="环上的-fft" class="level3">
<h3 class="anchored" data-anchor-id="环上的-fft">环上的 FFT</h3>
<p>除无法在任意环上使用 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D%5En%20=%20-1">，现有的抽象已足够让我们写出与之前类似的推导 FFT 的过程．</p>
<p>设 <img src="https://latex.codecogs.com/png.latex?R"> 是任意环，<img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D"> 是环 <img src="https://latex.codecogs.com/png.latex?R"> 上的一个 <img src="https://latex.codecogs.com/png.latex?2n"> 次主要单位根．由主要单位根的消去引理，<img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D%5E2"> 是环 <img src="https://latex.codecogs.com/png.latex?R"> 上的 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%20%7B2n%7D%7B%5Cgcd(2n,2)%7D%20=%20n"> 次主要单位根．方便起见，记 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%20=%20%5Comega_%7B2n%7D%5E2">．</p>
<p>考虑对模 <img src="https://latex.codecogs.com/png.latex?R%5E%7B2n%7D"> 中向量 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20a%20=%20%5Cleft(%20a_0,a_1,%5Cdots,a_%7B2n-1%7D%20%5Cright)%5ET"> 做 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D"> 对应的 <img src="https://latex.codecogs.com/png.latex?2n"> 点 DFT 变换，得到向量 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cboldsymbol%20a%7D%20=%20%5Cleft(%20%5Chat%20a_0,%20%5Chat%20a_1,%20%5Cdots,%20%5Chat%20a_%7B2n-1%7D%20%5Cright)%5ET">，其中 <img src="https://latex.codecogs.com/png.latex?%5Chat%20a_i%20=%20%5Csum_%7Bk=0%7D%5E%7B2n-1%7D%20a_k%20%5Comega_%7B2n%7D%5E%7Bik%7D">．将其奇偶分项为 <img src="https://latex.codecogs.com/png.latex?%5Chat%20a_i=A_0(i)+A_1(i)%20%5Comega_%7B2n%7D%5Ei">，其中 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%20%20%20%20A_0(i)%20&amp;:=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k%7D%20%5Comega_%7Bn%7D%5E%7Bik%7D%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k%7D%20%5Comega_%7B2n%7D%5E%7B2ik%7D%20%5C%5C%0A%20%20%20%20A_1(i)%20&amp;:=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k+1%7D%20%5Comega_%7Bn%7D%5E%7Bik%7D%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k+1%7D%20%5Comega_%7B2n%7D%5E%7B2ik%7D%0A%20%20%20%20%5Cend%7Baligned%7D%0A"></p>
</section>
<section id="环上的-fft-1" class="level3">
<h3 class="anchored" data-anchor-id="环上的-fft-1">环上的 FFT</h3>
<p>注意到 <img src="https://latex.codecogs.com/png.latex?A_0(i)=A_0(n+i)">，<img src="https://latex.codecogs.com/png.latex?A_1(i)=A_1(n+i)">，故 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%20%20%20%20%5Chat%20a_i%20%20%20%20%20&amp;=%20A_0(i)%20+%20A_1(i)%20%5Comega_%7B2n%7D%5Ei%20%5C%5C%0A%20%20%20%20%5Chat%20a_%7Bn+i%7D%20&amp;=%20A_0(i)%20+%20A_1(i)%20%5Comega_%7B2n%7D%5E%7Bn+i%7D%0A%20%20%20%20%5Cend%7Baligned%7D,%5Cquad%20i%20%5Cin%20%5Bn%5D%0A"> 而 <img src="https://latex.codecogs.com/png.latex?A_0(i),%5C,%20i%20%5Cin%20%5Bn%5D"> 的计算即计算向量 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7Ba_0%7D%20=%20%5Cleft(%20a_0,%20a_2,%20%5Cdots,%20a_%7B2n-2%7D%20%5Cright)"> 对应于 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 的 <img src="https://latex.codecogs.com/png.latex?n"> 点 DFT 的过程；<img src="https://latex.codecogs.com/png.latex?A_1(i),%5C,%20i%20%5Cin%20%5Bn%5D"> 的计算即计算向量 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7Ba_1%7D%20=%20%5Cleft(%20a_1,%20a_3,%20%5Cdots,%20a_%7B2n-1%7D%20%5Cright)"> 对应于 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 的 <img src="https://latex.codecogs.com/png.latex?n"> 点 DFT 的过程．</p>
<p>因此，令 <img src="https://latex.codecogs.com/png.latex?n%20=%202%5Em">，则只要环 <img src="https://latex.codecogs.com/png.latex?R"> 上存在 <img src="https://latex.codecogs.com/png.latex?2%5Em"> 次主要单位根，如上形式的 FFT 递归算法就可在 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)"> 的时间复杂度内快速计算 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 点 DFT．而若 <img src="https://latex.codecogs.com/png.latex?2%5Ek%201,%5C,%200%20%5Cleq%20k%20%5Cleq%20m"> 在 <img src="https://latex.codecogs.com/png.latex?R"> 内均存在逆元，<img src="https://latex.codecogs.com/png.latex?R%5En"> 上的 <img src="https://latex.codecogs.com/png.latex?n"> 点 IDFT 也可类似地快速计算．</p>
</section>
</section>
<section id="循环卷积与卷积定理" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="循环卷积与卷积定理"><span class="header-section-number">4.4</span> 循环卷积与卷积定理</h2>
<section id="循环卷积与卷积定理---导言" class="level3">
<h3 class="anchored" data-anchor-id="循环卷积与卷积定理---导言">循环卷积与卷积定理 - 导言</h3>
<p>上一节中，我们建立了在有主要单位根的环上的 DFT 及其快速算法 FFT 的相关理论，但由于放宽了对多项式环 <img src="https://latex.codecogs.com/png.latex?R%5Bx%5D"> 的限制，多项式的求值插值理论无法在此直接得到应用，环上 DFT 加速多项式卷积的理论尚需重新构建．</p>
<p>在求值与插值部分已经介绍求值变换 <img src="https://latex.codecogs.com/png.latex?V"> 在 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的线性表示，其保持 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的加法运算，并将规模不超过 <img src="https://latex.codecogs.com/png.latex?n"> 的两向量的卷积转化为 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的逐项乘法．本节中，我们来证明 DFT 变换 <img src="https://latex.codecogs.com/png.latex?F"> 也满足同样的性质，且将这一结果推广到卷积规模超过 <img src="https://latex.codecogs.com/png.latex?n"> 时的情况．</p>
</section>
<section id="循环卷积" class="level3">
<h3 class="anchored" data-anchor-id="循环卷积">循环卷积</h3>
<p>设 <img src="https://latex.codecogs.com/png.latex?R"> 是<strong>交换环</strong>，我们记 <img src="https://latex.codecogs.com/png.latex?A%20%5Cotimes%20B"> 代表模 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上两个向量的逐项乘法．</p>
<p>设 <img src="https://latex.codecogs.com/png.latex?F"> 是 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上主要单位根 <img src="https://latex.codecogs.com/png.latex?%5Comega_n"> 对应的 <img src="https://latex.codecogs.com/png.latex?n"> 点可逆 DFT 变换，<img src="https://latex.codecogs.com/png.latex?A,B"> 是 <img src="https://latex.codecogs.com/png.latex?R%5En"> 中两个任意取定的向量．显然 <img src="https://latex.codecogs.com/png.latex?F(A+B)=FA+FB">，故 DFT 变换保持 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上的加法运算．现在的主要问题是，求值与插值部分计算卷积的方法 <img src="https://latex.codecogs.com/png.latex?F%5E%7B-1%7D(FA%20%5Cotimes%20FB)"> 在放宽环限制的 <img src="https://latex.codecogs.com/png.latex?R%5En"> 上进行时，将会得到什么结果？</p>
<p>令 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bgathered%7D%0A%20%20%20%20%5Chat%7B%5Cboldsymbol%20a%7D%20=%20F%20%5Cboldsymbol%20a,%5Cquad%20%5Chat%7B%5Cboldsymbol%20b%7D%20=%20F%20%5Cboldsymbol%20b%20%5C%5C%0A%20%20%20%20%5Chat%20%7B%5Cboldsymbol%20c%7D=%20%5Chat%7B%5Cboldsymbol%20a%7D%20%5Cotimes%20%5Chat%7B%5Cboldsymbol%20b%7D,%5Cquad%20%5Cboldsymbol%20c%20=%20F%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%20c%7D%0A%20%20%20%20%5Cend%7Bgathered%7D%0A"> 则 <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%20a_i%20=%20%5Csum_%7Bj=0%7D%5E%7Bn-1%7D%20a_j%20%5Comega_n%5E%7Bij%7D,%5Cquad%20%5Chat%20b_i%20=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20b_k%20%5Comega_n%5E%7Bik%7D%0A"></p>
</section>
<section id="循环卷积-1" class="level3">
<h3 class="anchored" data-anchor-id="循环卷积-1">循环卷积</h3>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%20c_i%20=%20%5Chat%20a_i%20%5Chat%20b_i%20=%20%5Csum_%7Bj=0%7D%5E%7Bn-1%7D%20a_j%20%5Comega_n%5E%7Bij%7D%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20b_k%20%5Comega_n%5E%7Bik%7D%20=%20%5Csum_%7Bj=0%7D%5E%7Bn-1%7D%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_j%20b_k%20%5Comega_n%5E%7Bi(j+k)%7D%0A"> <img src="https://latex.codecogs.com/png.latex?%0Ac_i%20=%20%5Csum_%7Bt=0%7D%5E%7Bn-1%7D%20%5Comega_n%5E%7B-it%7D%20%5Chat%20c_t%20=%20%20%5Csum_%7Bt=0%7D%5E%7Bn-1%7D%20%5Comega_n%5E%7B-it%7D%20%5Csum_%7Bj=0%7D%5E%7Bn-1%7D%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_j%20b_k%20%5Comega_n%5E%7Bt(j+k)%7D%0A%20%20%20%20=%20%5Csum_%7Bj=0%7D%5E%7Bn-1%7D%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_j%20b_k%20%5Csum_%7Bt=0%7D%5E%7Bn-1%7D%20%5Comega_n%5E%7Bt(j+k-i)%7D%0A"> 对最里侧的求和使用主要单位根的定义（求和引理），就有 <img src="https://latex.codecogs.com/png.latex?%0Ac_i%20=%20%5Csum_%7Bj=0%7D%5E%7Bn-1%7D%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_j%20b_k%20%5Bn%20%5Cmid%20j+k-i%5D%20=%20%5Csum_%7Bj+k%20%5Cequiv%20i%20%5Cbmod%7Bn%7D%7D%20a_j%20b_k%0A"> 这便是所谓的循环卷积．以后将 <img src="https://latex.codecogs.com/png.latex?R%5En"> 中向量 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20a"> 和 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20b"> 的循环卷积记为 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%20a%20*%20%5Cboldsymbol%20b">．形象地来看，循环卷积中，次数超过 <img src="https://latex.codecogs.com/png.latex?n-1"> 的卷积项被模意义地地叠加到了以次数为 <img src="https://latex.codecogs.com/png.latex?0"> 为始的项上．</p>
</section>
<section id="卷积定理" class="level3">
<h3 class="anchored" data-anchor-id="卷积定理">卷积定理</h3>
<p>前述讨论已经证明<sup>30</sup> <img src="https://latex.codecogs.com/png.latex?%0AF(A%20*%20B)%20=%20FA%20%5Cotimes%20FB%0A"> 这便是一般交换环上 DFT 变换的（循环）卷积定理．</p>
<p>我们指出，当要求所作变换可逆时，卷积定理反过来也要求所作变换是一类似 DFT 映射的变换<sup>31</sup>．</p>
<div id="exr-2timesdft" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 5 </strong></span>尝试将任意序列 DFT 两次，观察结果．证明你的结论．</p>
</div>
<div id="exr-detdft" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6 </strong></span>求 DFT 矩阵的行列式．尽可能缩小可行解范围．</p>
</div>
</section>
</section>
</section>
<section id="advanced-operations" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Advanced Operations</h1>
<section id="多项式全家桶---序言" class="level3">
<h3 class="anchored" data-anchor-id="多项式全家桶---序言">多项式全家桶 - 序言</h3>
<ul>
<li><p>有哪些？</p>
<ul>
<li>求逆、开根、对数、指数、快速幂、复合等</li>
</ul></li>
<li><p>咋推的？</p>
<ul>
<li>求解思路几乎都是倍增，时间复杂度几乎都是大常数 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)"></li>
<li>Newton 迭代法是推导全家桶迭代公式的通法</li>
<li>严格化需要进一步的形式幂级数理论，主讲人不会</li>
</ul></li>
<li><p>有啥用？</p>
<ul>
<li>当你一波操作化出生成函数发现不会求系数</li>
</ul></li>
<li><p>怎么讲？</p>
<ul>
<li>受限于篇幅和主讲人能力，我们讲不完</li>
<li>只讲求逆和对数，其余请左转 OI Wiki</li>
</ul></li>
</ul>
</section>
<section id="多项式求逆" class="level3">
<h3 class="anchored" data-anchor-id="多项式求逆">多项式求逆</h3>
<p>给定一多项式 <img src="https://latex.codecogs.com/png.latex?A(x)">，求解满足 <img src="https://latex.codecogs.com/png.latex?A(x)%20B(x)%20=%201%20%5Cpmod%7Bx%5E%7Bn%7D%7D"> 的多项式 <img src="https://latex.codecogs.com/png.latex?B(x)">．</p>
<p>多项式逆元存在的充分必要条件是其常数项非零（这是因为边界条件 <img src="https://latex.codecogs.com/png.latex?b_0%20=%20%5Cfrac%201%20%7Ba_0%7D">），若存在则在模意义下一定唯一．这结论可直接由下述求解方法得到．不失一般性，只研究 <img src="https://latex.codecogs.com/png.latex?A(x)"> 的次数至多为奇数 <img src="https://latex.codecogs.com/png.latex?2n-1"> 的情况．设 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AA(x)%20&amp;=%20A_0(x)%20+%20x%5En%20A_1(x)%20%5C%5C%0AB(x)%20&amp;=%20B_0(x)%20+%20x%5En%20B_1(x)%0A%5Cend%7Baligned%7D%0A"> 考虑递归地在已知 <img src="https://latex.codecogs.com/png.latex?%0AA(x)%20B_0(x)%20=%20A_0(x)%20B_0(x)%20=%201%20%5Cpmod%7Bx%5En%7D%0A"> 的基础上求解 <img src="https://latex.codecogs.com/png.latex?A(x)"> 的逆元．先指出该方法的时间复杂度为 <img src="https://latex.codecogs.com/png.latex?%0AT(n)%20=%20T(%5Cfrac%20n%202)%20+%20O(n%20%5Clog%20n)%20=%20O(n%20%5Clog%20n)%0A"></p>
</section>
<section id="多项式求逆-1" class="level3">
<h3 class="anchored" data-anchor-id="多项式求逆-1">多项式求逆</h3>
<p>以下简记 <img src="https://latex.codecogs.com/png.latex?A(x)"> 为 <img src="https://latex.codecogs.com/png.latex?A">，其它多项式同理．注意到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bcases%7D%0AA%20B_0%20=%201%20%5Cpmod%7Bx%5En%7D%20%5C%5C%0AA%20B%20=%201%20%5Cpmod%7Bx%5En%7D%0A%5Cend%7Bcases%7D%20%5Cimplies%20A%20(B-B_0)%20=%200%20%5Cpmod%7Bx%5En%7D%0A"> 由于 <img src="https://latex.codecogs.com/png.latex?A%20%5Cbmod%7Bx%5En%7D"> 非零，故 <img src="https://latex.codecogs.com/png.latex?%0AB-B_0%20=%200%20%5Cpmod%7Bx%5En%7D%0A"> 这也说明，多项式逆元在模不同 <img src="https://latex.codecogs.com/png.latex?x%5En"> 下的前缀保持一致．</p>
<p>两边平方得 <img src="https://latex.codecogs.com/png.latex?B%5E2%20-%202%20B%20B_0%20+%20B_0%5E2%20=%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D"> 两侧同乘 <img src="https://latex.codecogs.com/png.latex?A"> 并移项得 <img src="https://latex.codecogs.com/png.latex?%0AB%20=%202%20B_0%20-%20A%20B_0%5E2%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A"></p>
</section>
<section id="多项式求逆---实现" class="level3">
<h3 class="anchored" data-anchor-id="多项式求逆---实现">多项式求逆 - 实现</h3>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1">Poly inv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> Poly <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb6-2">    ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>len<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">();</span> Poly B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span> B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>inv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]);</span></span>
<span id="cb6-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb6-4">        B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>subpoly<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span> B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>resize<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>hf<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb6-5">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span> B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>resize<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb6-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> B<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb6-7"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<ul>
<li>常数巨大的写法，仅作演示，请勿学习．</li>
<li>正确的写法是在 DFT 后的点值上操作多项式，请小心实现封装．</li>
</ul>
</section>
<section id="多项式-ln" class="level3">
<h3 class="anchored" data-anchor-id="多项式-ln">多项式 <img src="https://latex.codecogs.com/png.latex?%5Cln"></h3>
<p>给定一多项式 <img src="https://latex.codecogs.com/png.latex?A(x)">，求解满足 <img src="https://latex.codecogs.com/png.latex?B(x)%20=%20%5Cln%20A(x)%20%5Cpmod%7Bx%5E%7Bn%7D%7D"> 的多项式 <img src="https://latex.codecogs.com/png.latex?B(x)">．</p>
<p>次数为 <img src="https://latex.codecogs.com/png.latex?+%5Cinfty"> 的形式幂级数的 <img src="https://latex.codecogs.com/png.latex?%5Cln"> 存在的充分必要条件为其常数项非零（这是因为边界条件 <img src="https://latex.codecogs.com/png.latex?b_0%20=%20%5Cln%20a_0">），同样一旦存在则唯一．注意到仅整数 <img src="https://latex.codecogs.com/png.latex?a_0=1"> 时，<img src="https://latex.codecogs.com/png.latex?%5Cln%20a_0"> 可取得整数，故合理的 <img src="https://latex.codecogs.com/png.latex?a_0"> 只能是 <img src="https://latex.codecogs.com/png.latex?1">．</p>
<p>推导是容易的．方程两侧同时求导得 <img src="https://latex.codecogs.com/png.latex?%0AB'(x)%20=%20%5Cfrac%7BA'(x)%7D%7BA(x)%7D%20%5Cpmod%7Bx%5E%7Bn-1%7D%7D%0A"> 两侧再积分得 <img src="https://latex.codecogs.com/png.latex?%0AB(x)%20=%20%5Cint%20%5Cfrac%7BA'(x)%7D%7BA(x)%7D%20%5Coperatorname%7Bd%7D%5C!x%20+%20C%20%5Cpmod%7Bx%5E%7Bn%7D%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?C=%20%5Cln%20a_0">．多项式求逆、求导、积分即可．时间复杂度 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)">．</p>
</section>
<section id="多项式-ln---实现" class="level3">
<h3 class="anchored" data-anchor-id="多项式-ln---实现">多项式 <img src="https://latex.codecogs.com/png.latex?%5Cln"> - 实现</h3>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1">Poly drv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>Poly A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">// derivative</span></span>
<span id="cb7-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>len<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">();</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=(</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)*</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span>_<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb7-3">    A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>pop_back<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">();</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb7-4"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb7-5">Poly itg<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>Poly A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">// integral</span></span>
<span id="cb7-6">    A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>push_back<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>len<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">();</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">--)</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]*</span>inv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span>_<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb7-7">    A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span>c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb7-8"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb7-9">Poly ln<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> Poly <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb7-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> itg<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">((</span>drv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)*</span>inv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)).</span>subpoly<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>A<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>len<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">()-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">),</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/*log(A[0])*/</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb7-11"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</section>
<section id="acknowledgements" class="level3">
<h3 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h3>
<ul>
<li><p>感谢 <code>keke_046</code> 学长教授 FFT、集合幂级数与生成函数．微言大义，博大精深，至今仍在消化．</p></li>
<li><p>感谢队友 <code>ItzDesert</code> 提供位运算典题一道并提供内容编排建议．</p></li>
</ul>
</section>
<section id="题单" class="level3 allowframebreaks">
<h3 class="allowframebreaks anchored" data-anchor-id="题单">题单</h3>
<p>主讲人练题少，仅供参考．</p>
<dl>
<dt>模板</dt>
<dd>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P3803">洛谷 P3803</a> 【模板】多项式乘法（FFT）</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P6091">洛谷 P6091</a> 【模板】原根</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4238">洛谷 P4238</a> 【模板】多项式乘法逆</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P5205">洛谷 P5205</a> 【模板】多项式开根</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4725">洛谷 P4725</a> 【模板】多项式对数函数（多项式 ln）</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4726">洛谷 P4726</a> 【模板】多项式指数函数（多项式 exp）</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P5245">洛谷 P5245</a> 【模板】多项式快速幂</p></li>
</ul>
</dd>
<dt>大整数乘法</dt>
<dd>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1919">洛谷 P1919</a> 【模板】A*B Problem 升级版（FFT 快速傅里叶变换）</li>
</ul>
</dd>
<dt>基础计数</dt>
<dd>
<ul>
<li><p><a href="https://www.spoj.com/problems/TSUM/">SPOJ-TSUM</a> Triple Sums</p></li>
<li><p>BZOJ3513-MUTC2013 Idiots</p>
<p>上面两道题都是 OGF 消序，较 EGF 消序困难．一般的方法是使用 Polya 计数原理．</p></li>
</ul>
</dd>
<dt>位运算</dt>
<dd>
<ul>
<li><p><a href="https://atcoder.jp/contests/abc291/tasks/abc291_g">ABC291G</a> OR Sum</p>
<p>也是滤波器的应用．</p></li>
</ul>
</dd>
<dt>分治 FFT</dt>
<dd>
<ul>
<li><p>百度之星 2023 初赛第二场 T8</p>
<p>容斥后需要计算若干一次多项式乘积，分治 NTT 即可．</p></li>
<li><p><a href="https://www.bilibili.com/video/BV1p14y1z7sF">百度之星 2023 初赛第一场 T6</a></p>
<p>求 <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi%3Ej%7D%20%5Cfrac%7Ba_i%7D%7Ba_i%20+%20a_j%7D">．值域次数化后 CDQ 处理偏序．</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4721">洛谷 P4721</a> 【模板】分治 FFT</p>
<p>CDQ 偏序化处理前后项依赖．也可解生成函数方程再多项式求逆．</p></li>
</ul>
</dd>
<dt>字符串</dt>
<dd>
<ul>
<li><p><a href="https://atcoder.jp/contests/abc196/tasks/abc196_f">ABC196F</a> Substring 2</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4173">洛谷 P4173</a> 残缺的字符串</p>
<p>带单字符通配符的字符串匹配．体会设定字符串距离函数的方法．</p></li>
</ul>
</dd>
<dt>全家桶</dt>
<dd>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P4721">洛谷 P4721</a> 【模板】分治 FFT</p>
<p>体验生成函数简化复杂数列递推的威力．</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4389">洛谷 P4389</a> 付公主的背包</p>
<p>解决此问题的方法也可用于分拆数计算．</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4841">洛谷 P4841</a> 【集训队作业2013】城市规划</p>
<p>EGF 消序划分典题．体验生成函数风格的计数方法．</p></li>
<li><p><a href="https://loj.ac/p/6538">LOJ6538</a> 烷基计数 - 加强版 - 加强版</p>
<p>对生成函数使用的 Polya 计数．</p>
<p>Polya ex. 苯环碳接 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7B-C_4H_9%7D"> 同分异构体计数</p></li>
</ul>
</dd>
<dt>其它</dt>
<dd>
<ul>
<li><p><a href="https://qoj.ac/problem/5748">QOJ5748</a>-UCUP2023-Stage7-K Determinant, or...?</p>
<p>看似人畜无害的 <img src="https://latex.codecogs.com/png.latex?%5Cleft(%20a_%7Bi%20%5Coperatorname%7Bor%7D%20j%7D%20%5Cright)_%7B(i,j)%20%5Cin%20n%20%5Ctimes%20n%7D"> 行列式求值，解法的背后却潜藏 FMT 的思想．此类行列式与各类反演、卷积有密切联系，我们给出一篇研究了其与偏序集上反演的关系的参考文献<span class="citation" data-cites="wilf1968hadamard">[15]</span>，欢迎讨论．</p></li>
</ul>
</dd>
</dl>



</section>
</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-oiwiki-lagrange" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">OI-Wiki, <span>“拉格朗日插值.”</span> <a href="https://oi-wiki.org/math/numerical/lagrange/" class="uri">https://oi-wiki.org/math/numerical/lagrange/</a>.</div>
</div>
<div id="ref-euler-formula" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">张筑生, <span>“数学分析新讲（重排本）（第二册）,”</span> 2nd ed.北京: 北京大学出版社, 2021, pp. 256–262.</div>
</div>
<div id="ref-trigonometry" class="csl-entry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">杨树森, <span>“三角函数的严格定义.”</span> <a href="https://zhuanlan.zhihu.com/p/58814328/" class="uri">https://zhuanlan.zhihu.com/p/58814328/</a>, 2023.</div>
</div>
<div id="ref-algointro" class="csl-entry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, <span>“算法导论（原书第三版）,”</span> 北京: 机械工业出版社, 2013.</div>
</div>
<div id="ref-oiwiki-discretelog" class="csl-entry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">OI-Wiki, <span>“离散对数.”</span> <a href="https://oi-wiki.org/math/number-theory/discrete-logarithm/" class="uri">https://oi-wiki.org/math/number-theory/discrete-logarithm/</a>.</div>
</div>
<div id="ref-oiwiki-pr" class="csl-entry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">OI-Wiki, <span>“原根.”</span> <a href="https://oi-wiki.org/math/number-theory/primitive-root/" class="uri">https://oi-wiki.org/math/number-theory/primitive-root/</a>.</div>
</div>
<div id="ref-agarwal1974fast" class="csl-entry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">R. Agarwal and C. Burrus, <span>“Fast convolution using fermat number transforms with applications to digital filtering,”</span> <em>IEEE Transactions on Acoustics, Speech, and Signal Processing</em>, vol. 22, no. 2, pp. 87–97, 1974, doi: <a href="https://doi.org/10.1109/TASSP.1974.1162555">10.1109/TASSP.1974.1162555</a>.</div>
</div>
<div id="ref-qiu-algebra" class="csl-entry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">丘维声, <span>“高等代数&nbsp;下册,”</span> 3rd ed.北京: 高等教育出版社, 2015.</div>
</div>
<div id="ref-oiwiki-polynomial" class="csl-entry">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">OI-Wiki, <span>“多项式与生成函数简介.”</span> <a href="https://oi-wiki.org/math/poly/intro/" class="uri">https://oi-wiki.org/math/poly/intro/</a>.</div>
</div>
<div id="ref-wikipedia-formalpowerseries" class="csl-entry">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">Wikipedia, <span>“Formal power series.”</span> <a href="https://en.wikipedia.org/wiki/Formal_power_series" class="uri">https://en.wikipedia.org/wiki/Formal_power_series</a>.</div>
</div>
<div id="ref-wikipedia-lagrange" class="csl-entry">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">Wikipedia, <span>“Lagrange polynomial.”</span> <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial" class="uri">https://en.wikipedia.org/wiki/Lagrange_polynomial</a>.</div>
</div>
<div id="ref-furer2009faster" class="csl-entry">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">M. Fürer, <span>“Faster integer multiplication,”</span> <em>SIAM Journal on Computing</em>, vol. 39, no. 3, pp. 979–1005, 2009, doi: <a href="https://doi.org/10.1137/070711761">10.1137/070711761</a>.</div>
</div>
<div id="ref-wikipedia-dft-over-ring" class="csl-entry">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">Wikipedia, <span>“Discrete fourier transform over a ring.”</span> <a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform_over_a_ring" class="uri">https://en.wikipedia.org/wiki/Discrete_Fourier_transform_over_a_ring</a>.</div>
</div>
<div id="ref-baraquin2023uniqueness" class="csl-entry">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">I. Baraquin and N. Ratier, <span>“Uniqueness of the discrete fourier transform,”</span> <em>Signal Processing</em>, vol. 209, p. 109041, 2023.</div>
</div>
<div id="ref-wilf1968hadamard" class="csl-entry">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">H. S. Wilf, <span>“Hadamard determinants m<span>ö</span>bius functions, and the chromatic number of a graph,”</span> 1968.</div>
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>一种常见的证法是使用 Vandermonde 行列式证明矩阵可逆．后面会介绍多项式环风格的证明．↩︎</p></li>
<li id="fn2"><p>有的文献定义 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%20:=%20e%5E%7B-%5Cfrac%20%7B2%20%5Cpi%7D%7Bn%7D%20i%7D">，或是因为信号处理领域常用 IDFT 将信号时域采样数据变为频域信息．事实上，DFT/IDFT 的说法也常有反转，但这只是形式问题．↩︎</p></li>
<li id="fn3"><p>这三个引理是《算法导论》<span class="citation" data-cites="algointro">[4]</span> 引入的．↩︎</p></li>
<li id="fn4"><p>这也表明适当归一化后的 DFT 矩阵是一个酉矩阵．↩︎</p></li>
<li id="fn5"><p>NTT 原理需较多笔墨，稍后介绍．↩︎</p></li>
<li id="fn6"><p>否则只有 <img src="https://latex.codecogs.com/png.latex?p"> 个不同元素的 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_p"> 中根本取不到 <img src="https://latex.codecogs.com/png.latex?n"> 个不同位置的点值．后面会深入讨论．↩︎</p></li>
<li id="fn7"><p>多项式求逆等多项式进阶操作，我们后续讲解．↩︎</p></li>
<li id="fn8"><p>对质数 <img src="https://latex.codecogs.com/png.latex?p">，<img src="https://latex.codecogs.com/png.latex?%5Cvarphi(p)=p-1">．故 Euler 定理是 Fermat 小定理的一个推广．↩︎</p></li>
<li id="fn9"><p>ExBSGS 求解离散对数 <span class="citation" data-cites="oiwiki-discretelog">[5]</span> 的推导与此相似．↩︎</p></li>
<li id="fn10"><p>部分证明稍复杂，我们略过处理．感兴趣的同学请参考 OI Wiki <span class="citation" data-cites="oiwiki-pr">[6]</span>．↩︎</p></li>
<li id="fn11"><p>这是后文所述定理“整环上的本原单位根也是主要单位根”在一般环上的一个反例．↩︎</p></li>
<li id="fn12"><p>网传此模数由 UOJ 站长 vfleaking 提出并推广．在所有需要取模的题目中使用该模数，可使选手无法通过模数判断题目的做法．↩︎</p></li>
<li id="fn13"><p>一般语境下讨论的多项式环是在域上的 <img src="https://latex.codecogs.com/png.latex?K%5Bx%5D">，而非环上的 <img src="https://latex.codecogs.com/png.latex?R%5Bx%5D">．↩︎</p></li>
<li id="fn14"><p>本篇中环的定义包含乘法单位元，即幺环．↩︎</p></li>
<li id="fn15"><p>无零因子的交换幺环，稍后介绍．↩︎</p></li>
<li id="fn16"><p>可用前述多项式乘积次数公式证明．↩︎</p></li>
<li id="fn17"><p>试试在 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z%5Bx%5D"> 上用 <img src="https://latex.codecogs.com/png.latex?2x+1"> 去除 <img src="https://latex.codecogs.com/png.latex?x+1">．↩︎</p></li>
<li id="fn18"><p>首项为 <img src="https://latex.codecogs.com/png.latex?1"> 的多项式．↩︎</p></li>
<li id="fn19"><p>函数和映射几乎是等价名词．有时函数特指值域包含于复数域 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20C"> 的映射．↩︎</p></li>
<li id="fn20"><p>为良定义 <img src="https://latex.codecogs.com/png.latex?x%5E0">，环 <img src="https://latex.codecogs.com/png.latex?R"> 必须有单位元．↩︎</p></li>
<li id="fn21"><p>这里再次涉及环 <img src="https://latex.codecogs.com/png.latex?R"> 上的收敛问题．由于实践中只关心形式幂级数的前有限项，后续讨论系数-点值-系数法转换卷积时不需要用到幂级数理论，可以回避．↩︎</p></li>
<li id="fn22"><p>这种保持结构不变的映射被称为同态（homomorphism）．↩︎</p></li>
<li id="fn23"><p>其证明了域上一元多项式环的通用性质．仿照该证明应可证明环上的版本，从而证明这一同态关系．↩︎</p></li>
<li id="fn24"><p>该定理是下方高亮定理的一个自然的推论．↩︎</p></li>
<li id="fn25"><p>由于一次因式均为首一多项式，可以在整环上对其使用带余除法．↩︎</p></li>
<li id="fn26"><p>模是定义在环上的“线性空间”．↩︎</p></li>
<li id="fn27"><p>Lagrange 插值的构造用到了除法，且行列式非零推出矩阵可逆仅在域上的线性空间中适用，因此必须要求 <img src="https://latex.codecogs.com/png.latex?R"> 是域．↩︎</p></li>
<li id="fn28"><p>使得 <img src="https://latex.codecogs.com/png.latex?m%201%20=%20%5Csum_%7Bk=0%7D%5E%7Bm-1%7D1%20=%200"> 的最小正整数 <img src="https://latex.codecogs.com/png.latex?m">．不存在则记为 <img src="https://latex.codecogs.com/png.latex?0">．<img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bchar%7D%5Cmathbb%20C%20=%200">，<img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bchar%7D%5Cmathbb%20Z_p%20=%20p">．可以证明域的特征一定是 <img src="https://latex.codecogs.com/png.latex?0"> 或一质数<span class="citation" data-cites="qiu-algebra">[8, 第 7 章第 11 节定理 3，p.&nbsp;70]</span>．↩︎</p></li>
<li id="fn29"><p>证明使用主要单位根的定义（求和引理）即可．↩︎</p></li>
<li id="fn30"><p>虽然前面用到了 <img src="https://latex.codecogs.com/png.latex?F"> 可逆的要求，但该定理在 <img src="https://latex.codecogs.com/png.latex?F"> 不可逆时也成立．只需类似地验证两边相等即可．↩︎</p></li>
<li id="fn31"><p>具体来说，该变换只能是 DFT 矩阵的某个行置换．在 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20C%5En"> 上的证明可参见<span class="citation" data-cites="baraquin2023uniqueness">[14]</span>，主讲人目前正在研究整环上的版本，欢迎讨论．↩︎</p></li>
</ol>
</section></div> ]]></description>
  <category>OI</category>
  <category>数学</category>
  <category>讲稿</category>
  <category>slide</category>
  <guid>https://blog.sun123zxy.top/posts/20230928-dft/index.html</guid>
  <pubDate>Mon, 31 Jul 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>算法 &amp; 数学碎碎念</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230621-cpmodel/index.html</link>
  <description><![CDATA[ 



<p>前半部分主要为公式、推导、证明等速成提纲，大部分实现、模板、表格放在文末．</p>
<section id="数论" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="数论"><span class="header-section-number">1</span> 数论</h2>
<section id="exgcd" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="exgcd"><span class="header-section-number">1.1</span> ExGCD</h3>
<div id="thm-exgcd" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (ExGCD) </strong></span>给定线性方程组 <img src="https://latex.codecogs.com/png.latex?ax+by=%5Cgcd(a,b)">，其解可递归地由下式求得 <img src="https://latex.codecogs.com/png.latex?%0Aa%20y_1%20+%20b%20%5Cleft(%20x_1%20-%20%5Cleft%5Clfloor%20%5Cfrac%20a%20b%20%5Cright%5Crfloor%20y_1%20%5Cright)%20=%20%5Cgcd(b,%20a%20%5Cbmod%20b)%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?x_1,%20y_1"> 是 <img src="https://latex.codecogs.com/png.latex?b%20x%20+%20(a%20%5Cbmod%20b)%20y%20=%20%5Cgcd(b,%20a%20%5Cbmod%20b)"> 的一组解．</p>
</div>
</section>
<section id="crt" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="crt"><span class="header-section-number">1.2</span> CRT</h3>
<div id="thm-crt" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 (CRT) </strong></span>给定 <img src="https://latex.codecogs.com/png.latex?n"> 个同余方程 <img src="https://latex.codecogs.com/png.latex?%0Ax%20%5Cequiv%20a_i%20%5Cpmod%7Bm_i%7D%20%5Cpod%7Bi%20=%201,%20%5Cdots,%20n%7D%0A"></p>
<p>其中各 <img src="https://latex.codecogs.com/png.latex?m_i"> 两两互质，则上式等价于 <img src="https://latex.codecogs.com/png.latex?%0Ax%20%5Cequiv%20%5Csum_%7Bi=1%7D%5En%20a_i%20M_i%20%5Coperatorname%7Binv%7D_%7Bm_i%7D(M_i)%20%5Cpmod%20M%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?M%20=%20%5Csum_%7Bi=1%7D%5En%20m_i">，<img src="https://latex.codecogs.com/png.latex?M_i%20=%20%5Cfrac%7BM%7D%7Bm_i%7D">．</p>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span><img src="https://latex.codecogs.com/png.latex?%0AM_i%20%5Coperatorname%7Binv%7D_%7Bm_i%7D(M_i)%20%5Cmod%20m_j%20=%20%5Bi%20=%20j%5D%0A"></p>
</div>
<section id="excrt" class="level4">
<h4 class="anchored" data-anchor-id="excrt">ExCRT</h4>
<p>对一般的情况，考虑合并两个同余方程．给定 <img src="https://latex.codecogs.com/png.latex?2"> 个同余方程 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%5C%7B%0A%5Cbegin%7Baligned%7D%0A%20%20x%20&amp;%5Cequiv%20a_1%20%5Cpmod%7Bm_1%7D%20%5C%5C%0A%20%20x%20&amp;%5Cequiv%20a_2%20%5Cpmod%7Bm_2%7D%0A%5Cend%7Baligned%7D%0A%5Cright.%0A"> 考虑化为不定方程形式 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%20%20x%20=%20k_1%20m_1%20+%20a_1%20%5C%5C%0A%20%20x%20=%20k_2%20m_2%20+%20a_2%0A%5Cend%7Baligned%7D%0A"> 合并得到 <img src="https://latex.codecogs.com/png.latex?%0Ak_1%20m_1%20+%20a_1%20=%20k_2%20m_2%20+%20a_2%0A"> 即 <img src="https://latex.codecogs.com/png.latex?%0Ak_1%20m_1%20-%20k_2%20m_2%20=%20a_2%20-%20a_1%0A"> 此即关于 <img src="https://latex.codecogs.com/png.latex?k_1,%20k_2"> 的不定方程．若 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(m_1,%20m_2)%20%5Cmid%20a_2%20-%20a_1">，则可应用 ExGCD 求得方程的一组解，带回即得 <img src="https://latex.codecogs.com/png.latex?%0Ax%20%5Cequiv%20k_1%20m_1%20+%20a_1%20%5Cpmod%7B%5Coperatorname%7Blcm%7D(m_1,%20m_2)%7D%0A"> 否则同余方程组无解．</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>若一组同余方程两两可合并，则全部均可合并．当判断大规模同余方程组是否有解时可能用到．</p>
</div>
</section>
</section>
<section id="bsgs" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="bsgs"><span class="header-section-number">1.3</span> BSGS</h3>
<p>求 <img src="https://latex.codecogs.com/png.latex?a%5Ex%20%5Cequiv%20b%20%5Cpmod%7Bm%7D"> 的一个特解，其中 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(a,m)%20=%201">．</p>
<p>实质是非常暴力的根号分治．根据 Euler 定理，只需检测连续 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(m)"> 个 <img src="https://latex.codecogs.com/png.latex?x"> 就可判定是否有解．令 <img src="https://latex.codecogs.com/png.latex?x%20=%20q%20%5Cleft%5Clceil%20%5Csqrt%20m%20%5Cright%5Crceil%20-r">，其中 <img src="https://latex.codecogs.com/png.latex?q,r%20%5Cin%20%5B1,%5Cleft%5Clceil%20%5Csqrt%20m%20%5Cright%5Crceil%5D">，于是 <img src="https://latex.codecogs.com/png.latex?x%20%5Cin%20%5B0,%5Cleft%5Clceil%20%5Csqrt%20m%20%5Cright%5Crceil%5E2)">．代入原方程移项即得 <img src="https://latex.codecogs.com/png.latex?a%5E%7Bq%20%5Cleft%5Clceil%20%5Csqrt%20m%20%5Cright%5Crceil%7D%20%5Cequiv%20b%20a%5Er%20%5Cpmod%7Bm%7D">，右边使用 <code>map</code> 提前存下即可．时间复杂度 <img src="https://latex.codecogs.com/png.latex?O(%5Csqrt%20m)">．</p>
</section>
<section id="miller-rabintodo" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="miller-rabintodo"><span class="header-section-number">1.4</span> Miller-Rabin【TODO】</h3>
</section>
<section id="pollard-rhotodo" class="level3" data-number="1.5">
<h3 data-number="1.5" class="anchored" data-anchor-id="pollard-rhotodo"><span class="header-section-number">1.5</span> Pollard-Rho【TODO】</h3>
</section>
<section id="原根euler-定理等" class="level3" data-number="1.6">
<h3 data-number="1.6" class="anchored" data-anchor-id="原根euler-定理等"><span class="header-section-number">1.6</span> 原根、Euler 定理等</h3>
<p>见 <a href="../../posts/20230928-dft/">FFT/NTT 讲稿</a>．</p>
</section>
<section id="定理杂记" class="level3" data-number="1.7">
<h3 data-number="1.7" class="anchored" data-anchor-id="定理杂记"><span class="header-section-number">1.7</span> 定理杂记</h3>
<section id="lucas-定理" class="level4">
<h4 class="anchored" data-anchor-id="lucas-定理">Lucas 定理</h4>
<div id="thm-nt-lucas" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (Lucas 定理) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cbinom%7Bn%7D%7Bm%7D%20%5Cequiv%20%5Cprod_%7Bi%7D%20%5Cbinom%7Bn_i%7D%7Bm_i%7D%20%5Cequiv%20%5Cbinom%7B%5Cleft%5Clfloor%20n/p%20%5Cright%5Crfloor%7D%7B%5Cleft%5Clfloor%20m/p%20%5Cright%5Crfloor%7D%20%5Cbinom%7Bn%20%5Cbmod%20p%7D%7Bn%20%5Cbmod%20p%7D%20%5Cpmod%20p%0A"></p>
<p>其中 <img src="https://latex.codecogs.com/png.latex?p"> 是质数，<img src="https://latex.codecogs.com/png.latex?n_i"> 和 <img src="https://latex.codecogs.com/png.latex?m_i"> 是 <img src="https://latex.codecogs.com/png.latex?n"> 和 <img src="https://latex.codecogs.com/png.latex?m"> 的 <img src="https://latex.codecogs.com/png.latex?p"> 进制表示下的各数位．</p>
</div>
<p>证明的要点有二：一是 <img src="https://latex.codecogs.com/png.latex?%5Cbinom%20%7Bp%5Ei%7D%20m%20%5Cbmod%20%7Bp%7D%20=%20%5Bm%20=%200%20%5Cland%20m%20=%20p%5Ei%5D">，即 <img src="https://latex.codecogs.com/png.latex?(1+x)%5E%7Bp%5Ei%7D%20%5Cequiv%201%20+%20x%5E%7Bp%5Ei%7D%20%5Cpmod%20p">；二是 Vandermonde 卷积．生成函数食用风味更佳．</p>
<p>参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Lucas%27s_theorem">Lucas’s theorem - Wikipedia</a></li>
<li><a href="https://oi-wiki.org/math/number-theory/lucas/">卢卡斯定理 - OI Wiki</a></li>
</ul>
</section>
<section id="legendre-公式和-kummer-定理todo" class="level4">
<h4 class="anchored" data-anchor-id="legendre-公式和-kummer-定理todo">Legendre 公式和 Kummer 定理【TODO】</h4>
<div id="thm-nt-legendre" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4 (Legendre 公式) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cnu_p%20(n!)%20=%20%5Csum_%7Bi=1%7D%5E%7B+%5Cinfty%7D%20%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bp%5Ei%7D%20%5Cright%5Crfloor%0A"></p>
<p>其中 <img src="https://latex.codecogs.com/png.latex?p"> 是质数．</p>
</div>
<p>比较显然的结论，按和式统计贡献即证．</p>
<div id="thm-nt-kummer" class="theorem">
<p><span class="theorem-title"><strong>Theorem 5 (Kummer 定理) </strong></span><img src="https://latex.codecogs.com/png.latex?%5Cbinom%20n%20m"> 中质因子 <img src="https://latex.codecogs.com/png.latex?p"> 的指数等于 <img src="https://latex.codecogs.com/png.latex?p"> 进制下加法 <img src="https://latex.codecogs.com/png.latex?m+(n-m)"> 发生的进位次数，即 <img src="https://latex.codecogs.com/png.latex?%0A%5Cnu_p%20%5Cleft(%20%5Cbinom%20n%20m%20%5Cright)%20=%20%5Cfrac%7BS_p(m)+S_p(n-m)-S_p(n)%7D%7Bp-1%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?S_p(n)"> 是 <img src="https://latex.codecogs.com/png.latex?n"> 在 <img src="https://latex.codecogs.com/png.latex?p"> 进制下各数位数字之和．</p>
</div>
<p>证明待考．参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Kummer%27s_theorem">Kummer’s theorem - Wikipedia</a></li>
</ul>
</section>
<section id="扩展-euler-定理" class="level4">
<h4 class="anchored" data-anchor-id="扩展-euler-定理">扩展 Euler 定理</h4>
<p><img src="https://latex.codecogs.com/png.latex?%0Aa%5Eb%20%5Cequiv%20a%5E%7Bb%20%5Cbmod%20%5Cvarphi(m)%20+%20%5Cvarphi(m)%7D%20%5Cpmod%7Bm%7D%0A"></p>
<p>进入循环所需步骤其实很少，一定小于 <img src="https://latex.codecogs.com/png.latex?%5Cvarphi(m)">．（疑似量级在 <img src="https://latex.codecogs.com/png.latex?%5Clog%20m"> 以下，存疑，见 FFT 讲稿）</p>
</section>
<section id="lagrange-定理" class="level4">
<h4 class="anchored" data-anchor-id="lagrange-定理">Lagrange 定理</h4>
<div id="thm-nt-lagrange" class="theorem">
<p><span class="theorem-title"><strong>Theorem 6 (Lagrange 定理) </strong></span>设 <img src="https://latex.codecogs.com/png.latex?p"> 是质数，<img src="https://latex.codecogs.com/png.latex?A(x)%20%5Cin%20%5Cmathbb%20Z_p%5Bx%5D">．同余方程 <img src="https://latex.codecogs.com/png.latex?A(x)%20%5Cequiv%200%20%5Cpmod%20p"> 只有至多 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bdeg%7D%20A(x)"> 个模 <img src="https://latex.codecogs.com/png.latex?p"> 意义下不同的整数解，除非这多项式的系数在模 <img src="https://latex.codecogs.com/png.latex?p"> 意义下全为零．</p>
</div>
<p>这是域上的多项式理论在模 <img src="https://latex.codecogs.com/png.latex?p"> 整数域上的应用．</p>
</section>
<section id="wilson-定理" class="level4">
<h4 class="anchored" data-anchor-id="wilson-定理">Wilson 定理</h4>
<div id="thm-nt-wilson" class="theorem">
<p><span class="theorem-title"><strong>Theorem 7 (Wilson 定理) </strong></span>对质数 <img src="https://latex.codecogs.com/png.latex?p">， <img src="https://latex.codecogs.com/png.latex?%0A(p-1)!%20%5Cequiv%20-1%20%5Cpmod%20p%0A"></p>
</div>
<p><img src="https://latex.codecogs.com/png.latex?p=2"> 容易特判证明．现在只考虑 <img src="https://latex.codecogs.com/png.latex?p"> 是奇质数的情况．</p>
<p><img src="https://latex.codecogs.com/png.latex?(p-1)!"> 中，互为逆元的数相互抵消，仅剩下逆元为自身的数 <img src="https://latex.codecogs.com/png.latex?%5Cpm%201">，立得上述定理．</p>
<p>另一种证法注意到 <img src="https://latex.codecogs.com/png.latex?x%5E%7Bp-1%7D%20-%201%20=%20%5Cprod_%7Bk=1%7D%5E%7Bp-1%7D%20(x-k)">．这是因为 Fermat 小定理指出 <img src="https://latex.codecogs.com/png.latex?1"> 至 <img src="https://latex.codecogs.com/png.latex?p-1"> 的所有数的 <img src="https://latex.codecogs.com/png.latex?p-1"> 次幂均为 <img src="https://latex.codecogs.com/png.latex?1">，而 Lagrange 定理又保证了多项式点值到系数映射的唯一性．随后代入 <img src="https://latex.codecogs.com/png.latex?x=0"> 立得结论．</p>
<p>参见 <a href="https://en.wikipedia.org/wiki/Wilson%27s_theorem">Wilson’s theorem - Wikipedia</a>．</p>
</section>
</section>
<section id="线性预处理" class="level3" data-number="1.8">
<h3 data-number="1.8" class="anchored" data-anchor-id="线性预处理"><span class="header-section-number">1.8</span> 线性预处理</h3>
<section id="线性求逆元" class="level4">
<h4 class="anchored" data-anchor-id="线性求逆元">线性求逆元</h4>
<p>现欲求出 <img src="https://latex.codecogs.com/png.latex?a"> 模质数 <img src="https://latex.codecogs.com/png.latex?p"> 意义下的逆元 <img src="https://latex.codecogs.com/png.latex?a%5E%7B-1%7D">．用 <img src="https://latex.codecogs.com/png.latex?a"> 对 <img src="https://latex.codecogs.com/png.latex?p"> 做带余除法，<img src="https://latex.codecogs.com/png.latex?p=qa+r">，于是 <img src="https://latex.codecogs.com/png.latex?-qa%20%5Cequiv%20r%20%5Cpmod%20p">．两侧同时乘 <img src="https://latex.codecogs.com/png.latex?r"> 的逆元 <img src="https://latex.codecogs.com/png.latex?r%5E%7B-1%7D"> 得 <img src="https://latex.codecogs.com/png.latex?-q%20r%5E%7B-1%7D%20a%20%5Cequiv%201%20%5Cpmod%20p">，故 <img src="https://latex.codecogs.com/png.latex?%0Aa%5E%7B-1%7D%20=%20-%20q%20r%5E%7B-1%7D%20=%20-%20%5Cleft%5Clfloor%20%5Cfrac%20p%20a%20%5Cright%5Crfloor%20%5Ccdot%20(p%20%5Cbmod%20a)%5E%7B-1%7D%0A"></p>
</section>
<section id="线性阶乘逆" class="level4">
<h4 class="anchored" data-anchor-id="线性阶乘逆">线性阶乘逆</h4>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%201%20%7Bn!%7D%20=%20(n+1)%20%5Ccdot%20%5Cfrac%201%20%7B(n+1)!%7D%0A"></p>
</section>
</section>
</section>
<section id="积性函数" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="积性函数"><span class="header-section-number">2</span> 积性函数</h2>
<section id="整除分块" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="整除分块"><span class="header-section-number">2.1</span> 整除分块</h3>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1">ll ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-2"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb1-3">    d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-4">    ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=(</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)-</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">))*</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-5"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>此 <img src="https://latex.codecogs.com/png.latex?O(%5Csqrt%20n)"> 较满，极大劣于因子个数的 <img src="https://latex.codecogs.com/png.latex?O(%5Csqrt%20n)">．</p>
<p>另有变种枚举 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bd%5E2%7D%20%5Cright%5Crfloor"> 的整除分块如下，复杂度为 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B1/3%7D)">．</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1">ll ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-2"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb2-3">    d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/(</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">),</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>sqrt<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb2-4">    ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=(</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)-</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">))*</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-5"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<section id="上取整整除分块" class="level4">
<h4 class="anchored" data-anchor-id="上取整整除分块">上取整整除分块</h4>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1">ll cdiv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//ceil(a/b)</span></span>
<span id="cb3-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">||</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)?</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb3-3"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb3-4">ll ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb3-5"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb3-6">    d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>cdiv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">),</span> l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>cdiv<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb3-7">    ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=(</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)-</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">))*</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb3-8"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</section>
</section>
<section id="杜教筛" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="杜教筛"><span class="header-section-number">2.2</span> 杜教筛</h3>
<p>设 <img src="https://latex.codecogs.com/png.latex?f"> 为一数论函数，我们希望快速求得其前缀和 <img src="https://latex.codecogs.com/png.latex?%5Chat%20f%20(n)%20=%20%5Csum_%7Bi=1%7D%5En%20f(i)">. 考虑数论函数 <img src="https://latex.codecogs.com/png.latex?g"> 和 <img src="https://latex.codecogs.com/png.latex?h%20=%20g%20*%20f">， <img src="https://latex.codecogs.com/png.latex?%0Ah(n)%20=%20%5Csum_%7Bd%20%5Cmid%20n%7D%20g(d)%20f(%5Cfrac%20n%20d)%0A"> 两端做前缀和得 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Chat%20h%20(n)%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20h(i)%20%5C%5C%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bd%20%5Cmid%20i%7D%20g(d)%20f(%5Cfrac%20i%20d)%20%5C%5C%0A&amp;=%20%5Csum_%7Bd=1%7D%5En%20g(d)%20%5Csum_%7Bi=1%7D%5E%7B%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%7D%20f(i)%20%5C%5C%0A&amp;=%20%5Csum_%7Bd=1%7D%5En%20g(d)%20%5Chat%20f%20(%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor)%20%5C%5C%0A&amp;=%20g(1)%20%5Chat%20f%20(n)%20+%20%5Csum_%7Bd=2%7D%5En%20g(d)%20%5Chat%20f%20(%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor)%0A%5Cend%7Baligned%7D%0A"> 因此 <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%20f%20(n)%20=%20%5Cfrac%201%20%7Bg(1)%7D%20%5Cleft(%20%5Chat%20h%20(n)%20-%20%5Csum_%7Bd=2%7D%5En%20g(d)%20%5Chat%20f%20(%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor)%20%5Cright)%0A"></p>
<p>故若 <img src="https://latex.codecogs.com/png.latex?g">、<img src="https://latex.codecogs.com/png.latex?h"> 的前缀和可 <img src="https://latex.codecogs.com/png.latex?O(1)"> 算得，根据上式整除分块即可递归地计算出 <img src="https://latex.codecogs.com/png.latex?f"> 的前缀和．预处理前 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B2/3%7D)"> 项并记忆化得到的时间复杂度为 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B2/3%7D)">．外层整除分块不会增加时间复杂度．</p>
<p>关于时间复杂度证明可参考 <a href="https://blog.sun123zxy.top/posts/20230418-complexity/#%E6%9D%9C%E6%95%99%E7%AD%9B">sun123zxy’s blog - OI 数论中的上界估计与时间复杂度证明 # 杜教筛</a>．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bgathered%7D%0Af%20=%20%5Cmu,%20g%20=%20I,%20h%20=%20%5Cvarepsilon%20%5C%5C%0Af%20=%20%5Cvarphi,%20g%20=%20I,%20h%20=%20%5Coperatorname%7Bid%7D%5C%5C%0Af%20=%20%5Coperatorname%7Bid%7D%5Ek%20%5Cmu,%20g%20=%20%5Coperatorname%7Bid%7D%5Ek,%20h%20=%20%5Cvarepsilon%20%5C%5C%0Af%20=%20%5Coperatorname%7Bid%7D%5Ek%20%5Cvarphi,%20g%20=%20%5Coperatorname%7Bid%7D%5Ek,%20h%20=%20%5Coperatorname%7Bid%7D%5E%7Bk+1%7D%0A%5Cend%7Bgathered%7D%0A"></p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>杜教筛的这种化法事实上也是 Eratosthenes 筛法的应用．一般的我们有 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bd=1%7D%5En%20f(d)%20%5Chat%20g(%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%20)%20=%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bd%20%5Cmid%20i%7D%20f(d)%20g(%5Cfrac%20i%20d)%20=%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bd%20%5Cmid%20i%7D%20f(%5Cfrac%20i%20d)%20g(d)%20%20%20=%20%5Csum_%7Bd=1%7D%5En%20g(d)%20%5Chat%20f(%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%20)%0A"></p>
</div>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1">unordered_map<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">s_mu</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-2">ll S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb4-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span>MXG<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb4-4">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">// already accumulated</span></span>
<span id="cb4-5">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">else</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">s_mu</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>count<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)){</span></span>
<span id="cb4-6">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">s_mu</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb4-7">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-8">    ll ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb4-10">        d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-11">        ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)*(</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb4-12">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-13">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">s_mu</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-14"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</section>
<section id="杂式" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="杂式"><span class="header-section-number">2.3</span> 杂式</h3>
<p>无平方因子数计数： <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5En%20%5Cmu%5E2(i)%20=%20%5Csum_%7Bi=1%7D%5E%7B%5Cleft%5Clfloor%20%5Csqrt%20n%20%5Cright%5Crfloor%7D%20%5Cmu(i)%20%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bi%5E2%7D%20%5Cright%5Crfloor%0A"></p>
<p><a href="../../posts/20200220-factor/">约数个数函数的一个性质</a>：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ad(ab)%20=%20%5Csum_%7Bx%7Ca%7D%20%5Csum_%7By%7Cb%7D%20%5B%5Cgcd%20(x,y)%20=%201%5D%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ad(abc)%20=%20%5Csum_%7Bx%7Ca%7D%20%5Csum_%7By%7Cb%7D%20%5Csum_%7Bz%7Cc%7D%20%5B%5Cgcd%20(x,y)%20=%201%5D%20%5B%5Cgcd%20(y,z)%20=%201%5D%20%5B%5Cgcd%20(x,z)%20=1%5D%0A"></p>
<p>广义约数个数函数性质扩展：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_k%20(ab)%20=%20%5Csum_%7Bx%7Ca%7D%20%5Csum_%7By%7Cb%7D%20%5B%5Cgcd(x,y)=1%5D%20(x%20%5Cfrac%7Bb%7D%7By%7D)%5Ek%20=%20%5Csum_%7Bx%7Ca%7D%20%5Csum_%7By%7Cb%7D%20%5B%5Cgcd(x,%5Cfrac%7Bb%7D%7By%7D)=1%5D%20(x%20y)%5Ek%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_k%20(abc)%20=%20%5Csum_%7Bx%7Ca%7D%20%5Csum_%7By%7Cb%7D%20%5Csum_%7Bz%7Cc%7D%20%5B%5Cgcd(x,%5Cfrac%7Bb%7D%7By%7D)=1%5D%20%5B%5Cgcd(y,%5Cfrac%7Bc%7D%7Bz%7D)=1%5D%20%5B%5Cgcd(x,%20%5Cfrac%7Bc%7D%7Bz%7D=1)%5D%20(x%20y%20z)%5Ek%0A"></p>
</section>
</section>
<section id="组合" class="level2 page-columns page-full" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="组合"><span class="header-section-number">3</span> 组合</h2>
<section id="容斥-二项式反演" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="容斥-二项式反演"><span class="header-section-number">3.1</span> 容斥 / 二项式反演</h3>
<section id="形式一" class="level4">
<h4 class="anchored" data-anchor-id="形式一">形式一</h4>
<p>容斥原理的第一种形式给出了“子集和变换”的逆变换．</p>
<div id="thm-inex-first-set" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8 (容斥原理，形式一，集合) </strong></span><img src="https://latex.codecogs.com/png.latex?%0Ag(S)%20=%20%5Csum_%7BT%20%5Csubset%20S%7D%20f(T)%20%5Ciff%20f(S)%20=%20%5Csum_%7BT%20%5Csubset%20S%7D%20(-1)%5E%7B%7CS%7C%20-%20%7CT%7C%7D%20g(T)%0A"></p>
</div>
<p>证明的关键是 <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bk=0%7D%5En%20%5Cbinom%20n%20k%20(-1)%5Ek%20=%20(1-1)%5En%20=%20%5Bn=0%5D">．</p>
<div id="thm-inex-first-binomial" class="theorem">
<p><span class="theorem-title"><strong>Theorem 9 (容斥原理，形式一，二项式反演) </strong></span><img src="https://latex.codecogs.com/png.latex?%0Ag(n)%20=%20%5Csum_%7Bk=0%7D%5En%20%5Cbinom%20n%20k%20f(k)%20%5Ciff%20f(n)%20=%20%5Csum_%7Bk=0%7D%5En%20(-1)%5E%7Bn-k%7D%20%5Cbinom%20n%20k%20g(k)%0A"></p>
<p>若设 <img src="https://latex.codecogs.com/png.latex?F(x)"> 和 <img src="https://latex.codecogs.com/png.latex?G(x)"> 分别为 <img src="https://latex.codecogs.com/png.latex?f(n)"> 和 <img src="https://latex.codecogs.com/png.latex?g(n)"> 的指数生成函数（EGF），则结论可等价地表示为</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AG(x)%20=%20e%5Ex%20F(x)%20%5Ciff%20F(x)%20=%20e%5E%7B-x%7D%20G(x)%0A"></p>
</div>
<p>生成函数的形式使我们可在 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)"> 的优秀时间复杂度之内在 <img src="https://latex.codecogs.com/png.latex?f(n)"> 和 <img src="https://latex.codecogs.com/png.latex?g(n)"> 间做出变换．</p>
</section>
<section id="形式二" class="level4">
<h4 class="anchored" data-anchor-id="形式二">形式二</h4>
<p>形式一的补集形式，给出了全集 <img src="https://latex.codecogs.com/png.latex?U"> 下“超集和变换”的逆变换．</p>
<div id="thm-inex-second-set" class="theorem">
<p><span class="theorem-title"><strong>Theorem 10 (容斥原理，形式二，集合) </strong></span><img src="https://latex.codecogs.com/png.latex?%0Ag(S)%20=%20%5Csum_%7BS%20%5Csubset%20T%20%5Csubset%20U%7D%20f(T)%20%5Ciff%20f(S)%20=%20%5Csum_%7BS%20%5Csubset%20T%20%5Csubset%20U%7D%20(-1)%5E%7B%7CT%7C%20-%20%7CS%7C%7D%20g(T)%0A"></p>
</div>
<div id="thm-inex-second-binomal" class="theorem">
<p><span class="theorem-title"><strong>Theorem 11 (容斥原理，形式二，二项式反演) </strong></span><img src="https://latex.codecogs.com/png.latex?%0Ag(n)%20=%20%5Csum_%7Bk=0%7D%5E%7BN-n%7D%20%5Cbinom%20%7BN-n%7D%20k%20f(n+k)%20%5Ciff%20f(n)%20=%20%5Csum_%7Bk=0%7D%5E%7BN-n%7D%20(-1)%5Ek%20%5Cbinom%20%7BN-n%7D%20k%20g(n+k)%0A"></p>
</div>
</section>
<section id="应用" class="level4">
<h4 class="anchored" data-anchor-id="应用">应用</h4>
<div id="exm-inex-extraordinary" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 (不太常见的“容斥原理”) </strong></span>满足全部性质的元素数量可容斥地通过下式计算 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcap_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%20&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Csum_%7B%7CS%7C=k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U-S%7D%20A_i%20%5Cright)%20%5C%5C%0A&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Csum_%7B%7CS%7C=k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcup_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20%5C%5C%0A&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Csum_%7Bi_1%20%3C%20%5Cdots%20%3C%20i_k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20A_%7Bi_1%7D%20%5Ccup%20%5Cdots%20%5Ccup%20A_%7Bi_k%7D%20%5Cright)%0A%5Cend%7Baligned%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?A"> 代表全集，<img src="https://latex.codecogs.com/png.latex?A_i"> 代表满足第 <img src="https://latex.codecogs.com/png.latex?i"> 个性质的元素构成的集合，<img src="https://latex.codecogs.com/png.latex?U"> 是非空有限的性质指标集．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>令 <img src="https://latex.codecogs.com/png.latex?f(S)"> 为恰好只满足 <img src="https://latex.codecogs.com/png.latex?S"> 中各性质的元素数量，<img src="https://latex.codecogs.com/png.latex?g(S)"> 为至多只满足 <img src="https://latex.codecogs.com/png.latex?S"> 中各性质的元素数量，即 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bgathered%7D%0Af(S)%20:=%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cleft(%20A%20%5Ccap%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20-%20%5Cbigcup_%7Bi%20%5Cin%20U-S%7D%20A_i%20%5Cright)%20%5C%5C%0Ag(S)%20:=%20%5Coperatorname%7Bcard%7D%5Cleft(%20A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U-S%7D%20A_i%20%5Cright)%0A=%20%5Coperatorname%7Bcard%7D%5Cleft(A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%20+%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcup_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%0A%5Cend%7Bgathered%7D%0A"> 取 <img src="https://latex.codecogs.com/png.latex?S=U"> 代入 Theorem&nbsp;8 右侧就得到结论第一行的等式．继续化简 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcap_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%20&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Csum_%7B%7CS%7C=k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U-S%7D%20A_i%20%5Cright)%20%5C%5C%0A&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Csum_%7B%7CS%7C=k%7D%20%5Cleft(%20%5Coperatorname%7Bcard%7D%5Cleft(A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%20+%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcup_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20%5Cright)%20%5C%5C%0A&amp;=%20%5Coperatorname%7Bcard%7D%5Cleft(A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Cbinom%7B%7CU%7C%7D%7Bk%7D%20+%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Csum_%7B%7CS%7C=k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcup_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%0A%5Cend%7Baligned%7D%0A"> 注意到 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7B%7CU%7C-k%7D%20%5Cbinom%7B%7CU%7C%7D%7Bk%7D%20=%20%5B%7CU%7C%20=%200%5D%0A"> 而 <img src="https://latex.codecogs.com/png.latex?U%20%5Cneq%20%5Cvarnothing">，故上式左项为 <img src="https://latex.codecogs.com/png.latex?0">，即得结论式第二行．</p>
</div>
<div id="exm-inex-ordinary-out" class="theorem example">
<p><span class="theorem-title"><strong>Example 2 (有点常见的“容斥原理”) </strong></span>不满足任何性质的元素数量可容斥地通过下式计算 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bcard%7D%5Cleft(%20A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%0A&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5Ek%20%5Csum_%7B%7CS%7C%20=%20k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20A%20%5Ccap%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20%5C%5C%0A&amp;=%20%5Coperatorname%7Bcard%7DA%20+%20%5Csum_%7Bk=1%7D%5E%7B%7CU%7C%7D%20(-1)%5Ek%20%5Csum_%7B%7CS%7C%20=%20k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20%5C%5C%0A&amp;=%20%5Coperatorname%7Bcard%7DA%20+%20%5Csum_%7Bk=1%7D%5E%7B%7CU%7C%7D%20(-1)%5Ek%20%5Csum_%7Bi_1%20%3C%20%5Cdots%20%3C%20i_k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20A_%7Bi_1%7D%20%5Ccap%20%5Cdots%20%5Ccap%20A_%7Bi_k%7D%20%5Cright)%0A%5Cend%7Baligned%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?A"> 代表全集，<img src="https://latex.codecogs.com/png.latex?A_i"> 代表满足第 <img src="https://latex.codecogs.com/png.latex?i"> 个性质的元素构成的集合，<img src="https://latex.codecogs.com/png.latex?U"> 是非空有限的性质指标集．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>令 <img src="https://latex.codecogs.com/png.latex?f(S)"> 为恰好只满足 <img src="https://latex.codecogs.com/png.latex?S"> 中各性质的元素数量，<img src="https://latex.codecogs.com/png.latex?g(S)"> 为至少满足 <img src="https://latex.codecogs.com/png.latex?S"> 中各性质的元素数量，即 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bgathered%7D%0Af(S)%20:=%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cleft(%20A%20%5Ccap%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20-%20%5Cbigcup_%7Bi%20%5Cin%20U-S%7D%20A_i%20%5Cright)%20%5C%5C%0Ag(S)%20:=%20%5Coperatorname%7Bcard%7D%5Cleft(%20A%20%5Ccap%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%0A=%20%5Cbegin%7Bcases%7D%0A%5Coperatorname%7Bcard%7DA%20&amp;%20S%20=%20%5Cvarnothing%20%5C%5C%0A%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Bcases%7D%0A%5Cend%7Bgathered%7D%0A"> 取 <img src="https://latex.codecogs.com/png.latex?S=%5Cvarnothing"> 代入 Theorem&nbsp;10 右侧就得到结论．</p>
</div>
<div id="exr-inex-shuffle" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1 (错排) </strong></span>计算 <img src="https://latex.codecogs.com/png.latex?n"> 元错排的数量．</p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>Solution</em>. </span>设 <img src="https://latex.codecogs.com/png.latex?A_i"> 表示第 <img src="https://latex.codecogs.com/png.latex?i"> 个位置配对正确的置换构成的集合．直接应用 Example&nbsp;2 立得</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bcard%7D%5Cleft(%20A%20-%20%5Cbigcup_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%20&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5Ek%20%5Csum_%7B%7CS%7C%20=%20k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20A%20%5Ccap%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20%5C%5C%0A&amp;=%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5Ek%20%5Cbinom%20n%20k%20(n-k)!%20%5C%5C%0A&amp;=%20n!%20%5Csum_%7Bk=0%7D%5E%7B%7CU%7C%7D%20(-1)%5Ek%20%5Cfrac%201%20%7Bk!%7D%20%5Csim%20%5Cfrac%7Bn!%7D%7Be%7D%0A%5Cend%7Baligned%7D%0A"></p>
</div>
<p>这说明随机取一排列，其错排的概率趋近于 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%20e">．</p>
<div id="exm-inex-ordinary-in" class="theorem example">
<p><span class="theorem-title"><strong>Example 3 (常见的“容斥原理”) </strong></span>满足至少 <img src="https://latex.codecogs.com/png.latex?1"> 个性质的元素数量可容斥地通过下式计算 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcup_%7Bi%20%5Cin%20U%7D%20A_i%20%5Cright)%0A&amp;=%20%5Csum_%7Bk=1%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7Bk-1%7D%20%5Csum_%7B%7CS%7C%20=%20k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20%5Cbigcap_%7Bi%20%5Cin%20S%7D%20A_i%20%5Cright)%20%5C%5C%0A&amp;=%20%5Csum_%7Bk=1%7D%5E%7B%7CU%7C%7D%20(-1)%5E%7Bk-1%7D%20%5Csum_%7Bi_1%20%3C%20%5Cdots%20%3C%20i_k%7D%20%5Coperatorname%7Bcard%7D%5Cleft(%20A_%7Bi_1%7D%20%5Ccap%20%5Cdots%20%5Ccap%20A_%7Bi_k%7D%20%5Cright)%0A%5Cend%7Baligned%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?A_i"> 代表满足第 <img src="https://latex.codecogs.com/png.latex?i"> 个性质的元素构成的集合，<img src="https://latex.codecogs.com/png.latex?i%20%5Cin%20U">．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>对 Example&nbsp;2 做简单移项即得．</p>
</div>
</section>
</section>
<section id="球盒问题" class="level3 page-columns page-full" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="球盒问题"><span class="header-section-number">3.2</span> 球盒问题</h3>
<p>组合数学的万恶之源．</p>
<div class="column-screen-inset">
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">ID</th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?n"> balls</th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?r"> boxes</th>
<th style="text-align: center;">allow empty?</th>
<th style="text-align: center;">recurrence / closed-form</th>
<th style="text-align: center;">generating functions</th>
<th style="text-align: center;">notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B1,1,0%7D"></td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">MAY empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?r%5En"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%5Cmathrm%7BEGF%7D_r(x)%20&amp;=%20(e%5E%7Bx%7D)%5Er%20=%20e%5E%7Brx%7D%20%5C%5C%20%5Cmathrm%7BOGF%7D_r(x)%20&amp;=%20%5Cfrac%7B1%7D%7B1-rx%7D%5Cend%7Baligned%7D"></td>
<td style="text-align: center;">number of <img src="https://latex.codecogs.com/png.latex?%5Bn%5D%20%5Cto%20%5Br%5D"> mappings</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B1,1,1%7D"></td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?r!%20%7Bn%20%5Cbrace%20r%7D%20=%20%5Csum_%7Bk=0%7D%5Er%20(-1)%5E%7Br-k%7D%20%5Cbinom%20r%20k%20k%5En"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%20%5Cmathrm%7BEGF%7D_r(x)&amp;=(e%5Ex%20-%201)%5Er%20%5C%5C%20%5Cmathrm%7BEGF%7D_n(x)%20&amp;=%20e%5E%7B-x%7D%20%5Csum_%7Br=0%7D%5E%7B+%5Cinfty%7D%20r%5En%20%5Cfrac%7Bx%5Er%7D%7Br!%7D%20%5Cend%7Baligned%7D"></td>
<td style="text-align: center;">number of <img src="https://latex.codecogs.com/png.latex?%5Bn%5D%20%5Cto%20%5Br%5D"> surjections</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B1,1/%5CSigma,1%7D"></td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">Labeled; <img src="https://latex.codecogs.com/png.latex?r">-disabled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bk=0%7D%5En%20k!%20%7Bn%20%5Cbrace%20k%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D_r(x)=%5Cfrac%7B1%7D%7B2-e%5Ex%7D%20=%20%5Cfrac%7B1%7D%7B1-(e%5Ex-1)%7D"></td>
<td style="text-align: center;">ordered Bell number; number of weak orderings / ordered set partitions on <img src="https://latex.codecogs.com/png.latex?%5Bn%5D"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B1,0,0%7D"></td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bk=0%7D%5Er%20%7Bn%20%5Cbrace%20k%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D_r(x)%20=%20%5Csum_%7Bk=0%7D%5Er%20%5Cfrac%20%7B(e%5Ex%20-%201)%5Ek%7D%7Bk!%7D"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B1,0,1%7D"></td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%20%7Bn%20%5Cbrace%20r%7D%20&amp;=%20%5Csum_%7Bk=0%7D%5Er%20%5Cfrac%7Bk%5En%7D%7Bk!%7D%20%5Ccdot%20%5Cfrac%7B(-1)%5E%7Br-k%7D%7D%7B(r-k)!%7D%20%5C%5C%20%7Bn+1%20%5Cbrace%20r%7D%20&amp;=%20r%20%7Bn%20%5Cbrace%20r%7D%20+%20%7Bn%20%5Cbrace%20r-1%7D%20%5Cend%7Baligned%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%20%5Cmathrm%7BEGF%7D_r(x)%20&amp;=%20%5Cfrac%7B(e%5Ex%20-%201)%5Er%7D%7Br!%7D%20%5C%5C%20%5Cmathrm%7BOGF%7D_n(x)%20&amp;=%20e%5E%7B-x%7D%20%5Csum_%7Br=0%7D%5E%7B+%5Cinfty%7D%20r%5En%20%5Cfrac%7Bx%5Er%7D%7Br!%7D%20%5Cend%7Baligned%7D"></td>
<td style="text-align: center;">Stirling number of the second kind</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B1,0/%5CSigma,1%7D"></td>
<td style="text-align: center;">labeled</td>
<td style="text-align: center;">UNLabeled; <img src="https://latex.codecogs.com/png.latex?r">-disabled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%20B(n)%20&amp;=%20%5Csum_%7Bk=0%7D%5En%20%7Bn%20%5Cbrace%20k%7D%20%5C%5C%20B(n+1)%20&amp;=%20%5Csum_%7Bk=0%7D%5En%20%5Cbinom%20n%20k%20B(k)%20%5Cend%7Baligned%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D(x)=e%5E%7Be%5Ex%20-%201%7D"></td>
<td style="text-align: center;">Bell number; number of equivialent relations / set partitions on <img src="https://latex.codecogs.com/png.latex?%5Bn%5D"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B0,1,0%7D"></td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">MAY empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbinom%7Bn+r-1%7D%7Br-1%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BOGF_r%7D(x)%20=%20%5Cleft(%5Cfrac%201%20%7B1-x%7D%5Cright)%5Er"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?r"> 元不定方程非负整数解个数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B0,1,1%7D"></td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">Labeled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbinom%7Bn-1%7D%7Br-1%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%20%5Cmathrm%7BOGF_r%7D(x)%20&amp;=%20%5Cleft(%5Cfrac%20x%20%7B1-x%7D%5Cright)%5Er%20%5C%5C%20&amp;=%20x%5Er%20%5Cleft(%5Cfrac%201%20%7B1-x%7D%5Cright)%5Er%20%5Cend%7Baligned%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?r"> 元 <img src="https://latex.codecogs.com/png.latex?n"> 次单项式构型数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B0,1/%5CSigma,1%7D"></td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">Labeled; <img src="https://latex.codecogs.com/png.latex?r">-disabled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?a(n)=%5Cbegin%7Bcases%7D1%20&amp;%20n=1%20%5C%5C%202%5E%7Bn-1%7D%20&amp;%20n%5Cgeq%202%20%5Cend%7Bcases%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BOGF%7D(x)%20=%201+%5Cfrac%7Bx%7D%7B1-2x%7D%20=%20%5Cfrac%7B1%7D%7B1-%5Cfrac%7Bx%7D%7B1-x%7D%7D"></td>
<td style="text-align: center;">考虑“是否向前拼接”的 <img src="https://latex.codecogs.com/png.latex?n-1"> 个选择</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B0,0,0%7D"></td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">MAY empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bk=0%7D%5Er%20p(n,k)"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?r"> 元 <img src="https://latex.codecogs.com/png.latex?n"> 次单项对称多项式（monomial symmetric polynomial）构型数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B0,0,1%7D"></td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?p(n,r)=p(n-1,r-1)+p(n-r,r)"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?r"> 部分拆数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%7B0,0/%5CSigma,1%7D"></td>
<td style="text-align: center;">UNLabeled</td>
<td style="text-align: center;">UNLabeled; <img src="https://latex.codecogs.com/png.latex?r">-disabled</td>
<td style="text-align: center;">NON empty</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%20p(n)%20&amp;=%20%5Csum_%7B%5Csubstack%7Bk%20%5Cin%20%5Cmathbb%20Z%7D%7D%20(-1)%5Ek%20p_%7Bn-k(3k-1)/2%7D%20%5C%5C%20&amp;=%20p_%7Bn-1%7D%20+%20p_%7Bn-2%7D%20-%20p_%7Bn-5%7D%20-%20p_%7Bn-7%7D%20+%20%5Cdots%20%5Cend%7Baligned%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%20%5Cmathrm%7BOGF%7D(x)&amp;=%5Cprod_%7Bk=1%7D%5E%7B+%5Cinfty%7D%20%5Cfrac%201%20%7B1-x%5Ek%7D%20%5C%5C%20&amp;=%20%5Cleft(%20%5Csum_%7Bk%20%5Cin%20%5Cmathbb%20Z%7D%20(-1)%5Ek%20x%5E%7Bk(3k-1)/2%7D%20%5Cright)%5E%7B-1%7D%20%5Cend%7Baligned%7D"></td>
<td style="text-align: center;">partition function（分拆数）; number of partitions of <img src="https://latex.codecogs.com/png.latex?n">; <img src="https://latex.codecogs.com/png.latex?n"> 元（含）以上 <img src="https://latex.codecogs.com/png.latex?n"> 次单项对称多项式构型数</td>
</tr>
</tbody>
</table>
</div>
<p>以后我们约定：</p>
<ul>
<li>形如 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BBB_%7B1,1,0%7D%7D"> 的记号表示代号 <img src="https://latex.codecogs.com/png.latex?1,1,0"> 对应球盒问题的方案数；</li>
<li>形如 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D_n%5E%7B1,1,0%7D(x)"> 代表代号 <img src="https://latex.codecogs.com/png.latex?1,1,0"> 对应 <img src="https://latex.codecogs.com/png.latex?n"> 球球盒问题的指数生成函数；</li>
<li>形如 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D_r%5E%7B1,1,0%7D(x)"> 代表代号 <img src="https://latex.codecogs.com/png.latex?1,1,0"> 对应 <img src="https://latex.codecogs.com/png.latex?r"> 球球盒问题的指数生成函数；</li>
<li>普通生成函数 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BOGF%7D_r%5E%7B1,1,0%7D(x)"> 同理．</li>
</ul>
<p>在不至混淆的情况下，也可省略下标或上标上的代号．</p>
<section id="通用性质" class="level4">
<h4 class="anchored" data-anchor-id="通用性质">通用性质</h4>
<div id="prp-bb-sigma" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 (非空盒数量不限制) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bgathered%7D%0A%5Cmathrm%7BBB%7D_%7B*,*/%5CSigma,1%7D(n)%20=%20%5Csum_%7Bk=0%7D%5En%20%5Cmathrm%7BBB%7D_%7B*,*,1%7D(n,k)%20%5C%5C%0A%5Cmathrm%7BEGF%7D%5E%7B*,*/%5CSigma,1%7D(x)%20=%20%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20%5Cmathrm%7BEGF%7D_%7Br=k%7D%5E%7B*,*,1%7D(x)%0A%5Cend%7Bgathered%7D%0A"></p>
</div>
<div id="prp-bb-x10-x11" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2 (有标号盒空置) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bgathered%7D%0A%5Cmathrm%7BBB%7D_%7B*,1,0%7D(n,r)%20=%20%5Csum_%7Bk=0%7D%5Er%20%5Cbinom%20r%20k%20%5Cmathrm%7BBB%7D_%7B*,1,1%7D(n,k)%20%5C%5C%0A%5Cmathrm%7BEGF%7D_n%5E%7B*,1,0%7D(x)%20=%20e%5Ex%20%5Cmathrm%7BEGF%7D_n%5E%7B*,1,1%7D(x)%0A%5Cend%7Bgathered%7D%0A"></p>
</div>
<p>对有标号盒的二项式反演．在 <img src="https://latex.codecogs.com/png.latex?1,1,0">-球盒问题中，上式体现为第二类 Stirling 数的通项公式；在 <img src="https://latex.codecogs.com/png.latex?0,1,0">-球盒问题中，上式体现为 Vandermonde 卷积．</p>
<div id="prp-bb-x00-x01" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3 (无标号盒空置) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bgathered%7D%0A%5Cmathrm%7BBB%7D_%7B*,0,0%7D(n,r)%20=%20%5Csum_%7Bk=0%7D%5Er%20%5Cmathrm%7BBB%7D_%7B*,0,1%7D(n,k)%20%5C%5C%0A%5Cmathrm%7BOGF%7D_n%5E%7B*,0,0%7D(x)%20=%20%5Cfrac%201%20%7B1-x%7D%20%5Cmathrm%7BOGF%7D_n%5E%7B*,0,1%7D(x)%0A%5Cend%7Bgathered%7D%0A"></p>
</div>
<p>对无标号盒，直接求和即可．</p>
</section>
</section>
<section id="第二类-stirling-数" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="第二类-stirling-数"><span class="header-section-number">3.3</span> 第二类 Stirling 数</h3>
<p>第二类 Stirling 数的组合定义即 <img src="https://latex.codecogs.com/png.latex?1,0,1">-球盒问题的方案数 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BBB%7D_%7B1,0,1%7D(n,r)%20=%20%7Bn%20%5Cbrace%20r%7D">，亦作将 <img src="https://latex.codecogs.com/png.latex?n"> 个元素划分入 <img src="https://latex.codecogs.com/png.latex?r"> 个集合的方案数．</p>
<section id="递推" class="level4">
<h4 class="anchored" data-anchor-id="递推">递推</h4>
<p>由组合意义，考虑在已有 <img src="https://latex.codecogs.com/png.latex?n"> 个球时加入新球，此时面临将其放入原有的 <img src="https://latex.codecogs.com/png.latex?r"> 个集合或新开辟一个集合的两种选择，由此得递推式 <img src="https://latex.codecogs.com/png.latex?%0A%7Bn+1%20%5Cbrace%20r%7D%20=%20r%20%7Bn%20%5Cbrace%20r%7D%20+%20%7Bn%20%5Cbrace%20r-1%7D%0A"> 边界在 <img src="https://latex.codecogs.com/png.latex?%0A%7Bn%20%5Cbrace%200%7D%20=%20%5Bn%20=%200%5D,%5Cquad%20%7Bn%20%5Cbrace%20n%7D%20=%201%0A"></p>
</section>
<section id="第二类-striling-数同行计算mathrmogf_n101x-或-mathrmegf_n111x" class="level4">
<h4 class="anchored" data-anchor-id="第二类-striling-数同行计算mathrmogf_n101x-或-mathrmegf_n111x">第二类 Striling 数同行计算：<img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BOGF%7D_n%5E%7B1,0,1%7D(x)"> 或 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D_n%5E%7B1,1,1%7D(x)"></h4>
<p>来考虑用两种方法得到 <img src="https://latex.codecogs.com/png.latex?1,1,1">-球盒问题的方案数．</p>
<p>我们的第一种方法注意到，上述问题的方案数恰好是 <img src="https://latex.codecogs.com/png.latex?1,0,1">-球盒问题方案数 <img src="https://latex.codecogs.com/png.latex?r!"> 倍——这是对后者的盒进行标号的结果．我们得到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathrm%7BBB%7D_%7B1,1,1%7D(n,r)%20=%20r!%20%5Cmathrm%7BBB%7D_%7B1,0,1%7D(n,r)%20=%20r!%20%7Bn%20%5Cbrace%20r%7D%0A"></p>
<p>第二种方法考虑用容斥非空盒的方法与 <img src="https://latex.codecogs.com/png.latex?1,1,0">-球盒问题 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BBB%7D_%7B1,1,0%7D(n,r)%20=%20r%5En"> 建立联系．我们有 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathrm%7BBB%7D_%7B1,1,0%7D(n,r)%20=%20%5Csum_%7Bk=0%7D%5Er%20%5Cbinom%20r%20k%20%5Cmathrm%7BBB%7D_%7B1,1,1%7D(n,k)%0A"> 即 <img src="https://latex.codecogs.com/png.latex?%0Ar%5En%20=%20%5Csum_%7Bk=0%7D%5Er%20%5Cbinom%20r%20k%20k!%20%7Bn%20%5Cbrace%20k%7D%0A"> 二项式反演即得 <img src="https://latex.codecogs.com/png.latex?%0Ar!%20%7Bn%20%5Cbrace%20r%7D%20=%20%5Csum_%7Bk=0%7D%5Er%20(-1)%5E%7Br-k%7D%20%5Cbinom%20r%20k%20k%5En%0A"> 即 <img src="https://latex.codecogs.com/png.latex?%0A%7Bn%20%5Cbrace%20r%7D%20=%20%5Csum_%7Bk=0%7D%5Er%20%5Cfrac%7B(-1)%5E%7Br-k%7D%20k%5En%7D%7Bk!%20(r-k)!%7D%20=%20%5Csum_%7Bk=0%7D%5Er%20%5Cfrac%7Bk%5En%7D%7Bk!%7D%20%5Ccdot%20%5Cfrac%7B(-1)%5E%7Br-k%7D%7D%7B(r-k)!%7D%0A"> 这正是第二类 Stirling 数的通项公式．注意到其具有卷积的形式，由此可快速计算出同一行的第二类 Stirling 数．事实上，二项式反演的生成函数形式已向我们道尽一切 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathrm%7BOGF%7D_n%5E%7B1,0,1%7D(x)%20=%20%5Cmathrm%7BEGF%7D_n%5E%7B1,1,1%7D(x)%20=%20e%5E%7B-x%7D%20%5Cmathrm%7BEGF%7D_n%5E%7B1,1,0%7D(x)%20=%20e%5E%7B-x%7D%20%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20k%5En%20%5Cfrac%7Bx%5Ek%7D%7Bk!%7D%0A"></p>
</section>
<section id="第二类-striling-数同列计算mathrmegf_r101xmathrmegf_r110x-与-mathrmegf10sigma1x" class="level4">
<h4 class="anchored" data-anchor-id="第二类-striling-数同列计算mathrmegf_r101xmathrmegf_r110x-与-mathrmegf10sigma1x">第二类 Striling 数同列计算：<img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D_r%5E%7B1,0,1%7D(x)">，<img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D_r%5E%7B1,1,0%7D(x)"> 与 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BEGF%7D%5E%7B1,0/%5CSigma,1%7D(x)"></h4>
<p>为快速计算同一列的第二类 Stirling 数，考虑用生成函数的思路构造 <img src="https://latex.codecogs.com/png.latex?1,1,0">-球盒问题和 <img src="https://latex.codecogs.com/png.latex?1,0,1">-球盒问题的方案数．前者将大小为 <img src="https://latex.codecogs.com/png.latex?n"> 的有标号集合划分为 <img src="https://latex.codecogs.com/png.latex?r"> 个有标号等价类，这相当于有序拼接 <img src="https://latex.codecogs.com/png.latex?r"> 个非空有标号集合；后者则是前者除掉 <img src="https://latex.codecogs.com/png.latex?r!"> 消序的版本．写成生成函数即 <span id="eq-egf-110-101"><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathrm%7BEGF%7D_r%5E%7B1,1,0%7D(x)%20&amp;=%20(e%5Ex%20-%201)%5Er%20%5C%5C%0A%5Cmathrm%7BEGF%7D_r%5E%7B1,0,1%7D(x)%20&amp;=%20%5Cfrac%7B(e%5Ex%20-%201)%5Er%7D%7Br!%7D%0A%5Cend%7Baligned%7D%0A%5Ctag%7B1%7D"></span></p>
</section>
<section id="bell-数" class="level4">
<h4 class="anchored" data-anchor-id="bell-数">Bell 数</h4>
<p>Bell 数 <img src="https://latex.codecogs.com/png.latex?B(n)"> 的组合定义即 <img src="https://latex.codecogs.com/png.latex?1,0/%5CSigma,1">-球盒问题的方案数 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BBB%7D_%7B1,0/%5CSigma,1%7D">，亦可描述为 <img src="https://latex.codecogs.com/png.latex?n"> 元集合上等价关系（划分）的数量．</p>
<p>注意到 <img src="https://latex.codecogs.com/png.latex?1,0,1">-球盒问题和 <img src="https://latex.codecogs.com/png.latex?1,0/%5CSigma,1">-球盒问题的关系 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathrm%7BBB%7D_%7B1,0/%5CSigma,1%7D(n)%20=%20%5Csum_%7Br=0%7D%5E%7Bn%7D%20%5Cmathrm%7BBB%7D_%7B1,0,1%7D(n,r)%20=%20%5Csum_%7Br=0%7D%5E%7B+%5Cinfty%7D%20%5Cmathrm%7BBB%7D_%7B1,0,1%7D(n,r)%0A"> 我们首先有 <img src="https://latex.codecogs.com/png.latex?%0AB(n)%20=%20%5Csum_%7Br=0%7D%5En%20%7Bn%20%5Cbrace%20r%7D%0A"> 其次，根据 Equation&nbsp;1 写出此关系的 EGF 形式就有 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathrm%7BEGF%7D%5E%7B1,0/%5CSigma,1%7D(x)%20=%20%5Csum_%7Br=0%7D%5E%7B+%5Cinfty%7D%20%5Cmathrm%7BEGF%7D_r%5E%7B1,0,1%7D(x)%20=%20%5Csum_%7Br=0%7D%5E%7B+%5Cinfty%7D%20%5Cfrac%7B(e%5Ex%20-%201)%5Er%7D%7Br!%7D%20=%20e%5E%7Be%5Ex%20-%201%7D%0A"> 我们得到 Bell 数的可用于快速计算的 EGF．</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>有标号集合的无序划分是指数型生成函数的一类重要应用．例如，有标号连通图计数可视为对有标号一般图的无序划分，故有标号连通图的 EGF <img src="https://latex.codecogs.com/png.latex?G(x)"> 和有标号一般图的 EGF <img src="https://latex.codecogs.com/png.latex?F(x)"> 间有着 <img src="https://latex.codecogs.com/png.latex?e%5E%7BG(x)%7D%20=%20F(x)"> 的关系．</p>
</div>
<p>Bell 数还有递推形式 <img src="https://latex.codecogs.com/png.latex?%0AB(n+1)%20=%20%5Csum_%7Bk=0%7D%5En%20%5Cbinom%20n%20k%20B(k)%0A"> 边界 <img src="https://latex.codecogs.com/png.latex?B(0)=1">．组合的解释是，枚举第 <img src="https://latex.codecogs.com/png.latex?n+1"> 个元素被放入的集合的大小，再对除该集合之外的元素进行划分．从指数生成函数的角度来看，设 <img src="https://latex.codecogs.com/png.latex?B(n)"> 的 EGF 为 <img src="https://latex.codecogs.com/png.latex?F(x)">，由 EGF 的移位性质和二项式反演的 EGF 形式，上式等价于 <img src="https://latex.codecogs.com/png.latex?F'(x)%20=%20e%5Ex%20F(x)">，解此微分方程也能得到 Bell 数的生成函数．</p>
</section>
<section id="第一类-stirling-数stirling-数与阶乘幂todo" class="level4">
<h4 class="anchored" data-anchor-id="第一类-stirling-数stirling-数与阶乘幂todo">第一类 Stirling 数、Stirling 数与阶乘幂【TODO】</h4>
<p>更多参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Stirling_number">Stirling number - Wikipedia</a></li>
<li><a href="https://oi-wiki.org/math/combinatorics/stirling/">斯特林数 - OI Wiki</a></li>
</ul>
</section>
</section>
<section id="分拆数todo" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="分拆数todo"><span class="header-section-number">3.4</span> 分拆数【TODO】</h3>
<p>关于 <img src="https://latex.codecogs.com/png.latex?k"> 部分拆数，</p>
<blockquote class="blockquote">
<p>By taking conjugates, the number <img src="https://latex.codecogs.com/png.latex?p_k(n)"> of partitions of <img src="https://latex.codecogs.com/png.latex?n"> into exactly <img src="https://latex.codecogs.com/png.latex?k"> parts is equal to the number of partitions of <img src="https://latex.codecogs.com/png.latex?n"> in which the largest part has size <img src="https://latex.codecogs.com/png.latex?k">.</p>
</blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (number theory) - Wikipedia</a></li>
<li><a href="https://oi-wiki.org/math/combinatorics/partition/">分拆数 - OI Wiki</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/530925142">组合数学（2）分拆数 - 知乎</a></li>
</ul>
</section>
<section id="背包计数" class="level3" data-number="3.5">
<h3 data-number="3.5" class="anchored" data-anchor-id="背包计数"><span class="header-section-number">3.5</span> 背包计数</h3>
<p>通式： <img src="https://latex.codecogs.com/png.latex?%0A%5Cprod_%7Bi=1%7D%5En%20(1+%20s_i%20x%5E%7Bv_i%7D)%5E%7Bm_i%7D%20=%20%5Cexp%20%5Csum_%7Bi=1%7D%5En%20m_i%20%5Cln%20(1%20+%20s_i%20x%5E%7Bv_i%7D)%20=%20%5Cexp%20%5Csum_%7Bi=1%7D%5En%20m_i%20%5Csum_%7Bk=1%7D%5E%7B+%5Cinfty%7D%20(-1)%5E%7Bk-1%7D%20%5Cfrac%20%7Bs_i%5Ek%7D%7Bk%7D%20x%5E%7Bk%20v_i%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?v_i"> 互不相同（相同者体现在 <img src="https://latex.codecogs.com/png.latex?m_i"> 上）．后者可以埃筛调和级数计算贡献 + 多项式 <img src="https://latex.codecogs.com/png.latex?%5Cexp"> 地在 <img src="https://latex.codecogs.com/png.latex?O(t%20%5Clog%20t)">（这里的 <img src="https://latex.codecogs.com/png.latex?t"> 指我们所关心的体积上限）内快速计算．</p>
<p>下面问题的 OGF 都可化归至通式，从而 <img src="https://latex.codecogs.com/png.latex?O(t%20%5Clog%20t)"> 地得到计算．</p>
<p>设有 <img src="https://latex.codecogs.com/png.latex?n"> 种可区分的物品，体积分别为 <img src="https://latex.codecogs.com/png.latex?v_i">．当每种物品只有一件时，方案数 OGF 为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cprod_%7Bi=1%7D%5En%20(1+%20x%5E%7Bv_i%7D)%0A"> 当每种物品有无限件时，方案数 OGF 为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cprod_%7Bi=1%7D%5En%20(1+%20x%5E%7Bv_i%7D%20+%20x%5E%7B2%20v_i%7D%20+%20%5Cdots)%20=%20%5Cprod_%7Bi=1%7D%5En%20(1%20-%20x%5E%7Bv_i%7D)%5E%7B-1%7D%0A"> 当每种物品分别有 <img src="https://latex.codecogs.com/png.latex?c_i"> 件时，方案数 OGF 为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cprod_%7Bi=1%7D%5En%20(1+%20x%5E%7Bv_i%7D%20+%20x%5E%7B2%20v_i%7D%20+%20%5Cdots%20+%20x%5E%7Bc_i%20v_i%7D)%20=%20%5Cprod_%7Bi=1%7D%5En%20%5Cfrac%7B1%20-%20x%5E%7B(c_i+1)%20v_i%7D%7D%7B1%20-%20x%5E%7Bv_i%7D%7D%20=%20%5Cprod_%7Bi=1%7D%5En%20(1%20-%20x%5E%7B(c_i+1)%20v_i%7D)%20%5Cprod_%7Bi=1%7D%5En%20(1%20-%20x%5E%7Bv_i%7D)%5E%7B-1%7D%0A"></p>
<p>ex：普通的最优化背包也有卷积视角的理解，见 <a href="https://codeforces.com/blog/entry/98663">Knapsack, Subset Sum and the (max,+) Convolution - Codeforces</a>．</p>
</section>
<section id="各种图计数" class="level3" data-number="3.6">
<h3 data-number="3.6" class="anchored" data-anchor-id="各种图计数"><span class="header-section-number">3.6</span> 各种图计数</h3>
<section id="有无标号有无根树计数todo" class="level4">
<h4 class="anchored" data-anchor-id="有无标号有无根树计数todo">有（无）标号有（无）根树计数【TODO】</h4>
</section>
<section id="有标号-dag-计数" class="level4">
<h4 class="anchored" data-anchor-id="有标号-dag-计数">有标号 DAG 计数</h4>
<p><img src="https://latex.codecogs.com/png.latex?%0Af_n=%5Csum_%7Bi=1%7D%5En(-1)%5E%7Bi+1%7D%5Cbinom%7Bn%7D%7Bi%7D2%5E%7Bi(n-i)%7Df_%7Bn-i%7D%0A"> 思路是对 DAG 的入度为零的点做容斥．进一步推导可拆出卷积形式，再用类似分治 FFT 的生成函数方法可得封闭形式．</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph#Combinatorial_enumeration">Wikipedia</a></li>
<li><a href="https://oeis.org/A003024">OEIS</a></li>
<li><a href="https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/#dag-%E8%AE%A1%E6%95%B0">OI-Wiki</a></li>
<li><a href="https://www.cnblogs.com/cjyyb/p/10134575.html">cjyyb 题解</a></li>
</ul>
</section>
<section id="有标号偏序图计数" class="level4">
<h4 class="anchored" data-anchor-id="有标号偏序图计数">有标号偏序图计数</h4>
<p>问得好，但这是个著名的 open problem．各种类型的偏序图计数参考 <a href="https://en.wikipedia.org/wiki/Partially_ordered_set#Number_of_partial_orders">Partially ordered set - Wikipedia # Number of partial orders</a>．</p>
<ul>
<li><a href="https://math.stackexchange.com/questions/2677986/how-many-partial-orders-can-be-defined-on-varnothing-and-a-finite-set">Stack Exchange</a></li>
<li><a href="https://oeis.org/A001035">OEIS</a></li>
<li><a href="https://doi.org/10.1007/BF00383446">Erné, M., Stege, K. Counting finite posets and topologies. Order 8, 247–265 (1991)</a>（内有研究历史综述）</li>
</ul>
</section>
<section id="有标号连通图计数" class="level4">
<h4 class="anchored" data-anchor-id="有标号连通图计数">有标号连通图计数</h4>
<p>标准的有标号无序划分．EGF 是有标号一般图计数 EGF 的 <img src="https://latex.codecogs.com/png.latex?%5Cln">．</p>
</section>
<section id="竞赛图" class="level4">
<h4 class="anchored" data-anchor-id="竞赛图">竞赛图</h4>
<p>强连通的竞赛图一定存在 Hamilton 回路（归纳证明）；无环的竞赛图是全序图．两者结合可推出竞赛图一定存在 Hamilton 路径．同时，强连通竞赛图中存在所有大小的环路．</p>
</section>
<section id="有标号划分为-k-个全序图" class="level4">
<h4 class="anchored" data-anchor-id="有标号划分为-k-个全序图">有标号划分为 <img src="https://latex.codecogs.com/png.latex?k"> 个全序图</h4>
<p>Lah 数 <img src="https://latex.codecogs.com/png.latex?%0AL(n,k)%20=%20%5Cfrac%7Bn!%7D%7Bk!%7D%20%5Cbinom%7Bn-1%7D%7Bk-1%7D%0A"> 思路是先 <img src="https://latex.codecogs.com/png.latex?n!"> 排个大序，再无标号球入非空有标号桶，再除 <img src="https://latex.codecogs.com/png.latex?k!"> 给桶消序．</p>
<p>生成函数的思路是，考虑非空全序计数的 EGF 为 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%20%7B1-x%7D%20-%201%20=%20%5Cfrac%20x%20%7B1-x%7D">，<img src="https://latex.codecogs.com/png.latex?k"> 次有序拼接再消序即得 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum%20_%7Bn%5Cgeq%20k%7DL(n,k)%7B%5Cfrac%20%7Bx%5E%7Bn%7D%7D%7Bn!%7D%7D=%7B%5Cfrac%20%7B1%7D%7Bk!%7D%7D%5Cleft(%7B%5Cfrac%20%7Bx%7D%7B1-x%7D%7D%5Cright)%5E%7Bk%7D%0A"></p>
<p>更多信息参考 Wikipedia．</p>
</section>
<section id="有根树拓扑序计数" class="level4">
<h4 class="anchored" data-anchor-id="有根树拓扑序计数">有根树拓扑序计数</h4>
<p>对于外向树，<img src="https://latex.codecogs.com/png.latex?%5Cfrac%7Bn!%7D%7B%5Cprod_%7Bu%20%5Cin%20V%7D%20%5Coperatorname%7Bsize%7D(u)%7D">，其中 <img src="https://latex.codecogs.com/png.latex?V"> 是所有节点的集合，<img src="https://latex.codecogs.com/png.latex?n"> 是树大小，<img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bsize%7D(u)"> 是以 <img src="https://latex.codecogs.com/png.latex?u"> 为根的子树大小．</p>
<p>树形 DP 风格的归纳证明是可以的．下面的链接中提供了一个有趣的组合理解，其思路是从全序出发，逐步按照拓扑序的要求对每个节点下的子树消序．</p>
<p>题目常见要求对每个节点作为根节点求出方案数，换根 DP 即可．</p>
<p>注意到每个合法的外向树拓扑序 reverse 后立刻与内向树拓扑序形成一一对应，故内向树拓扑序计数与外向树相同．</p>
<ul>
<li><a href="https://codeforces.com/blog/entry/75627">[Insight] Number of Topological Orderings of a Directed Tree - Codeforces</a></li>
</ul>
</section>
<section id="dag-拓扑序计数" class="level4">
<h4 class="anchored" data-anchor-id="dag-拓扑序计数">DAG 拓扑序计数</h4>
<p>对一般的 DAG 上的拓扑序计数，其本质上是偏序上线性扩张的计数问题，这被证明是 #P-complete 的问题（总之就是很困难）．</p>
<ul>
<li><a href="https://math.stackexchange.com/questions/814177/how-many-topological-orderings-exist-for-a-graph">How many topological orderings exist for a graph? - Mathematics Stack Exchange</a></li>
<li><a href="https://en.wikipedia.org/wiki/Topological_sorting#Relation_to_partial_orders">Topological sorting - Wikipedia # Relation to partial orders</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linear_extension">Linear extension - Wikipedia</a></li>
</ul>
</section>
<section id="无向图的色多项式chromatic-polynomial和无环定向acyclic-orientations" class="level4">
<h4 class="anchored" data-anchor-id="无向图的色多项式chromatic-polynomial和无环定向acyclic-orientations">无向图的色多项式（chromatic polynomial）和无环定向（acyclic orientations）</h4>
<p>色多项式是对图的 <img src="https://latex.codecogs.com/png.latex?k">-colorings 的数量在 <img src="https://latex.codecogs.com/png.latex?k=0,1,%5Cdots,n"> 进行 Lagrange 插值后得到的多项式．<img src="https://latex.codecogs.com/png.latex?k%3En"> 的 <img src="https://latex.codecogs.com/png.latex?k">-colorings 的数量也可通过在色多项式的 <img src="https://latex.codecogs.com/png.latex?x=k"> 处求值得到．这一证明主要依赖所谓的 deletion–contraction 递推关系式．</p>
<p>对一般的图而言，色多项式的大部分系数和求值问题都是 “NP” 相关的，但在一些特殊的图上有好的形式：</p>
<ul>
<li>完全图 <img src="https://latex.codecogs.com/png.latex?K_n">：<img src="https://latex.codecogs.com/png.latex?x%5E%7B%5Cunderline%7Bn%7D%7D">（下降阶乘幂）</li>
<li>无边图 <img src="https://latex.codecogs.com/png.latex?%5Coverline%20K_n">：<img src="https://latex.codecogs.com/png.latex?x%5En"></li>
<li>链 / 树：<img src="https://latex.codecogs.com/png.latex?P_n">：<img src="https://latex.codecogs.com/png.latex?x(x-1)%5E%7Bn-1%7D"></li>
<li>环：<img src="https://latex.codecogs.com/png.latex?(x-1)%5En%20+%20(-1)%5En%20(x-1)"></li>
</ul>
<p>多个连通分量拼接时，色多项式满足乘法性．</p>
<p>关于图的无环定向的方案数，Richard Stanley 在一篇 1973 年的论文中证明其恰为图的色多项式在 <img src="https://latex.codecogs.com/png.latex?-1"> 处的取值．</p>
<ul>
<li><a href="https://mathworld.wolfram.com/ChromaticPolynomial.html">Chromatic Polynomial - from Wolfram MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Chromatic_polynomial">Chromatic polynomial - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Orientation_(graph_theory)">Orientation (graph theory) - Wikipedia</a></li>
<li>Stanley, R. P. “Acyclic Orientations of Graphs.” Disc. Math. 5, 171-178, 1973.</li>
</ul>
</section>
</section>
<section id="矩阵树定理" class="level3" data-number="3.7">
<h3 data-number="3.7" class="anchored" data-anchor-id="矩阵树定理"><span class="header-section-number">3.7</span> 矩阵树定理</h3>
<section id="无向图的情形" class="level4">
<h4 class="anchored" data-anchor-id="无向图的情形">无向图的情形</h4>
<p>对无向图，度数矩阵 <img src="https://latex.codecogs.com/png.latex?D%20=%20%5Coperatorname%7Bdiag%7D%20%5C%7B%20%5Coperatorname%7Bdeg%7D(i)%20%5C%7D">，邻接矩阵 <img src="https://latex.codecogs.com/png.latex?A"> 定义为 <img src="https://latex.codecogs.com/png.latex?%0AA_%7Bi,j%7D%20=%20%5Cbegin%7Bcases%7D%0A0%20&amp;%20i=j%20%5C%5C%0Ae(i,j)%20&amp;%20i%20%5Cneq%20j%0A%5Cend%7Bcases%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?e(i,j)"> 表示点 <img src="https://latex.codecogs.com/png.latex?i"> 到点 <img src="https://latex.codecogs.com/png.latex?j"> 的边的数量（对无向图，<img src="https://latex.codecogs.com/png.latex?e(i,j)%20=%20e(j,i)">）．</p>
<p>定义 Laplace 矩阵（Kirchhoff 矩阵）<img src="https://latex.codecogs.com/png.latex?L=D-A">．</p>
<p>Laplace 矩阵有性质 <img src="https://latex.codecogs.com/png.latex?L=%20B%20B%5ET">，其中关联矩阵 <img src="https://latex.codecogs.com/png.latex?B"> 按如下方式定义 <img src="https://latex.codecogs.com/png.latex?%0AB_%7Bi,j%7D%20=%20%5Cbegin%7Bcases%7D%0A1%20&amp;%20%5Ctext%7Bnode%20$i$%20is%20the%20ID-smaller%20endpoint%20of%20edge%20$j$%7D%20%5C%5C%0A-1%20&amp;%20%5Ctext%7Bnode%20$i$%20is%20the%20ID-larger%20endpoint%20of%20edge%20$j$%7D%20%5C%5C%0A0%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Bcases%7D%0A"></p>
<p>这里 <img src="https://latex.codecogs.com/png.latex?1"> 与 <img src="https://latex.codecogs.com/png.latex?-1"> 的引入完成了一种对边的“手动定向”，其用途将在后文介绍．</p>
<div id="thm-mattree-nondirected" class="theorem">
<p><span class="theorem-title"><strong>Theorem 12 (矩阵树定理，无向图) </strong></span><img src="https://latex.codecogs.com/png.latex?n"> 点无向图的生成树的个数与该图的 Laplace 矩阵 <img src="https://latex.codecogs.com/png.latex?L"> 的任意主子式的值相等．其也与 <img src="https://latex.codecogs.com/png.latex?L"> 所有 <img src="https://latex.codecogs.com/png.latex?n-1"> 个非零特征值乘积的 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%20n"> 倍相等．</p>
</div>
<p>Laplace 矩阵同行的代数余子式均相等（这性质由行和为 <img src="https://latex.codecogs.com/png.latex?0"> 得到），因此去掉任意一行一列均可得到正确的无向图生成树计数．此外，由于 <img src="https://latex.codecogs.com/png.latex?L%20=%20B%20B%5ET"> 至少半正定，<img src="https://latex.codecogs.com/png.latex?L"> 的所有特征值非负．</p>
<p>证明的要点在于对 <img src="https://latex.codecogs.com/png.latex?L%20=%20B%20B%5ET"> 的某个主子式（一般选择去掉第一行第一列）应用 Cauchy-Binet 公式，随后说明行列式的组合意义中，环的情况一定相互抵消．关于特征值的结论可从特征多项式、各 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶主子式与韦达定理的关系中得到（依此方法能进一步得到有关 <img src="https://latex.codecogs.com/png.latex?k"> - 生成森林的一些结论）．</p>
<p>事实上，去掉第 <img src="https://latex.codecogs.com/png.latex?i"> 行第 <img src="https://latex.codecogs.com/png.latex?i"> 列，即是统计以 <img src="https://latex.codecogs.com/png.latex?i"> 为根的根向生成树的数量．先前定义关联矩阵 <img src="https://latex.codecogs.com/png.latex?B"> 时“手动定向”，是为了使换向过程中环的情况相互抵消，只留下树的唯一一种情况．当然，因为是无向图，这里树的朝向和根的具体位置并不重要．</p>
</section>
<section id="有向图的情形" class="level4">
<h4 class="anchored" data-anchor-id="有向图的情形">有向图的情形</h4>
<p>对有向图，我们明确统计的对象为根向（或叶向）生成树的数量．根向树形图与出度 Laplace 矩阵相关，<img src="https://latex.codecogs.com/png.latex?L%5E%7Bout%7D%20=%20D%5E%7Bout%7D%20-%20A">，其中 <img src="https://latex.codecogs.com/png.latex?D%5E%7Bout%7D"> 是出度矩阵．</p>
<p>为体现有向图的要求，出度 Laplace 矩阵对应的关联矩阵需要一些修改．令矩阵 <img src="https://latex.codecogs.com/png.latex?B"> 满足 <img src="https://latex.codecogs.com/png.latex?%0AB_%7Bi,j%7D%20=%20%5Cbegin%7Bcases%7D%0A1%20&amp;%20%5Ctext%7Bnode%20$i$%20is%20the%20head%20of%20edge%20$j$%7D%20%5C%5C%0A0%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Bcases%7D%0A"> 矩阵 <img src="https://latex.codecogs.com/png.latex?C"> 满足 <img src="https://latex.codecogs.com/png.latex?%0AC_%7Bi,j%7D%20=%20%5Cbegin%7Bcases%7D%0A1%20&amp;%20%5Ctext%7Bnode%20$i$%20is%20the%20head%20of%20edge%20$j$%7D%20%5C%5C%0A-1%20&amp;%20%5Ctext%7Bnode%20$i$%20is%20the%20tail%20of%20edge%20$j$%7D%20%5C%5C%0A0%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Bcases%7D%0A"> 则出度 Laplace 矩阵满足性质 <img src="https://latex.codecogs.com/png.latex?L%5E%7Bout%7D%20=%20B%20C%5ET">．我们构造的矩阵 <img src="https://latex.codecogs.com/png.latex?B"> 体现了对出边方向的要求，在此基础上矩阵 <img src="https://latex.codecogs.com/png.latex?C"> 进一步完成了“手动定向”的工作．</p>
<div id="thm-mattree-rootwise" class="theorem">
<p><span class="theorem-title"><strong>Theorem 13 (矩阵树定理，根向树形图) </strong></span><img src="https://latex.codecogs.com/png.latex?n"> 点有向图以 <img src="https://latex.codecogs.com/png.latex?i"> 为根的生成根向树形图的数量与该图出度 Laplace 矩阵 <img src="https://latex.codecogs.com/png.latex?L%5E%7Bout%7D"> 去掉第 <img src="https://latex.codecogs.com/png.latex?i"> 行第 <img src="https://latex.codecogs.com/png.latex?i"> 列的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 <img src="https://latex.codecogs.com/png.latex?L%5E%7Bout%7D"> 的所有 <img src="https://latex.codecogs.com/png.latex?n-1"> 个非零特征值的乘积相等．</p>
</div>
<p>由于 <img src="https://latex.codecogs.com/png.latex?L%5E%7Bout%7D"> 的行和仍为 <img src="https://latex.codecogs.com/png.latex?0">，其同行代数余子式仍然相等．</p>
<p>关于叶向树形图，我们有类似的结论：</p>
<div id="thm-mattree-leafwise" class="theorem">
<p><span class="theorem-title"><strong>Theorem 14 (矩阵树定理，叶向树形图) </strong></span><img src="https://latex.codecogs.com/png.latex?n"> 点有向图以 <img src="https://latex.codecogs.com/png.latex?i"> 为根的生成叶向树形图的数量与该图入度 Laplace 矩阵 <img src="https://latex.codecogs.com/png.latex?L%5E%7Bin%7D"> 去掉第 <img src="https://latex.codecogs.com/png.latex?i"> 行第 <img src="https://latex.codecogs.com/png.latex?i"> 列的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 <img src="https://latex.codecogs.com/png.latex?L%5E%7Bin%7D"> 的所有 <img src="https://latex.codecogs.com/png.latex?n-1"> 个非零特征值的乘积相等．</p>
</div>
<p>由于 <img src="https://latex.codecogs.com/png.latex?L%5E%7Bin%7D"> 的列和（而非行和）为 <img src="https://latex.codecogs.com/png.latex?0">，其同列（而非同行）代数余子式均相等．</p>
<p>更多内容，参考</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Laplacian_matrix">Laplacian matrix - Wikipedia</a></li>
<li><a href="https://oi-wiki.org/graph/matrix-tree/">矩阵树定理 - OI Wiki</a></li>
<li><a href="https://en.wikipedia.org/wiki/Kirchhoff's_theorem">Kirchhoff’s theorem - Wikipedia</a></li>
</ul>
</section>
</section>
<section id="polya-计数" class="level3" data-number="3.8">
<h3 data-number="3.8" class="anchored" data-anchor-id="polya-计数"><span class="header-section-number">3.8</span> Polya 计数</h3>
<div id="thm-burnside" class="theorem">
<p><span class="theorem-title"><strong>Theorem 15 (Burnside) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%E7%AD%89%E4%BB%B7%E7%B1%BB%E8%AE%A1%E6%95%B0%20&amp;=%20%5Cfrac%7B1%7D%7B%7CG%7C%7D%5Csum_%7Bf%20%5Cin%20G%7D%20%7CC(f)%7C%0A%5Cend%7Baligned%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?G"> 是等价操作群，<img src="https://latex.codecogs.com/png.latex?C(f)"> 是操作 <img src="https://latex.codecogs.com/png.latex?f"> 下的不动点集合．</p>
</div>
</section>
<section id="杂数选提" class="level3" data-number="3.9">
<h3 data-number="3.9" class="anchored" data-anchor-id="杂数选提"><span class="header-section-number">3.9</span> 杂数选提</h3>
<section id="catalan-数" class="level4">
<h4 class="anchored" data-anchor-id="catalan-数">Catalan 数</h4>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb5-1">1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, ...</span></code></pre></div>
<p><img src="https://latex.codecogs.com/png.latex?%0AC_n%20=%20%5Cbinom%7B2n%7D%7Bn%7D%20-%20%5Cbinom%7B2n%7D%7Bn+1%7D%20=%20%5Cfrac%201%20%7Bn+1%7D%20%5Cbinom%7B2n%7D%7Bn%7D%20=%20%5Cprod_%7Bk=2%7D%5En%20%5Cfrac%7Bn+k%7D%7Bk%7D%0A"></p>
<p>Segner’s recurrence relation: <img src="https://latex.codecogs.com/png.latex?%0AC_0%20=%201;%5Cquad%20C_%7Bn+1%7D%20=%20%5Csum_%7Bi=0%7D%5En%20C_i%20C_%7Bn-i%7D%0A"></p>
<p>OGF: <img src="https://latex.codecogs.com/png.latex?%0AA(z)%20=%201%20+%20z%20A%5E2(z)%20%5Cimplies%20A(z)%20=%20%5Cfrac%7B1-%5Csqrt%7B1-4z%7D%7D%7B2z%7D%0A"></p>
<p>注意下面组合意义间的前后逻辑顺序．</p>
<ul>
<li><p>number of full binary tree with <img src="https://latex.codecogs.com/png.latex?n"> interior nodes / <img src="https://latex.codecogs.com/png.latex?n+1"> leaves / <img src="https://latex.codecogs.com/png.latex?2n+1"> nodes</p>
<p>在数内点意义下可以导出 Catalan 数的生成函数．</p></li>
<li><p>number of ways of associating <img src="https://latex.codecogs.com/png.latex?n"> binary operators / parenthesizing <img src="https://latex.codecogs.com/png.latex?n+1"> factors completely</p></li>
<li><p>number of proper parenthesis sequences with <img src="https://latex.codecogs.com/png.latex?n"> pairs of parentheses</p>
<p>【TODO】暂时不知道怎么从上面推过来的．另一种理解是长度为 <img src="https://latex.codecogs.com/png.latex?n"> 的出栈序列的数量．</p></li>
<li><p>number of ordered trees with <img src="https://latex.codecogs.com/png.latex?n+1"> vertices</p>
<p>最外层要补一对括号．</p></li>
<li><p>number of binary trees with <img src="https://latex.codecogs.com/png.latex?n"> vertices</p>
<p>by left-child right-sibling encoding of ordered trees. 最后删去只有左儿子的根．</p>
<p>该组合意义可以导出 Catalan 数的生成函数．</p></li>
</ul>
<p>Catalan 数的组合意义并不止如此几种．cf.&nbsp;<a href="https://en.wikipedia.org/wiki/Catalan_number">Wikipedia</a></p>
</section>
</section>
</section>
<section id="多项式" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="多项式"><span class="header-section-number">4</span> 多项式</h2>
<p>此部分详细介绍请移步 <a href="../../posts/20230928-dft/">FFT/NTT 讲稿</a>．</p>
<section id="通用" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="通用"><span class="header-section-number">4.1</span> 通用</h3>
</section>
<section id="fft-fntt-卷积" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="fft-fntt-卷积"><span class="header-section-number">4.2</span> FFT / FNTT / 卷积</h3>
<ul>
<li><p>DFT：（本原）单位根构造 <img src="https://latex.codecogs.com/png.latex?%5Comega_n%20=%20e%5E%7B%5Cfrac%20%7B2%20%5Cpi%7D%7Bn%7Di%7D">．</p></li>
<li><p>NTT：<img src="https://latex.codecogs.com/png.latex?P=998244353%20=%207%20%5Ctimes%2017%20%5Ctimes%202%5E%7B23%7D%20+%201">，<img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BPR%7D%20=%203"> 是它的一个原根．（本原）单位根构造 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7Bn%7D%20=%20%5Cmathrm%7BPR%7D%5E%7B%5Cfrac%7BP-1%7D%7Bn%7D%7D%20%5Cbmod%20P">．</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?P=1004535809%20=%20479%20%5Ctimes%202%5E%7B21%7D%20+%201">，<img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BPR%7D%20=%203"></p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?P=469762049%20=%207%20%5Ctimes%202%5E%7B26%7D+1">，<img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BPR%7D%20=%203"></p></li>
</ul>
<p>考虑将待变换多项式 <img src="https://latex.codecogs.com/png.latex?%0AA(x)%20=%20%5Csum_%7Bk=0%7D%5E%7B2n-1%7D%20a_k%20x%5Ek%0A"> 奇偶分项为两个多项式 <img src="https://latex.codecogs.com/png.latex?%0AA(x)%20=%20A_0%20(x%5E2)%20+%20x%20A_1(x%5E2)%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AA_0%20(x)%20&amp;=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k%7D%20x%5Ek%20%5C%5C%0AA_1%20(x)%20&amp;=%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20a_%7B2k+1%7D%20x%5Ek%0A%5Cend%7Baligned%7D%0A"> 代入 <img src="https://latex.codecogs.com/png.latex?x%20=%20%5Comega_%7B2n%7D%5Ek%20%5Cpod%7Bk%20=%200,%5Cdots,%202n-1%7D">，用单位根消去 / 折半性质（<img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D%5E%7B2k%7D%20=%20%5Comega_n%5Ek">） <img src="https://latex.codecogs.com/png.latex?%0AA(%5Comega_%7B2n%7D%5Ek)%20=%20A_0%20(%5Comega_%7Bn%7D%5Ek)%20+%20%5Comega_%7B2n%7D%5Ek%20A_1%20(%5Comega_%7Bn%7D%5Ek)%0A"> 用 <img src="https://latex.codecogs.com/png.latex?%5Comega_%7B2n%7D%5E%7Bn+k%7D%20=%20-%20%5Comega_%7B2n%7D%5Ek"> <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AA(%5Comega_%7B2n%7D%5Ek)%20&amp;=%20A_0%20(%5Comega_n%5Ek)%20+%20%5Comega_%7B2n%7D%5Ek%20A_1%20(%5Comega_n%5Ek)%20%5C%5C%0AA(%5Comega_%7B2n%7D%5E%7Bn+k%7D)%20&amp;=%20A_0%20(%5Comega_n%5Ek)%20-%20%5Comega_%7B2n%7D%5Ek%20A_1(%5Comega_n%5Ek)%0A%5Cend%7Baligned%7D%0A%5Cpod%7Bk%20=%200,%20%5Cdots,%20n-1%7D%0A"> 即得 FFT/FNTT 递归算法．用单位根求和性质 <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%201%20n%20%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%20%5Comega%5E%7Bik%7D%20=%20%5Bi%20%5Cmid%20n%5D%0A"> 可知 DFT/NTT 变换矩阵 <img src="https://latex.codecogs.com/png.latex?F%20=%20%5Cbegin%7Bpmatrix%7D%5Comega_%7Bn%7D%5E%7Bij%7D%5Cend%7Bpmatrix%7D_%7B(i,j)%20%5Cin%20n%20%5Ctimes%20n%7D"> 满足 <img src="https://latex.codecogs.com/png.latex?F%20F%5EH%20=%20F%5EH%20F%20=%20n%20I_n">，故 <img src="https://latex.codecogs.com/png.latex?F%5E%7B-1%7D%20=%20%5Cfrac%201%20n%20F%5EH%20=%20%5Cbegin%7Bpmatrix%7D%20%5Cfrac%201%20n%20%5Comega_%7Bn%7D%5E%7B-ij%7D%5Cend%7Bpmatrix%7D_%7B(i,j)%20%5Cin%20n%20%5Ctimes%20n%7D">，此即 DFT/NTT 逆变换矩阵．</p>
<section id="蝶形运算与迭代算法" class="level4">
<h4 class="anchored" data-anchor-id="蝶形运算与迭代算法">蝶形运算与迭代算法</h4>
<p>为使用迭代算法，需要快速得到递归算法向下深入过程中 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20a_n%20%5C%7D"> 置换后的最终结果．观察知该置换是位逆序置换，可按如下方法线性求出．</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1">rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">++)</span> rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]=(</span>rev<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]&gt;&gt;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)+((</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)&lt;&lt;(</span>n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span></span></code></pre></div>
</section>
</section>
<section id="多项式方程求解newton-迭代法todo" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="多项式方程求解newton-迭代法todo"><span class="header-section-number">4.3</span> 多项式方程求解（Newton 迭代法）【TODO】</h3>
<p>给定一多项式 <img src="https://latex.codecogs.com/png.latex?A(x)">，求解满足 <img src="https://latex.codecogs.com/png.latex?A(B(x))%20=%200%20%5Cpmod%7Bx%5En%7D"> 的多项式 <img src="https://latex.codecogs.com/png.latex?B(x)">．</p>
<p>显然 <img src="https://latex.codecogs.com/png.latex?B(x)"> 只有前 <img src="https://latex.codecogs.com/png.latex?n"> 项有效．目前我们尚不清楚解的存在性、唯一性等性质，但注意到 <img src="https://latex.codecogs.com/png.latex?%0AA(B(x))%20=%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D%20%5Cimplies%20A(B(x))%20=%200%20%5Cpmod%7Bx%5En%7D%0A"> 故考虑递推求解．首先，边界条件 <img src="https://latex.codecogs.com/png.latex?A(b_0)%20=%200"> 需要单独求解．在确定某一 <img src="https://latex.codecogs.com/png.latex?b_0"> 的基础上，我们开始递推．考虑已经获得 <img src="https://latex.codecogs.com/png.latex?A(B(x))%20=%200%20%5Cpmod%7Bx%5En%7D"> 的一个解 <img src="https://latex.codecogs.com/png.latex?B(x)%20=%20B_0(x)">，下面尝试得到方程 <img src="https://latex.codecogs.com/png.latex?A(B(x))%20=%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D"> 的解．</p>
<p>将待求解方程 <img src="https://latex.codecogs.com/png.latex?A(B(x))%20=%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D"> 左式多项式 <img src="https://latex.codecogs.com/png.latex?A"> 在 <img src="https://latex.codecogs.com/png.latex?B_0"> 处 Taylor 展开 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bsplit%7D%0AA(B(x))%20=%20A(B_0(x))%20&amp;+%20A'(B_0(x))%20(B(x)-B_0(x))%20%5C%5C%20&amp;+%20%5Cfrac%7BA''(B_0(x))%7D%7B2!%7D%20(B(x)-B_0(x))%5E2%20+%20%5Cdots%0A=%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A%5Cend%7Bsplit%7D%0A"> <strong>假若</strong> <img src="https://latex.codecogs.com/png.latex?B(x)-B_0(x)%20=%200%20%5Cpmod%7Bx%5En%7D">，那么模 <img src="https://latex.codecogs.com/png.latex?x%5E%7B2n%7D"> 意义下二次方以上的项可以舍去，上式等价于 <img src="https://latex.codecogs.com/png.latex?%0AA(B_0(x))%20+%20A'(B_0(x))%20(B(x)-B_0(x))%20=%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A"> 移项即可解出待求 <img src="https://latex.codecogs.com/png.latex?B(x)"> <img src="https://latex.codecogs.com/png.latex?%0AB(x)%20=%20%20B_0(x)%20-%20%5Cfrac%7BA(B_0(x))%7D%7BA'(B_0(x))%7D%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A"> 这里要求 <img src="https://latex.codecogs.com/png.latex?A'(B_0(x))"> 需在 <img src="https://latex.codecogs.com/png.latex?x%5E%7B2n%7D"> 意义下可逆，即 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bsplit%7D%0A%5Bx%5E0%5D%20A'(B_0(x))%20=%20%5Bx%5E0%5D%20A'(b_0)%20&amp;=%20%5Csum_%7Bk=0%7D%5E%5Cinfty%20%5Cleft(%20%5Bx%5Ek%5D%20A'%20%5Cright)%20b_0%5Ek%20%5C%5C%0A&amp;=%20%5Csum_%7Bk=0%7D%5E%5Cinfty%20(k+1)%20a_%7Bk+1%7D%20b_0%5Ek%20%5Cneq%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A%5Cend%7Bsplit%7D%0A"> 注意到 <img src="https://latex.codecogs.com/png.latex?B(x)%20-%20B_0(x)%20=%20-%5Cfrac%7BA(B_0(x))%7D%7BA'(B_0(x))%7D%20=%200%20%5Cpmod%7Bx%5E%7Bn%7D%7D">，故满足上述“假若”的解存在且唯一．然而，若不要求这一“假若”成立，则每步迭代解的唯一性无法得到保证．考虑到边界条件 <img src="https://latex.codecogs.com/png.latex?b_0"> 的解亦不一定唯一，故一般的 Newton 迭代法解唯一性的讨论较为复杂．当然，上述推导至少为我们提供了一种寻找特解的方法．</p>
<p>Newton 迭代法作为通用求解框架，可涵盖几乎所有多项式初等运算．【TODO】</p>
</section>
<section id="多项式求逆" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="多项式求逆"><span class="header-section-number">4.4</span> 多项式求逆</h3>
<p>给定一多项式 <img src="https://latex.codecogs.com/png.latex?A(x)">，求解满足 <img src="https://latex.codecogs.com/png.latex?A(x)%20B(x)%20=%201%20%5Cpmod%7Bx%5E%7Bn%7D%7D"> 的多项式 <img src="https://latex.codecogs.com/png.latex?B(x)">．</p>
<p>多项式逆元存在的充分必要条件是其常数项非零（这是因为边界条件 <img src="https://latex.codecogs.com/png.latex?b_0%20=%20%5Cfrac%201%20%7Ba_0%7D">），若存在则在模意义下一定唯一．这结论可直接由下述求解方法得到．不失一般性，我们只研究 <img src="https://latex.codecogs.com/png.latex?A(x)"> 的次数为奇数 <img src="https://latex.codecogs.com/png.latex?2n-1"> 的情况．设 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AA(x)%20&amp;=%20A_0(x)%20+%20x%5En%20A_1(x)%20%5C%5C%0AB(x)%20&amp;=%20B_0(x)%20+%20x%5En%20B_1(x)%0A%5Cend%7Baligned%7D%0A"> 下述两种方法均递归地在已知 <img src="https://latex.codecogs.com/png.latex?%0AA(x)%20B_0(x)%20=%20A_0(x)%20B_0(x)%20=%201%20%5Cpmod%7Bx%5En%7D%0A"> 的基础上求解 <img src="https://latex.codecogs.com/png.latex?A(x)"> 的逆元．时间复杂度均为 <img src="https://latex.codecogs.com/png.latex?%0AT(n)%20=%20T(%5Cfrac%20n%202)%20+%20O(n%20%5Clog%20n)%20=%20O(n%20%5Clog%20n)%0A"></p>
<p>以下简记 <img src="https://latex.codecogs.com/png.latex?A(x)"> 为 <img src="https://latex.codecogs.com/png.latex?A">，其它多项式同理．</p>
<section id="倍增法一原创" class="level4">
<h4 class="anchored" data-anchor-id="倍增法一原创">倍增法一（原创）</h4>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A&amp;%20A%20B%20=%201%20%5Cpmod%7Bx%5E%7B2n%7D%7D%20%5C%5C%0A%5Ciff&amp;%20(A_0%20+%20x%5En%20A_1)(B_0%20+%20x%5En%20B_1)%20=%201%20%5Cpmod%7Bx%5E%7B2n%7D%7D%20%5C%5C%0A%5Ciff&amp;%20x%5En(A_1%20B_0%20+%20A_0%20B_1)%20+%20A_0%20B_0%20=%201%20%5Cpmod%7Bx%5E%7B2n%7D%7D%20%5C%5C%0A%5Ciff&amp;%20A_1%20B_0%20+%20A_0%20B_1%20+%20%5Cleft%5Clfloor%20%5Cfrac%7BA_0%20B_0%7D%7Bx%5En%7D%20%5Cright%5Crfloor%20=%200%20%5Cpmod%7Bx%5E%7Bn%7D%7D%20%5C%5C%0A%5Ciff&amp;%20%20A_0%20B_1%20=%20-%5Cleft%5Clfloor%20%5Cfrac%7BA_0%20B_0%7D%7Bx%5En%7D%20%5Cright%5Crfloor%20-%20A_1%20B_0%20%5Cpmod%7Bx%5E%7Bn%7D%7D%20%5C%5C%0A%5Ciff&amp;%20%20B_1%20=%20-%20B_0%20%5Cleft(%20%5Cleft%5Clfloor%20%5Cfrac%7BA_0%20B_0%7D%7Bx%5En%7D%20%5Cright%5Crfloor%20+%20A_1%20B_0%20%5Cright)%20%5Cpmod%7Bx%5E%7Bn%7D%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p>常数偏大，这里就不放代码了．</p>
</section>
<section id="倍增法二" class="level4">
<h4 class="anchored" data-anchor-id="倍增法二">倍增法二</h4>
<p>注意到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bcases%7D%0AA%20B_0%20=%201%20%5Cpmod%7Bx%5En%7D%20%5C%5C%0AA%20B%20=%201%20%5Cpmod%7Bx%5En%7D%0A%5Cend%7Bcases%7D%20%5Cimplies%20A%20(B-B_0)%20=%200%20%5Cpmod%7Bx%5En%7D%0A"> 由于 <img src="https://latex.codecogs.com/png.latex?A"> 的常数项非零，故 <img src="https://latex.codecogs.com/png.latex?%0AB-B_0%20=%200%20%5Cpmod%7Bx%5En%7D%0A"> （这证明了逆元在不同模数下的前缀保持一致）</p>
<p>两边平方得 <img src="https://latex.codecogs.com/png.latex?%0AB%5E2%20-%202%20B%20B_0%20+%20B_0%5E2%20=%200%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A"> 两侧同乘 <img src="https://latex.codecogs.com/png.latex?A"> 并移项得 <img src="https://latex.codecogs.com/png.latex?%0AB%20=%202%20B_0%20-%20A%20B_0%5E2%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A"></p>
</section>
</section>
<section id="多项式开方todo" class="level3" data-number="4.5">
<h3 data-number="4.5" class="anchored" data-anchor-id="多项式开方todo"><span class="header-section-number">4.5</span> 多项式开方【TODO】</h3>
<p>和多项式求逆类似的推导可得递推方程 <img src="https://latex.codecogs.com/png.latex?%0AB%20=%20%5Cfrac%201%202%20%5Cleft(%5Cfrac%20A%20%7BB_0%7D%20+%20B_0%20%5Cright)%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A"> 有一些和 Newton 法一样麻烦的边界条件讨论，也会出现复杂的多解情况．<img src="https://latex.codecogs.com/png.latex?a_0%20=%201"> 时 <img src="https://latex.codecogs.com/png.latex?b_0%20=%20%5Cpm%201">，按 <img src="https://latex.codecogs.com/png.latex?b_0%20=%201"> 的实现如下．</p>
<p>亦可 <img src="https://latex.codecogs.com/png.latex?%5Csqrt%20A%20=%20%5Cexp%20%5Cleft(%20%5Cfrac%201%202%20%5Cln%20A%20%5Cright)">，此法可处理多项式任意幂指数运算．</p>
</section>
<section id="多项式-ln" class="level3" data-number="4.6">
<h3 data-number="4.6" class="anchored" data-anchor-id="多项式-ln"><span class="header-section-number">4.6</span> 多项式 <img src="https://latex.codecogs.com/png.latex?%5Cln"></h3>
<p>给定一多项式 <img src="https://latex.codecogs.com/png.latex?A(x)">，求解满足 <img src="https://latex.codecogs.com/png.latex?B(x)%20=%20%5Cln%20A(x)%20%5Cpmod%7Bx%5E%7Bn%7D%7D"> 的多项式 <img src="https://latex.codecogs.com/png.latex?B(x)">．</p>
<p>次数为 <img src="https://latex.codecogs.com/png.latex?+%5Cinfty"> 的多项式 <img src="https://latex.codecogs.com/png.latex?%5Cln"> 存在的充分必要条件为其常数项非零（这是因为边界条件 <img src="https://latex.codecogs.com/png.latex?b_0%20=%20%5Cln%20a_0">），同样一旦存在则唯一．注意到仅整数 <img src="https://latex.codecogs.com/png.latex?a_0=1"> 时，<img src="https://latex.codecogs.com/png.latex?%5Cln%20a_0"> 可取得整数，故合理的 <img src="https://latex.codecogs.com/png.latex?a_0"> 只能是 <img src="https://latex.codecogs.com/png.latex?1">．另一种解释参见<a href="https://oi-wiki.org/math/poly/elementary-func/#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0--%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0">多项式初等函数 - OI Wiki # 多项式对数函数 &amp; 指数函数</a>．</p>
<p>推导是容易的．方程两侧同时求导得 <img src="https://latex.codecogs.com/png.latex?%0AB'(x)%20=%20%5Cfrac%7BA'(x)%7D%7BA(x)%7D%20%5Cpmod%7Bx%5E%7Bn-1%7D%7D%0A"> 两侧再积分得 <img src="https://latex.codecogs.com/png.latex?%0AB(x)%20=%20%5Cint%20%5Cfrac%7BA'(x)%7D%7BA(x)%7D%20%5Coperatorname%7Bd%7D%5C!x%20+%20C%20%5Cpmod%7Bx%5E%7Bn%7D%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?C=%20%5Cln%20a_0">．多项式求逆、求导、积分即可．时间复杂度 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)">．</p>
</section>
<section id="多项式-exptodo" class="level3" data-number="4.7">
<h3 data-number="4.7" class="anchored" data-anchor-id="多项式-exptodo"><span class="header-section-number">4.7</span> 多项式 <img src="https://latex.codecogs.com/png.latex?%5Cexp">【TODO】</h3>
<p>Newton 迭代法可推出 <img src="https://latex.codecogs.com/png.latex?%0AB%20=%20B(1%20-%20%5Cln%20B_0%20+%20A)%20%5Cpmod%7Bx%5E%7B2n%7D%7D%0A"> 时间复杂度 <img src="https://latex.codecogs.com/png.latex?%0AT(n)%20=%20T(%5Cfrac%20n%202)%20+%20O(n%20%5Clog%20n)%20=%20O(n%20%5Clog%20n)%0A"></p>
<p>存在的充要条件是 <img src="https://latex.codecogs.com/png.latex?a_0=0">．唯一性证明暂不明确．</p>
</section>
<section id="多项式快速幂" class="level3" data-number="4.8">
<h3 data-number="4.8" class="anchored" data-anchor-id="多项式快速幂"><span class="header-section-number">4.8</span> 多项式快速幂</h3>
<p>普通的多项式快速幂实现当然是 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n%20%5Clog%20k)"> 的．下面介绍基于指对数性质的 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)"> 求法．</p>
<p>对常数项 <img src="https://latex.codecogs.com/png.latex?a_0=1"> 的 <img src="https://latex.codecogs.com/png.latex?n-1"> 次多项式 <img src="https://latex.codecogs.com/png.latex?A(x)">， <img src="https://latex.codecogs.com/png.latex?%0AA%5Ek(x)%20=%20e%5E%7Bk%20%5Cln%20A(x)%7D%0A"></p>
<p>我们指出，在系数对质数 <img src="https://latex.codecogs.com/png.latex?p"> 取模的意义下，当我们关心的多项式长度 <img src="https://latex.codecogs.com/png.latex?n%20%5Cleq%20p"> 时，有 <img src="https://latex.codecogs.com/png.latex?%0AA%5Ep(x)%20%5Cequiv%20a_0%20%5Cequiv%201%20%5Cpmod%20p%0A"> 这是因为 <img src="https://latex.codecogs.com/png.latex?%0A(a+b)%5Ep%20%5Cequiv%20a%5Ep%20+%20b%5Ep%20%5Cpmod%20p%0A"> 故 <img src="https://latex.codecogs.com/png.latex?%0AA%5Ep(x)%20=%20(a_0%20+%20x%20A_1%20(x))%5Ep%20%5Cequiv%20a_0%5Ep%20+%20x%5Ep%20A_1%5Ep(x)%20%5Cpmod%20p%0A"> 由费马小定理，<img src="https://latex.codecogs.com/png.latex?a_0%5Ep%20=%20a_0">，而 <img src="https://latex.codecogs.com/png.latex?n%20%5Cleq%20p"> 表明 <img src="https://latex.codecogs.com/png.latex?x%5Ep%20A_1%5Ep(x)"> 一项可被忽略，故上述结论得到证明．这些讨论可用于处理幂指数 <img src="https://latex.codecogs.com/png.latex?k%20%5Cgeq%20p"> 的情况．</p>
<p>一般的，当常数项非 <img src="https://latex.codecogs.com/png.latex?1"> 时，为满足多项式 <img src="https://latex.codecogs.com/png.latex?%5Cln"> 的要求，设多项式 <img src="https://latex.codecogs.com/png.latex?A(x)"> 的最低次项为 <img src="https://latex.codecogs.com/png.latex?a_t%20x%5Et">，则 <img src="https://latex.codecogs.com/png.latex?%0AA%5Ek(x)%20=%20(a_t%20x%5Et)%5Ek%20%5Cleft(%20%5Cfrac%7BA(x)%7D%7Ba_t%20x%5Et%7D%20%5Cright)%5Ek%0A"> 右侧的多项式常数项归一，故可再应用上述方法计算．</p>
<p>关于多项式，更代数的内容参考 <a href="https://en.wikipedia.org/wiki/Formal_power_series">Formal power series - Wikipedia</a></p>
</section>
</section>
<section id="集合幂级数todo" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="集合幂级数todo"><span class="header-section-number">5</span> 集合幂级数【TODO】</h2>
</section>
<section id="矩阵" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="矩阵"><span class="header-section-number">6</span> 矩阵</h2>
<section id="矩阵乘法" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="矩阵乘法"><span class="header-section-number">6.1</span> 矩阵乘法</h3>
<p>普通的 <img src="https://latex.codecogs.com/png.latex?O(n%5E3)"> 实现．</p>
</section>
<section id="矩阵快速幂" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="矩阵快速幂"><span class="header-section-number">6.2</span> 矩阵快速幂</h3>
<p>普通的 <img src="https://latex.codecogs.com/png.latex?O(n%5E3%20%5Clog%20k)"> 实现．</p>
</section>
<section id="行列式" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="行列式"><span class="header-section-number">6.3</span> 行列式</h3>
<p>普通的实现是使用逆元进行高斯消元，可用于域上的线性空间．若求解逆元的时间复杂度为 <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20p)">，则时间复杂度为 <img src="https://latex.codecogs.com/png.latex?O(n%5E3+%20n%5E2%20%5Clog%20p)">．</p>
<p>这里给出另一种做法．该做法在消去时使用辗转相除法，可用于任意 Euclid 整环（Euclidean domain，有带余除法的无零因子的交换幺环）上的模（环上的线性空间），且时间复杂度不会增加．一个常见的应用是模 <img src="https://latex.codecogs.com/png.latex?m"> 整数环 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20Z_m"> 上的行列式求值，其中 <img src="https://latex.codecogs.com/png.latex?m"> 不是质数．</p>
<p>消去各目标行第 <img src="https://latex.codecogs.com/png.latex?c"> 列元素时，以第 <img src="https://latex.codecogs.com/png.latex?c"> 行的 <img src="https://latex.codecogs.com/png.latex?a_%7Bc,c%7D"> 为除数与目标行的第 <img src="https://latex.codecogs.com/png.latex?c"> 列元素辗转相除，最终使 <img src="https://latex.codecogs.com/png.latex?a_%7Bc,c%7D"> 变为 <img src="https://latex.codecogs.com/png.latex?0">，再做一次行交换将其换至目标行，就完成了一次行消去过程．注意到当 <img src="https://latex.codecogs.com/png.latex?a_%7Bc,c%7D"> 非零时，一次行消去操作结束后 <img src="https://latex.codecogs.com/png.latex?a_%7Bc,c%7D"> 单调不增，且过程中 <img src="https://latex.codecogs.com/png.latex?a_%7Bc,c%7D"> 不会从非零变为零，故辗转相除带来的 <img src="https://latex.codecogs.com/png.latex?%5Clog%20p"> 次额外操作开销被分摊到整轮对第 <img src="https://latex.codecogs.com/png.latex?c"> 列的消去过程中，因此时间复杂度仍为 <img src="https://latex.codecogs.com/png.latex?O(n%5E3+%20n%5E2%20%5Clog%20p)">．</p>
</section>
</section>
<section id="图论todo" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="图论todo"><span class="header-section-number">7</span> 图论【TODO】</h2>
<section id="最短路" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="最短路"><span class="header-section-number">7.1</span> 最短路</h3>
</section>
<section id="强连通分量" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="强连通分量"><span class="header-section-number">7.2</span> 强连通分量</h3>
</section>
<section id="网络流" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="网络流"><span class="header-section-number">7.3</span> 网络流</h3>
</section>
</section>
<section id="杂项" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="杂项"><span class="header-section-number">8</span> 杂项</h2>
<section id="模板" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="模板"><span class="header-section-number">8.1</span> 模板</h3>
<p>见 <a href="code/model.cpp">model.cpp</a>, <a href="code/model_temp.cpp">model_temp.cpp</a>, <a href="code/divntt_min.cpp">divntt_min.cpp</a>．</p>
</section>
<section id="对拍" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="对拍"><span class="header-section-number">8.2</span> 对拍</h3>
<section id="windows-batch" class="level4">
<h4 class="anchored" data-anchor-id="windows-batch">Windows Batch</h4>
<pre class="batch"><code>:loop
    gen.exe&gt;dat.in
    my.exe&lt;dat.in&gt;my.out
    std.exe&lt;dat.in&gt;std.out
    fc my.out std.out
    if not errorlevel 1 goto loop
pause</code></pre>
</section>
<section id="linux-shell" class="level4">
<h4 class="anchored" data-anchor-id="linux-shell">Linux Shell</h4>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">while</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">true</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">do</span></span>
<span id="cb8-2">    <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">./gen</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span>dat.in</span>
<span id="cb8-3">    <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">./std</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>dat.in<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span>std.out</span>
<span id="cb8-4">    <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">./my</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>dat.in<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span>my.out</span>
<span id="cb8-5">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">diff</span> std.out my.out<span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">then</span></span>
<span id="cb8-6">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">printf</span> OK</span>
<span id="cb8-7">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">else</span></span>
<span id="cb8-8">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">printf</span> DIFF</span>
<span id="cb8-9">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">exit</span> 0</span>
<span id="cb8-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">fi</span></span>
<span id="cb8-11"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">done</span></span></code></pre></div>
</section>
</section>
<section id="表" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="表"><span class="header-section-number">8.3</span> 表</h3>
<section id="质数表" class="level4">
<h4 class="anchored" data-anchor-id="质数表">质数表</h4>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb9-1">1e2         1e3         1e4         1e5         1e6</span>
<span id="cb9-2">101         1009        10007       100003      1000003</span>
<span id="cb9-3"></span>
<span id="cb9-4">1e7         1e8         1e9         1e10        1e11            </span>
<span id="cb9-5">10000019    100000007   1000000007  10000000019 100000000003</span>
<span id="cb9-6"></span>
<span id="cb9-7">1e12            1e13            1e14            1e15</span>
<span id="cb9-8">1000000000039   10000000000037  100000000000031 1000000000000037</span>
<span id="cb9-9"></span>
<span id="cb9-10">1e16                1e17                1e18</span>
<span id="cb9-11">10000000000000061   100000000000000003  1000000000000000003</span></code></pre></div>
</section>
<section id="典列" class="level4">
<h4 class="anchored" data-anchor-id="典列">典列</h4>
<p>见</p>
<ul>
<li><a href="https://oeis.org/wiki/Index_to_OEIS:_Section_Cor#core">OEIS Core Sequence</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_integer_sequences">List of Integer Sequences - Wikipedia</a></li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>OI</category>
  <category>数学</category>
  <guid>https://blog.sun123zxy.top/posts/20230621-cpmodel/index.html</guid>
  <pubDate>Tue, 20 Jun 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>CCPC 2023 湘潭邀请赛游记</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230530-xiangtan/index.html</link>
  <description><![CDATA[ 



<section id="序" class="level2">
<h2 class="anchored" data-anchor-id="序">序</h2>
<p>04:36，长沙返程的硬卧列车上。</p>
<p>禁不起隔壁大叔富有特色的鼾声，对着窗外发愣。</p>
<p>写写游记吧。</p>
</section>
<section id="day--inf-0" class="level2">
<h2 class="anchored" data-anchor-id="day--inf-0">Day (-inf, 0)</h2>
<p>由于 UCUP Taiwan 场神奇的发挥，意外获得湘潭邀请赛名额 x1。公费旅游万岁！</p>
<p>然而，飞机不给报，高铁不给报，软卧不给报，打车也不给报，路途时间高达 30h，还被迫翘掉周五周一头尾三节大课，体验并不良好。祸不单行，赛前十余日惊悉普物 27 日下午期末考试，若申请缓考，本学期的奖学金怕是无了。思量再三，还是想去，决定与队友兵分两路，考完直接空降长沙，再想办法到湘潭。晚上城铁已经收班，要是想当天到，恐怕只能高价打车了。这么算下来……</p>
<p>自费金额 +1000 : (</p>
<p>火车票意外地非常抢手，稍不留神，返程火车就只剩晚上 11 点半的了——赶上明天的早课是没必要再想了。不过，岳麓山橘子洲恰在长沙站西不远处，看看夜景也是不错的。</p>
<p>其它队伍似乎并不太着急……</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/whynot.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">你先别急</figcaption>
</figure>
</div>
<p>最后竟因抢票太积极，被迫与大部队分道扬镳 : (</p>
</section>
<section id="day-0" class="level2">
<h2 class="anchored" data-anchor-id="day-0">Day 0</h2>
<p>去湘潭的路途并无太多亮点，感受是 <img src="https://latex.codecogs.com/png.latex?%0A1000%20%5Ctext%7BCNY%7D%20=%20%5Ctext%7B%E9%A3%9E%E6%9C%BA%7D%20+%20%5Ctext%7B%E6%89%93%E8%BD%A6%7D%20+%20%5Ctext%7B%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%E5%8F%8D%E6%AD%A3%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%B0%B1%E5%88%B0%E4%BA%86%E7%9A%84%E4%BD%93%E9%AA%8C%7D%0A"></p>
<p>从半径来看，大兴机场并没有想象中的大。但其空间设计非常有意思。雪花状的航站楼中间高两头低，下站点、值机、安检全部集中在中心区域，而航站楼、廊桥、登机口通过几只触角向远端延伸，空间利用率极高，极大地节省了转场行走花费的时间。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/daxing.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">颇有商圈风范</figcaption>
</figure>
</div>
<p>与队友联系，惊悉热身赛诸多不尽人意之处。这小破赛居然不用 DOMJudge？Pending 一发 20 min？评测机 32 位没 <code>__int128</code>？PE 是什么鬼东西？Dev C++ 只提供魔改版？VSCode 给了但机子带不动？……感觉不如校赛。希望不是所有 CCPC 都这样（</p>
<p>队友给看了道热身赛题说是签到数论，飞机上吭哧吭哧半天无果，结果发现被诈骗了，赛时场内一人未过（</p>
<p>到达 XX 电竞酒店，半夜。发现机子上竟有 Age of Empires 2——更神奇的是，队友竟突然指出 AoE2 是其机房的传统艺能！？小众中的小众，从未发现同好的 RTS/AoE 玩家落泪了。遗憾的是到得太晚，没来得及切磋一把。01:00 左右睡下。</p>
</section>
<section id="day-1" class="level2">
<h2 class="anchored" data-anchor-id="day-1">Day 1</h2>
<p>湖南的清晨从一碗米粉开始——味道不错，但口感并不太中意。</p>
<p>一出门才感受到湖南的湿热：湿度高达 90% 的头顶烈日，走上两分钟就汗水淋漓，可不比某火炉城市好到那里。已经可以想象无法洗澡就要登上返程火车的我们会有多臭了 : ( 。更别说湘潭大学惊人的大小，坚持到开幕式现场的根本就没几个队（</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/xiangtan-1.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">湘大某入口</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/xiangtan-2.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">校徽版（据说存在缺漏）</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>有气球（没有 CCPC 图标），有打印（比评测快），有汉堡套餐（没怎么认真吃），志愿者人手似乎不太够，每个考室甚至分不到一个监考。</p>
<p>随便开题。两位队友秒了 I 然后 J（牛！）。随机游走开题，L 感觉是什么大力数据结构嵌套，E 数学题玩了玩感觉并没有什么思路，但发现并秒了 H，然后第一梯队的签到题好像就做完了。继续随机游走，看了 G 以为队友做过，确认后发现并没有，那应该就不太容易了。看榜开 F，干碎臭长题面发现就是个基础<del>随机运筹学</del>期望 dp，队友灵魂提醒需要特判 <img src="https://latex.codecogs.com/png.latex?B=1">，成功 1A。这期间两位队友也开了 A 但一发 WA 一发 TLE——怎么会 T 呢？在此之间卡壳卡爆。三人干瞪眼贡献四发罚时浪费 1h，结果竟是 <img src="https://latex.codecogs.com/png.latex?10%5E5"> 次 <code>printf</code> 在老爷评测上跑的太慢！写题的队友表示以后彻底切割 C 风格读写（</p>
<p>然后三人回头看之前和一位队友讨论一半的 K（J 是 K 的 checker 海星）。想到了 <code>aa</code>, <code>bb</code>, <code>cc</code>, …, <code>ab</code>, <code>ac</code>, <code>ad</code>, … 的构造方式，但在考虑后续延伸时莫名认为要继续移位构造超大置换环 <code>abcde...</code>, <code>acegi...</code>，于是开始大力计算 <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi=0%7D%5E%7B25%7D%20%5Cgcd(26,i)">。队友打断吟唱，指出只需 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%20%7B25%20%5Ctimes%2024%7D%7B2%7D"> 两位循环并在后面填充 <code>z</code> 即可，遂暴毙，决定先拿下汉堡套餐，然后继续游走摆烂。然而队友小脑转的比大脑快，光速敲完遗憾 WA，似乎他的特判有亿点多。调试无果，打印，换我重写。写得差不多了，两位队友合力调试突然成功，于是历经坎坷终于进入 6 题区。</p>
<p>距比赛结束还有一个半小时左右。看 B 看 D，深感星穹铁道题面之博大精深，决定搏一搏 L。上了个厕所发现会二维了，三维似乎也只是颗二维线段树，维护 max/min 判断当前操作方块是否平整 + 区间覆盖的修改操作即可。然而队友思路是神奇的二维扫描线，顿感自己非常不熟悉这种非标线段树。激烈讨论后，还是让擅长数据结构的队友按他熟悉的方法实现。然而队友实现一半算法竟然假了，又紧急更换写法，此前表现正常的电脑突然开始变卡，三个人对着电脑大吼大叫，最后 2 min 写完了代码！F11！输出“No”！摆！</p>
<p>第一次外出比赛就这样结束了。比较遗憾的，无疑是 A <code>printf</code> 吃的四发罚时了。给你校老爷评测机跪了（</p>
<p>滚榜环节的操作非常迷惑，不从奖牌区滚起，又跳过了 Cu Ag 区，滚了个寂寞。因为老爷评测机的原因，封榜前后的排名也几乎没有发生变化。6 题金银铜，这是我能见着的区分度吗（</p>
<p>最后冠军颁奖倒意外地有节目效果。主持人抑扬顿挫念出“梦想天生”，BGM 和掌声突然响起，恍惚有 Dream Battle 前奏噔噔咚，灵梦按在地上揍的感觉（</p>
</section>
<section id="day-1-赛后" class="level2">
<h2 class="anchored" data-anchor-id="day-1-赛后">Day 1 赛后</h2>
<p>返程继续暴汗。从湘潭乘城铁至长沙。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/city-railway.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">高铁风格，地铁运营</figcaption>
</figure>
</div>
<p>队友来时已经踩好点了，拉着啥也不知道的我就往五一广场走……</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 75.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/plaza.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">五一广场</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 25.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/tea.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">到处都是的某神奇奶茶店</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>队友在前面慢悠悠地寻找吃饭的地方，看上去是准备边吃边坐挨到火车到点了。还想出去逛逛，于是暂时各奔东西。街边随便点了份牛杂面（超辣！）和臭豆腐（完全不臭），乘地铁二号线至橘子洲西岸，向岳麓山前进。然而功课未做充足，到达山门才发现索道已停，大巴收班。天色已晚，爬上去显然赶不上 11 点半的火车，只好悻悻而去。</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/mount-2.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">岳麓山门</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/mount-1.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">岳麓山麓</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>然而……</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/young.jpg" height="600" class="figure-img"></p>
<figcaption class="figure-caption">年轻真好</figcaption>
</figure>
</div>
<p>于是从麓山路返回，上至橘子洲大桥。由此可直接步行至江心的橘子洲。</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/orange-1.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">橘子洲西望</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/orange-2.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">橘子洲东望</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>时间来到 10 点整。准备返程。地铁至五一广场，与队友汇合，前往长沙站。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230530-xiangtan/img/station.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">旅途的终点</figcaption>
</figure>
</div>
<p>疲惫，忘记买早饭就过安检了。候车大厅已无空位，站着闲聊了小会儿，时间到了。之前车上刷夜的豪言壮语早已抛之脑后，上车一躺——Day 1, end.</p>
<p>upd x1: 酒店登录过 Steam 的群友都被盗号了 <img src="https://latex.codecogs.com/png.latex?%5CSigma%20(%20%5Csupset%20%5Cmathrm%7BO%7D%20_%5Cfrown%20%5Cmathrm%7BO%7D%20)%20%5Csupset"></p>
<p>upd x2: 报销疑似仍然有戏，感谢学校感谢党 <img src="https://latex.codecogs.com/png.latex?%5CSigma%20(%20%5Csupset%20%5Cmathrm%7BO%7D%20_%5Csmile%20%5Cmathrm%7BO%7D%20)%20%5Csupset"></p>
</section>
<section id="补题" class="level2">
<h2 class="anchored" data-anchor-id="补题">补题</h2>
<p><a href="https://codeforces.com/gym/104396">GYM104396</a></p>
<section id="l" class="level3">
<h3 class="anchored" data-anchor-id="l">L</h3>
<p>需要注意的是，四分树 / K-D 树不存在时间复杂度优秀的区间修改。对于任意区间修改，树套树的实现是必要的。</p>
<p>L 其实有基于差分的非常容易的解法，见解法二。随机分划长度的类似 hash 的解法三也非常震撼。</p>


</section>
</section>

 ]]></description>
  <category>游记</category>
  <category>OI</category>
  <category>回忆</category>
  <guid>https://blog.sun123zxy.top/posts/20230530-xiangtan/index.html</guid>
  <pubDate>Mon, 29 May 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>Hilbert 曲线与集合势理论</title>
  <dc:creator>sun123zxy </dc:creator>
  <dc:creator>宁同学 </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230519-hilbert/index.html</link>
  <description><![CDATA[ 



<div class="hidden">
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cnewcommand%7B%5Clen%7D%7B%5Coperatorname%7Blen%7D%7D%0A"></p>
</div>
<section id="空间填充曲线" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="空间填充曲线"><span class="header-section-number">1</span> 空间填充曲线</h2>
<section id="曲线" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="曲线"><span class="header-section-number">1.1</span> 曲线</h3>
<p>（我们所讨论的）曲线：定义域为 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D"> 的连续映射．</p>
</section>
<section id="空间填充曲线-1" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="空间填充曲线-1"><span class="header-section-number">1.2</span> 空间填充曲线</h3>
<p>（我们所讨论的）空间填充曲线的定义：连续满射 <img src="https://latex.codecogs.com/png.latex?f:%20%5B0,1%5D%20%5Cto%20%5B0,1%5D%5E2">．</p>
</section>
</section>
<section id="hilbert-曲线" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="hilbert-曲线"><span class="header-section-number">2</span> Hilbert 曲线</h2>
<section id="n-阶伪-hilbert-曲线-h_nt" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="n-阶伪-hilbert-曲线-h_nt"><span class="header-section-number">2.1</span> <img src="https://latex.codecogs.com/png.latex?n"> 阶伪 Hilbert 曲线 <img src="https://latex.codecogs.com/png.latex?H_n(t)"></h3>
<p>理解一：将 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D%5E2"> 等分成 <img src="https://latex.codecogs.com/png.latex?2%5En%20%5Ctimes%202%5En"> 个小方块，按特定顺序将每个小方块的中心点用直线连接起来．这顺序是递归构造的．</p>
<p>理解二：构造 <img src="https://latex.codecogs.com/png.latex?n"> 阶伪 Hilbert 曲线时，将所研究的方块区域四等分．左下角填入左上-右下翻转的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶伪 Hilbert 曲线；左上、右上角填入未翻转的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶伪 Hilbert 曲线；右下角填入左下-右上翻转的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶伪 Hilbert 曲线．最后用三条直线连接各小方块内曲线的起止点．</p>
<div id="exr-fakehil-len" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1 </strong></span><img src="https://latex.codecogs.com/png.latex?n"> 阶伪 Hilbert 曲线的长度 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Blen%7DH_n%20=%202%5En%20-%202%5E%7B-n%7D">．</p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>Solution</em> (递推). </span>由伪 Hilbert 曲线的递归定义得 <img src="https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7Blen%7DH_n%20=%202%20%5Coperatorname%7Blen%7DH_%7Bn-1%7D%20+%20%5Cfrac%203%20%7B2%5En%7D%0A"> 边界为 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Blen%7DH_0%20=%200">．求解该递推式即可．</p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>Solution</em> (直观). </span>注意到 <img src="https://latex.codecogs.com/png.latex?n"> 阶伪 Hilbert 曲线将区间分为 <img src="https://latex.codecogs.com/png.latex?2%5En%20%5Ctimes%202%5En%20=%204%5En"> 个小方块，除首尾方块，其余小方块内的曲线长度均为小方块边长 <img src="https://latex.codecogs.com/png.latex?2%5En">．因此 <img src="https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7Blen%7DH_n%20=%204%5E%7B-n%7D%20%5Ccdot%202%5E%7B-n%7D%20-%202%20%5Ccdot%20%5Cfrac%20%7B2%5E%7B-n%7D%7D%7B2%7D%20=%202%5En%20-%202%5E%7B-n%7D%0A"></p>
</div>
<p>式中 “<img src="https://latex.codecogs.com/png.latex?-%202%5E%7B-n%7D">” 部分并不讨人喜爱．我们考虑水平或垂直地延长首尾方块曲线至任意边界，这样曲线长度 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Blen%7DH_n%20=%202%5En"> 就恒成立了．我们在后文的讨论中使用这一改进．</p>
</section>
<section id="hilbert-曲线-ht" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="hilbert-曲线-ht"><span class="header-section-number">2.2</span> Hilbert 曲线 <img src="https://latex.codecogs.com/png.latex?H(t)"></h3>
<p>真正的 Hilbert 曲线是由 <img src="https://latex.codecogs.com/png.latex?n"> 阶伪 Hilbert 曲线取逐点极限得到的．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AH(t)%20=%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20H_n(t)%0A"></p>
<div id="thm-converge" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (良定义性) </strong></span>伪 Hilbert 曲线一致收敛（因此也是逐点收敛的）．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>对一给定的 <img src="https://latex.codecogs.com/png.latex?t%20%5Cin%20%5B0,1%5D">，设其落在区间 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5B%20k%204%5E%7B-n_0%7D,%20(k+1)%204%5E%7B-n_0%7D%20%5Cright%5D">，则对任意 <img src="https://latex.codecogs.com/png.latex?n%20%5Cgeq%20n_0">，<img src="https://latex.codecogs.com/png.latex?H_n(t)"> 均落在 <img src="https://latex.codecogs.com/png.latex?H_%7Bn_0%7D(t)"> 所确定的边长为 <img src="https://latex.codecogs.com/png.latex?2%5E%7B-n%7D"> 的小闭方块内，即 <img src="https://latex.codecogs.com/png.latex?%5C%7C%20H_%7Bn%7D(t)%20-%20H_%7Bn_0%7D(t)%20%5C%7C_%5Cinfty%20%5Cleq%202%5E%7B-n%7D">．由 Cauchy 收敛原理即得其一致收敛性．</p>
</div>
<div id="thm-surjective" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 (满射性) </strong></span>Hilbert 曲线是 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D%20%5Cto%20%5B0,1%5D%5E2"> 的满射．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>对一给定的 <img src="https://latex.codecogs.com/png.latex?(x,y)%20%5Cin%20%5B0,1%5D%5E2">，将所研究的闭方块区域四等分，任取一 <img src="https://latex.codecogs.com/png.latex?(x,y)"> 所在小闭方块作为下一个研究的闭方块．如此进行下去，构造出一列框住 <img src="https://latex.codecogs.com/png.latex?(x,y)"> 的收缩的闭方块套．闭方块套里的每一个半径为 <img src="https://latex.codecogs.com/png.latex?2%5E%7B-n%7D"> 的闭方块都对应着 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D"> 上长 <img src="https://latex.codecogs.com/png.latex?4%5E%7B-n%7D"> 的一个闭区间，这些区间同样构成了 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D"> 上的一个闭区间套．由闭区间套原理，这列闭区间套确定了一个实数 <img src="https://latex.codecogs.com/png.latex?t%20%5Cin%20%5B0,1%5D">，它就是使得 <img src="https://latex.codecogs.com/png.latex?f(t)%20=%20(x,y)"> 的一个解．</p>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>需要注意的是，当 <img src="https://latex.codecogs.com/png.latex?(x,y)"> 落在某两个闭方块的公共边界上时，证明中我们任取其中一个闭方块继续讨论．因此，选择不同闭方块将可能使我们得到不同的 <img src="https://latex.codecogs.com/png.latex?t"> 值，这是 Hilbert 曲线不是单射的原因之一．</p>
</div>
<div id="thm-surjective" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (连续性) </strong></span>Hilbert 曲线在其定义域内连续．</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>对一给定的 <img src="https://latex.codecogs.com/png.latex?t%20%5Cin%20%5B0,1%5D">，考虑 <img src="https://latex.codecogs.com/png.latex?H(t)"> 任意取定的 <img src="https://latex.codecogs.com/png.latex?%5Cvarepsilon"> 邻域 <img src="https://latex.codecogs.com/png.latex?U_%7B%5Cvarepsilon%7D(H(t))%20=%20%5C%7B%20(x,y)%20:%20%5C%7C%20H(t)%20-%20(x,y)%20%5C%7C_%7B%5Cinfty%7D%20%3C%20%5Cvarepsilon%20%5C%7D">，取 <img src="https://latex.codecogs.com/png.latex?n_0%20=%20%5Clog_2%20%5Cvarepsilon%20-%202">，即可使第 <img src="https://latex.codecogs.com/png.latex?n_0"> 阶伪 Hillbert 曲线划分出的各闭方块边长为<img src="https://latex.codecogs.com/png.latex?2%5E%7B-n_0%7D%20%3C%20%5Cfrac%20%5Cvarepsilon%202">．设此时 <img src="https://latex.codecogs.com/png.latex?t"> 落在闭区间 <img src="https://latex.codecogs.com/png.latex?I%20=%20%5Cleft%5B%20k%204%5E%7B-n_0%7D,%20(k+1)%204%5E%7B-n_0%7D%20%5Cright%5D">（如在边界，则任取），其对应闭方块 <img src="https://latex.codecogs.com/png.latex?J%20=%20H(I)">．由于 <img src="https://latex.codecogs.com/png.latex?I"> 已经是 <img src="https://latex.codecogs.com/png.latex?t"> 的一个（单侧）邻域，为证明 <img src="https://latex.codecogs.com/png.latex?H(t)"> 在点 <img src="https://latex.codecogs.com/png.latex?t"> 的连续性，下面只需证 <img src="https://latex.codecogs.com/png.latex?J%20%5Csubset%20U_%5Cvarepsilon(H(t))">．由于我们构造的 <img src="https://latex.codecogs.com/png.latex?n_0"> 使闭方块 <img src="https://latex.codecogs.com/png.latex?J"> 的边长为 <img src="https://latex.codecogs.com/png.latex?2%5E%7B-n_0%7D%20%3C%20%5Cfrac%20%5Cvarepsilon%202">，<img src="https://latex.codecogs.com/png.latex?H(t)"> 与这闭方块中任意点 <img src="https://latex.codecogs.com/png.latex?(x,y)"> 的距离 <img src="https://latex.codecogs.com/png.latex?%0A%5C%7C%20H(t)%20-%20(x,y)%20%5C%7C_%7B%5Cinfty%7D%20%5Cleq%20%5Cfrac%20%5Cvarepsilon%202%20%3C%20%5Cvarepsilon%0A"> 故 <img src="https://latex.codecogs.com/png.latex?J%20%5Csubset%20U_%5Cvarepsilon(H(t))">．</p>
</div>
<div id="exr-hil-len" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2 </strong></span>Hilbert 曲线是不可求长的．</p>
</div>
<p>对一般的曲线而言，逐点收敛于曲线 <img src="https://latex.codecogs.com/png.latex?f"> 的曲线族 <img src="https://latex.codecogs.com/png.latex?f_n"> 的长度的极限 <img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Coperatorname%7Blen%7Df_n"> 与 <img src="https://latex.codecogs.com/png.latex?f"> 的长度 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Blen%7Df"> 并不一定相同．这一事实有一简单有力的实例验证：用锯齿状曲线逼近圆．</p>
<p>因此，直接取 Exercise&nbsp;1 的极限并不可行．根据曲线长度的定义，只有构造出一族直接由 <img src="https://latex.codecogs.com/png.latex?H(t)"> 上点构成的近似曲线，我们才能从这族曲线长度的极限中得到 Hilbert 曲线的正确长度．</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>考虑划分 <img src="https://latex.codecogs.com/png.latex?P_%7Bn%7D%20:%20t_k%20=%20k%204%5E%7B-%7Bn%7D%7D%20%5Cpod%7Bk%20=%200,%201,%20%5Cdots,%204%5E%7Bn%7D%7D">，将 <img src="https://latex.codecogs.com/png.latex?H(t_k)"> 依次用折线连接，就得到了《Space-filling curves》2.6 节<span class="citation" data-cites="sagan">[1]</span>讨论的 Hilbert 曲线的 <img src="https://latex.codecogs.com/png.latex?n"> 阶近似多边形曲线 <img src="https://latex.codecogs.com/png.latex?P_n(t)">（Approximating polygon for the Hilbert curve）．我们指出，与 <img src="https://latex.codecogs.com/png.latex?n"> 阶伪 Hilbert 曲线相同，<img src="https://latex.codecogs.com/png.latex?n"> 阶 Hilbert 近似多边形曲线仍然可以类似的由递归方法得到，遍历 <img src="https://latex.codecogs.com/png.latex?2%5En%20%5Ctimes%202%5En"> 个小方块，且平均每个小方块内的曲线长度为 <img src="https://latex.codecogs.com/png.latex?2%5E%7B-n%7D">．因此，<img src="https://latex.codecogs.com/png.latex?n"> 阶 Hilbert 近似多边形曲线的长度 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Blen%7DP_n(t)%20=%20(2%5En%20%5Ctimes%202%5En)%20%5Ccdot%202%5E%7B-n%7D%20=%202%5En">．由于该数列没有上界，故我们说明了 Hilbert 曲线的不可求长性．</p>
</div>
</section>
<section id="全平面填充" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="全平面填充"><span class="header-section-number">2.3</span> 全平面填充</h3>
<p>环绕填充并连接相邻曲线即可．</p>
</section>
<section id="四进制小数表示" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="四进制小数表示"><span class="header-section-number">2.4</span> 四进制小数表示</h3>
<p><img src="https://latex.codecogs.com/png.latex?n"> 阶伪 Hilbert 曲线对 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D"> 区间的划分操作可被一一对应地记为 <img src="https://latex.codecogs.com/png.latex?n"> 位四进制小数，从而为 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D"> 上被划分出的区间和对应的 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D%5E2"> 上的方块赋予了一种简洁的表示方法．但由于递归构造时左下、右下角涉及翻转操作，为每个实数 <img src="https://latex.codecogs.com/png.latex?t">（无限位规范四进制小数）写出其平面对应点 <img src="https://latex.codecogs.com/png.latex?H(t)"> 的非递归封闭形式表达稍显复杂．《Space-filling curves》<span class="citation" data-cites="sagan">[1]</span>的 2.3 节给出了基于复数和四进制小数的精确表示．</p>
</section>
<section id="小结" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="小结"><span class="header-section-number">2.5</span> 小结</h3>
<ul>
<li>Hilbert 曲线确实遍历了 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D%5E2"> 区域的所有点.</li>
<li>Hilbert 曲线是满射, 但不是单射，所以不是从线段到正方形区域的双射．</li>
<li><img src="https://latex.codecogs.com/png.latex?%5B0,1%5D%5E2%20%5Cto%20%5B0,1%5D"> 的单射（甚至双射）？集合势理论．</li>
<li>（补充）空间填充曲线必自交，即不能是单射．（Pf：否则与 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D%5E2"> 同胚，这显然荒谬．）（证明同胚逆映射连续需用拓扑定理：any continuous bijection from a compact space onto a Hausdorff space is a homeomorphism）</li>
<li>（补充）不自交但有面积的曲线：Osgood 曲线．但它不是空间填充曲线．</li>
</ul>
</section>
</section>
<section id="集合势理论" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="集合势理论"><span class="header-section-number">3</span> 集合势理论</h2>
<section id="集合的势" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="集合的势"><span class="header-section-number">3.1</span> 集合的势</h3>
<ul>
<li><p>等势，劣势于，优势于．</p></li>
<li><p>“劣势于”是集合上的序关系：自反性、反对称性（Bernstein 定理）、传递性．</p>
<p>事实上更是全序关系，证明需用到选择公理．</p></li>
</ul>
</section>
<section id="有限集可列集与无限集" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="有限集可列集与无限集"><span class="header-section-number">3.2</span> 有限集、可列集与无限集</h3>
<ul>
<li><p>有限集，可列集，无限集．</p></li>
<li><p>无限集的充要条件：与某一真子集等势（Dedekind 定义）．</p>
<p>充分性：归纳取出可列集，该部分映射到后继形成双射．</p>
<p>必要性：即有限集不与任何其真子集等势．冗长，证明略．</p></li>
<li><p>无限集并有限或可列集仍与原无限集等势．</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%20N%5E2%20%5Capprox%20%5Cmathbb%20N%0A"></p>
<p>本质：可列个可列集的并还是可列集；可列集的有限次笛卡尔积仍是可列集．</p>
</section>
<section id="从可列到不可列" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="从可列到不可列"><span class="header-section-number">3.3</span> 从可列到不可列</h3>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%20R%20%5Cnot%20%5Capprox%20%5Cmathbb%20N%0A"></p>
<p>写成小数，对角线法．</p>
<p>规范小数（规定其均为无限小数），规范二进制小数．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A2%5E%7B%5Cmathbb%20N%7D%20%5Capprox%20%5Cmathbb%20R%0A"></p>
<p>核心在于不规范小数是可列集．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%7B%5Cmathbb%20R%7D%5E2%20%5Capprox%20%5Cmathbb%20R%0A"></p>
<p>小数穿插构造法．需要注意的是，构造的 <img src="https://latex.codecogs.com/png.latex?(0,1)%5E2%20%5Cto%20(0,1)"> 的单射不是满射 <img src="https://latex.codecogs.com/png.latex?%0Ac%20=%200.303030%5Cdots%20%5Cimplies%20a%20=%200.333%5Cdots,%20b=%200.000%5Cdots%0A"> 此外，它也不是连续映射 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0Aa=0.3333%5Cdots,%20b=0.4999%5Cdots%20&amp;%5Cimplies%20c=0.343939%5Cdots%20%5C%5C%0Aa=0.3333%5Cdots,%20b=0.5000%5Cdots%20&amp;%5Cimplies%20c=0.353030%5Cdots%0A%5Cend%7Baligned%7D%0A"> 其对应的 <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D%20%5Cto%20%5B0,1%5D%5E2"> 的非单的满射（如构造出的小数不规范，则将其规范化）亦不连续． <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0Ac%20=%200.4999%5Cdots%20&amp;%5Cimplies%20a%20=%200.4999%5Cdots,%20b=0.9999%0A%5Cdots%20%5C%5C%0Ac%20=%200.5000%5Cdots%20&amp;%5Cimplies%20a%20=%200.5000%5Cdots,%20b=0.0000%5Cdots%0A%5Cend%7Baligned%7D%0A"></p>
<p>Fun fact: <img src="https://latex.codecogs.com/png.latex?%7B%5Cmathbb%20R%7D%5E2%20%5Capprox%20%5Cleft(2%5E%7B%5Cmathbb%20N%7D%5Cright)%5E%7B2%7D%20%5Capprox%202%5E%7B%5Cleft(%7B%5Cmathbb%20N%20%5Ctimes%202%7D%20%5Cright)%7D%20%5Capprox%202%5E%7B%5Cmathbb%20N%7D%20%5Capprox%20%5Cmathbb%20R">（基数理论）</p>
</section>
<section id="小结-1" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="小结-1"><span class="header-section-number">3.4</span> 小结</h3>
<ul>
<li>Hilbert 曲线：<img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R%20%5Cto%20%7B%5Cmathbb%20R%7D%5E2"> 的连续满射．</li>
<li>集合势理论：<img src="https://latex.codecogs.com/png.latex?%7B%5Cmathbb%20R%7D%5E2%20%5Cto%20%7B%5Cmathbb%20R%7D"> 的不连续单（双）射．</li>
</ul>
</section>
</section>



<div id="quarto-appendix" class="default"><section id="comments" class="level2 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Comments</h2><div class="quarto-appendix-contents">

<ul>
<li><p>希尔伯特曲线及性质的形式化理解 - zzdyyy<span class="citation" data-cites="zzdyyy">[2]</span></p>
<p>本文脉络的主要参考．</p></li>
<li><p>Why does the Hilbert curve fill the whole square? - Math StackExchange<span class="citation" data-cites="mathex_fill">[3]</span></p>
<p>提供了收敛性的较严谨证明．</p></li>
<li><p>希尔伯特曲线：无限数学怎样应用于有限世界 - 3Blue1Brown<span class="citation" data-cites="3b1b">[4]</span></p>
<p>优秀的可视化．</p></li>
<li><p>Space-filling curve - Wikipedia<span class="citation" data-cites="wikipedia_spacefilling">[5]</span></p></li>
<li><p>《集合论基础教程》张峰、陶然<span class="citation" data-cites="zhangfeng">[6]</span></p></li>
</ul>
<p>扩展阅读：</p>
<ul>
<li><p>《Space-filling curves》Hans Sagan<span class="citation" data-cites="sagan">[1]</span></p>
<p>回顾了空间填充曲线发展历史；用形式化的语言刻画了 Hilbert 曲线，见文内引用．</p></li>
</ul>
</div></section><section id="acknowledgements" class="level2 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Acknowledgements</h2><div class="quarto-appendix-contents">

<p>感谢吕老师组织研讨课．本次研讨课与宁同学一同准备并主要由后者主讲，在讨论和展示过程中收获颇丰．</p>



</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-sagan" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">H. Sagan, <em>Space-filling curves</em>. Springer Science &amp; Business Media, 1994.</div>
</div>
<div id="ref-zzdyyy" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">zzdyyy, <span>“希尔伯特曲线及性质的形式化理解.”</span> <a href="https://www.cnblogs.com/zzdyyy/p/7636474.html" class="uri">https://www.cnblogs.com/zzdyyy/p/7636474.html</a>, 2017.</div>
</div>
<div id="ref-mathex_fill" class="csl-entry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">M. A. (https://math.stackexchange.com/users/22857/martin-argerami), <span>“Why does the hilbert curve fill the whole square?”</span> Mathematics Stack Exchange. Available: <a href="https://math.stackexchange.com/q/142029">https://math.stackexchange.com/q/142029</a></div>
</div>
<div id="ref-3b1b" class="csl-entry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">3Blue1Brown, <span>“希尔伯特曲线：无限数学怎样应用于有限世界.”</span> <a href="https://www.bilibili.com/video/av4201747" class="uri">https://www.bilibili.com/video/av4201747</a>, 2016.</div>
</div>
<div id="ref-wikipedia_spacefilling" class="csl-entry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">Wikipedia, <span>“Space-filling curve - wikipedia.”</span> <a href="https://en.wikipedia.org/wiki/Space-filling_curve" class="uri">https://en.wikipedia.org/wiki/Space-filling_curve</a>.</div>
</div>
<div id="ref-zhangfeng" class="csl-entry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">张峰 and 陶然, <em>集合论基础教程</em>. 北京: 清华大学出版社, 2021.</div>
</div>
</div></section></div> ]]></description>
  <category>数学</category>
  <category>讲稿</category>
  <guid>https://blog.sun123zxy.top/posts/20230519-hilbert/index.html</guid>
  <pubDate>Wed, 17 May 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>Wallis 公式、Stirling 公式与正态分布</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230423-stirling/index.html</link>
  <description><![CDATA[ 



<div class="hidden">
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cnewcommand%7B%5Cdiff%7D%7B%5Coperatorname%7Bd%7D%5C!%7D%0A"></p>
</div>
<p>参考：</p>
<ul>
<li>张筑生《数学分析新讲》第二册<span class="citation" data-cites="analysis">[1]</span></li>
<li>张颢《概率论》<span class="citation" data-cites="prob">[2]</span></li>
<li>Wikipedia, Math StackExchange, etc.</li>
</ul>
<section id="warm-up" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="warm-up"><span class="header-section-number">1</span> Warm up</h2>
<div id="exm-double-factorial" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 </strong></span>求 <img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B(2n-1)!!%7D%7B(2n)!!%7D%20=%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B1%20%5Ctimes%203%20%5Ctimes%205%20%5Ctimes%20%5Cdots%20%5Ctimes%20(2n-1)%7D%7B2%20%5Ctimes%204%20%5Ctimes%206%20%5Ctimes%20%5Cdots%20%5Ctimes%202n%7D%0A"></p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>Solution</em>. </span>用放缩 <img src="https://latex.codecogs.com/png.latex?%0A2k%20%3E%20%5Csqrt%7B(2k-1)(2k+1)%7D%0A"> 拆分母即得 <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B(2n-1)!!%7D%7B(2n)!!%7D%20%3C%20%5Cfrac%201%20%7B%5Csqrt%7B2n+1%7D%7D%20%5Csim%200%0A"></p>
</div>
<div id="exm-binomial" class="theorem example">
<p><span class="theorem-title"><strong>Example 2 (中心二项式系数) </strong></span>求 <img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B%5Cbinom%7B2n%7D%7Bn%7D%7D%7B2%5E%7B2n%7D%7D%0A"></p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>Solution</em>. </span><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cbinom%7B2n%7D%7Bn%7D%7D%7B2%5E%7B2n%7D%7D%20=%20%5Cfrac%7B(2n)!%7D%7B2%5E%7B2n%7D%20(n!)%5E2%7D%20=%20%5Cfrac%7B(2n)!%7D%7B(2%5En%20n!)%5E2%7D%20=%20%5Cfrac%7B(2n)!%7D%7B((2n)!!)%5E2%7D%20=%20%5Cfrac%7B(2n-1)!!%7D%7B(2n)!!%7D%20%3C%20%5Cfrac%201%20%7B%5Csqrt%7B2n+1%7D%7D%20%5Csim%200%0A"></p>
</div>
<p>上两例有没有更精确的渐进估计？这便是我们马上要研究的问题．</p>
</section>
<section id="wallis-公式" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="wallis-公式"><span class="header-section-number">2</span> Wallis 公式</h2>
<div id="lem-wallis-integral" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1 (Wallis 积分公式) </strong></span>定积分系列 <img src="https://latex.codecogs.com/png.latex?%0AJ_n%20=%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Csin%5En%20x%20%5Coperatorname%7Bd%7D%5C!x%0A"> 满足 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AJ_%7B2n%7D%20&amp;=%20%5Cfrac%7B(2n-1)!!%7D%7B(2n)!!%7D%20%5Ccdot%20%5Cfrac%20%5Cpi%202%20%5C%5C%0AJ_%7B2n+1%7D%20&amp;=%20%5Cfrac%7B(2n)!!%7D%7B(2n+1)!!%7D%20%5Ccdot%201%0A%5Cend%7Baligned%7D%0A"></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>我们的思路是：先把一个 <img src="https://latex.codecogs.com/png.latex?%5Csin%20x"> 放进微分中，然后分部积分得到递推式．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AJ_n%20&amp;=%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Csin%5En%20x%20%5Coperatorname%7Bd%7D%5C!x%20%5C%5C%0A&amp;=%20-%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Csin%5E%7Bn-1%7D%20x%20%5Coperatorname%7Bd%7D%5C!%5Ccos%20x%20%5C%5C%0A&amp;=%20%5Cleft%5B%20-%20%5Csin%5E%7Bn-1%7D%20x%20%5Ccos%20x%20%5Cright%5D_%7B0%7D%5E%7B%5Cfrac%20%5Cpi%202%7D%20+%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Ccos%20x%20%5Coperatorname%7Bd%7D%5C!%5Csin%5E%7Bn-1%7D%20x%20%5C%5C%0A&amp;=%20(n-1)%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Ccos%5E2%20x%20%5Csin%5E%7Bn-2%7D%20x%20%5Coperatorname%7Bd%7D%5C!x%20%5C%5C%0A&amp;=%20(n-1)%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20(1%20-%20%5Csin%5E2%20x)%20%5Csin%5E%7Bn-2%7D%20x%20%5Coperatorname%7Bd%7D%5C!x%20%5C%5C%0A&amp;=%20(n-1)%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Csin%5E%7Bn-2%7D%20x%20%5Coperatorname%7Bd%7D%5C!x%20-%20(n-1)%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Csin%5En%20x%20%5Coperatorname%7Bd%7D%5C!x%20%5C%5C%0A&amp;=%20(n-1)%20J_%7Bn-2%7D%20-%20(n-1)%20J_n%0A%5Cend%7Baligned%7D%0A"></p>
<p>故 <img src="https://latex.codecogs.com/png.latex?%0AJ_n%20=%20%5Cfrac%7Bn-1%7D%7Bn%7D%20J_%7Bn-2%7D%0A"> 边界条件 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AJ_0%20&amp;=%20%5Cfrac%20%5Cpi%202%20%5C%5C%0AJ_1%20&amp;=%20%5Cint_0%5E%7B%5Cfrac%20%5Cpi%202%7D%20%5Csin%20x%20%5Coperatorname%7Bd%7D%5C!x%20=%201%0A%5Cend%7Baligned%7D%0A"> 代入递推式求解就得到了要证的结论．</p>
</div>
<div id="thm-wallis" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Wallis 公式) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%20%5Cpi%202%20=%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%201%20%7B2n+1%7D%20%5Cleft(%20%5Cfrac%7B(2n)!!%7D%7B(2n-1)!!%7D%20%5Cright)%5E2%0A"></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>注意到在积分区间上，<img src="https://latex.codecogs.com/png.latex?%5Csin%5En%20x%20%5Cgeq%20%5Csin%5E%7Bn+1%7D%20x">，由积分的单调性，<img src="https://latex.codecogs.com/png.latex?J_n"> 随 <img src="https://latex.codecogs.com/png.latex?n"> 单调递减，故 <img src="https://latex.codecogs.com/png.latex?J_%7B2n+1%7D%20%5Cleq%20J_%7B2n%7D%20%5Cleq%20J_%7B2n-1%7D"> 成立．代入 Lemma&nbsp;1 中得到的结果 <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B(2n)!!%7D%7B(2n+1)!!%7D%20%5Cleq%20%5Cfrac%7B(2n-1)!!%7D%7B(2n)!!%7D%20%5Ccdot%20%5Cfrac%20%5Cpi%202%20%5Cleq%20%5Cfrac%7B(2n-2)!!%7D%7B(2n-1)!!%7D%0A"> 移项得 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft(%20%5Cfrac%7B(2n)!!%7D%7B(2n-1)!!%7D%20%5Cright)%5E2%20%5Cfrac%7B1%7D%7B2n+1%7D%20%5Cleq%20%5Cfrac%20%5Cpi%202%20%5Cleq%20%5Cleft(%20%5Cfrac%7B(2n)!!%7D%7B(2n-1)!!%7D%20%5Cright)%5E2%20%5Cfrac%201%20%7B2n%7D%0A"></p>
<p>现在只需说明 RHS 与 LHS 的差是一个无穷小． <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cleft(%20%5Cfrac%7B(2n)!!%7D%7B(2n-1)!!%7D%20%5Cright)%5E2%20%5Cleft(%20%5Cfrac%201%20%7B2n%7D%20-%20%5Cfrac%201%20%7B2n+1%7D%20%20%5Cright)%0A&amp;=%20%5Cleft(%20%5Cfrac%7B(2n)!!%7D%7B(2n-1)!!%7D%20%5Cright)%5E2%20%5Cleft(%20%5Cfrac%201%20%7B2n(2n+1)%7D%20%5Cright)%20%5C%5C%0A&amp;=%20%5Cleft(%20%5Cfrac%7B(2n-2)!!%7D%7B(2n-1)!!%7D%20%5Cright)%5E2%20%5Cfrac%20%7B2n%7D%7B(2n+1)%7D%0A%5Cend%7Baligned%7D%0A"> 由 Example&nbsp;1 ，<img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B(2n-2)!!%7D%7B(2n-1)!!%7D%20=%200">，故上式确为一个无穷小，定理得证．</p>
</div>
<p>Wallis 公式还有其它表现形式： <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B2%5E%7B2n%7D%7D%7B%5Cbinom%7B2n%7D%7Bn%7D%7D%20=%20%5Cfrac%7B(2n)!!%7D%7B(2n-1)!!%7D%20%5Csim%20%5Csqrt%7B%5Cpi%20n%7D%20%5Cpod%7Bn%20%5Cto%20%5Cinfty%7D%0A"> 这里 Wallis 公式反映为对 Example&nbsp;1 和 Example&nbsp;2 的渐进估计．</p>
<div id="exr-catalan" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1 </strong></span>对 Catalan 数 <img src="https://latex.codecogs.com/png.latex?%0AC_n%20=%20%5Cbinom%7B2n%7D%7Bn%7D%20-%20%5Cbinom%7B2n%7D%7Bn+1%7D%0A"> 做出渐进估计．</p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>Solution</em>. </span>注意到 <img src="https://latex.codecogs.com/png.latex?%0AC_n%20=%20%5Cbinom%7B2n%7D%7Bn%7D%20-%20%5Cbinom%7B2n%7D%7Bn+1%7D%20=%20%5Cbinom%7B2n%7D%7Bn%7D%20-%20%5Cfrac%20n%20%7Bn+1%7D%20%5Cbinom%7B2n%7D%7Bn%7D%20=%20%5Cfrac%201%20%7Bn+1%7D%20%5Cbinom%7B2n%7D%7Bn%7D%0A"> 用 Wallis 公式计算即得 <img src="https://latex.codecogs.com/png.latex?%0AC_n%20%5Csim%20%5Cfrac%20%7B2%5E%7B2n%7D%7D%7B%5Csqrt%7B%5Cpi%7D%20n%5E%7B%5Cfrac%203%202%7D%7D%0A"></p>
</div>
<p>Wallis 公式的另一种表现形式是 <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%20%5Cpi%202%20=%20%5Cprod_%7Bn=1%7D%5E%5Cinfty%20%5Cfrac%7B4%20n%5E2%7D%7B4%20n%5E2-1%7D%20=%20%5Cprod_%7Bn=1%7D%5E%5Cinfty%20%5Cleft(%20%5Cfrac%7B2n%7D%7B2n-1%7D%20%5Ccdot%20%5Cfrac%7B2n%7D%7B2n+1%7D%20%5Cright)%0A"> 这表达式也被称为 Wallis product，用于近似计算 <img src="https://latex.codecogs.com/png.latex?%5Cpi">．</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>这和我们在 Example&nbsp;1 中使用的放缩技巧……</p>
</div>
</section>
<section id="stirling-公式" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="stirling-公式"><span class="header-section-number">3</span> Stirling 公式</h2>
<div id="lem-e" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 2 </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cleft(%201+%5Cfrac%201%20n%20%5Cright)%5En%20%3C%20e%20%3C%20%5Cleft(%201%20+%20%5Cfrac%201%20n%20%5Cright)%5E%7Bn+1%7D%0A"></p>
</div>
<p>这是《数学分析 I》中大家所熟知的．</p>
<div id="thm-stirling-weak" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Cleft(%5Cfrac%20n%20e%20%5Cright)%5En%20%3C%20%5Cfrac%20%7Bn!%7D%20e%0A%3C%20n%20%5Cleft(%20%5Cfrac%20n%20e%20%5Cright)%5En%0A"></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>将 Lemma&nbsp;2 写成 <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B(n+1)%5En%7D%7Bn%5En%7D%20%3C%20e%20%3C%20%5Cfrac%7B(n+1)%5E%7Bn+1%7D%7D%7Bn%5E%7Bn+1%7D%7D%0A"> 对 <img src="https://latex.codecogs.com/png.latex?k%20=%201,2,%20%5Cdots,%20n-1"> 做连乘 <img src="https://latex.codecogs.com/png.latex?%0A%5Cprod_%7Bk=1%7D%5E%7Bn-1%7D%20%5Cfrac%7B(k+1)%5Ek%7D%7Bk%5Ek%7D%20%3C%20e%5E%7Bn-1%7D%20%3C%20%5Cprod_%7Bk=1%7D%5E%7Bn-1%7D%20%5Cfrac%7B(k+1)%5E%7Bk+1%7D%7D%7Bk%5E%7Bk+1%7D%7D%0A"> 注意到乘积的相邻两项中，前一项的分子与后一项的分母可以约分，中间每项只余下 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%20k">，故上式可化为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7Bn%5E%7Bn-1%7D%7D%7B(n-1)!%7D%20%3C%20e%5E%7Bn-1%7D%20%3C%20%5Cfrac%7Bn%5En%7D%7B(n-1)!%7D%0A"> 两端再同乘 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7Bn!%7D%7Be%5E%7Bn%7D%7D"> 就得到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft(%5Cfrac%20n%20e%20%5Cright)%5En%20%3C%20%5Cfrac%20%7Bn!%7D%20e%0A%3C%20n%20%5Cleft(%20%5Cfrac%20n%20e%20%5Cright)%5En%0A"></p>
</div>
<div id="thm-stirling" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (Stirling 公式) </strong></span><img src="https://latex.codecogs.com/png.latex?%0An!%20%5Csim%20%5Csqrt%7B2%20%5Cpi%20n%7D%20%5Cleft(%20%5Cfrac%20n%20e%20%5Cright)%5En%20%5Cpod%7Bn%20%5Cto%20%5Cinfty%7D%0A"></p>
</div>
<p>完整证明较复杂，这里介绍证明最后一步：已知 <img src="https://latex.codecogs.com/png.latex?n!%20%5Csim%20a%20%5Csqrt%20n%20%5Cleft(%20%5Cfrac%20n%20e%20%5Cright)%5En">，用 Wallis 公式对 <img src="https://latex.codecogs.com/png.latex?2%5E%7B2n%7D%20/%20%5Cbinom%7B2n%7D%7Bn%7D"> 的渐进估计确定系数 <img src="https://latex.codecogs.com/png.latex?a">．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csqrt%7B%5Cpi%20n%7D%20%5Csim%20%5Cfrac%20%7B2%5E%7B2n%7D%7D%7B%5Cbinom%7B2n%7D%7Bn%7D%7D%20=%20%5Cfrac%7B2%5E%7B2n%7D%20(n!)%5E2%7D%7B(2n)!%7D%20%5Csim%20%5Cfrac%7B2%5E%7B2n%7D%20(a%20%5Csqrt%20n%20n%5En%20e%5E%7B-n%7D)%5E2%7D%7Ba%20%5Csqrt%7B2n%7D%202%5E%7B2n%7D%20n%5E%7B2n%7D%20e%5E%7B-2n%7D%7D%20=%20%5Csqrt%7B%5Cfrac%20n%202%7D%20a%0A"></p>
<p>因此 <img src="https://latex.codecogs.com/png.latex?a=%5Csqrt%7B2%20%5Cpi%7D">．</p>
<div id="exm-stirling-binomial" class="theorem example">
<p><span class="theorem-title"><strong>Example 3 </strong></span>当 <img src="https://latex.codecogs.com/png.latex?n%20%5Cto%20%5Cinfty">，<img src="https://latex.codecogs.com/png.latex?k%20%5Cto%20%5Cinfty"> 时，用 Stirling 公式渐进估计 <img src="https://latex.codecogs.com/png.latex?%5Cbinom%20n%20k">．</p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>Solution</em>. </span><img src="https://latex.codecogs.com/png.latex?%0A%5Cbinom%20n%20k%20%5Csim%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20%5Cpi%20k%20(n-k)%7D%7D%20%5Cfrac%7Bn%5En%7D%7Bk%5Ek%20(n-k)%5E%7Bn-k%7D%7D%0A"></p>
</div>
</section>
<section id="poisson-分布" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="poisson-分布"><span class="header-section-number">4</span> Poisson 分布</h2>
<p>描述单位时间平均发生次数恒定的随机事件的概率分布．</p>
<div id="def-poission" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Poisson 分布) </strong></span>若离散随机变量 <img src="https://latex.codecogs.com/png.latex?X"> 满足 <img src="https://latex.codecogs.com/png.latex?%0AP(X%20=%20k)%20=%20%5Cfrac%7B%5Clambda%5Ek%7D%7Bk!%7De%5E%7B-%5Clambda%7D%0A"> 其中 <img src="https://latex.codecogs.com/png.latex?%5Clambda%20%3E%200"> 是确定的常数，则随机变量 <img src="https://latex.codecogs.com/png.latex?X"> 服从 Poisson 分布．</p>
</div>
<section id="从二项分布的推导" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="从二项分布的推导"><span class="header-section-number">4.1</span> 从二项分布的推导</h3>
<p>在 <img src="https://latex.codecogs.com/png.latex?np%20=%20%5Clambda"> 的条件下，取 <img src="https://latex.codecogs.com/png.latex?P(X_n%20=%20k)%20=%20%5Cbinom%20n%20k%20p%5Ek%20(1-p)%5E%7Bn-k%7D"> 在 <img src="https://latex.codecogs.com/png.latex?n%20%5Cto%20%5Cinfty"> 在 <img src="https://latex.codecogs.com/png.latex?n%20%5Cto%20%5Cinfty"> 上的逐点极限．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AP(X_n%20=%20k)%0A&amp;=%20%5Cbinom%7Bn%7D%7Bk%7D%20p%5Ek%20(1-p)%5E%7Bn-k%7D%20%5C%5C%0A&amp;=%20%5Cbinom%7Bn%7D%7Bk%7D%20%5Cfrac%7B%5Clambda%5Ek%7D%7Bn%5Ek%7D%20%5Cleft(%201-%5Cfrac%20%5Clambda%20n%20%5Cright)%5E%7Bn-k%7D%20%5C%5C%0A&amp;=%20%5Clambda%5Ek%20%5Cleft(%201-%5Cfrac%20%5Clambda%20n%20%5Cright)%5En%20%5Cleft(%201-%5Cfrac%20%5Clambda%20n%20%5Cright)%5E%7B-k%7D%20%5Cbinom%7Bn%7D%7Bk%7D%20%5Cfrac%7B1%7D%7Bn%5Ek%7D%20%5C%5C%0A&amp;%5Csim%20%5Clambda%5Ek%20e%5E%7B-%5Clambda%7D%5Cbinom%7Bn%7D%7Bk%7D%20%5Cfrac%201%20%7Bn%5Ek%7D%20%5C%5C%0A&amp;=%20%5Clambda%5Ek%20e%5E%7B-%5Clambda%7D%20%5Cfrac%20%7Bn%20(n-1)%20%5Cdots%20(n-k+1)%7D%7Bk!%20n%5Ek%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B%5Clambda%5Ek%7D%7Bk!%7D%20e%5E%7B-%5Clambda%7D%20%5Ccdot%201%20%5Ccdot%20(1-%5Cfrac%201%20n)%20%5Cdots%20(1%20-%20%5Cfrac%7Bk-1%7D%7Bn%7D)%20%5C%5C%0A&amp;%5Csim%20%5Cfrac%7B%5Clambda%5Ek%7D%7Bk!%7D%20e%5E%7B-%5Clambda%7D%0A%5Cend%7Baligned%7D%0A"></p>
</section>
<section id="归一性验证" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="归一性验证"><span class="header-section-number">4.2</span> 归一性验证</h3>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20P(X%20=%20k)%20=%20%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20%5Cfrac%7B%5Clambda%5Ek%7D%7Bk!%7De%5E%7B-%5Clambda%7D%20=%20%20e%5E%7B-%5Clambda%7D%20%5Csum_%7Bk=0%7D%5E%7B+%5Cinfty%7D%20%5Cfrac%7B%5Clambda%5Ek%7D%7Bk!%7D%20=%20e%5E%7B-%5Clambda%7D%20e%5E%7B%5Clambda%7D%20=%201%0A"></p>
</section>
</section>
<section id="正态分布" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="正态分布"><span class="header-section-number">5</span> 正态分布</h2>
<p>与 Poisson 分布不同，（标准）正态分布是在 <img src="https://latex.codecogs.com/png.latex?n%20%5Cto%20%5Cinfty"> 的过程中假定 <img src="https://latex.codecogs.com/png.latex?p"> 不变的情况下，对归一化（即假定期望和方差不变）后的 <img src="https://latex.codecogs.com/png.latex?X_n"> 取逐点极限得到的．</p>
<div id="def-poission" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2 (正态分布) </strong></span>若连续随机变量 <img src="https://latex.codecogs.com/png.latex?X"> 的期望 <img src="https://latex.codecogs.com/png.latex?E(X)%20=%20%5Cmu">，方差 <img src="https://latex.codecogs.com/png.latex?D(X)%20=%20%5Csigma">，且其概率分布函数为 <img src="https://latex.codecogs.com/png.latex?%0Af(x)%20=%20%5Cfrac%201%20%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B(x-%5Cmu)%5E2%7D%7B2%20%5Csigma%5E2%7D%5Cright)%0A"> 则变量 <img src="https://latex.codecogs.com/png.latex?X"> 服从正态分布，记为 <img src="https://latex.codecogs.com/png.latex?X%20%5Csim%20N(%5Cmu,%20%5Csigma%5E2)">．</p>
<p>特别的，当 <img src="https://latex.codecogs.com/png.latex?%5Cmu%20=%200">，<img src="https://latex.codecogs.com/png.latex?%5Csigma%20=%201"> 时，变量 <img src="https://latex.codecogs.com/png.latex?X"> 服从标准正态分布 <img src="https://latex.codecogs.com/png.latex?%0Af(x)%20=%20%5Cfrac%201%20%7B%5Csqrt%7B2%20%5Cpi%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D%20x%5E2%5Cright)%0A"></p>
</div>
<section id="从二项分布的推导de-moivre-laplace-定理" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="从二项分布的推导de-moivre-laplace-定理"><span class="header-section-number">5.1</span> 从二项分布的推导（de Moivre-Laplace 定理）</h3>
<p>设随机变量 <img src="https://latex.codecogs.com/png.latex?X_n%20%5Csim%20B(n,p)">．方便起见，令 <img src="https://latex.codecogs.com/png.latex?q%20=%201-p">．众所周知，二项分布的期望与方差满足 <img src="https://latex.codecogs.com/png.latex?E(X_n)%20=%20np">，<img src="https://latex.codecogs.com/png.latex?D(X_n)%20=%20npq">．</p>
<p>对随机变量 <img src="https://latex.codecogs.com/png.latex?X_n"> 做归一化： <img src="https://latex.codecogs.com/png.latex?%0A%5Cbar%20X_n%20=%20%5Cfrac%7BX_n%20-%20E(X_n)%7D%7B%5Csqrt%7BD(X_n)%7D%7D%20=%20%5Cfrac%7BX_n%20-%20np%7D%7B%5Csqrt%7Bnpq%7D%7D%0A"> 考虑到 <img src="https://latex.codecogs.com/png.latex?%0AP(%5Cbar%20X_n%20=%20x)%20=%20P(X_n%20=%20np%20+%20x%20%5Csqrt%7Bnpq%7D)%0A"> 令 <img src="https://latex.codecogs.com/png.latex?k%20=%20np%20+%20x%20%5Csqrt%7Bnpq%7D">，则 <img src="https://latex.codecogs.com/png.latex?%0AP(%5Cbar%20X_n%20=%20x)%20=%20P(X_n%20=%20k)%20=%20%5Cbinom%7Bn%7D%7Bk%7D%20p%5Ek%20q%5E%7Bn-k%7D%0A"> 此时 <img src="https://latex.codecogs.com/png.latex?n,k"> 均趋于无穷大，故可应用 Example&nbsp;3 对二项式系数做出估计 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cbinom%7Bn%7D%7Bk%7D%20p%5Ek%20q%5E%7Bn-k%7D%0A&amp;%5Csim%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20%5Cpi%20k%20(n-k)%7D%7D%20%5Cfrac%7Bn%5En%7D%7Bk%5Ek%20(n-k)%5E%7Bn-k%7D%7D%20p%5Ek%20q%5E%7Bn-k%7D%20%5C%5C%0A&amp;=%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20%5Cpi%20k%20(n-k)%7D%7D%20%5Cleft(%20%5Cfrac%7Bnp%7D%7Bk%7D%20%5Cright)%5E%7Bk%7D%20%5Cleft(%20%5Cfrac%7Bnq%7D%7Bn-k%7D%20%5Cright)%5E%7Bn-k%7D%20%5C%5C%0A&amp;=%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20%5Cpi%20k%20(n-k)%7D%7D%20%5Cexp%7B%5Cleft(%20k%20%5Cln%7B%5Cfrac%7Bnp%7D%7Bk%7D%7D%20+%20(n-k)%20%5Cln%7B%5Cfrac%7Bnq%7D%7Bn-k%7D%7D%20%5Cright)%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p>下面分别处理 <img src="https://latex.codecogs.com/png.latex?k%20%5Cln%7B%5Cfrac%7Bnp%7D%7Bk%7D%7D"> 和 <img src="https://latex.codecogs.com/png.latex?(n-k)%20%5Cln%7B%5Cfrac%7Bnq%7D%7Bn-k%7D%7D">．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0Ak%20%5Cln%7B%5Cfrac%7Bnp%7D%7Bk%7D%7D%0A&amp;=%20-(np%20+%20x%20%5Csqrt%7Bnpq%7D)%20%5Cln%7B%5Cfrac%7Bnp%20+%20x%20%5Csqrt%7Bnpq%7D%7D%7Bnp%7D%7D%20%5C%5C%0A&amp;=%20-(np%20+%20x%20%5Csqrt%7Bnpq%7D)%20%5Cln%7B%5Cleft(%201%20+%20x%20%5Csqrt%7B%5Cfrac%20q%20%7Bnp%7D%7D%20%5Cright)%7D%20%5C%5C%0A&amp;=%20-(np%20+%20x%20%5Csqrt%7Bnpq%7D)%20%5Cleft(%20x%20%5Csqrt%7B%5Cfrac%20q%20%7Bnp%7D%7D%20-%20%5Cfrac%7Bx%5E2%20q%7D%7B2np%7D%20+%20o%5Cleft(%20%5Cfrac%201%20n%20%5Cright)%20%5Cright)%20%5C%5C%0A&amp;=%20-x%20%5Csqrt%7Bnpq%7D%20+%20%5Cfrac%7B1%7D%7B2%7D%20x%5E2%20q%20-%20x%5E2%20q%20+%20o(1)%0A%5Cend%7Baligned%7D%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A(n-k)%20%5Cln%7B%5Cfrac%7Bnq%7D%7Bn-k%7D%7D%0A&amp;=%20-(nq%20-%20x%20%5Csqrt%7Bnpq%7D)%20%5Cln%7B%5Cfrac%7Bnq%20-%20x%20%5Csqrt%7Bnpq%7D%7D%7Bnq%7D%7D%20%5C%5C%0A&amp;=%20-(nq%20-%20x%20%5Csqrt%7Bnpq%7D)%20%5Cln%7B%5Cleft(%201%20-%20x%20%5Csqrt%7B%5Cfrac%20p%20%7Bnq%7D%7D%20%5Cright)%7D%20%5C%5C%0A&amp;=%20(nq%20-%20x%20%5Csqrt%7Bnpq%7D)%20%5Cleft(%20x%20%5Csqrt%7B%5Cfrac%20p%20%7Bnq%7D%7D%20+%20%5Cfrac%7Bx%5E2%20p%7D%7B2nq%7D%20+%20o%5Cleft(%20%5Cfrac%201%20n%20%5Cright)%20%5Cright)%20%5C%5C%0A&amp;=%20x%20%5Csqrt%7Bnpq%7D%20+%20%5Cfrac%7B1%7D%7B2%7D%20x%5E2%20p%20-%20x%5E2%20p%20+%20o(1)%0A%5Cend%7Baligned%7D%0A"></p>
<p>因此 <img src="https://latex.codecogs.com/png.latex?%0Ak%20%5Cln%7B%5Cfrac%7Bnp%7D%7Bk%7D%7D%20+%20(n-k)%20%5Cln%7B%5Cfrac%7Bnq%7D%7Bn-k%7D%7D%20=%20-%20%5Cfrac%7B1%7D%7B2%7D%20x%5E2%20(p+q)%20+%20o(1)%20=%20-%20%5Cfrac%201%202%20x%5E2%20+%20o(1)%0A"></p>
<p>下面处理 <img src="https://latex.codecogs.com/png.latex?%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20%5Cpi%20k%20(n-k)%7D%7D">．</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20%5Cpi%20k%20(n-k)%7D%7D%0A&amp;=%20%5Csqrt%7B%5Cfrac%7Bn%7D%7B2%20%5Cpi%20(np%20+%20x%20%5Csqrt%7Bnpq%7D)%20(nq%20-%20x%20%5Csqrt%7Bnpq%7D)%7D%7D%20%5C%5C%0A&amp;=%20%5Csqrt%7B%5Cfrac%7B1%7D%7B2%20%5Cpi%20(p%20+%20x%20%5Csqrt%7B%5Cfrac%7Bpq%7D%7Bn%7D%7D)%20(q%20-%20x%20%5Csqrt%7B%5Cfrac%7Bpq%7D%7Bn%7D%7D)%7D%7D%20%5C%5C%0A&amp;=%20%5Csqrt%7B%5Cfrac%7B1%7D%7B2%20%5Cpi%20n%20p%20q%20+%20o(1)%7D%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p>将上述结果代回，我们就得到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cbinom%7Bn%7D%7Bk%7D%20p%5Ek%20q%5E%7Bn-k%7D%0A&amp;%5Csim%20%5Csqrt%7B%5Cfrac%7B1%7D%7B2%20%5Cpi%20n%20p%20q%20+%20o(1)%7D%7D%20%5Cexp%7B%5Cleft(%20-%20%5Cfrac%201%202%20x%5E2%20+%20o(1)%20%5Cright)%7D%20%5C%5C%0A&amp;%5Csim%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%20n%20p%20q%7D%7D%20%5Cexp%7B%5Cleft(%20-%20%5Cfrac%201%202%20x%5E2%20%5Cright)%7D%0A%5Cend%7Baligned%7D%0A"> 即 <img src="https://latex.codecogs.com/png.latex?%0AP(%5Cbar%20X_n%20=%20x)%20=%20P(X_n%20=%20k)%20%5Csim%20%5Cfrac%201%20%7B%5Csqrt%7B2%20%5Cpi%20npq%7D%7D%20%5Cexp%20%5Cleft(%20-%7B%5Cfrac%201%202%20x%5E2%7D%20%5Cright)%20=%20%5Cfrac%201%20%7B%5Csqrt%7B2%20%5Cpi%20npq%7D%7D%20%5Cexp%20%5Cleft(%20-%5Cfrac%7B(k-np)%5E2%7D%7B2npq%7D%20%5Cright)%0A"> 这正是我们想要的．</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>细心的同学可能会对式子前边的系数仍是 <img src="https://latex.codecogs.com/png.latex?n%20%5Cto%20%5Cinfty"> 时的无穷小产生疑问．事实上，在将 <img src="https://latex.codecogs.com/png.latex?X_n"> 归一化为 <img src="https://latex.codecogs.com/png.latex?%5Cbar%20X_n"> 的过程中，我们将整个变量“压缩”至原来的 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B%5Csqrt%7Bnpq%7D%7D">，因此前面的系数可以理解为一种类似 <img src="https://latex.codecogs.com/png.latex?%5Coperatorname%7Bd%7D%5C!x"> 的存在．关于归一化的直观理解，3Blue1Brown 的中心极限定理视频<span class="citation" data-cites="3b1b-clt">[3]</span>提供了很好的讲解．</p>
<p>更形式化的，由于归一化得到的离散型随机变量 <img src="https://latex.codecogs.com/png.latex?%5Cbar%20X_n"> 在 <img src="https://latex.codecogs.com/png.latex?n%20%5Cto%20%5Cinfty"> 的过程中已经变成连续型随机变量 <img src="https://latex.codecogs.com/png.latex?X">，我们研究的对象也应从单点转向区间．因此，对 <img src="https://latex.codecogs.com/png.latex?X_n"> 与 <img src="https://latex.codecogs.com/png.latex?%5Cbar%20X_n"> 概率分布的叙述做一点变动 <img src="https://latex.codecogs.com/png.latex?%0AP%5Cleft(x%20%5Cleq%20%5Cbar%20X_n%20%3C%20x%20+%20%5Cfrac%201%20%7B%5Csqrt%7Bnpq%7D%7D%5Cright)%0A=%20P%5Cleft(k%20%5Cleq%20X_n%20%3C%20k%20+%201%20%5Cright)%0A=%20P(X_n=k)%20%5Csim%20%5Cfrac%201%20%7B%5Csqrt%7B2%20%5Cpi%20npq%7D%7D%20%5Cexp%20%5Cleft(%20-%7B%5Cfrac%201%202%20x%5E2%7D%20%5Cright)%0A"> 令区间大小趋于 <img src="https://latex.codecogs.com/png.latex?0"> 就得到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0Af(x)%20&amp;=%20%5Clim_%7Bh%20%5Cto%200%7D%7B%5Cfrac%7BP(x%20%5Cleq%20X%20%3C%20x+h)%7D%7Bh%7D%7D%20%5C%5C%0A&amp;=%20%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Csqrt%7Bnpq%7D%20%5Ccdot%20P%5Cleft(x%20%5Cleq%20%5Cbar%20X_n%20%3C%20x%20+%20%5Cfrac%201%20%7B%5Csqrt%7Bnpq%7D%7D%5Cright)%20%5C%5C%0A&amp;=%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Csqrt%7Bnpq%7D%20%5Ccdot%20%5Cfrac%201%20%7B%5Csqrt%7B2%20%5Cpi%20npq%7D%7D%20%5Cexp%20%5Cleft(%20-%7B%5Cfrac%201%202%20x%5E2%7D%20%5Cright)%20&amp;%20%5Cdots%20%5Ctext%7B%E8%BF%99%E9%87%8C%20$%5Csim$%20%E8%A1%A8%E7%8E%B0%E4%B8%BA%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E6%9B%BF%E6%8D%A2%7D%20%5C%5C%0A&amp;=%20%5Cfrac%201%20%7B%5Csqrt%7B2%20%5Cpi%7D%7D%20%5Cexp%20%5Cleft(%20-%7B%5Cfrac%201%202%20x%5E2%7D%20%5Cright)%0A%5Cend%7Baligned%7D%0A"> 这才是我们真正想要的，由二项分布归一化后取极限得到的，标准正态分布的概率密度函数．</p>
</div>
</section>
</section>
<section id="challenge" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="challenge"><span class="header-section-number">6</span> Challenge</h2>
<p>选讲或留作课后讨论．</p>
<section id="中心极限定理要求下正态分布的唯一性" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="中心极限定理要求下正态分布的唯一性"><span class="header-section-number">6.1</span> 中心极限定理要求下正态分布的唯一性</h3>
<p>正态分布概率密度函数 <img src="https://latex.codecogs.com/png.latex?e%5E%7B-x%5E2%7D"> 的形式是如何被确定的？怎么说明这形式是满足中心极限定理的独一无二的概率密度函数？</p>
<p>3Blue1Brown 关于正态分布的系列视频较完整的解答了上述疑问，下面是推导思路的提纲．</p>
<p>首先需要意识到，随机变量之和的概率分布即原变量概率密度函数的卷积．</p>
<p>形式化的唯一性证明一般分为两步：</p>
<ul>
<li>使用 moment generating function 的方法证明，任一分布的概率密度函数的各次卷积所构成的函数列一定收敛，且收敛至的函数与初始选取的分布无关．</li>
<li>验证正态分布概率密度函数的卷积仍有 <img src="https://latex.codecogs.com/png.latex?e%5E%7B-x%5E2%7D"> 的形式．</li>
</ul>
<p>这是严谨但并不令人满意的．我们需要更“几何”化的理解来理解 <img src="https://latex.codecogs.com/png.latex?e%5E%7B-x%5E2%7D"> 的这种唯一性，即为什么只有 <img src="https://latex.codecogs.com/png.latex?e%5E%7B-x%5E2%7D"> 在卷积下具有形式不变性．（需要指出的是，3Blue1Brown 的系列视频中，下面部分的严谨性不够充分，有待进一步研究）</p>
<p>Herschel-Maxwell derivation 指出，若二维概率分布满足以下两个条件：</p>
<ul>
<li>该分布具有各向同性，即该二维分布概率密度函数在某点处的取值只与该点离原点的距离有关</li>
<li>分布关于 <img src="https://latex.codecogs.com/png.latex?x,y"> 坐标轴独立，即该二维分布的概率密度函数可写为 <img src="https://latex.codecogs.com/png.latex?f(x)f(y)"> 的形式．</li>
</ul>
<p>则一维情形下此分布的概率密度函数被唯一地确定为具有 <img src="https://latex.codecogs.com/png.latex?f(x)%20=%20e%5E%7Bc%20x%5E2%7D"> 的形式．当然需要假设 <img src="https://latex.codecogs.com/png.latex?f(x)"> 连续，并在最后做归一化处理．</p>
<p>两个随机变量 <img src="https://latex.codecogs.com/png.latex?X,Y"> 的和 <img src="https://latex.codecogs.com/png.latex?X+Y"> 的概率密度函数可被视为这两个随机变量的 Descartes 积 <img src="https://latex.codecogs.com/png.latex?(X,Y)"> 的二元概率密度函数“切片”并按面积（除掉 <img src="https://latex.codecogs.com/png.latex?%5Csqrt%202"> 的常数因子后）“投影”至 <img src="https://latex.codecogs.com/png.latex?y=-x"> 上的结果．</p>
<p>考虑中心极限定理．两个独立同分布变量相加，这已经满足了二维分布独立性的要求．若考虑要求卷积后形式不变，也有必要要求二维分布的各项同性（这样一来，沿 <img src="https://latex.codecogs.com/png.latex?y=-x"> 方向的“切片”的形状与坐标轴向的“切片”只有一个常数因子 <img src="https://latex.codecogs.com/png.latex?%5Csqrt%202"> 的差别）．因此，中心极限定理某种意义上正好对应了 Herschel-Maxwell derivation 的要求，从而唯一确定了正态分布概率密度函数 <img src="https://latex.codecogs.com/png.latex?e%5E%7B-x%5E2%7D"> 的形式．</p>
</section>
<section id="正态分布的归一性验证maxwell-速率分布与高维球体表面积" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="正态分布的归一性验证maxwell-速率分布与高维球体表面积"><span class="header-section-number">6.2</span> 正态分布的归一性验证、Maxwell 速率分布与高维球体表面积</h3>
<p>Guass 积分： <img src="https://latex.codecogs.com/png.latex?%0A%5Cint_%7B-%5Cinfty%7D%5E%7B+%5Cinfty%7D%20e%5E%7B-x%5E2%7D%20%5Coperatorname%7Bd%7D%5C!x%20=%20%5Csqrt%20%5Cpi%0A"></p>
<p>Maxwell 速率分布： <img src="https://latex.codecogs.com/png.latex?%0Af(v)%20=%204%20%5Cpi%20v%5E2%20%5Cleft(%20%5Cfrac%7Bm%7D%7B2%20%5Cpi%20kT%7D%20%5Cright)%5E%7B%5Cfrac%203%202%7D%20%5Cexp%20%5Cleft(%20-%20%5Cfrac%7Bm%7D%7B2kT%7Dv%5E2%20%5Cright)%0A"></p>
<p>以及它们与高维球体表面积的联系涉及多元积分学的内容．参见 3Blue1Brown 有关 <img src="https://latex.codecogs.com/png.latex?%5Cpi"> 与正态分布的视频<span class="citation" data-cites="3b1b-pi">[4]</span>．</p>
</section>
<section id="n-的其它估计" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="n-的其它估计"><span class="header-section-number">6.3</span> <img src="https://latex.codecogs.com/png.latex?n!"> 的其它估计</h3>
<p>一种更容易想到的做法是 <img src="https://latex.codecogs.com/png.latex?%0An%20%5Cln%20n%20-%20n%20-%201%20=%20%5Cint_1%5En%20%5Cln%20x%20%5Coperatorname%7Bd%7D%5C!x%20%5Cleq%0A%5Cln%20n!%20=%20%5Csum_%7Bk=1%7D%5En%20%5Cln%20k%0A%5Cleq%20%5Cint_1%5E%7Bn+1%7D%20%5Cln%20x%20%5Coperatorname%7Bd%7D%5C!x%20=%20(n+1)%20%5Cln%20(n+1)%20-%20n%20-%202%0A"> 从而 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft(%20%5Cfrac%20n%20e%20%5Cright)%5En%20%5Cleq%20e%20%5Ccdot%20n!%20%5Cleq%20%5Cleft(%5Cfrac%7Bn+1%7D%7Be%7D%5Cright)%5E%7Bn+1%7D%0A"> 当然这比 Theorem&nbsp;2 的估计稍差．</p>
<p>更多估计可参考这篇文章<span class="citation" data-cites="hijjjjq">[5]</span>．</p>
</section>
<section id="wallis-公式的其它证明" class="level3" data-number="6.4">
<h3 data-number="6.4" class="anchored" data-anchor-id="wallis-公式的其它证明"><span class="header-section-number">6.4</span> Wallis 公式的其它证明</h3>
<p>3Blue1Brown 频道提供了一个几何风格的证明<span class="citation" data-cites="3b1b-wallis">[6]</span>，其与 Bassel 问题的 Euler 解法有着神秘的联系．事实上，Euler 对 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Csin%20x%7D%7Bx%7D"> 的无穷乘积拆解也可用于证明 Wallis product，参见 Wikipedia<span class="citation" data-cites="wp-wallis">[7]</span>．</p>
</section>
<section id="wallis-公式视角下三阶乘与中心三项式系数的渐进估计" class="level3" data-number="6.5">
<h3 data-number="6.5" class="anchored" data-anchor-id="wallis-公式视角下三阶乘与中心三项式系数的渐进估计"><span class="header-section-number">6.5</span> Wallis 公式视角下三阶乘与中心三项式系数的渐进估计</h3>
<div id="exr-triple-factorial-1" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2 </strong></span>求 <img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B(3n-2)!!!%7D%7B(3n)!!!%7D%20=%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B1%20%5Ctimes%204%20%5Ctimes%207%20%5Ctimes%20%5Cdots%20%5Ctimes%20(3n-2)%7D%7B3%20%5Ctimes%206%20%5Ctimes%209%20%5Ctimes%20%5Cdots%20%5Ctimes%203n%7D%0A"> 并对其做出渐进估计．</p>
</div>
<div id="exr-triple-factorial-2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 3 </strong></span>求 <img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B(3n-1)!!!%7D%7B(3n)!!!%7D%20=%20%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B2%20%5Ctimes%205%20%5Ctimes%208%20%5Ctimes%20%5Cdots%20%5Ctimes%20(3n-1)%7D%7B3%20%5Ctimes%206%20%5Ctimes%209%20%5Ctimes%20%5Cdots%20%5Ctimes%203n%7D%0A"> 并对其做出渐进估计．</p>
</div>
<div id="exr-trinomial" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 4 </strong></span>求 <img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B(3n)!%20/%20(n!)%5E3%7D%7B3%5E%7B3n%7D%7D%0A"> 并对其做出渐进估计．</p>
</div>
<p>用 Stirling 公式计算得到的结果是 <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Csqrt%203%7D%7B2%20%5Cpi%20n%7D%0A"> 但在 Wallis 公式的视角下如何获得？</p>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="acknowledgments" class="level2 appendix" data-number="7"><h2 class="anchored quarto-appendix-heading"><span class="header-section-number">7</span> Acknowledgments</h2><div class="quarto-appendix-contents">

<p>感谢吕老师组织<del>我最喜欢的</del>研讨课环节．此外，Example&nbsp;1 的放缩技巧由“吸取教训”同学提供，Poisson 分布的二项分布推导是与“抱头蹲防”同学讨论的结果，在此表示感谢．</p>



</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-analysis" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">张筑生, <em>数学分析新讲（重排本）（第二册）</em>, 2nd ed. 北京: 北京大学出版社, 2021.</div>
</div>
<div id="ref-prob" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">张颢, <em>概率论</em>. 北京: 高等教育出版社, 2018.</div>
</div>
<div id="ref-3b1b-clt" class="csl-entry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">3Blue1Brown, <span>“Why is the "central limit" a normal distribution?”</span> <a href="https://www.youtube.com/watch?v=d_qvLDhkg00" class="uri">https://www.youtube.com/watch?v=d_qvLDhkg00</a>, 2023.</div>
</div>
<div id="ref-3b1b-pi" class="csl-entry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">3Blue1Brown, <span>“Why π is in the normal distribution (beyond integral tricks).”</span> <a href="https://www.youtube.com/watch?v=cy8r7WSuT1I" class="uri">https://www.youtube.com/watch?v=cy8r7WSuT1I</a>, 2023.</div>
</div>
<div id="ref-hijjjjq" class="csl-entry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">hijjjjq, <span>“对n的阶乘（n!）进行估计.”</span> <a href="https://zhuanlan.zhihu.com/p/552658420" class="uri">https://zhuanlan.zhihu.com/p/552658420</a>, 2022.</div>
</div>
<div id="ref-3b1b-wallis" class="csl-entry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">3Blue1Brown, <span>“The wallis product for pi, proved geometrically.”</span> <a href="https://www.youtube.com/watch?v=8GPy_UMV-08" class="uri">https://www.youtube.com/watch?v=8GPy_UMV-08</a>, 2018.</div>
</div>
<div id="ref-wp-wallis" class="csl-entry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">Wikipedia, <span>“Wallis product.”</span> <a href="https://en.wikipedia.org/wiki/Wallis_product#Proof_using_Euler's_infinite_product_for_the_sine_function" class="uri">https://en.wikipedia.org/wiki/Wallis_product#Proof_using_Euler's_infinite_product_for_the_sine_function</a>.</div>
</div>
</div></section></div> ]]></description>
  <category>数学</category>
  <category>讲稿</category>
  <guid>https://blog.sun123zxy.top/posts/20230423-stirling/index.html</guid>
  <pubDate>Sat, 22 Apr 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>OI 数论中的上界估计与时间复杂度证明</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230418-complexity/index.html</link>
  <description><![CDATA[ 



<div class="hidden">
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cnewcommand%7B%5Cfloor%7D%5B1%5D%7B%5Cleft%5Clfloor%20#1%20%5Cright%5Crfloor%7D%0A"></p>
</div>
<section id="预备" class="level2" data-number="">
<h2 data-number="" class="anchored" data-anchor-id="预备"><span class="header-section-number"></span> 预备</h2>
<section id="渐进符号" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="渐进符号"><span class="header-section-number">0.1</span> 渐进符号</h3>
<p>其实不少高等数学 / 数学分析教材在讲解无穷小的比较时已经相当严谨地介绍过大 O、小 O 记号，然而各种历史习惯记法的符号滥用（abuse of notation）<span class="citation" data-cites="wikipedia_abuse">[1]</span> 直到现在都让笔者头疼. These notations seem to be innocent, but can be catastrophic without careful manipulation. For example,</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?%0An%20=%20O(n%5E2)%20%5Cland%20n%5E2%20=%20O(n%5E2)%20%5Cimplies%20n%20=%20n%5E2%0A"></p>
<p>Knuth 在《具体数学》里举出的例子 <span class="citation" data-cites="concretemath_onotation">[2]</span>. “<img src="https://latex.codecogs.com/png.latex?=">” 隐含的对称性使其在 <img src="https://latex.codecogs.com/png.latex?g(x)%20=%20O(f(x))"> 中格格不入. 事实上，将 <img src="https://latex.codecogs.com/png.latex?O(f(x))"> 看作“阶不高于 <img src="https://latex.codecogs.com/png.latex?f(x)"> 的所有函数的集合”是比“某个阶不高于 <img src="https://latex.codecogs.com/png.latex?f(x)"> 的函数”更严谨的理解. 因此，本文将使用 <img src="https://latex.codecogs.com/png.latex?f(x)%20%5Cin%20O(g(x))"> （有时也记为 <img src="https://latex.codecogs.com/png.latex?O(f(x))%20%5Csubset%20O(g(x))">）的集合论符号代替传统的 <img src="https://latex.codecogs.com/png.latex?f(x)%20=%20O(g(x))"> 记法.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?%0An%5E2%20%5Csin%20n%20%5Cin%20O(n%5E2)%20%5Cimplies%20%5Csum_%7Bi=1%7D%5En%20i%5E2%20%5Csin%20i%20%5Cin%20%5Csum_%7Bi=1%7D%5En%20O(i%5E2)%20%5Csubset%20O%5Cleft(%20%5Csum_%7Bi=1%7D%5En%20i%5E2%20%5Cright)%20%5Csubset%20O(n%5E3)%0A"> 或更一般的， <img src="https://latex.codecogs.com/png.latex?%0Ag(x)%20%5Cin%20O(f(x))%20%5Cimplies%20%5Csum_%7BP(n,i)%7D%20g(i)%20%5Cin%20%5Csum_%7BP(n,i)%7D%20O(f(i))%20%5Csubset%20O%20%5Cleft(%5Csum_%7BP(n,i)%7D%20f(i)%20%5Cright)%0A"></p>
<p>没看出有啥问题，对吧？笔者在写作此文时犯了同样的错误. 请注意，大 O 记号的作用对象是函数，<img src="https://latex.codecogs.com/png.latex?f(i)"> 是什么？它只是个函数值，是确定的数——这是因为 <img src="https://latex.codecogs.com/png.latex?i"> 也是求和枚举中确定的数，而不是 <img src="https://latex.codecogs.com/png.latex?n"> 这种真正代表变元的记号. 所以 <img src="https://latex.codecogs.com/png.latex?O(f(i))"> 是什么？它什么也不是.</p>
<p>这种错误的出现是在所难免的，我们太习惯用 <img src="https://latex.codecogs.com/png.latex?x">、<img src="https://latex.codecogs.com/png.latex?x%5E3%20+%205%20x%5E2%20+%20x"> 这种变元都不明确的记号来表示函数了<span class="citation" data-cites="wikipedia_abuse">[1]</span>. 写成 <img src="https://latex.codecogs.com/png.latex?f(x)"> 也不严谨，因为只有 <img src="https://latex.codecogs.com/png.latex?f"> 才应代表函数本身，<img src="https://latex.codecogs.com/png.latex?f(x)"> 只能是函数值. 这样我们就可以放心地写下 <img src="https://latex.codecogs.com/png.latex?O(f)">，不用担心把变元与确定值弄混了.</p>
<p>然而大家还是喜欢写 <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> 和 <img src="https://latex.codecogs.com/png.latex?O(e%5E%7Bn%5E2%7D)">，而不是奇怪的 <img src="https://latex.codecogs.com/png.latex?O(%5Cmathrm%7Bid%7D%5E2)"> 和 <img src="https://latex.codecogs.com/png.latex?O(%5Cmathrm%7Bexp%7D%20%5Ccirc%20%7B%5Cmathrm%7Bid%7D%5E2%7D)">. 所以，我们大概只能沿用这种不太严谨的记号，并时刻提醒自己加倍小心了. （形如 <img src="https://latex.codecogs.com/png.latex?x%20%5Cmapsto%20e%5E%7Bx%5E2%7D"> 的 <img src="https://latex.codecogs.com/png.latex?%5Clambda"> 风格“匿名函数”记号可能更好？）</p>
<p>但上述命题从结论上是正确的. 正确的推导过程应为 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7BP(n,i)%7D%20g(i)%20%5Cleq%20%5Csum_%7BP(n,i)%7D%20C%20f(i)%20%5Cleq%20C%20%5Csum_%7BP(n,i)%7D%20f(i)%20%5Cin%20O%20%5Cleft(%5Csum_%7BP(n,i)%7D%20f(i)%20%5Cright)%5C%0A"></p>
<p>第一步是直接由大 O 记号的定义得到的结果.</p></li>
</ul>
<p>Wikipedia<span class="citation" data-cites="asymptotic_wikipedia">[3]</span> 中有一张详尽的表格介绍了各种渐进符号的定义，OI Wiki<span class="citation" data-cites="asymptotic_oiwiki">[4]</span> 上也有极好的讲解，尚不熟练的读者可以参考. 有兴趣仔细研究的读者可以参考《具体数学》第九章<span class="citation" data-cites="concretemath_onotation">[2]</span>、Wikipedia 及其 reference（个人推荐 Knuth 关于 <img src="https://latex.codecogs.com/png.latex?O">、<img src="https://latex.codecogs.com/png.latex?%5COmega">、<img src="https://latex.codecogs.com/png.latex?%5CTheta"> 的短文<span class="citation" data-cites="knuth_omicron">[5]</span>）. 本文除用 “<img src="https://latex.codecogs.com/png.latex?%5Cin">” 和“<img src="https://latex.codecogs.com/png.latex?%5Csubset">”替代 “<img src="https://latex.codecogs.com/png.latex?=">” 外，完全使用 Knuth 提议的记号体系.</p>
</section>
<section id="调和数-hn-调和级数" class="level3" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="调和数-hn-调和级数"><span class="header-section-number">0.2</span> 调和数 <img src="https://latex.codecogs.com/png.latex?H(n)"> / 调和级数</h3>
<p>调和级数的部分和 <img src="https://latex.codecogs.com/png.latex?H(n)"> 定义为 <img src="https://latex.codecogs.com/png.latex?%0AH(n)%20=%20%5Csum_%7Bi=1%7D%5En%20%5Cfrac%201%20i%0A"> 通过一些与 <img src="https://latex.codecogs.com/png.latex?e"> 有关的数列放缩可以证明 <img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20(%20H(n)%20-%20%5Clog%20n%20)%20=%20c">，其中 <img src="https://latex.codecogs.com/png.latex?c%20%5Capprox%200.577"> 是 Euler 常数. 因此 <img src="https://latex.codecogs.com/png.latex?n%20H(n)%20%5Csim%20n%20%5Clog%20n%20%5Cin%20%5CTheta(%5Clog%20n)">.</p>
</section>
<section id="自然数等幂和-p_pn-p---级数" class="level3" data-number="0.3">
<h3 data-number="0.3" class="anchored" data-anchor-id="自然数等幂和-p_pn-p---级数"><span class="header-section-number">0.3</span> 自然数等幂和 <img src="https://latex.codecogs.com/png.latex?P_p(n)"> / <img src="https://latex.codecogs.com/png.latex?p"> - 级数</h3>
<p><img src="https://latex.codecogs.com/png.latex?p"> - 级数可视为调和级数的推广. 其部分和定义为 <img src="https://latex.codecogs.com/png.latex?%0AP_p(n)%20=%20%5Csum_%7Bi=1%7D%5En%20i%5E%7B-p%7D%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?p"> - 级数具有如下性质：</p>
<ul>
<li><p>当 <img src="https://latex.codecogs.com/png.latex?p%20%3E%201"> 时，<img src="https://latex.codecogs.com/png.latex?p"> - 级数收敛；</p></li>
<li><p>当 <img src="https://latex.codecogs.com/png.latex?p%20=%201"> 时，<img src="https://latex.codecogs.com/png.latex?p"> - 级数是调和级数；</p></li>
<li><p>当 <img src="https://latex.codecogs.com/png.latex?-%5Cinfty%20%3C%20p%20%3C%201"> 时，我们指出 <img src="https://latex.codecogs.com/png.latex?%0AP_p(n)%20%5Csim%20%5Cfrac%7B1%7D%7B1-p%7D%20n%5E%7B1-p%7D%20%5Cin%20%5CTheta(n%5E%7B1-p%7D)%0A"></p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?-%5Cinfty%20%3C%20p%20%3C%201"> 时 <img src="https://latex.codecogs.com/png.latex?p"> - 级数的渐进估计可以从连续幂函数积分的角度理解. 证明这渐进性，离散情况下，可对 <img src="https://latex.codecogs.com/png.latex?n%5Ep"> 差分后前缀和 + 二项式定理得到高次项系数，或可用离散微积分理论得到精确表示（参见《具体数学》<span class="citation" data-cites="concretemath_calculus">[6]</span>）；连续情况下，Lagrange 中值定理应为较简单的估计方法. 这里从略. 总之，我们得到： <img src="https://latex.codecogs.com/png.latex?%0AP_p(n)%20%5Cin%20%5Cbegin%7Bcases%7D%0A%5CTheta(n%5E%7B1-p%7D)%20&amp;%20p%20%3C%201%20%5C%5C%0A%5CTheta(n%20%5Clog%20n)%20&amp;%20p%20=%201%20%5C%5C%0A%5CTheta(1)%20&amp;%20p%20%3E%201%0A%5Cend%7Bcases%7D%0A"></p>
</section>
</section>
<section id="约数函数-sigma_zn" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="约数函数-sigma_zn"><span class="header-section-number">1</span> 约数函数 <img src="https://latex.codecogs.com/png.latex?%5Csigma_z(n)"></h2>
<p>约数函数（Divisor Function，也可称为除数函数、因数函数）是与 <img src="https://latex.codecogs.com/png.latex?n"> 的因子有关的一类函数，定义如下：</p>
<div id="def-sigma" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (约数函数) </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_z(n)%20=%20%5Csum_%7Bd%20%5Cmid%20n%7D%20d%5Ez%0A"></p>
</div>
<p>当 <img src="https://latex.codecogs.com/png.latex?z=0"> 时，<img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)"> 被称为约数个数函数（number-of-divisors function），常被记为 <img src="https://latex.codecogs.com/png.latex?d(n)"> 或 <img src="https://latex.codecogs.com/png.latex?%5Ctau(n)">. 当 <img src="https://latex.codecogs.com/png.latex?z=1"> 时，<img src="https://latex.codecogs.com/png.latex?%5Csigma_1(n)"> 被称为约数和函数（sum-of-divisors function），常直接记为 <img src="https://latex.codecogs.com/png.latex?%5Csigma(n)">.</p>
<div id="exm-sigma0ub" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 </strong></span>估计 <img src="https://latex.codecogs.com/png.latex?%5Csigma_0%20(n)"> 的渐进上界.</p>
</div>
<p>也就是估计 <img src="https://latex.codecogs.com/png.latex?n"> 的因子的数量. 一个广为人知的上界是 <img src="https://latex.codecogs.com/png.latex?2%20%5Csqrt%20n">，因为 <img src="https://latex.codecogs.com/png.latex?n"> 的所有小于 <img src="https://latex.codecogs.com/png.latex?%5Csqrt%20n"> 的因子 <img src="https://latex.codecogs.com/png.latex?d"> 均与另一因子 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%20n%20d"> 一一对应.</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>事实上进一步可以证明 <img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)%20%5Cin%20o(n%5E%5Cepsilon)%20%5Cquad%20%5Cforall%20%5Cepsilon%20%3E%200">，或更精确的，<img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)%20%5Cin%20O(n%5E%7B%5Clog%202%20/%20%5Clog%20%5Clog%20n%7D)"> <span class="citation" data-cites="wikipedia_divisor">[7]</span>．这一点说明，在实现与枚举因子有关的算法时，虽然仍会从 <img src="https://latex.codecogs.com/png.latex?1"> 枚举至 <img src="https://latex.codecogs.com/png.latex?%5Csqrt%20n"> 探测因子，但真正参与计算的因子其实相当少．因此，这些算法的实际表现往往极大程度地优于按 <img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)%20%5Cin%20O(%5Csqrt%20n)"> 估计的理论时间复杂度．</p>
</div>
<div id="exm-sumsigma0ub" class="theorem example">
<p><span class="theorem-title"><strong>Example 2 </strong></span>估计 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Csigma_0%7D(n)%20=%20%5Csum_%7Bi=1%7D%5En%20%5Csigma_0%20(i)"> 的渐进上界.</p>
</div>
<p>即估计 <img src="https://latex.codecogs.com/png.latex?1"> 到 <img src="https://latex.codecogs.com/png.latex?n"> 中所有数因子个数的和. 这是一个形式上鲜为人知但其应用广为人知的例子. 变换求和顺序，容易得到</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Csigma_0%7D(n)%20=%20%5Csum_%7Bi=1%7D%5En%20%5Csigma_0%20(i)%0A=%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bd%20%5Cmid%20i%7D%201%0A=%20%5Csum_%7Bd=1%7D%5En%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%0A%5Cleq%20%5Csum_%7Bd=1%7D%5En%20%5Cfrac%20n%20d%0A=%20n%20H(n)%20%5Cin%20O(n%20%5Clog%20n)%0A"></p>
<p>显然，这比 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Csqrt%20n)"> 的平凡估计好上不少. 本例的思路不仅是埃氏筛（Sieve of Eratosthenes）的理论基础，也在杜教筛、快速 Mobius 变换、<img src="https://latex.codecogs.com/png.latex?%5Cgcd"> 卷积<span class="citation" data-cites="gcdconv">[8]</span>等处出现.</p>
<p>进一步利用此技巧和 <img src="https://latex.codecogs.com/png.latex?p"> - 级数的估计，我们甚至能在仔细研究 <img src="https://latex.codecogs.com/png.latex?%5Csigma_z(n)"> 前就得到其前缀和的渐进估计：</p>
<div id="exm-sumsigmazub" class="theorem example">
<p><span class="theorem-title"><strong>Example 3 </strong></span>估计 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Csigma_z%7D(n)%20=%20%5Csum_%7Bi=1%7D%5En%20%5Csigma_z%20(i)"> 的渐进上界.</p>
</div>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Csigma_z%7D(n)%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20%5Csigma_z%20(i)%0A=%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bd%20%5Cmid%20i%7D%20d%5Ez%0A=%20%5Csum_%7Bd=1%7D%5En%20d%5Ez%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%20%5C%5C%0A&amp;%5Cleq%20n%20%5Csum_%7Bd=1%7D%5En%20d%5E%7Bz-1%7D%0A=%20n%20P_%7B1-z%7D(n)%0A%5Cin%20%5Cbegin%7Bcases%7D%0AO(n%5E%7Bz+1%7D)%20&amp;%20z%20%3E%200%20%5C%5C%0AO(n%20%5Clog%20n)%20&amp;%20z%20=%200%20%5C%5C%0AO(n)%20&amp;%20z%20%3C%200%0A%5Cend%7Bcases%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p>遗憾的是，对此前缀和做差分并不能得到 <img src="https://latex.codecogs.com/png.latex?%5Csigma_z(n)"> 的优秀估计.</p>
<p>现在引入一个重要放缩技巧，其在后续估计中屡试不爽.</p>
<div id="prp-trick1" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bd%20%5Cmid%20n%7D%20f(d)%20%5Cleq%20%5Csum_%7Bi=1%7D%5En%20f%20(%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor)%0A"></p>
</div>
<p>显然，右式比左式多算了 <img src="https://latex.codecogs.com/png.latex?i%20%5Cnmid%20n"> 的项，因此命题是正确的. 但我们还可以做得更好：</p>
<div id="prp-trick1ex" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2 </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bd%20%5Cmid%20n%7D%20f(d)%20%5Cleq%20%5Csum_%7Bi=1%7D%5E%7B%5Csqrt%20n%7D%20f(i)%20+%20f(%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor)%0A"></p>
</div>
<p><img src="https://latex.codecogs.com/png.latex?%5Csqrt%20n"> 分治. 我们其实已经在 Example&nbsp;1 估计 <img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)"> 时用过此技巧了.</p>
<div id="exm-sigma1ub" class="theorem example">
<p><span class="theorem-title"><strong>Example 4 </strong></span>估计 <img src="https://latex.codecogs.com/png.latex?%5Csigma_1%20(n)"> 的渐进上界.</p>
</div>
<p>用 Proposition&nbsp;1： <img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_1%20(n)%0A=%20%5Csum_%7Bd%20%5Cmid%20n%7D%20d%20%5Cleq%20%5Csum_%7Bi=1%7D%5En%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%20%5Cleq%20n%20H(n)%20%5Cin%20O(n%20%5Clog%20n)%0A"></p>
<p>可以证明用 Proposition&nbsp;2 不会得到更优的结果.</p>
<p>我们发现了一个有趣的事实：<img src="https://latex.codecogs.com/png.latex?%5Csigma_1%20(n)"> 和 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Csigma_0%7D(n)"> 的渐进上界均为 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)">.</p>
<div id="exm-sigmazub" class="theorem example">
<p><span class="theorem-title"><strong>Example 5 </strong></span>估计 <img src="https://latex.codecogs.com/png.latex?%5Csigma_z%20(n)"> 的渐进上界.</p>
</div>
<p>用 Proposition&nbsp;2 和 <img src="https://latex.codecogs.com/png.latex?p"> - 级数的性质：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csigma_z%20(n)%0A&amp;=%20%5Csum_%7Bd%20%5Cmid%20n%7D%20d%5Ez%0A%5Cleq%20%5Csum_%7Bi=1%7D%5E%7B%5Csqrt%20n%7D%20i%5Ez%20+%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%5Ez%20%5C%5C%0A&amp;%5Cleq%20%5Cbegin%7Bcases%7D%0A%5Cdisplaystyle%202%20%5Csum_%7Bi=1%7D%5E%7B%5Csqrt%20n%7D%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%5Ez%20%5Cleq%202%20n%5Ez%20%5Csum_%7Bi=1%7D%5E%7B%5Csqrt%20n%7D%20i%5E%7B-z%7D%20&amp;%20=%202%20n%5Ez%20P_z(%5Csqrt%20n)%20&amp;%20z%20%5Cgeq%200%5C%5C%0A%5Cdisplaystyle%202%20%5Csum_%7Bi=1%7D%5E%7B%5Csqrt%20n%7D%20i%5Ez%20&amp;%20=%202%20P_%7B-z%7D(%5Csqrt%20n)%20%20&amp;%20z%20%3C%200%0A%5Cend%7Bcases%7D%20%5C%5C%0A%5Cin%20&amp;%20%5Cbegin%7Bcases%7D%0A2%20n%5Ez%20O(1)%20&amp;%20z%20%3E%201%20%5C%5C%0A2%20n%20O(%5Clog%20%5Csqrt%20n)%20&amp;%20z%20=%201%20%5C%5C%0A2%20n%5Ez%20O(n%5E%7B%5Cfrac%20%7B1-z%7D%202%7D)%20&amp;%200%20%5Cleq%20z%20%3C%201%20%5C%5C%0A2%20O(n%5E%7B%5Cfrac%20%7B1+z%7D%202%7D)%20&amp;%20-1%20%3C%20z%20%3C%200%20%5C%5C%0A2%20O(%5Clog%20%5Csqrt%20n)%20&amp;%20z%20=%20-1%20%5C%5C%0A2%20O(1)%20&amp;%20z%20%3C%20-1%0A%5Cend%7Bcases%7D%0A=%20%5Cbegin%7Bcases%7D%0AO(n%5Ez)%20&amp;%20z%20%3E%201%20%5C%5C%0AO(n%20%5Clog%20n)%20&amp;%20z%20=%201%20%5C%5C%0AO(n%5E%7B%5Cfrac%20%7B1+z%7D%202%7D)%20&amp;%20-1%20%3C%20z%20%3C%201%20%5C%5C%0AO(%5Clog%20n)%20&amp;%20z%20=%20-1%20%5C%5C%0AO(1)%20&amp;%20z%20%3C%20-1%0A%5Cend%7Bcases%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p>我们得到了一个相当优秀的渐进上界. 值得关注的是：</p>
<ul>
<li>当 <img src="https://latex.codecogs.com/png.latex?z=0"> 时，<img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)%20%5Cin%20O(n%5E%7B%5Cfrac%201%202%7D)">. 这与 Example&nbsp;1 的结果一致.</li>
<li>当 <img src="https://latex.codecogs.com/png.latex?z=%5Cfrac%201%202"> 时，<img src="https://latex.codecogs.com/png.latex?%5Csigma_%7B%5Cfrac%201%202%7D(n)%20%5Cin%20O(n%5E%7B%5Cfrac%203%204%7D)">，即 <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bd%20%5Cmid%20n%7D%20%5Csqrt%20d%20%5Cin%20O(n%5E%7B%5Cfrac%203%204%7D)">. 洛谷 P4980 Polya 定理模板题<span class="citation" data-cites="polya_luogu">[9]</span>的一种比较 trivial 的解法<span class="citation" data-cites="polya_my">[10]</span>的时间复杂度证明就来源于此. 我们之后还会在整除分块与杜教筛中见到它.</li>
</ul>
<p>另外，如果只使用 Proposition&nbsp;1 ，<img src="https://latex.codecogs.com/png.latex?-1%3Cz%3C1"> 部分的渐进上界将只能估计至 <img src="https://latex.codecogs.com/png.latex?O(n)">. 因此 Proposition&nbsp;2 是更为优越的.</p>
<p>约数函数更复杂的上限与渐进估计可参考 Wikipedia<span class="citation" data-cites="wikipedia_divisor">[7]</span>.</p>
</section>
<section id="整除分块" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="整除分块"><span class="header-section-number">2</span> 整除分块</h2>
<p>也被称为数论分块. 求 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5En%20f(i)%20g(%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor)%0A"> 我们按 <img src="https://latex.codecogs.com/png.latex?d%20=%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor"> 分块求和： <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bd%7D%20g(d)%20%5Csum_%7B%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%20=%20d%7D%20f(i)%0A"> 可以证明，对一指定的 <img src="https://latex.codecogs.com/png.latex?d">，满足 <img src="https://latex.codecogs.com/png.latex?d%20=%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor"> 的 <img src="https://latex.codecogs.com/png.latex?i"> 取遍一连续区间，故若 <img src="https://latex.codecogs.com/png.latex?f"> 的前缀和能 <img src="https://latex.codecogs.com/png.latex?O(1)"> 求出，块数量 <img src="https://latex.codecogs.com/png.latex?%5C#%20%5Cleft%5C%7B%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%20%5Cright%5C%7D_%7Bi=1%7D%5En"> 即该算法的时间复杂度. 注意到当 <img src="https://latex.codecogs.com/png.latex?i%20%5Cleq%20%5Csqrt%20n"> 时，<img src="https://latex.codecogs.com/png.latex?%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor"> 最多只有 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5Clfloor%20%5Csqrt%20n%20%5Cright%5Crfloor"> 种取值，而 <img src="https://latex.codecogs.com/png.latex?i%20%5Cgeq%20%5Csqrt%20n"> 时，<img src="https://latex.codecogs.com/png.latex?1%20%5Cleq%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%20%5Cleq%20%5Csqrt%20n"> 表明其也最多只有 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5Clfloor%20%5Csqrt%20n%20%5Cright%5Crfloor"> 种取值. 因此整除分块的时间复杂度 <img src="https://latex.codecogs.com/png.latex?%0AT_1(n)%20=%20%5C#%20%5Cleft%5C%7B%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%20%5Cright%5C%7D_%7Bi=1%7D%5En%20%5Cleq%202%20%5Csqrt%20n%20%5Cin%20O(%5Csqrt%20n)%0A"></p>
<p>方便起见，后文记 <img src="https://latex.codecogs.com/png.latex?D(n)%20=%20%5Cleft%5C%7B%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%20%5Cright%5C%7D_%7Bi=1%7D%5En">.</p>
<section id="整除分块嵌套" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="整除分块嵌套"><span class="header-section-number">2.1</span> 整除分块嵌套</h3>
<p>将 Proposition&nbsp;2 加强，我们有如下通用放缩：</p>
<div id="prp-trick2ex" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3 </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bd%20%5Cmid%20n%7D%20f(d)%20%5Cleq%20%5Csum_%7Bd%20%5Cin%20D(n)%7D%20f(d)%20%5Cleq%20%5Csum_%7Bi=1%7D%5E%7B%5Csqrt%20n%7D%20f(i)%20+%20f(%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor)%0A"></p>
</div>
<p>LHS 成立的关键在于 <img src="https://latex.codecogs.com/png.latex?%5C%7Bd:%20d%20%5Cmid%20n%5C%7D%20%5Csubset%20D(n)">；而 RHS 的本质就是上述对整除分块块数量上界的估计.</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>整除分块的 <img src="https://latex.codecogs.com/png.latex?O(%5Csqrt%20n)"> 相当满，而枚举因子的 <img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)%20%5Cin%20O(%5Csqrt%20n)"> 却相当不满．这一点在前面介绍 <img src="https://latex.codecogs.com/png.latex?%5Csigma_0(n)"> 时已经提到．</p>
</div>
<p>注意到 Proposition&nbsp;2 是 Example&nbsp;5 证明的核心，而 Proposition&nbsp;3 是 Proposition&nbsp;2 的加强版，故仿造 Example&nbsp;5 的证明，我们有</p>
<div id="exm-divissigma" class="theorem example">
<p><span class="theorem-title"><strong>Example 6 </strong></span>令 <img src="https://latex.codecogs.com/png.latex?%0AS_z(n)%20=%20%5Csum_%7Bd%20%5Cin%20D(n)%7D%20d%5Ez%0A"> 则前述 Example&nbsp;5 中 <img src="https://latex.codecogs.com/png.latex?%5Csigma_z(n)"> 的上界与渐进上界也同样适用于 <img src="https://latex.codecogs.com/png.latex?S_z(n)">.</p>
</div>
<p>现在可以对嵌套整除分块 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5En%20f(i)%20%5Csum_%7Bj=1%7D%5E%7B%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%7D%20g(j)%20h(%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bij%7D%20%5Cright%5Crfloor)%0A"> 的时间复杂度 <img src="https://latex.codecogs.com/png.latex?T_2"> 做出估计了. 对 Example&nbsp;6 取 <img src="https://latex.codecogs.com/png.latex?z=%5Cfrac%201%202">，立刻有 <img src="https://latex.codecogs.com/png.latex?%0AT_2(n)%20=%20%5Csum_%7Bd%20%5Cin%20D(n)%7D%20T_1(d)%20%5Cleq%202%20%5Csum_%7Bd%20%5Cin%20D(n)%7D%20%5Csqrt%20d%20=%202%20S_%7B%5Cfrac%201%202%7D(n)%20%5Cleq%204%20%5Csqrt%20n%20P_%7B%5Cfrac%201%202%7D(%5Csqrt%20n)%20%5Cin%20O(n%5E%7B%5Cfrac%203%204%7D)%0A"></p>
<p>我们还可以进一步归纳. 假定 <img src="https://latex.codecogs.com/png.latex?%5Cforall%20m%20%5Cgeq%200,%20%5Cquad%20%5Cexists%20z_m%20:%200%20%5Cleq%20z_m%20%3C%201,%20%5Cquad%20T_m(n)%20=%20O(n%5E%7Bz_m%7D)">，我们有</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AT_%7Bm+1%7D(n)%20=%20%5Csum_%7Bd%20%5Cin%20D(n)%7D%20T_m(d)%20%5Cleq%20C%20%5Csum_%7Bd%20%5Cin%20D(n)%7D%20n%5E%7Bz_m%7D%20=%20C%20S_%7Bz_m%7D(n)%20%5Cin%20O(n%5E%7B%5Cfrac%20%7B1+z_m%7D%202%7D)%0A"></p>
<p>因此 <img src="https://latex.codecogs.com/png.latex?z_%7Bm+1%7D%20=%20%5Cfrac%20%7B1+z_m%7D%202">. 边界条件 <img src="https://latex.codecogs.com/png.latex?z_0%20=%200">，数列递推求得 <img src="https://latex.codecogs.com/png.latex?z_m%20=%201-2%5E%7B-m%7D">，检验满足条件. 因此 <img src="https://latex.codecogs.com/png.latex?m"> 重嵌套整除分块的时间复杂度 <img src="https://latex.codecogs.com/png.latex?%0AT_m(n)%20%5Cin%20O(n%5E%7B1-%202%5E%7B-m%7D%7D)%0A"></p>
</section>
</section>
<section id="杜教筛" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="杜教筛"><span class="header-section-number">3</span> 杜教筛</h2>
<p>杜教筛可以以低于线性的时间复杂度求解某些数论函数的前缀和. 其思路并不复杂. 设 <img src="https://latex.codecogs.com/png.latex?f"> 为一数论函数，我们希望快速求得其前缀和 <img src="https://latex.codecogs.com/png.latex?%5Chat%20f%20(n)%20=%20%5Csum_%7Bi=1%7D%5En%20f(i)">. 考虑数论函数 <img src="https://latex.codecogs.com/png.latex?g"> 和 <img src="https://latex.codecogs.com/png.latex?h%20=%20g%20*%20f">， <img src="https://latex.codecogs.com/png.latex?%0Ah(n)%20=%20%5Csum_%7Bd%20%5Cmid%20n%7D%20g(d)%20f(%5Cfrac%20n%20d)%0A"> 两端做前缀和得 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Chat%20h%20(n)%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20h(i)%20%5C%5C%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bd%20%5Cmid%20i%7D%20g(d)%20f(%5Cfrac%20i%20d)%20%5C%5C%0A&amp;=%20%5Csum_%7Bd=1%7D%5En%20g(d)%20%5Csum_%7Bi=1%7D%5E%7B%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%7D%20f(i)%20%5C%5C%0A&amp;=%20%5Csum_%7Bd=1%7D%5En%20g(d)%20%5Chat%20f%20(%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor)%20%5C%5C%0A&amp;=%20g(1)%20%5Chat%20f%20(n)%20+%20%5Csum_%7Bd=2%7D%5En%20g(d)%20%5Chat%20f%20(%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor)%0A%5Cend%7Baligned%7D%0A"> 因此 <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%20f%20(n)%20=%20%5Cfrac%201%20%7Bg(1)%7D%20%5Cleft(%20%5Chat%20h%20(n)%20-%20%5Csum_%7Bd=2%7D%5En%20g(d)%20%5Chat%20f%20(%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor)%20%5Cright)%0A"></p>
<p>故若 <img src="https://latex.codecogs.com/png.latex?g">、<img src="https://latex.codecogs.com/png.latex?h"> 的前缀和可 <img src="https://latex.codecogs.com/png.latex?O(1)"> 算得，根据上式整除分块即可递归地计算出 <img src="https://latex.codecogs.com/png.latex?f"> 的前缀和.</p>
<p>下面分析算法的复杂度. 注意到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%5Clfloor%20%5Cfrac%7B%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%7D%7Bj%7D%20%5Cright%5Crfloor%20=%20%5Cleft%5Clfloor%20%5Cfrac%7Bn%7D%7Bij%7D%20%5Cright%5Crfloor%0A"> 故单轮递归涉及到的自变量均可表示为 <img src="https://latex.codecogs.com/png.latex?d%20=%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor"> 的形式. 一个 <img src="https://latex.codecogs.com/png.latex?%5Chat%20f%20(d)"> 做整除分块耗时 <img src="https://latex.codecogs.com/png.latex?T_1(d)">，若采用记忆化递归，由上节分析，算法总时间复杂度为 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bd%20%5Cin%20D(n)%7D%20T_1(d)%20=%20T_2(n)%20%5Cin%20O(n%5E%7B%5Cfrac%203%204%7D)%0A"></p>
<p>但我们还可以做得更好——考虑先用 <img src="https://latex.codecogs.com/png.latex?O(K)"> 的时间复杂度线性筛出前 <img src="https://latex.codecogs.com/png.latex?K"> 个 <img src="https://latex.codecogs.com/png.latex?f(n)"> 并求前缀和，则递归求解时，<img src="https://latex.codecogs.com/png.latex?d%20%5Cleq%20K"> 的 <img src="https://latex.codecogs.com/png.latex?%5Chat%20f(d)"> 就无需再向下递归了. 为分析此类时间复杂度，对 Proposition&nbsp;3 做最后一点扩展：</p>
<div id="prp-trick3ex" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4 </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7B%5Cbegin%7Bgathered%7D%20d%20%5Cmid%20n%20%5C%5C%20d%20%3E%20K%20%5Cend%7Bgathered%7D%7D%20f(d)%20%5Cleq%20%5Csum_%7B%5Cbegin%7Bgathered%7D%20d%20%5Cin%20D(n)%20%5C%5C%20d%20%3E%20K%20%5Cend%7Bgathered%7D%7D%20f(d)%20%5Cleq%20%5Csum_%7BK%20%3C%20i%20%5Cleq%20%5Csqrt%20n%7D%20f(i)%20+%20%5Csum_%7B1%20%5Cleq%20i%20%5Cleq%20%5Cmin%7B%5C%7B%20%5Cleft%5Clfloor%20%5Cfrac%20n%20K%20%5Cright%5Crfloor,%5Csqrt%20n%20%5C%7D%20%7D%7D%20f(%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor)%0A"></p>
<p>特别的，当 <img src="https://latex.codecogs.com/png.latex?K%20%3E%20%5Csqrt%20n"> 时，有</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7B%5Cbegin%7Bgathered%7D%20d%20%5Cmid%20n%20%5C%5C%20d%20%3E%20K%20%5Cend%7Bgathered%7D%7D%20f(d)%20%5Cleq%20%5Csum_%7B%5Cbegin%7Bgathered%7D%20d%20%5Cin%20D(n)%20%5C%5C%20d%20%3E%20K%20%5Cend%7Bgathered%7D%7D%20f(d)%20%5Cleq%20%5Csum_%7B1%20%5Cleq%20i%20%5Cleq%20%5Cleft%5Clfloor%20%5Cfrac%20n%20K%20%5Cright%5Crfloor%7D%20f(%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor)%0A"></p>
</div>
<p>故用 Proposition&nbsp;4 ，当 <img src="https://latex.codecogs.com/png.latex?K%20%3E%20%5Csqrt%20n"> 时，算法在递归部分的时间复杂度降低为</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathrm%7BDu%7D_K(n)%20&amp;=%0A%5Csum_%7B%5Cbegin%7Bgathered%7D%20d%20%5Cin%20D(n)%20%5C%5C%20d%20%3E%20K%20%5Cend%7Bgathered%7D%7D%20T_1(d)%20%5C%5C%0A&amp;=%20%5Csum_%7B1%20%5Cleq%20i%20%5Cleq%20%5Cleft%5Clfloor%20%5Cfrac%20n%20K%20%5Cright%5Crfloor%7D%20T_1(%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor)%20%5C%5C%0A&amp;%5Cleq%20%5Csum_%7B1%20%5Cleq%20i%20%5Cleq%20%5Cleft%5Clfloor%20%5Cfrac%20n%20K%20%5Cright%5Crfloor%7D%20C%20%5Csqrt%7B%5Cfrac%20n%20i%7D%20%5C%5C%0A&amp;=%20C%20%5Csqrt%20n%20%5Csum_%7B1%20%5Cleq%20i%20%5Cleq%20%5Cleft%5Clfloor%20%5Cfrac%20n%20K%20%5Cright%5Crfloor%7D%20i%5E%7B-%5Cfrac%201%202%7D%20%5C%5C%0A&amp;=%20%20C%20%5Csqrt%20n%20P_%7B%5Cfrac%201%202%7D%5Cleft(%5Cleft%5Clfloor%20%5Cfrac%20n%20K%20%5Cright%5Crfloor%5Cright)%20%5C%5C%0A&amp;%5Cin%20%5Csqrt%20n%20O%5Cleft(%20%5Cleft(%5Cfrac%20n%20K%5Cright)%5E%7B%5Cfrac%201%202%7D%20%5Cright)%20%5C%5C%0A&amp;%5Csubset%20O(n%20K%5E%7B-%5Cfrac%201%202%7D)%0A%5Cend%7Baligned%7D%0A"></p>
<p>总时间复杂度 <img src="https://latex.codecogs.com/png.latex?%0AO(K)%20+%20O(n%20K%5E%7B-%5Cfrac%201%202%7D)%0A"></p>
<p>为最小化时间复杂度，取 <img src="https://latex.codecogs.com/png.latex?K%20=%20n%5E%7B%5Cfrac%202%203%7D">，得到最优时间复杂度 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B%5Cfrac%202%203%7D)">.</p>
<p>这部分的时间复杂度证明主要参考了文章<span class="citation" data-cites="zhihu_dusieve">[11]</span>.</p>
</section>
<section id="challenge" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="challenge"><span class="header-section-number">4</span> Challenge</h2>
<div id="exm-nonsquare" class="theorem example">
<p><span class="theorem-title"><strong>Example 7 </strong></span>对 <img src="https://latex.codecogs.com/png.latex?1"> 到 <img src="https://latex.codecogs.com/png.latex?n"> 间的无平方因子数计数. <img src="https://latex.codecogs.com/png.latex?n%20%5Cleq%2010%5E%7B18%7D">.</p>
<p>参见蓝桥杯 2023 省赛 A 组 J 题《翻转硬币》<span class="citation" data-cites="nonsquare1_luogu">[12]</span>或《完全平方数》<span class="citation" data-cites="nonsquare2_luogu">[13]</span>.</p>
</div>
<p>我们指出，无平方因子数有如下计数公式 <img src="https://latex.codecogs.com/png.latex?%0Af(n)%20=%20%5Csum_%7Bi=1%7D%5En%20%5Cmu%5E2%20(i)%20=%20%5Csum_%7Bi=1%7D%5E%7B%5Cleft%5Clfloor%20%5Csqrt%20n%20%5Cright%5Crfloor%7D%20%5Cmu(i)%20%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bi%5E2%7D%20%5Cright%5Crfloor%0A"></p>
<p>朴素实现复杂度为 <img src="https://latex.codecogs.com/png.latex?O(%5Csqrt%20n)">，考虑对 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bi%5E2%7D%20%5Cright%5Crfloor"> 开发一种新的整除分块算法. 现在问题有三. 一是估计 <img src="https://latex.codecogs.com/png.latex?%0A%5C#%20D_2(n)%20=%20%5C#%20%5Cleft%5C%7B%20%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bi%5E2%7D%20%5Cright%5Crfloor%20%5Cright%5C%7D_%7Bi=1%7D%5E%7B%5Csqrt%20n%7D%0A"> 这并不困难，按 <img src="https://latex.codecogs.com/png.latex?i%20%5Cleq%20n%5E%7B%5Cfrac%201%203%7D"> 和 <img src="https://latex.codecogs.com/png.latex?i%20%5Cgeq%20n%5E%7B%5Cfrac%201%203%7D"> 讨论即知其上界为 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B%5Cfrac%201%203%7D)">.</p>
<p>二是实现方案. 这里也直接给出：</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1">ll sqrtN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>sqrt<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb1-2">ll ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-3"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span>sqrtN<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb1-4">    d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/(</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">),</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>sqrt<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>N<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb1-5">    ans<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=(</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>r<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)-</span>S_mu<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>l<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">))*</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-6"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>最后是算法时间复杂度分析. 普通的 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5Clfloor%20%20%5Cfrac%20n%20i%20%5Cright%5Crfloor"> 整除分块不会因杜教筛增加时间复杂度，但 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5Clfloor%20%20%5Cfrac%20n%20%7Bi%5E2%7D%20%5Cright%5Crfloor"> 则需要额外的讨论. 注意到该整除分块枚举中，需做杜教筛的数的集合为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%5C%7B%20%5Cleft%5Clfloor%20%20%5Cleft(%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%20%5Cright)%5E%7B%5Cfrac%201%202%7D%20%20%5Cright%5Crfloor%5Cright%5C%7D_%7Bd%20%5Cin%20D_2%20(n)%7D%0A"> 同样类似 Proposition&nbsp;3 ，我们有</p>
<div id="prp-trick4ex" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 5 </strong></span><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bd%5E2%20%5Cmid%20n%7D%20f(%5Cfrac%20n%20%7Bd%5E2%7D)%20%5Cleq%20%5Csum_%7Bd%20%5Cin%20D_2(n)%7D%20f(d)%20%5Cleq%20%5Csum_%7Bi=1%7D%5E%7Bn%5E%7B%5Cfrac%201%203%7D%7D%20f(i)%20+%20f(%5Cleft%5Clfloor%20%5Cfrac%20n%20%7Bi%5E2%7D%20%5Cright%5Crfloor)%0A"></p>
</div>
<p>因此算法递归部分时间复杂度可估计为 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csum_%7Bd%20%5Cin%20D_2%20(n)%7D%20%5Cmathrm%7BDu%7D_K%20%5Cleft(%5Cleft%5Clfloor%20%5Cleft(%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%20%5Cright)%5E%7B%5Cfrac%201%202%7D%20%5Cright%5Crfloor%5Cright)%0A&amp;%5Cleq%20%5Csum_%7Bd%20%5Cin%20D_2%20(n)%7D%20C%20%5Cleft%5Clfloor%20%5Cleft(%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%20%5Cright)%5E%7B%5Cfrac%201%202%7D%20%5Cright%5Crfloor%20K%5E%7B-%5Cfrac%201%202%7D%20%5C%5C%0A&amp;%5Cleq%20C%20K%5E%7B-%5Cfrac%201%202%7D%20%5Cleft(%20%5Csum_%7Bi=1%7D%5E%7Bn%5E%7B%5Cfrac%201%203%7D%7D%20%5Cleft(%20%5Cfrac%20n%20%7B%5Cfrac%20n%20%7Bi%5E2%7D%7D%20%5Cright)%5E%7B%5Cfrac%201%202%7D%20+%20%5Csum_%7Bi=1%7D%5E%7Bn%5E%7B%5Cfrac%201%203%7D%7D%20%5Cleft(%20%5Cfrac%20n%20i%20%5Cright)%5E%7B%5Cfrac%201%202%7D%20%5Cright)%20%5C%5C%0A&amp;=%20C%20K%5E%7B-%5Cfrac%201%202%7D%20%5Cleft(%20%5Csum_%7Bi=1%7D%5E%7Bn%5E%7B%5Cfrac%201%203%7D%7D%20i%20+%20n%5E%7B%5Cfrac%201%202%7D%20%5Csum_%7Bi=1%7D%5E%7Bn%5E%7B%5Cfrac%201%203%7D%7D%20i%5E%7B-%5Cfrac%201%202%7D%20%5Cright)%20%5C%5C%0A&amp;%5Cin%20K%5E%7B-%5Cfrac%201%202%7D%20%5Cleft(%20O(n%5E%7B%5Cfrac%202%203%7D)%20+%20n%5E%7B%5Cfrac%201%202%7D%20O(n%5E%7B%5Cfrac%201%206%7D)%20%5Cright)%20%5C%5C%0A&amp;%5Csubset%20O(n%5E%7B%5Cfrac%202%203%7D%20K%5E%7B-%5Cfrac%201%202%7D)%0A%5Cend%7Baligned%7D%0A"> 总时间复杂度为 <img src="https://latex.codecogs.com/png.latex?%0AO(K)%20+%20O(n%5E%7B%5Cfrac%202%203%7D%20K%5E%7B-%5Cfrac%201%202%7D)%0A"> 取 <img src="https://latex.codecogs.com/png.latex?K=n%5E%7B%5Cfrac%204%209%7D">，得到最优时间复杂度 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B%5Cfrac%204%209%7D)">. 代入 <img src="https://latex.codecogs.com/png.latex?n%20=%2010%5E%7B18%7D">，量级约为 <img src="https://latex.codecogs.com/png.latex?10%5E8">.</p>
<p>这估计并不算优秀. 传言存在 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B%5Cfrac%202%205%7D)"> 的估计，猜测大概优化了 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5C%7B%20%5Cleft%5Clfloor%20%5Cfrac%20n%20i%20%5Cright%5Crfloor%20%5Cright%5C%7D_%7Bi=1%7D%5En"> 和 <img src="https://latex.codecogs.com/png.latex?%5Cleft%5C%7B%20%5Cleft%5Clfloor%20%20%5Cleft(%20%5Cleft%5Clfloor%20%5Cfrac%20n%20d%20%5Cright%5Crfloor%20%5Cright)%5E%7B%5Cfrac%201%202%7D%20%20%5Cright%5Crfloor%5Cright%5C%7D_%7Bd%20%5Cin%20D_2%20(n)%7D"> 的重叠部分。笔者尚未找出其推导方式.</p>
<p>upd: 关于 <img src="https://latex.codecogs.com/png.latex?O(n%5E%7B%5Cfrac%202%205%7D)"> 的估计，请参阅博客<span class="citation" data-cites="nonsquare_blog">[14]</span>和论文<span class="citation" data-cites="nonsquare_paper">[15]</span>．</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-wikipedia_abuse" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline"><span>“Abuse of notation - wikipedia.”</span> <a href="https://en.wikipedia.org/wiki/Abuse_of_notation#Function_notation" class="uri">https://en.wikipedia.org/wiki/Abuse_of_notation#Function_notation</a>.</div>
</div>
<div id="ref-concretemath_onotation" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">R. L. Graham, D. E. Knuth, and O. Patashnik, <span>“Concrete mathematics: A foundation for computer science,”</span> Second.in A @foundation for computer science. Addison-Wesley, 1994, pp. 443–449.</div>
</div>
<div id="ref-asymptotic_wikipedia" class="csl-entry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline"><span>“Big o notation - wikipedia # family of bachmann–landau notations.”</span> <a href="https://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations" class="uri">https://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations</a>.</div>
</div>
<div id="ref-asymptotic_oiwiki" class="csl-entry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline"><span>“复杂度 - OI wiki.”</span> <a href="https://oi-wiki.org/basic/complexity/#%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%AE%9A%E4%B9%89" class="uri">https://oi-wiki.org/basic/complexity/#%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%AE%9A%E4%B9%89</a>.</div>
</div>
<div id="ref-knuth_omicron" class="csl-entry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">D. E. Knuth, <span>“Big omicron and big omega and big theta,”</span> <em>SIGACT News</em>, vol. 8, no. 2, pp. 18–24, Apr. 1976, doi: <a href="https://doi.org/10.1145/1008328.1008329">10.1145/1008328.1008329</a>.</div>
</div>
<div id="ref-concretemath_calculus" class="csl-entry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">R. L. Graham, D. E. Knuth, and O. Patashnik, <span>“Concrete mathematics: A foundation for computer science,”</span> Second.in A @foundation for computer science. Addison-Wesley, 1994, pp. 47–56.</div>
</div>
<div id="ref-wikipedia_divisor" class="csl-entry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline"><span>“Divisor function - wikipedia # growth_rate.”</span> <a href="https://en.wikipedia.org/wiki/Divisor_function#Growth_rate" class="uri">https://en.wikipedia.org/wiki/Divisor_function#Growth_rate</a>.</div>
</div>
<div id="ref-gcdconv" class="csl-entry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">sun123zxy, <span>“sun123zxy’s blog - 原创OI题目 GCD卷积 problem and solution.”</span> <a href="https://blog.sun123zxy.top/posts/20201206-gcdconv/" class="uri">https://blog.sun123zxy.top/posts/20201206-gcdconv/</a>, 2020.</div>
</div>
<div id="ref-polya_luogu" class="csl-entry">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline"><span>“P4980 【模板】pólya 定理 - 洛谷 | 计算机科学教育新生态.”</span> <a href="https://www.luogu.com.cn/problem/P4980" class="uri">https://www.luogu.com.cn/problem/P4980</a>.</div>
</div>
<div id="ref-polya_my" class="csl-entry">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">sun123zxy, <span>“sun123zxy’s blog - 等价类计数：Burnside引理 &amp; Polya定理.”</span> <a href="http://blog.sun123zxy.top/posts/20200321-burnside/#s-4.3" class="uri">http://blog.sun123zxy.top/posts/20200321-burnside/#s-4.3</a>, 2020.</div>
</div>
<div id="ref-zhihu_dusieve" class="csl-entry">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">Ander, <span>“杜教筛.”</span> <a href="https://zhuanlan.zhihu.com/p/521699400" class="uri">https://zhuanlan.zhihu.com/p/521699400</a>, 2022.</div>
</div>
<div id="ref-nonsquare1_luogu" class="csl-entry">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline"><span>“P9238 [蓝桥杯 2023 省 a] 翻转硬币 - 洛谷 | 计算机科学教育新生态.”</span> <a href="https://www.luogu.com.cn/problem/P9238" class="uri">https://www.luogu.com.cn/problem/P9238</a>.</div>
</div>
<div id="ref-nonsquare2_luogu" class="csl-entry">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline"><span>“P4318 完全平方数 - 洛谷 | 计算机科学教育新生态.”</span> <a href="https://www.luogu.com.cn/problem/P4318" class="uri">https://www.luogu.com.cn/problem/P4318</a>.</div>
</div>
<div id="ref-nonsquare_blog" class="csl-entry">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">smsxgz, <span>“Counting square free numbers.”</span> <a href="https://smsxgz.github.io/post/pe/counting_square_free_numbers/" class="uri">https://smsxgz.github.io/post/pe/counting_square_free_numbers/</a>, 2019.</div>
</div>
<div id="ref-nonsquare_paper" class="csl-entry">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">J. Pawlewicz, <span>“Counting square-free numbers.”</span> 2011. Available: <a href="https://arxiv.org/abs/1107.4890">https://arxiv.org/abs/1107.4890</a></div>
</div>
</div></section></div> ]]></description>
  <category>OI</category>
  <category>数学</category>
  <guid>https://blog.sun123zxy.top/posts/20230418-complexity/index.html</guid>
  <pubDate>Mon, 17 Apr 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>国家博物馆兼东单良乡骑行一日游</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230306-national-museum-tour/index.html</link>
  <description><![CDATA[ 



<p>“来北京，当然要逛逛啊！”嘴上这么说，充实的学习生活却总能带来无数个宅在宿舍的理由。恰逢本学期思政课需亿点社会实践，国家博物馆乃官方推荐之所，而东可游长安街、王府井，南可观东交民巷，完成任务而了却游园之心，岂不美哉？虽开学未几，春景未至，然天气渐暖，今日不去，更待何时？不妨早做打算。遂与室友相约，周日出游。</p>
<p>乘地铁至天安门东，一路罚站。当然毕竟是淡季，车上并不拥挤。惊奇地发现一号线已非昔日模样：站台已加装护栏，而列车的内饰也早已翻新。</p>
<p>例行排队安检，上至天安门广场东侧。国家博物馆就在眼前，隔天安门广场与人民大会堂遥相呼应。馆子很大，上上下下一共六层，尚分南北两区，一整天或许也很难逛完，故我们只选取少量展馆参观。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230306-national-museum-tour/img/col-museum-outside.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">博物馆外侧</figcaption>
</figure>
</div>
<p>展览当然是相当不错的，但具体说来却没啥好写。博物馆这种地方，始终还是得自己去看。常设的《复兴之路》展区是标准的《中国近现代史纲要》，最近也新开了新时代展区，但我们去的时候……空无一人……（逃）</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230306-national-museum-tour/img/museum-exhibits.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">神州十三号返回舱（左）；复兴之路“新时代”展厅（右）</figcaption>
</figure>
</div>
<p>总之，逛逛逛拍拍拍，出来已经一点半了。讨论一下，准备往东单走找地儿吃饭。走在东长安街的人行道上，公安部、生态环境部、<del>长安俱乐部</del>滚滚而来，赫赫有名的北京饭店也映入眼帘。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230306-national-museum-tour/img/beijing-hotel.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">挺敦实一栋楼</figcaption>
</figure>
</div>
<p>王府井的人气似乎已经恢复了八成。我们并无兴致逛街，草草填饱肚子，往南向东交民巷前进。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230306-national-museum-tour/img/wangfujing.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">王府井步行街</figcaption>
</figure>
</div>
<p>比起嘈杂的天安门广场，东交民巷可谓意外的宁静。从东侧进入东交民巷，街上行人三三两两，似乎都是本地居民。往东前进，法国邮政局、西班牙领事馆等欧式建筑在街边排列，但均未开放游览，亦无游客驻足。灰黑色的砖瓦在紧闭的大门后默默不语，枯树残影的映衬下略显凄凉。教堂倒是小有人气，时有新人在此拍摄婚纱。行至天安门广场前最后一个路口，有警卫把守，似乎已不得入内。查看地图，前面已是公安局地界。也许得从天安门广场方向步行进入才可进一步游览吧。（事后调查，不少使馆的入口其实在前门大街一侧，许多建筑也已商业运行，除外观保持原样外，已无太多历史可寻。）</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230306-national-museum-tour/img/church.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">东交民巷的教堂</figcaption>
</figure>
</div>
<p>室友突然提议骑回良乡——英雄所见略同啊（笑）。从学校骑至主城一直是我的计划之一，现在离天黑尚有三四小时光景，晚 7:00 之前骑回学校并无不可。已有一室友因事先行离开，另一位室友苦于舟车劳顿，计划地铁回程。于是和提议的室友开启了近 40km 的骑行之旅。</p>
<p>已在东交民巷南边，我们没有选择卢沟桥路线，而是往京良路方向前进。二环可不小，出了前门公园，在狭窄的胡同间穿行，不一会就有点小累了。室友事后表示他没意识到 40km 的严重性（</p>
<p>渐行至三、四环外。偶然拐离干道，驶入普通道路。路上房屋低矮，矮墙垛垛，货车辆辆，尘土飞扬，加之今日有霾，揉眼一看，好似来到某西部偏远地区的乡间小路上。偌大的北京城也有如此“土里土气”的地方……之前在房山线上看到的壮美秋景，似乎也不在本次路线之上。况且春天尚未到来，即使经过也别无二致吧。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20230306-national-museum-tour/img/col-riding.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">胡同、“乡道”与分界处</figcaption>
</figure>
</div>
<p>至京良路。室友体力已下降不少，速度逐渐放缓。然而调高座椅、换用前脚掌蹬车的我似乎还能一战。<del>室友表示你个山区居民怎么这么能蹬，</del>虽然中途因未知原因迷路多绕出几公里的路程，最终还是在 7:00 之前赶回了学校。</p>
<p>买了面包和咖啡匆匆赶去参加组会，坐下的瞬间，突然感觉如断电般困倦……</p>



 ]]></description>
  <category>游记</category>
  <guid>https://blog.sun123zxy.top/posts/20230306-national-museum-tour/index.html</guid>
  <pubDate>Sun, 05 Mar 2023 16:00:00 GMT</pubDate>
  <media:content url="https://blog.sun123zxy.top/posts/20230306-national-museum-tour/img/wangfujing.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>聊聊红石音乐</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230217-rmg/index.html</link>
  <description><![CDATA[ 



<p>咕极必肝，肝极必咕。</p>
<p>本来是打算做完 Ancient Temple 和视频一起发出的，但现在看到这篇文章，说明下文随想里立下的 flag 已经被打脸了（</p>
<p>咕的原因，一方面是因为现实生活太过充实有趣，即使红乐般的激昂也有黯淡之时；但更重要的，还是对第二次迭代的表现效果不满意。模子是 Foxtail Grass Studio 的专辑封面和《妖妖剑戟梦想》的白玉楼阶梯，但始终没能做出想要的效果。更好的想法？暂时也没有。</p>
<p>半途而废很可惜，但糟蹋更可惜。或许暂时搁置、静待花开，会有更好的结果。</p>
<p>写下随想与技术细节，封存于冷清的博客，是纪念，还是重启的依托？</p>
<blockquote class="blockquote">
<p>东方的天空微微露出青白色的天光，幻想乡迎来了又一个清晨。</p>
<p>很快，太阳就会出现，将光芒洒满这片遗忘之地。</p>
<p>尽管，那片原野已然如幻梦般消失不见——</p>
<p>但，在看不见的隐秘角落，无数的原野正在悄然生长——</p>
<p>这里也是，那里也是</p>
<p>——如同小小的光芒。</p>
<p>——<a href="https://www.bilibili.com/read/cv11907285">东方莳梦原～Champaign of Unfinished Dreams</a> by 秋ノ宮飛鳥</p>
</blockquote>
<section id="一点随想" class="level2">
<h2 class="anchored" data-anchor-id="一点随想">一点随想</h2>
<p>2022 年 8 月 17 日夜，Ancient Temple 完成过半，月色入户，欣然开摆。</p>
<p>对，今天又是 8 月 17 日，是妖妖梦、风神录的发售日，<del>也是某个枪毙节</del>，还是某个新博客启用的周年纪念日——我又来写随想了。</p>
<p>18 年华灯宴 1U_s 大佬一曲<a href="https://b23.tv/FwrlLWL">十七岁</a>把我拉入红石音乐的大坑，到现在也有 4 年多了。随便聊聊感想，谈谈技术和非技术的各种话题。</p>
<p>我玩红乐，或许“科技靠考古的自闭造轮手”是个不错的形容。不加红石群、不更新版本，没人带没人陪，Google + Minecraft Wiki 在手，自己瞎倒腾，其他看造化。风格是 18 年的远古遗风——realpiano + 命令方块 + WorldEdit 的前进式、贪吃蛇式、下落式红石音乐大行其道的年头。到后来，特效红石音乐开始流行，但我心中的红乐早已定型。</p>
<p>我喜欢那个年代红石音乐特有的那种风格，那种朴素，但红石音乐完美融入场景的感觉。当年东方各作红石音乐全曲中就可见一斑——跟随红石信号一步步向前，如同听着 BGM 驾驶自机飞翔于道中，看版面缓缓向前伸展——STG 原作与 Minecraft 的奇妙融合让我着迷。我想做这样的红石音乐，我想做这样能化出心中幻想的红石音乐。</p>
<p>想做？音乐你懂吗？建筑你会吗？</p>
<p>不会，但可以学！</p>
<p>那你还会什么？</p>
<p>我是 OIer！我会编程！</p>
<p>这就是后来近三年红乐自动化尝试的开端。倒也开始稍微认真点的学习 MIDI、乐理以及其他各种各样的东西。</p>
<p>时间来到 20 年暑假。当时正好在玩 Python，偶然一搜，找到了 Raspberry Jam Mod 和 <a href="https://github.com/mido/mido">mido</a>——前者把 <a href="https://www.minecraft.net/en-us/edition/pi" class="uri">https://www.minecraft.net/en-us/edition/pi</a> 的 Python API 移植到 Java 版，后者提供在 Python 中处理 MIDI 文件的方法。</p>
<p>诶，这就不可以开工了吗！</p>
<p>肝能量发动，写了第一个能跑起来的脚本，随便丢了个正在做的第三版 Ancient Temple 进去听听——哎哟挺不错啊！</p>
<p>生产力工具上线，整活得以开始。要说最想做的，那一定是妖妖梦五面道中。对，就是 《东方妖妖梦 ~ Ancient Temple》。如 ZUN 所说，那是使古老寺院的空气突然升温的曲子。樱花上飘，楼观斩下……那是原作带来的难以忘怀的幻想。</p>
<p>但当时的我，没打算做，或者说有点不敢做。一方面，当然是 1U_s 大大的<a href="https://www.bilibili.com/video/BV1Gs411i7K9">妖妖梦红乐曲集</a>实在精彩，随手制作的五面道中已足以满足我自娱自乐的需求；二来也是对自己实力不太自信，怕做出自己也不太喜欢的作品。但 1U 的曲集毕竟是手工打造，两条音轨虽然意境极佳，但与原曲相比确也是捉襟见肘，而我手中的自动化可以极大程度地减轻工作量（虽然造轮子的过程没少花时间 (lll￢ω￢)）</p>
<p>所以到头来还是想做——或者下次一定？</p>
<p>那这次造啥呢？</p>
<p>余光瞄到刚退坑不久的 Dancing Line——说是舞线，其实脑子里全是 Through the Fog 的场景。回去重打 TTF 风暴的时候，听着 90% 后疯狂的雷声，突然想到 Minecraft 可以 <code>/weather rain</code> 可以 <code>/summon lightning_bolt</code>，加之场景想要偷懒的话搞个单层水世界就行，倒是试水的不错选择。</p>
<p>于是就开始试着扒谱。暑假结束，MIDI 是写好了，人却咕起来了。一咕就咕到了后一年的四月，忍不住了，爆肝三个周末整出来了。这个明显还是有很多问题的，首先曲子扒得就不太好，而且灯光一直到最后一小段才加上，另外前面下雨那段也太黑了。Sildur’s Vibrant Shader 的黑雷电问题也没解决，加上当时电脑太菜，Replaymod 录制还是挺难受的（不过预览模式倒是意外的贡献了个封面 XD），当然凑合能看。</p>
<p>后来就又到暑假了，打算一口气把 RMG 这个烂摊子写好，于是大刀阔斧的重构了，命名为 <a href="https://github.com/sun123zxy/redstone-music-generator">redstone-music-generator</a>，甚至还写了文档发了 Github，收获人生首 star &amp; issue（</p>
<p>或许是为了尝试 observer 的设计模式，亦或是太重视轮子的易用性，代码比较臃肿，过了几个月发现自己也很难看懂了。</p>
<p>其实写脚本主要还是给自己创作使用啊，没必要考虑太多“别人的需求”。</p>
<p>反思的结果就是新版的 redstone-music-generator 了，现暂存于原版本的 <code>develop</code> 分支下。这个版本再次重构，学习了某些命令行软件的做法，配置参数从之前在各个组件上的零散分布变为了单一配置文件的集中分布，显然提高了效率。</p>
<p>Ancient Temple 的 MIDI 也已经做到第五版了，这次以红乐的标准，大幅参考原曲 MIDI，期望能尽力还原出原作的表现。</p>
<p>鼓起勇气脱离咕海的动力来源，还是喜欢这曲子吧。说到底还是想把它做了再养老。</p>
<p>说起来，红石音乐到底应该怎样定义呢？之前 WorldEdit 的使用就已经引发过争议，那自动化搭建到底是红是黑？而在发声方面，是坚持音符盒的原教旨主义，还是命令方块的改良革新，甚至是更激进的 Midiout？</p>
<blockquote class="blockquote">
<p>up辛苦了，工作量能看出来。</p>
<p>但是原谅我还是很难接受这种从mc映射到外部midi播放器的格式。我觉得这并不能称作红石音乐，因为不是在mc内部完成播放的。</p>
<p>不过，用资源包和用接口，也不过只是内部调用和外部调用的区别罢了，也说不清…这是个哲学层次的问题。</p>
<p>红石音乐最后到底会变成什么样我也不知道，而且这种发展的方向和趋势我也没办法也没有理由去阻止。</p>
<p>我大概是，跟不上时代了吧…</p>
<p>——<a href="https://www.bilibili.com/video/BV1oW411a7eJ">【黑石音乐】aLIEz【接近完美的还原】_哔哩哔哩_bilibili</a> 下 <a href="https://space.bilibili.com/32262433">NJune六月</a> 的评论</p>
</blockquote>
<p>或许每个人心中的红乐标准都有所不同……或许我们只能求同存异，力求百花齐放，不要走火入魔。但最近粒子特效红石音乐的发展又让我感到困惑——一点红石、音符盒甚至命令方块都不出现，真的算红乐吗？那些炫酷的粒子特效，真的属于 Minecraft 吗？</p>
<p>只能交给时间回答了。我想，我能保证的，只是一颗全心投入、宁缺毋滥的创作心态；而我应该做的，是继续完成手头的作品。</p>
</section>
<section id="mc-指令相关" class="level2">
<h2 class="anchored" data-anchor-id="mc-指令相关">MC 指令相关</h2>
<section id="setblock-datavalue-block-state-and-data-tag-nbt" class="level3">
<h3 class="anchored" data-anchor-id="setblock-datavalue-block-state-and-data-tag-nbt">setblock, dataValue, block state and data tag (nbt)</h3>
<section id="扁平化前1.12-及以前" class="level4">
<h4 class="anchored" data-anchor-id="扁平化前1.12-及以前">扁平化前（1.12 及以前）</h4>
<p><code>setblock &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;block&gt; [dataValue|state] [oldBlockHandling] [dataTag]</code></p>
<p><code>dataValue</code> 和 <code>blockstate</code> 在扁平化之前是方块状态的两种不同描述方式，<code>dataValue</code> 是实际存储时使用的 4 bit 数据。通常，<code>blockstate</code> 或 <code>dataValue</code> 用来描述方块的一些基本性质，比如朝向 <code>facing</code>、羊毛的颜色 <code>color</code>、中继器的延迟刻数 <code>delay</code>。</p>
<p>具体写法例如：<code>/setblock ~ ~ ~1 minecraft:unpowered_repeater delay=4,facing=east</code> 设置一个延迟为 4 rt，面朝“东方”的红石中继器。（这里打上了引号，因为事实上<strong>红石中继器的 facing 代表的方向与信号传导的方向是相反的</strong>）</p>
<p>又，其效果等同于 <code>/setblock ~ ~ ~1 minecraft:unpowered_repeater 15</code>。（<code>dataValue = (delay - 1) * 4 + facing</code>，<code>facing=south|west|north|east</code> 分别对应 <code>0|1|2|3</code> 。默认值是 <code>north</code>）</p>
<p>再例如，<code>/setblock ~ ~ ~1 minecraft:command_block facing=down 0 {Command:"/time set 6000"}</code> 设置一个修改时间为正午的，面朝下方的命令方块。</p>
<p>中间的 <code>0</code> 是用来占位的。</p>
<p>查找某方块的 <code>dataValue</code> 和 <code>blockstate</code> 时可以翻阅 Minecraft Wiki 1.13 以前的历史版本（1.13 于 2018 年 6 月 18 日发布）</p>
</section>
<section id="扁平化后1.13-及以后" class="level4">
<h4 class="anchored" data-anchor-id="扁平化后1.13-及以后">扁平化后（1.13 及以后）</h4>
<p><code>setblock &lt;pos&gt; &lt;block&gt; [destroy|keep|replace]</code></p>
<p>其中 <code>&lt;block&gt;</code> 是 <code>block_state</code>， 具体的写法是 <code>namespaced_ID[block_states=value]{data_tags:value}</code></p>
<p>也就是说，原先的 <code>block</code>、<code>block_state</code> 和 <code>dataTag</code> 现在被统一整合入 <code>block_state</code> 里面，显然这更方便使用了。（然而作为考古学家，这好像也没法用上…）</p>
</section>
</section>
<section id="fallingsand-or-falling_block" class="level3">
<h3 class="anchored" data-anchor-id="fallingsand-or-falling_block">FallingSand or falling_block</h3>
<p>掉落方块实体。1.11 前它叫 <code>FallingSand</code>，1.11 及以后它叫 <code>falling_block</code>。</p>
<p>1.12 及以前可用 <code>/summon falling_block ~ ~ ~ {Block:minecraft:redstone_block,Time: 1}</code> 召唤掉落的红石块。Time 参数设置最长掉落时间，实际上会与 30 秒取最大值，但如果留空则会马上消失。</p>
<p>而 <code>/summon falling_block ~ ~ ~ {Block:"minecraft:wool", Data: 14, Time:1}</code> 可召唤掉落的红色羊毛。<code>Data</code> 标签自然与颜色对应了。</p>
<p>1.13 后由于扁平化更新了 <code>block_state</code> 的概念，指令格式变为 <code>/summon falling_block &lt;x&gt; &lt;y&gt; &lt;z&gt; {BlockState:{Name:&lt;Namespaced block ID&gt;,Properties:{&lt;blockstate_name&gt;:&lt;value&gt;}}}</code>。</p>
<p>参见：</p>
<ul>
<li><p><a href="https://minecraft.fandom.com/wiki/Falling_Block">Falling Block – Minecraft Wiki</a></p></li>
<li><p><a href="https://minecraft.fandom.com/wiki/Tutorials/Falling_blocks">Tutorials/Falling blocks – Minecraft Wiki</a></p></li>
<li><p><a href="https://minecraft.fandom.com/wiki/Tutorials/Command_NBT_tags#Entities">Tutorials/Command NBT tags – Minecraft Wiki</a></p></li>
</ul>
</section>
<section id="解决指令引号嵌套无法识别问题" class="level3">
<h3 class="anchored" data-anchor-id="解决指令引号嵌套无法识别问题">解决指令引号嵌套无法识别问题</h3>
<p>见 <a href="https://gaming.stackexchange.com/questions/246064/why-are-my-quotation-marks-causing-an-unexpected-token-error-with-this-command">minecraft java edition - Why are my quotation marks causing an “unexpected token” error with this command? - Arqade</a>，用 <code>\</code> 转义即可。</p>
</section>
</section>
<section id="mod资源包" class="level2">
<h2 class="anchored" data-anchor-id="mod资源包">mod、资源包</h2>
<p>注意此处提到的 mod 和资源包均只在其 1.12.2 对应版本下测试，不少功能在新版已经不需要 mod 了。</p>
<section id="worldedit" class="level3">
<h3 class="anchored" data-anchor-id="worldedit">WorldEdit</h3>
<p>建筑党老相识了，不细讲了，Google 一下你就知道。</p>
<ul>
<li><a href="https://worldedit.enginehub.org/en/latest/">WorldEdit Documentation</a></li>
</ul>
<p>用的多的命令 <code>copy</code>、<code>flip</code>、<code>rotate</code>、<code>paste</code>、<code>stack</code>、<code>set</code>、<code>replace</code>。当然还有最要命的 <code>undo</code> 啦（</p>
<p><code>schematic</code> 系列指令也很好用（用来偷建筑）（逃）</p>
</section>
<section id="voxelmap" class="level3">
<h3 class="anchored" data-anchor-id="voxelmap">VoxelMap</h3>
<p>常见的小地图，用来传送挺方便的。也不细讲了。</p>
</section>
<section id="tickratechanger" class="level3">
<h3 class="anchored" data-anchor-id="tickratechanger">TickrateChanger</h3>
<p><a href="https://www.curseforge.com/minecraft/mc-mods/tickratechanger">TickrateChanger - Mods - Minecraft - CurseForge</a></p>
<p>tickrate changer，就是字面意思嘛。改 tickrate 可以使游戏变快或变慢，从而实现精确调节 BPM。正常值 20。</p>
<p>但是有个挺烦的问题是调了过后声音的频率也随之改变了，这样音高就发生变化了…有大佬知道怎么办吗？</p>
</section>
<section id="colored-redstone" class="level3">
<h3 class="anchored" data-anchor-id="colored-redstone">Colored Redstone</h3>
<p><a href="https://www.curseforge.com/minecraft/mc-mods/colored-redstone">Colored Redstone - Mods - Minecraft - CurseForge</a></p>
<p>材质包编辑红石颜色失败后的替代品。具体细节有点忘了，只记得生成时 namespace 好像是 <code>coloredredstone:colored_redstone_block</code>，用 datavalue 来调颜色。（也忘了自己是怎么知道的了……好像是拆 jar 看的？）</p>
<p>顺序大概是这样：</p>
<p><img src="https://blog.sun123zxy.top/posts/20230217-rmg/colorful-redstone.jpg" class="img-fluid"></p>
</section>
<section id="invisiblights" class="level3">
<h3 class="anchored" data-anchor-id="invisiblights">InvisibLights</h3>
<p><a href="https://www.curseforge.com/minecraft/mc-mods/invisiblights">InvisibLights - Mods - Minecraft - CurseForge</a></p>
<p>材质包编辑发光材质失败后的替代品。字面义，作为隐形光源使用。</p>
</section>
<section id="realpiano-资源包" class="level3">
<h3 class="anchored" data-anchor-id="realpiano-资源包">realpiano 资源包</h3>
<p><a href="http://lkrb.net/blog/54.html">原出处</a>已挂，有个<a href="https://www.cr173.com/soft/277354.html">下载站</a>还有资源。</p>
<p>发声命令 <code>/execute @p ~ ~ ~ playsound lkrb.piano.p60fff voice @p ~ ~ ~"</code>，<code>C5 = 60</code>，音高 21 至 108，力度可选 <code>ppp,pp,p,mp,mf,f,ff,fff</code>。</p>
</section>
<section id="soma-资源包" class="level3">
<h3 class="anchored" data-anchor-id="soma-资源包">soma 资源包</h3>
<p>这个老强了，按 MIDI 音源标准制作的全套音色，长短音都有。</p>
<p>因为没怎么用就不细讲了。</p>
</section>
<section id="材质包编辑" class="level3">
<h3 class="anchored" data-anchor-id="材质包编辑">材质包编辑</h3>
<p>一开始是因为 SEUS v11.0 太黑看不清红石块，想找个方法让红石块自发光 。找了半天没找到的现成的，只好现学现做。</p>
<p>关于如何获取作为参考的 Default 材质包，参考 <a href="https://www.reddit.com/r/Minecraft/comments/47sycp/where_can_i_find_the_default_texture_pack_to_edit/">Where can I find the default texture pack to edit? : Minecraft</a>，直接把 <code>1.12.2.jar</code> 解压后里面的 <code>assets</code> 文件夹提到资源包里就可以用了，意外的方便啊（</p>
<p>（其实 mod 的 jar 里面也有这个文件夹！）</p>
<p>参考 <a href="https://optifine.readthedocs.io/emissive_textures.html">Emissive Textures - OptiFine documentation</a>，只需在材质包放置 <code>/assets/minecraft/optifine/emissive.properties</code> 和 <code>/assets/minecraft/textures/blocks/redstone_block_e.png</code>，<code>emissive.properties</code> 里写上 <code>suffix.emissive=_e</code> 就可以了。</p>
<p>1.12 差不多也算是古董版本了，参考网上教程时还需注意版本差异。</p>
<p>于是兴高采烈的准备用到掉落式红石钢琴上，发现——欸？光呢？？？</p>
<p>于是发现了 <a href="https://github.com/sp614x/optifine/issues/1342">Emissive textures not working for certain entities and items · Issue #1342 · sp614x/optifine · GitHub</a>——woc，这不是 xwj 大佬吗？？？</p>
<p>所以人家 18 年就把这些东西玩透了……<del>只有红石音乐作者才能发现的 bug</del></p>
<p>这个 Issue 至今 open，一下不知道怎么办了…只能暂时搁置。后来使用上文提到的 Colored Redstone 和 invisiblights 解决问题。</p>
<p>此外，发现同一地点方块贴图始终一致，这说明随机种子由位置决定。但作为 Falling_block 生成时，全都只会用第一个贴图。</p>
</section>
</section>
<section id="mcpi-和-raspberryjammod-相关" class="level2">
<h2 class="anchored" data-anchor-id="mcpi-和-raspberryjammod-相关">MCPI 和 RaspberryJamMod 相关</h2>
<p>RaspberryJamMod：把 <a href="https://www.minecraft.net/en-us/edition/pi">Minecraft: Pi Edition</a> 的 Python API 移植到 Java 版的一款 mod。</p>
<ul>
<li>Github 库：<a href="https://github.com/arpruss/raspberryjammod">GitHub - arpruss/raspberryjammod: Raspberry Jam Mod - a Mod Forge Minecraft mod implementing most of Raspberry Juice/Pi API</a></li>
<li>官方指南：<a href="https://www.instructables.com/Python-coding-for-Minecraft/">Python Coding for Minecraft : 18 Steps (with Pictures) - Instructables</a></li>
<li>Minecraft: Pi Edition 的 API：<a href="https://www.stuffaboutcode.com/p/minecraft-api-reference.html">Minecraft: Pi Edition API</a></li>
</ul>
<section id="mcpi-block-类在-setblock-setblockwithnbt-中的使用" class="level3">
<h3 class="anchored" data-anchor-id="mcpi-block-类在-setblock-setblockwithnbt-中的使用">MCPI Block 类在 setBlock &amp; setBlockWithNBT 中的使用</h3>
<p><code>Block</code> 类被封装成了包含三个元素 <code>id:int</code>, <code>data:int</code>, <code>nbt:str</code> 的“数组”，在 <code>setBlock</code> 和 <code>setBlockWithNBT</code> 中直接使用 <code>Block</code> 类会被 <code>flatten()</code> 或 <code>floorFlatten()</code> 函数“拍扁”成分散的参数。一个 <code>Block</code> 对象只可能被拍扁成 <code>data, id</code> 或 <code>id, data, nbt</code>，取决于该对象是否设置了 <code>nbt</code> （用 <code>None</code> 判断）。</p>
<p>因此，需要自定义 <code>data</code> 时，不能使用 <code>block</code> 模块的预设方块。</p>
<p><code>Vec3</code> 类也可被拍扁。</p>
<p>例如：</p>
<ul>
<li><code>setBlock(Vec3(0,0,0), 137, 2)</code> 等同于 <code>mc.setBlock(Vec3(0,0,0), Block(137, 2))</code></li>
<li><code>setBlockWithNBT(Vec3(0,0,0), 137, 2, '{Command:"your command"}')</code> 等同于 <code>setBlockWithNBT(Vec3(0,0,0), Block(137, 2), '{Command:"your command"}')</code> 等同于 <code>setBlockWithNBT(Vec3(0,0,0), Block(137, 2, '{Command:"your command"}'))</code></li>
</ul>
<p>需要注意的是， <code>setBlock()</code> 不能接受 <code>nbt</code> 参数或带 <code>nbt</code> 的 <code>Block</code> 对象，否则会报错。而 <code>setBlockWithNBT()</code> 则有无 <code>nbt</code> 皆可。</p>
</section>
<section id="关于-mcpi-与游戏内的坐标差" class="level3">
<h3 class="anchored" data-anchor-id="关于-mcpi-与游戏内的坐标差">关于 MCPI 与游戏内的坐标差</h3>
<p>见 <a href="https://stackoverflow.com/questions/70747581/python-minecraft-coordinates-trouble">Python + Minecraft Coordinates Trouble - Stack Overflow</a>：</p>
<blockquote class="blockquote">
<p>getPos, getTilePos, setPos and setTilePos all appear to be relative to the player’s spawn point at least in a single player world. I am going through trying to teleport my character but the coordinates I end up on are not the world’s coordinates but a coordinate relative to where my character would spawn.</p>
</blockquote>
<blockquote class="blockquote">
<p>So, either fix an offset of 66 blocks into the y-axis values, or manually set the world spawn to <code>(0, 0, 0)</code> with <code>/setworldspawn</code>.</p>
</blockquote>
</section>
</section>
<section id="自制轮子" class="level2">
<h2 class="anchored" data-anchor-id="自制轮子">自制轮子</h2>
<section id="redstone-music-generator旧版" class="level3">
<h3 class="anchored" data-anchor-id="redstone-music-generator旧版">redstone-music-generator（旧版）</h3>
<p>（这是重构旧版前再次阅读代码后的小报告）</p>
<p>大概使用了 observer 的设计模式，写了类似 C# 中的 Event，Delegate 暂时还没有封装，稍微有点混乱。</p>
<p>自己写了一些工具类，然后弄了个 <code>MIDIHandler</code> 预处理 MIDI 文件。</p>
<p>整个生成在最上层由 <code>RMG</code> 类管，<code>RMG</code> 读取 <code>MIDIHandler</code> 的信息然后触发绑定在 <code>RMG</code> 上的各种 <code>onNote()</code>、<code>onBeat()</code> 函数（触发过程由封装的 <code>Event</code> 类实现）。通过设置 <code>RMG</code> 的成员变量可以设置例如要生成的音轨、起始终止拍等参数。</p>
<p>然后各种插件都丢在了 <code>observer.py</code> 里。这些插件接受各种需要的信息（当前音符编号、音高等），一些是用于生成 <code>Vec3</code> 或 <code>Block</code> 的 <code>XXXPosGen</code> 和 <code>XXXBlockGen</code>（还没有给他们写基类，主要是现在还没封装 Delegate），另一些是包含 <code>onNote()</code>、<code>onBeat()</code>，用来绑在 <code>RMG</code> 上的插件。（注意绑在 <code>RMG</code> 上的是函数而不是插件本身！）每个插件都有自己的参数，插件之间也可以相互嵌套（例如 <code>GroundedAdvancing</code> 里面就套了个 <code>SingleBlock</code>）。插件存在的目的是为各个输出函数 <code>onNote()</code>、<code>onBeat()</code> 统一设置参数。（这里是否可以再改的函数式编程一点？）</p>
<p>现在有一个问题就是 PosGen 和 BlockGen 分开了，有 Issue 提到想要自定义每个 Note 下放的 partBlock，像这样搞就很麻烦。</p>
<p>应该有一个把 PosGen 和 BlockGen 合起来的方案，最好是能独立表示多个方块及其位置信息的一个整体。</p>
</section>
<section id="redstone-music-generator新版" class="level3">
<h3 class="anchored" data-anchor-id="redstone-music-generator新版">redstone-music-generator（新版）</h3>
<p>TODO（咕咕咕）</p>
<p>temp: <code>/execute @p ~ ~ ~ playsound block.note.guitar voice @p ~ ~ ~</code></p>


</section>
</section>

 ]]></description>
  <category>回忆</category>
  <category>Minecraft</category>
  <category>音乐</category>
  <category>Python</category>
  <guid>https://blog.sun123zxy.top/posts/20230217-rmg/index.html</guid>
  <pubDate>Thu, 16 Feb 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>str 学数学 题解</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230213-strwithmath/index.html</link>
  <description><![CDATA[ 



<div id="exm-problem" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 (str 学数学) </strong></span>str 同学因为名字里含有一个 str，所以觉得字符串对于他来说太简单了，于是他开始了他的数学之旅。</p>
<p>在旅途中str遇到了刚抽到胡桃的 lyl，而 lyl 同学正沉浸在出货的喜悦之中，为了能收获双倍喜悦，他便询问 str，他选的区间内有多少个幸运数字，str觉得这个问题和字符串一样简单，于是把这个问题交给了你。</p>
<p>共有 <img src="https://latex.codecogs.com/png.latex?T"> 组询问，每次给出两个正整数 <img src="https://latex.codecogs.com/png.latex?L,R">，你需要判断有多少 <img src="https://latex.codecogs.com/png.latex?n">，<img src="https://latex.codecogs.com/png.latex?L%20%5Cleq%20n%20%5Cleq%20R"> 使得方程 <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20%5Cleft%20%5Clfloor%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20=%20%5Cfrac%20%7Bn%5E2%20(n-1)%7D%7B4%7D%0A"> 成立。</p>
<p>请输出你得到的答案。</p>
<p>数据范围：<img src="https://latex.codecogs.com/png.latex?1%20%5Cleq%20T%20%5Cleq%2010000">，<img src="https://latex.codecogs.com/png.latex?1%20%5Cleq%20L%20%5Cleq%20R%20%5Cleq%2010%5E7"></p>
<p>样例输入：</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb1-1">4</span>
<span id="cb1-2">1 4</span>
<span id="cb1-3">2 8</span>
<span id="cb1-4">1 10</span>
<span id="cb1-5">1 100</span></code></pre></div>
<p>样例输出：</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb2-1">3</span>
<span id="cb2-2">3</span>
<span id="cb2-3">5</span>
<span id="cb2-4">26</span></code></pre></div>
<p>来源：2023 年寒假集训 B 组总结赛</p>
</div>
<p>考场上当然是打表找规律了，但非常愚钝地没看出来……</p>
<p>结论是，<img src="https://latex.codecogs.com/png.latex?n"> 是一个幸运数字，当且仅当 <img src="https://latex.codecogs.com/png.latex?n+1"> 是一个质数。下面提供两种证明方法。</p>
<section id="official-solution" class="level2">
<h2 class="anchored" data-anchor-id="official-solution">Official Solution</h2>
<p>出题人提供的非常有技巧性的解法。</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20%5Cleft%20%5Clfloor%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20=%20%5Cfrac%20%7Bn%5E2%20(n-1)%7D%7B4%7D%0A"></p>
<p>考虑为 <img src="https://latex.codecogs.com/png.latex?%5Clfloor%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Crfloor"> 配对，</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20%5Cleft%20%5Clfloor%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20+%20%5Cleft%20%5Clfloor%20%5Cfrac%20%7Bi(n-j+1)%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20&amp;=%20%5Cfrac%20%7Bn%5E2%20(n-1)%7D%7B2%7D%20%5C%5C%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20%5Cleft%20%5Clfloor%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20+%20%5Cleft%20%5Clfloor%20i%20-%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20&amp;=%20%5Cfrac%20%7Bn%5E2%20(n-1)%7D%7B2%7D%20%5C%5C%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20i%20-%20%5B%20n+1%20%5Cnmid%20ij%20%5D%20&amp;=%20%5Cfrac%20%7Bn%5E2%20(n-1)%7D%7B2%7D%20%5C%5C%0A%5Cfrac%7Bn%5E2%20(n+1)%7D%7B2%7D%20-%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20%5B%20n+1%20%5Cnmid%20ij%20%5D%20&amp;=%20%5Cfrac%20%7Bn%5E2%20(n-1)%7D%7B2%7D%20%5C%5C%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20%5B%20n+1%20%5Cnmid%20ij%20%5D%20&amp;=%20n%5E2%0A%5Cend%7Baligned%7D%0A"></p>
<p>即要求 <img src="https://latex.codecogs.com/png.latex?n+1%20%5Cnmid%20ij"> 对任意 <img src="https://latex.codecogs.com/png.latex?1%20%5Cleq%20i,j%20%5Cleq%20n"> 成立。因此根据质数定义，<img src="https://latex.codecogs.com/png.latex?n+1"> 就是且只能是质数了。</p>
</section>
<section id="alternative-solution" class="level2">
<h2 class="anchored" data-anchor-id="alternative-solution">Alternative Solution</h2>
<p>考场上推了一半的想法。</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20%5Cleft%20%5Clfloor%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20=%20%5Cfrac%20%7Bn%5E2%20(n-1)%7D%7B4%7D%0A"></p>
<p>注意到 <img src="https://latex.codecogs.com/png.latex?a%20%5Cbmod%20b%20=%20a%20-%20b%20%5Clfloor%20%5Cfrac%20a%20b%20%5Crfloor">，考虑构造取模</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20(n+1)%20%5Cleft%20%5Clfloor%20%5Cfrac%20%7Bij%7D%20%7Bn+1%7D%20%5Cright%20%5Crfloor%20=%20%5Cfrac%20%7Bn%5E2%20(n-1)(n+1)%7D%7B4%7D%20%5C%5C%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20ij%20-%20ij%20%5Cbmod%20(n+1)%20=%20%5Cfrac%20%7Bn%5E2%20(n-1)(n+1)%7D%7B4%7D%20%5C%5C%0A%5Cleft(%20%5Cfrac%20%7Bn(n+1)%7D%7B2%7D%20%5Cright)%5E2%20-%20%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20ij%20%5Cbmod%20(n+1)%20=%20%5Cfrac%20%7Bn%5E2%20(n-1)(n+1)%7D%7B4%7D%20%5C%5C%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20ij%20%5Cbmod%20(n+1)%20=%20%5Cfrac%20%7Bn%5E2%20(n+1)%7D%20%7B2%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p>考虑固定 <img src="https://latex.codecogs.com/png.latex?i">，研究 <img src="https://latex.codecogs.com/png.latex?j"> 变化下左式的情况。方便起见，我们将上式左侧 <img src="https://latex.codecogs.com/png.latex?j"> 的取值范围扩展至 <img src="https://latex.codecogs.com/png.latex?0"> 到 <img src="https://latex.codecogs.com/png.latex?n">： <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=0%7D%5En%20ij%20%5Cbmod%20(n+1)%20=%20%5Cfrac%20%7Bn%5E2%20(n+1)%7D%20%7B2%7D%0A"> 细心的读者或许已经发现，当 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(i,n+1)%20=%201"> 恒成立，即 <img src="https://latex.codecogs.com/png.latex?n+1"> 为质数时，<img src="https://latex.codecogs.com/png.latex?ij%20%5Cbmod%20(n+1)"> 将取遍 <img src="https://latex.codecogs.com/png.latex?0"> 到 <img src="https://latex.codecogs.com/png.latex?n">，此时左右两式相等。下面我们证明这是上式相等的充分必要条件。</p>
<p>仍从 <img src="https://latex.codecogs.com/png.latex?ij%20%5Cbmod%20(n+1)"> 的取值下手，我们研究如下以 <img src="https://latex.codecogs.com/png.latex?j"> 和 <img src="https://latex.codecogs.com/png.latex?t"> 为变量的不定方程的解 <img src="https://latex.codecogs.com/png.latex?%0Aij%20+%20(n+1)%20t%20=%20m%20%5Cpod%7B0%20%5Cleq%20m%20%3C%20n+1%7D%0A"> 由裴蜀定理（Bézout’s identity），方程有解的充分必要条件为 <img src="https://latex.codecogs.com/png.latex?%5Cgcd(i,n+1)%20%5Cmid%20m">。不妨记 <img src="https://latex.codecogs.com/png.latex?d%20=%20%5Cgcd(i,n+1)">，<img src="https://latex.codecogs.com/png.latex?m%20=%20k%20d">，方程变为 <img src="https://latex.codecogs.com/png.latex?%0Aij%20+%20(n+1)%20t%20=%20kd%20%5Cpod%7B0%20%5Cleq%20k%20%3C%20%5Cfrac%20%7Bn+1%7D%20d%7D%0A"> 写出该不定方程的通解 <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%20%5C%7B%0A%5Cbegin%7Baligned%7D%0Aj%20&amp;=%20j_0%20+%20s%20%5Ccdot%20%5Cfrac%7Bn+1%7D%7Bd%7D%5C%5C%0At%20&amp;=%20t_0%20-%20s%20%5Ccdot%20%5Cfrac%7Bi%7D%7Bd%7D%0A%5Cend%7Baligned%7D%0A%5Cright%20.%20%5Cpod%7Bs%20%5Cin%20%5Cmathbb%20Z%7D%0A"> 不难发现，对 <img src="https://latex.codecogs.com/png.latex?0%20%5Cle%20k%20%3C%20%5Cfrac%20n%20d">，上述不定方程在 <img src="https://latex.codecogs.com/png.latex?0%20%5Cleq%20j%20%5Cleq%20n"> 的范围内总有 <img src="https://latex.codecogs.com/png.latex?d"> 个解，这意味着 <img src="https://latex.codecogs.com/png.latex?ij%20%5Cbmod%20(n+1)"> 将有 <img src="https://latex.codecogs.com/png.latex?d"> 次取到 <img src="https://latex.codecogs.com/png.latex?kd">。故我们有 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csum_%7Bi=1%7D%5En%20%5Csum_%7Bj=1%7D%5En%20ij%20%5Cbmod%20(n+1)%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20d%20%5Csum_%7Bk=0%7D%5E%7B%5Cfrac%20%7Bn+1%7D%7Bd%7D%20-1%7D%20kd%20%5C%5C%0A&amp;=%20%5Csum_%7Bi=1%7D%5En%20d%5E2%20%5Csum_%7Bk=0%7D%5E%7B%5Cfrac%20%7Bn+1%7D%7Bd%7D%20-1%7D%20k%20%5C%5C%0A&amp;=%20%5Cfrac%201%202%20%5Csum_%7Bi=1%7D%5En%20d%5E2%20%5Cleft(%20%5Cfrac%20%7Bn+1%7D%20d%20-%201%20%5Cright)%20%5Cfrac%20%7Bn+1%7D%20d%20%5C%5C%0A&amp;=%20%5Cfrac%20%7Bn+1%7D%202%20%5Csum_%7Bi=1%7D%5En%20(n+1-d)%20=%20%5Cfrac%7Bn%5E2%20(n+1)%7D%7B2%7D%0A%5Cend%7Baligned%7D%0A"> 化简即得 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Csum_%7Bi=1%7D%5En%20(n+1-d)%20&amp;=%20n%5E2%20%5C%5C%0A%5Csum_%7Bi=1%7D%5En%20d%20&amp;=%20n%20%5C%5C%0A%5Csum_%7Bi=1%7D%5En%20%5Cgcd(i,%20n+1)%20&amp;=%20n%0A%5Cend%7Baligned%7D%0A"> 显然上式等价于对任意 <img src="https://latex.codecogs.com/png.latex?1%20%5Cleq%20i%20%5Cleq%20n">，<img src="https://latex.codecogs.com/png.latex?%5Cgcd(i,%20n+1)%20=%201"> 恒成立。因此我们证明了 <img src="https://latex.codecogs.com/png.latex?n+1"> 是质数是原方程成立的充分必要条件。</p>


</section>

 ]]></description>
  <category>OI</category>
  <category>数学</category>
  <category>题解</category>
  <guid>https://blog.sun123zxy.top/posts/20230213-strwithmath/index.html</guid>
  <pubDate>Sun, 12 Feb 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>算法竞赛向 C++ Standard Library 使用速查</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20230124-stl/index.html</link>
  <description><![CDATA[ 



<p>本文旨在对算法竞赛所需 C++ Standard Library 做一个全面而相对严谨的总结。</p>
<p>全文主要参考以下文档：</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/container">Containers library - cppreference.com</a></li>
<li><a href="https://oi-wiki.org/lang/csl/">C++ 标准库简介 - OI Wiki</a></li>
</ul>
<p>如有能力，阅读原文可获得更深入的了解。</p>
<section id="stl-算法" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="stl-算法"><span class="header-section-number">1</span> STL 算法</h2>
<p>均在 <code>#include&lt;algorithm&gt;</code> 定义。</p>
<ul>
<li><p><code>std::sort(first,last,cmp)</code></p>
<p>排序为不降序列。</p>
<p>接受随机访问迭代器。可自定义比较函数。</p>
<p>平均时间复杂度 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)">，C++11 后严格 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)">。</p></li>
<li><p><code>std::stable_sort(first,last,cmp)</code></p>
<p>排序为不降序列，且保持相等元素的顺序。</p></li>
<li><p><code>std::lower_bound(first,last,val,cmp)</code></p>
<p>返回指向首个不小于 <code>val</code> 的元素的迭代器，如无，返回 <code>last</code>。</p>
<p>要求小于 <code>val</code> 的值和大于等于 <code>val</code> 的值分居区间两侧。</p>
<p>可自定义比较函数。若迭代器支持随机访问，对数时间复杂度，否则为线性。</p></li>
<li><p><code>std::upper_bound(first,last,val,cmp)</code></p>
<p>返回指向首个大于 <code>val</code> 的元素的迭代器，如无，返回 <code>last</code>。</p></li>
<li><p><code>std::unique(first,last,cmp)</code></p>
<p>保留区间中所有连续等值区间的首个元素组成新序列，返回处理后序列的尾迭代器。</p>
<p>接受前向迭代器，可自定义判断相等的函数。</p>
<p>线性时间复杂度。</p></li>
</ul>
</section>
<section id="基本或特殊容器" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="基本或特殊容器"><span class="header-section-number">2</span> 基本或特殊容器</h2>
<p>注：C++11 新引入的容器，大部分头文件名与容器名一致。</p>
<ul>
<li><code>pair</code> <code>#include&lt;utility&gt;</code> ：元素对。</li>
<li><code>tuple</code> (C++11) ：元组。</li>
<li><code>bitset</code> <code>#include&lt;bitset&gt;</code> ：定长压缩 01 串，可在 <img src="https://latex.codecogs.com/png.latex?O(%5Cfrac%20N%20K)"> 的时空复杂度内完成常见运算，<img src="https://latex.codecogs.com/png.latex?K"> 对应操作系统位数。</li>
<li><code>string</code> <code>#include&lt;string&gt;</code> ：字符串。</li>
</ul>
<section id="pair" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="pair"><span class="header-section-number">2.1</span> pair</h3>
<ul>
<li><code>operator=</code> ：重载了赋值运算符用于拷贝。</li>
<li><code>first</code> / <code>second</code> ：访问第一项或第二项。</li>
<li><code>std::make_pair(a,b)</code> ：新建元素对，自动检测类型。</li>
<li><code>operator&lt;=&gt;</code> ：重载了各种比较运算符，按第一关键字、第二关键字顺序比较。</li>
</ul>
</section>
<section id="tuple" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="tuple"><span class="header-section-number">2.2</span> tuple</h3>
<ul>
<li><code>operator=</code> ：重载了赋值运算符用于拷贝。</li>
<li><code>std::get&lt;i&gt;(tp)</code> ：获取元组的第 i 项。</li>
<li><code>std::get&lt;T&gt;(tp)</code> ：获取元组中类型为 T 的项。</li>
<li><code>std::tie(a,b,...)</code> ：构造一个变量引用构成的元组．用于在赋值时将等号右侧的元组解包到左侧的 <code>a,b,...</code> 等变量中。</li>
<li><code>std::make_tuple(a,b,c,...)</code>：新建元组，自动检测类型。</li>
<li><code>operator&lt;=&gt;</code> ：重载比较运算符，同样是顺序关键字比较。</li>
</ul>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>下面是一个应用 C++11 新引入的元组和列表初始化的 ExGCD 实现。</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">typedef</span> tuple<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> Tuple<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-2">Tuple exgcd<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb1-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">};</span></span>
<span id="cb1-4">    ll x1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>y1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> tie<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>x1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>y1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)=</span>exgcd<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb1-5">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>y1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>x1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)*</span>y1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">};</span></span>
<span id="cb1-6"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</div>
</div>
</div>
</section>
<section id="string" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="string"><span class="header-section-number">2.3</span> string</h3>
<p>与 <code>vector</code> 类似。其余重要特性如下：</p>
<ul>
<li><code>c_str()</code> ：生成一个 C 风格字符串（尾部置 0）并返回其头部指针。</li>
<li><code>length()</code> ：<code>size()</code> 的同义函数。</li>
<li><code>append(str)</code> ：后方追加字符串，返回 <code>*this</code>。</li>
<li><code>append(first, last)</code> ：区间插入版本。</li>
<li><code>operator+</code> ：连接两个字符串。</li>
<li><code>compare(str)</code> ：字典序比较。返回一个 <code>int</code>，用 <code>&lt;0</code> / <code>==0</code> / <code>&gt;0</code> 判断该字符串小于 / 等于 / 大于参数字符串。</li>
<li><code>operator&lt;=&gt;</code> ：字典序比较的运算符重载。</li>
<li><code>substr(pos=0, count)</code>：返回 <code>[pos, min(pos+count, size()))</code> 的子串。时间复杂度与 <code>count</code> 成线性。</li>
<li><code>pop_back()</code> (C++11)</li>
<li><code>find(str)</code> / <code>rfind(str)</code> / <code>find_first_of(c)</code> / <code>find_first_not_of(c)</code> / <code>find_last_of(c)</code> / <code>find_last_not_of(c)</code>：找字符串或字符，返回位置。若无，返回 <code>npos=-1</code>。<strong>无时间复杂度保证</strong>，不建议使用。</li>
</ul>
</section>
<section id="bitset" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="bitset"><span class="header-section-number">2.4</span> bitset</h3>
<p><code>bitset&lt;N&gt; bs(val / str)</code>：声明一个长度为 N 的 <code>bitset</code> 并设定初值。</p>
<ul>
<li><code>&amp; / ! / ^ / ~ / &gt;&gt; / &lt;&lt;</code> ：支持 AND / OR / XOR / NOT / 右移 / 左移等位运算系列。</li>
<li><code>operator==</code> ：判断两个 <code>bitset</code> 是否相同。</li>
<li><code>test(idx) / operator[idx]</code> ：前者会做越界检查，抛出异常。</li>
<li><code>size()</code></li>
<li><code>count()</code> ：返回 1 的个数。</li>
<li><code>all()</code> (C++11) ：检查是否全为 1。</li>
<li><code>any() / none()</code> ：检查是否存在 1 / 没有 1。</li>
<li><code>set() / reset()</code> ：所有位赋 1 / 0。</li>
<li><code>flip()</code> ：翻转 0 / 1。</li>
</ul>
</section>
</section>
<section id="stl-容器概览" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="stl-容器概览"><span class="header-section-number">3</span> STL 容器概览</h2>
<p>以下部分均为 STL 容器相关内容。</p>
<section id="迭代器" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="迭代器"><span class="header-section-number">3.1</span> 迭代器</h3>
<p>声明：形如 <code>vector&lt;int&gt;::iterator iter = xxx.begin()</code>。C++11 后可用 <code>auto</code> 代替类型声明。</p>
<p><code>*iter</code> 取值，<code>iter++</code> 后继。</p>
<p>双向迭代器可 <code>iter--</code>，随机访问迭代器支持加减、比较运算。</p>
<ul>
<li><code>begin()</code>, <code>end()</code> ：返回迭代器。<code>end()</code> 常作为 NULL 使用。</li>
<li><code>cbegin()</code>, <code>cend()</code> (C++11) ：部分容器支持，返回只读迭代器。</li>
<li><code>rbegin()</code>, <code>rend()</code> ：部分容器支持，返回反向迭代器。</li>
<li><code>crbegin()</code>, <code>crend()</code> ：部分容器支持，返回只读反向迭代器。</li>
</ul>
</section>
<section id="公共性质" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="公共性质"><span class="header-section-number">3.2</span> 公共性质</h3>
<ul>
<li><code>[first, last)</code> 式迭代器构造，拷贝构造等。</li>
<li><code>operator=</code> ：重载了赋值运算符用于拷贝。</li>
<li><code>empty()</code> ：返回容器是否为空，即 <code>v.begin() == v.end()</code>。</li>
<li><code>size()</code> ：返回容器内元素个数。</li>
<li><code>clear()</code> ：清空容器。</li>
</ul>
</section>
</section>
<section id="序列式容器或容器适配器" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="序列式容器或容器适配器"><span class="header-section-number">4</span> 序列式容器或容器适配器</h2>
<p>序列式容器：</p>
<ul>
<li><code>array</code> (C++11) ：定长顺序表，常数随机访问。</li>
<li><code>vector</code> <code>#include&lt;vector&gt;</code>：顺序表，常数后段插入，常数随机访问。</li>
<li><code>deque</code> <code>#include&lt;deque&gt;</code> ：顺序表，常数双端插入，<strong>常数随机访问</strong>。</li>
<li><code>list</code> <code>#include&lt;list&gt;</code> ：链表，常数插入删除，双向迭代器。
<ul>
<li><code>forward_list</code> (C++11) ：单向版本。</li>
</ul></li>
</ul>
<p>容器适配器（均不支持迭代器）：</p>
<ul>
<li><code>queue</code> <code>#include&lt;queue&gt;</code>：队列（FIFO）。适配双向变长序列式容器，即 <code>deque</code>（默认）或 <code>list</code>。</li>
<li><code>stack</code> <code>#include&lt;stack&gt;</code>：栈（LIFO）。适配变长序列式容器，即 <code>deque</code>（默认）、<code>vector</code>或 <code>list</code>。</li>
<li><code>priority_queue</code> <code>#include&lt;queue&gt;</code>：大根堆。适配随机访问变长序列式容器，即 <code>vector</code>（默认）或 <code>deque</code>。</li>
</ul>
<section id="vector" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="vector"><span class="header-section-number">4.1</span> vector</h3>
<p>Construct:</p>
<ul>
<li><code>vector&lt;T&gt;(count,value)</code> ：初始化时放 <code>count</code> 个 <code>value</code> 的拷贝在里面。</li>
</ul>
<p>Access:</p>
<ul>
<li><code>crbegin()</code></li>
<li><code>at(idx)</code> / <code>operator[idx]</code> ：前者会做越界检查，抛出异常。</li>
<li><code>front()</code>, <code>back()</code> ：返回首尾元素引用。</li>
</ul>
<p>Modify:</p>
<ul>
<li><code>push_back(x)</code> / <code>pop_back()</code> ：均摊常数复杂度。</li>
<li><code>insert(iter, val)</code> ：于迭代器 <code>iter</code> 前插入，返回指向被插入元素的迭代器。 <code>insert(iter, first, last)</code> ：左闭右开区间插入，返回指向首个被插入元素的迭代器。 注意，此操作<strong>非常数时间复杂度</strong>。</li>
<li><code>erase(iter)</code> ：于迭代器 <code>iter</code> 处删除，返回指向被删除元素的后一个元素的迭代器。 <code>erase(first, last)</code> ：左闭右开区间删除，返回指向被删除元素的后一个元素的迭代器。 注意，此操作<strong>非常数时间复杂度</strong>。</li>
</ul>
<p>Size:</p>
<ul>
<li><code>resize(n)</code> ：改变长度，可指定补充元素默认值。</li>
<li><code>shrink_to_fit()</code> ：调整为恰好长度。</li>
</ul>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><code>vector&lt;bool&gt;</code> 被特殊定义，使用方式较为复杂，<strong>不建议使用</strong>。</p>
</div>
</div>
</div>
</section>
<section id="deque" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="deque"><span class="header-section-number">4.2</span> deque</h3>
<ul>
<li><code>push_front(x)</code>, <code>pop_front()</code></li>
</ul>
<p>其余与 <code>vector</code> 类似。</p>
<section id="stack" class="level4">
<h4 class="anchored" data-anchor-id="stack">stack</h4>
<ul>
<li><code>top()</code></li>
<li><code>push(x)</code></li>
<li><code>pop()</code></li>
</ul>
</section>
<section id="queue" class="level4">
<h4 class="anchored" data-anchor-id="queue">queue</h4>
<ul>
<li><code>front()</code></li>
<li><code>push(x)</code></li>
<li><code>pop()</code></li>
</ul>
</section>
<section id="priority_queue" class="level4">
<h4 class="anchored" data-anchor-id="priority_queue">priority_queue</h4>
<ul>
<li><code>std::priority_queue&lt;TypeName&gt;</code> ：<code>Compare</code> 默认使用 <code>std::less&lt;T&gt;</code>，即以 <code>operator &lt;</code> 作为大根堆的比较依据。</li>
<li><code>std::priority_queue&lt;TypeName, Container, Compare&gt;</code> ：亦可自行指定底层容器和比较函数对象。</li>
</ul>
<p>例如，传入 <code>std::greater&lt;T&gt;</code> 将使用 <code>&gt;</code> 作为比较符号，进而构造出小根堆。</p>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>自定义比较函数对象，可仿照以下代码：</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">#include</span><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">&lt;iostream&gt;</span></span>
<span id="cb2-2"><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">#include</span><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">&lt;queue&gt;</span></span>
<span id="cb2-3"><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">#include</span><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">&lt;vector&gt;</span></span>
<span id="cb2-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">typedef</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">long</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">long</span> ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">struct</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb2-6">    ll x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-7">    Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(){}</span></span>
<span id="cb2-8">    Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb2-9">        <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">this</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">this</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-10">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb2-11"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">};</span></span>
<span id="cb2-12"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">struct</span> vecCompare<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb2-13">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">bool</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">operator</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">()</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb2-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">||(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;&amp;</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb2-15">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb2-16"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">};</span></span>
<span id="cb2-17"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> main<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(){</span></span>
<span id="cb2-18">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">std::</span>priority_queue<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">std::</span>vector<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;,</span> vecCompare <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> H<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-19">    H<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>push<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span></span>
<span id="cb2-20">    H<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>push<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span></span>
<span id="cb2-21">    Vec t<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>H<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>top<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">();</span></span>
<span id="cb2-22">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">std::</span>cout<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;</span>t<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">","</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;</span>t<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-23"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</div>
</div>
</div>
<p>用法基本同 <code>queue</code>，但 <code>push() / pop()</code> 为对数时间复杂度。</p>
</section>
</section>
<section id="list" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="list"><span class="header-section-number">4.3</span> list</h3>
<ul>
<li>无随机访问接口。</li>
<li><code>insert(iter, val)</code> / <code>erase(iter)</code> ：插入与删除变为常数时间复杂度，参见 <code>vector</code>。</li>
<li><code>sort(cmp)</code> ：为链表特殊设计的 <img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20n)"> 稳定排序算法。</li>
</ul>
<p>其余与 <code>deque</code> 类似。</p>
</section>
</section>
<section id="关联式容器" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="关联式容器"><span class="header-section-number">5</span> 关联式容器</h2>
<p>不支持随机访问，双向迭代器，大部分操作为对数时间复杂度，红黑树实现。</p>
<ul>
<li><code>set</code> / <code>multiset</code> <code>#include&lt;set&gt;</code>：元素有序。后者支持同值多元素。</li>
<li><code>map</code> / <code>multimap</code> <code>#include&lt;map&gt;</code>：键有序。后者支持同键值多元素。</li>
</ul>
<section id="set-multiset" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="set-multiset"><span class="header-section-number">5.1</span> set / multiset</h3>
<ul>
<li><code>set&lt;Key&gt;</code>：默认使用 <code>operator &lt;</code> 比较（升序）。</li>
<li><code>set&lt;Key, Compare&gt;</code>：也可使用类似 <code>priority_queue</code> 的方法自定义比较函数对象 <code>Compare</code>。</li>
</ul>
<p>Access：</p>
<ul>
<li><code>crbegin()</code></li>
<li><code>count(x)</code> ：返回值为 <code>x</code> 的元素数量。</li>
<li><code>lower_bound(x)</code> / <code>upper_bound(x)</code> ：为 <code>set</code> 特殊定制的对数时间复杂度 <code>lower_bound</code> 和 <code>upper_bound</code>。</li>
</ul>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>没有 <code>nth_element()</code>，对数时间复杂度查询第 k 大需自行手写平衡树或使用 pbds 库。</p>
</div>
</div>
</div>
<p>Modify:</p>
<ul>
<li><code>insert(x)</code> ：插入元素 x。返回 <code>pair&lt;iterator, bool&gt;</code>，表示插入元素的迭代器与插入是否成功。 对于 <code>multiset</code>，由于插入不会失败，<code>insert</code> 只返回迭代器。</li>
<li><code>erase(x)</code> ：删除所有值为 x 的元素，返回删除元素的个数。 <code>erase(iter)</code> ：删除迭代器指向的元素，(C++11) 返回指向被删除元素的后一个元素的迭代器。 <code>erase(first, last)</code>：左闭右开区间删除，(C++11) 返回指向被删除元素的后一个元素的迭代器。</li>
</ul>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>删除单个值为 x 的元素，可按如下方法进行：</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">auto</span> it <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> s<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>find<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb3-2">s<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>erase<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>it<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span></code></pre></div>
</div>
</div>
</div>
</section>
<section id="map-multimap" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="map-multimap"><span class="header-section-number">5.2</span> map / multimap</h3>
<p><code>map&lt;Key, T, Compare&gt;</code>：可自定义比较方式。</p>
<ul>
<li>对迭代器解引用得到 <code>pair&lt;Key, T&gt;</code>。</li>
<li><code>insert(pair&lt;Key, T&gt;)</code></li>
<li><code>at[key]</code> / <code>operator[key]</code>：前者会做越界检查，抛出异常。</li>
</ul>
<p>其余与 <code>set</code> 类似。</p>
</section>
</section>
<section id="无序关联式容器-c11" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="无序关联式容器-c11"><span class="header-section-number">6</span> 无序关联式容器 (C++11)</h2>
<p>单向迭代器，平均常数时间复杂度，Hash 实现。</p>
<p>若不支持 c++11，使用时需引入 TR1 扩展。例如，使用 <code>unordered_map</code> 需引入 <code>#include&lt;tr1/unordered_map&gt;</code> 头文件，使用时需写为 <code>std::tr1::unordered_map</code>。</p>
<ul>
<li><code>unordered_set</code> / <code>unordered_multiset</code> <code>#include&lt;unordered_set&gt;</code>：元素无序。</li>
<li><code>unorderep_map</code> / <code>unordered_multimap</code> <code>#include&lt;unordered_map&gt;</code>：键无序。</li>
</ul>
<p>只有单向迭代器，其余特性与有序版本类似。</p>
<p>此外，还可自行指定相等判定方式和 Hash 函数。</p>
<ul>
<li><code>unordered_set&lt;Key, Hash, KeyEqual&gt;</code></li>
<li><code>unordered_map&lt;Key, T, Hash, KeyEqual&gt;</code></li>
</ul>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Hash 函数的自定义方法也与 <code>priority_queue</code> 中的方法类似：</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">#include</span><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">&lt;iostream&gt;</span></span>
<span id="cb4-2"><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">#include</span><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">&lt;unordered_set&gt;</span></span>
<span id="cb4-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">typedef</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">long</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">long</span> ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">struct</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-5">  ll x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-6">    Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(){}</span></span>
<span id="cb4-7">    Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>ll x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>ll y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb4-8">        <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">this</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">this</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-9">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-10"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">};</span></span>
<span id="cb4-11"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">bool</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">operator</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb4-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;&amp;</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-13"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-14"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">struct</span> vecHash<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-15">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">size_t</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">operator</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">()</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&amp;</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">const</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-16">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>ll<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1E9</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)+</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>y<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)%</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">107897</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-17">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-18"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">};</span></span>
<span id="cb4-19"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> main<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(){</span></span>
<span id="cb4-20">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">std::</span>unordered_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span>vecHash<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> S<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-21">    S<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>insert<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span></span>
<span id="cb4-22">    S<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>insert<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span></span>
<span id="cb4-23">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">std::</span>cout<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;&lt;</span>S<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>count<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>Vec<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">));</span></span>
<span id="cb4-24"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
</div>
</div>
</div>


</section>

 ]]></description>
  <category>OI</category>
  <category>C++</category>
  <guid>https://blog.sun123zxy.top/posts/20230124-stl/index.html</guid>
  <pubDate>Mon, 23 Jan 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>Jekyll 2 Quarto: Academic Writing’s not All About PDF</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20221226-quarto-fantasia/index.html</link>
  <description><![CDATA[ 



<section id="旅程继续" class="level2">
<h2 class="anchored" data-anchor-id="旅程继续">旅程继续</h2>
<p><a href="../../posts/20210817-aboutblog">上回说到</a>，sun123zxy 同学完成了手撸 Jekyll 的伟大壮举，然后悠哉游哉地度过了他的高三生活。现在，静态博客的大厦已经基本落成，剩下的只是一些装修工作。然而，几朵不大不小的乌云却总让他感到不安。</p>
<p>sun123zxy 曾写过一篇相对严谨的学习笔记<a href="../../posts/20200321-burnside">等价类计数：Burnside引理 &amp; Polya定理</a>，还有一篇关于行列式与生成树计数的笔记尚未发布。这些笔记里包含大量章节标号、定理与交叉引用。关于交叉引用，原生 Markdown 只支持在链接处以 section 的标题作为标签完成引用，显然对中文文档不大友好。不少人选择使用内嵌 HTML 解决问题，但死脑筋的 sun123zxy 认为这种方式背离了 Markdown 简化格式的初衷。后来他发现，<a href="https://michelf.ca/projects/php-markdown/extra/">PHP Markdown Extra</a> 格式的 Special Attributes 能解决部分交叉引用的问题，更惊喜的是 Pandoc 竟然兼容这种语法（当时 sun123zxy 对 Pandoc 还没有做深入了解，只局限于使用 jekyll-pandoc 渲染而已）。至于处理章节标号，只需对已经写好的目录系统脚本做一点改动即可，而且当时 sun123zxy 也并没有那么多篇严谨的学术向写作。总之，问题暂时得到解决。</p>
<p>另一朵乌云来自 LaTeX。众所周知，Markdown 的内嵌数学公式是 LaTeX Math Mode 的某个子集。sun123zxy 发现，自己在 LaTeX 上的不求甚解开始给他带来各种麻烦。比如，他无法解释为什么只有 <code>aligned</code> 环境能被正确渲染，而不少教程中提到的 <code>align*</code> 和支持标号的 <code>align</code> 却总是报错；再比如，由于使用了重视速度的 <a href="https://katex.org/">KaTeX</a> 而不是更加完备的 <a href="https://www.mathjax.org/">MathJax</a> 作为渲染引擎，他发现自己无法使用诸如 <code>\newcommand</code>、<code>\DeclareMathOperator</code> 的宏定义。而且，一些教程中提到的 <code>physics</code> 等需要自行导入的“宏包”也让他摸不着头脑。</p>
<p>最重要的是，sun123zxy 开启了他的大学生活，论文写作的需求使他产生了系统学习 LaTeX 的想法。他在网协大牛那里听说了 <a href="https://www.overleaf.com/">Overleaf</a>，并在间歇性热情驱使下疯狂啃食文档，最终写出了自己的文档类，覆盖常见中文社科、科技向论文写作需求。验之以文，效果拔群。学习过程中，sun123zxy 习得众多排版常识，掌握了各种 font family 的区别、衬线字体的使用情景、英文 dash 的分辨方式等技巧，姿势水平得到质的飞跃。</p>
<p>sun123zxy 发现自己有点沉迷 LaTeX 了。他在写集合论大作业时学习了 <code>amsthm</code> 宏包，现已完全抵挡不住“定理 2.3”、“推论 4.1.1”、“例题 3.2”、“图 3”、“表 1”自动标号和交叉引用的诱惑。曾经博客使用的加强版 Markdown 在完备的 LaTeX 面前不值一提。他突然感觉有点害怕，毕竟 PDF 格式的网络发布效果并不理想。他需要找到一种能兼取两种格式长处的解决方案，否则他的博客将成为历史的眼泪。</p>
<p>然而在这里他遇到了瓶颈。尽管已经有一系列形如 LaTeX2HTML 的项目存在，但因为 TeX/LaTeX 是为 PDF 等页面固定的展现方式而设计，在转换成尺寸动态变化的网页（HTML）时必然面临信息损失。<a href="https://yihui.org/en/2013/10/markdown-or-latex/">Markdown or LaTeX? - Yihui Xie | 谢益辉</a> 这篇文章详细的讨论了 Markdown 和 LaTeX 间不可调和的冲突。更好的思路是，利用轻巧且可读性优秀的 Markdown 作为写作语言直接输出 HTML，需要 PDF 时再使用其它程序处理得到 LaTeX 代码。<a href="https://ctan.org/pkg/markdown">markdown 宏包</a>就解决了这样的问题。</p>
<blockquote class="blockquote">
<p>「你喜爱的 Markdown 写作，现更以 LaTeX 呈现。」</p>
<p>——<a href="https://liam.page/2020/03/30/writing-manuscript-in-Markdown-and-typesetting-with-LaTeX/">以 Markdown 撰写文稿，以 LaTeX 排版 | 始终</a></p>
</blockquote>
<p>markdown 宏包提供的 hybrid 功能还提供了将 LaTeX 命令混入 Markdown 的功能，完美覆盖了上述使用情景。然而，Markdown 自身在学术写作方面的固有缺陷——难以交叉引用、无法自动编号、没有定理系统——仍然让 HTML 输出举步维艰。问题在这里似乎陷入了死结：既想要 Markdown 的可读性和 HTML 输出，又想要 LaTeX 的定理系统和 PDF 输出——这可能吗？</p>
<p>sun123zxy 询问了不少同时掌握 Markdown 和 LaTeX 的大佬，他们都没有研究过这样的问题。唯一的希望是：找到一种合适的方式扩展 Markdown 的语法。sun123zxy 想起了 <a href="https://pandoc.org/">Pandoc</a>——文档转换界的瑞士军刀。事实证明 Pandoc 确实对得起这个称呼。他离解决方案已经非常近了：<a href="https://pandoc.org/MANUAL.html#pandocs-markdown">Pandoc’s Markdown</a> 已经非常强大，强大到可以随意内嵌 LaTeX 代码（当然只对 LaTeX 输出有效），交叉引用几乎任何内容，甚至可以用 Markdown 风格的 fenced syntax 控制 HTML 中的 <code>div</code>、<code>span</code> 及其参数！再加上 <a href="https://github.com/tomduck/pandoc-xnos">pandoc-xnos</a> 插件提供的自动标号功能，问题几乎得到全部解决——而现在看来，定理系统也可以通过编写 Pandoc filter 实现。</p>
<p>当然，sun123zxy 是个懒人，在能搜到解决方案的情况下，他不会干重复造轮子的傻事。某日，sun123zxy 又开始他了的头脑风暴。通过 Google 新的关键字 <code>markdown</code>、<code>cross-reference</code>、<code>academic writing</code>，他发现了 <a href="https://rmarkdown.rstudio.com/">R Markdown</a>，进而发现了 <a href="https://quarto.org/">Quarto</a>。</p>
<blockquote class="blockquote">
<p>Quarto is an open-source scientific and technical publishing system built on Pandoc.</p>
<ul>
<li>Create dynamic content with Python, R, Julia, and Observable.</li>
<li>Author documents as plain text markdown or Jupyter notebooks.</li>
<li>Publish high-quality articles, reports, presentations, websites, blogs, and books in HTML, PDF, MS Word, ePub, and more.</li>
<li>Author with scientific markdown, including equations, citations, crossrefs, figure panels, callouts, advanced layout, and more.</li>
</ul>
<p>——几乎让我一下子跳起来的 Overview</p>
</blockquote>
<p>Quarto 是构建在 Pandoc 上的文档发布系统，对 Pandoc’s Markdown 做了进一步扩展以适应学术写作，其中就包含了 pandoc-xnos 的语法和——用 Pandoc’s Markdown 的 fenced syntax 实现的定理系统！此外，Quarto 甚至还支持 Jupyter Notebook 的动态计算，附上 Matplotlib 代码就可动态生成统计图表——而且同样也可以被交叉引用！更让人欣喜的是，除了直接输出 HTML 和 PDF/LaTeX，Quarto 还提供了类似 Jekyll 的生成静态网站的功能！</p>
<p>于是，长达数月的探索终于落下帷幕，语法学习、环境配置与博客迁移被提上日程。又是近一个月的辛勤劳动，sun123zxy 终于完成了写作流程的构建和博客的搭建工作。盯着桌前已经冷透了的保温杯，他陷入了沉思……</p>
</section>
<section id="主要成果" class="level2">
<h2 class="anchored" data-anchor-id="主要成果">主要成果</h2>
<ul>
<li>基于 Quarto 的 <a href="https://github.com/sun123zxy/sunquartex">SunQuarTeX</a> 多格式中文学术写作出版流程，内含适用于常见中文论文写作的 LaTeX 文档类及其示例文档。</li>
<li>Quarto 驱动的适应学术写作要求的<a href="https://blog.sun123zxy.top">新版博客</a>（<a href="https://github.com/sun123zxy/blog-quarto-code">sun123zxy/blog-quarto-code</a>）。</li>
</ul>
<p>上一个 Jekyll 博客，一砖一瓦都是自己搭出来的，有感情了（笑）。所以也没下线，放在 <a href="https://blog-jekyll.sun123zxy.top">blog-jekyll.sun123zxy.top</a> 上了。如果你也和我一样怀旧，可以去看看~</p>
<p>那么，依照惯例，聊聊学习与折腾中的一点心得体会。</p>
</section>
<section id="关于-latex" class="level2">
<h2 class="anchored" data-anchor-id="关于-latex">关于 LaTeX</h2>
<p>很多人说 LaTeX 不好学——的确。即使是 OIer 群体，对 LaTeX 的认知也大多停留在数学公式水平。然而比起客观的困难，更应该问的问题是——Why LaTeX? 不同人的答案或许有所不同，但应有以下几点：</p>
<ul>
<li>有学术写作或打印文档的需求（否则可直接使用 Markdown/HTML）</li>
<li>认同内容与样式分离的设计思想，希望对文档排版有清晰的控制，而不是所见即所得的富文本格式导致的混乱。</li>
<li>希望用相对不易损坏且可读性较高的代码式文档替代 <code>.docx</code> 式的黑箱存储。</li>
<li>需要使用章节标号、定理系统等交叉引用功能。</li>
<li>想用简洁的代码生成严谨美观的数学公式。</li>
<li><del>就是感觉 LaTeX 排出来的东西很牛逼</del></li>
</ul>
<p>学习 LaTeX 需要了解它的历史，理解它的开发理念，理清 TeX/LaTeX 的历史进程，弄清 pdfLaTeX、XeLaTeX、LuaLaTeX 各自的特点，在 MikeTeX、TeXLive 两个发行版中做出选择，学习 BibTeX 引用管理格式，还有对排版知识的初步了解——知识体系可谓庞大。此外，不少 LaTeX 教学文档、各种宏包的手册本身就是由 LaTeX 生成的，这意味它们都是 PDF 格式，无法在互联网上得到很好的传播。但请不要忘记，它们是学习 LaTeX 的第一手资料。例如，<a href="https://www.ctan.org/">CTAN</a> 上的手册是学习各类宏包的第一途径，<a href="https://www.latex-project.org/help/documentation/">LaTeX 官网</a>也提供了不少相对系统的 PDF 教程。当然，近年来网页渲染工具 <a href="https://www.overleaf.com/">Overleaf</a> 的出现降低了环境配置的难度，<a href="https://www.overleaf.com/learn">Overleaf 的 LaTeX 教学文档</a>也非常优秀。我还强烈推荐 <a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档 | 始终</a> 这篇文章作为入门，作者是一位参与维护 CTeX 宏集的大佬，之前提到的 markdown 宏包他也写过一篇详细的介绍，详见上文引用中的链接。</p>
<p>在互联网上碎片化的学习 LaTeX，一定要经常问自己——这功能是哪个宏包定义的？例如，关于交叉引用，<code>\label</code>、<code>\ref</code>、<code>\pageref</code> 均为原生自带，<code>\eqref</code> 是 <code>amsmath</code> 宏包定义的，而 <code>\autoref</code> <code>\href</code> <code>\url</code> 均为 <code>hyperref</code> 宏包的命令，引入 <code>hyperref</code> 的目的主要是让文章里的交叉引用都变成 PDF 里可点击跳转的超链接；再例如，定理系统是 LaTeX 原生支持的，但 <code>amsthm</code> 提供了无标号版本的定理、设置 <code>\theoremstyle</code> 的方式和自动添加 QED symbol 的 <code>proof</code> 环境。再次强调，不要错过宏包的 PDF 手册！阅读手册是整合碎片知识、查漏补缺的最佳途径。</p>
</section>
<section id="关于-ctex" class="level2">
<h2 class="anchored" data-anchor-id="关于-ctex">关于 CTeX</h2>
<p>此外，有必要对中文排版基础宏包 <a href="https://ctan.org/pkg/ctex">CTeX</a> 做进一步说明。</p>
<blockquote class="blockquote">
<p>最初，Knuth 在设计开发 TeX 的时候没有考虑到多国文字支持，特别是对多字节的中日韩表意文字的支持。这使得 TeX 以至后来的 LaTeX 对中文的支持一直不是很好。即使在 CJK 宏包解决了中文字符处理的问题以后，中文用户使用 LaTeX 仍然要面对许多困难。这些困难里，以章节标题的中文化为最。由于中文和西文书写习惯的差异，用户很难使用标准文档类中的代码结构来表达中文标题。于是，用户不得不对标准文档类做较大的修改。除此之外，日期格式、首行缩进、中文字号和字距等细节问题，也需要精细的调校。我们设计 CTeX 宏集的目的之一就是解决这些 LaTeX 文档的汉化难题。</p>
<p>另一方面，随着 TeX 引擎和 LaTeX 宏包的不断发展，LaTeX 的中文支持方式从早期的专用系统（如 CCT）发展为适用于不同引擎的多种方式。这些方式的适用情况和使用方式有不少细节上的差异，同时操作系统的不同、语言环境的不同等客观情况又进一步带来了更多的细节差异。我们设计 CTeX 宏集的另一个主要目的就是尽可能消除这些差异带来的影响，使用户能够以一个统一的接口来使用不同的中文支持方式，使得同一份文档能够在不同环境下交换使用。</p>
<p>——CTeX 宏集手册 - 第 1 节：介绍</p>
</blockquote>
<p>CTeX 的基础使用，我仍然推荐上面始终的入门文档。<a href="https://zhuanlan.zhihu.com/p/538459335">LaTeX 中文字体配置基础指南 - 知乎</a>对我的帮助也很大。如果打算进一步自定义样式建立自己的文档类，还得沉下心来研读手册。</p>
</section>
<section id="关于-pandoc" class="level2">
<h2 class="anchored" data-anchor-id="关于-pandoc">关于 Pandoc</h2>
<p>Pandoc 其实一直致力于扩展 Markdown 的语法使其适合学术写作。<a href="https://www.youtube.com/watch?v=T9uZJFO54iM">TUG 2020 — John MacFarlane — Pandoc for TeXnicians</a> 的演讲几乎涵盖了所有值得关心的问题。</p>
<p>我认为 Pandoc 已有能力成为下一代学术写作的终极解决方案。语法上，Markdown 简洁易读，语法天然与格式解耦（反例是 LaTeX），而 Pandoc’s Markdown 是 Markdown 方言的集大成者，交叉引用、文献引用、图表等 Markdown 原生痛点都有很好的支持，fenced syntax 甚至可以视为 LaTeX environment 的平替；技术上，Pandoc 已经是非常成熟的格式转换工具，而 Pandoc filter 好比 LaTeX 中的 documentclass 和 style 文件，事实上实现了 Markdown 中的“宏定义”。如社区进一步发展，大部分常用 filter 能像在 LaTeX 中引用 documentclass 一样轻松获取，我们就能真正告别格式的困扰，拥抱 Pandoc’s Markdown 治下的多格式学术写作。</p>
<p>从这角度来看，Quarto 似乎更像是 Jupyter、Jekyll 和一堆 Pandoc filter 的混合物（笑）</p>
</section>
<section id="关于-quarto" class="level2">
<h2 class="anchored" data-anchor-id="关于-quarto">关于 Quarto</h2>
<p>Quarto 首个 Release 距今不到 2 年，是相当年轻的项目。开发 Quarto 的团队之前主要维护 R Markdown，Quarto 是他们跳出 R 语言生态圈，将成果扩展至更广阔生态圈（如 Python）的尝试，这也意味着项目尚存不尽人意之处。把它调理成满意的模样，还真得花不少功夫。<del>甚至让笔者开了人生首个正经 issue</del></p>
<section id="sunquartex" class="level3">
<h3 class="anchored" data-anchor-id="sunquartex">SunQuarTeX</h3>
<p>使用 Quarto，我主要有两大需求——论文多格式输出和静态博客生成。两个需求相对独立，因此有必要将离线论文输出的功能单独抽象出来。折腾的结果就是 <a href="https://github.com/sun123zxy/sunquartex">SunQuarTeX</a>。Quarto 原生的 HTML 输出还不错，自带目录高亮还有引用提示，稍微改改就能用了。关于自定义，Quarto 使用 SCSS 作为 CSS 生成器，意味着可以直接通过修改变量或 <code>@extend</code> 完成大部分工作。参考以下文档：</p>
<ul>
<li><a href="https://quarto.org/docs/output-formats/html-themes.html">Quarto - HTML Theming</a></li>
<li><a href="https://quarto.org/docs/output-formats/html-themes-more.html">Quarto - More About Quarto Themes</a></li>
<li><code>quarto-cli</code> 下的 <code>/src/resources/formats/html/bootstrap/</code>：内有 Quarto 的 SCSS 定义，目录下还有各种官方主题的 SCSS 文件，可作参照。Tip: 善用 Github 搜索功能！</li>
</ul>
<p>我这边的修改主要是把定理做成了 callout 的样式，另外给 proof 尾部加了 QED symbol。</p>
<p>难绷的是 PDF，直接生成效果可谓一言难尽……还好，与 Pandoc 相似，Quarto 提供了设置 <code>template</code> 的功能，可使用稍加改动的 LaTeX 文件作为生成模板，从而完全控制文章 LaTeX 的生成方式，进而控制 PDF 输出的样式。可参考以下文档食用：</p>
<ul>
<li><a href="https://github.com/quarto-dev/quarto-cli/discussions/2543">complex thesis with quarto · Discussion #2543 · quarto-dev/quarto-cli · GitHub</a></li>
<li><a href="https://quarto.org/docs/journals/templates.html#templates">Quarto - Article Templates</a></li>
</ul>
<p>当然，这得在已有成熟 LaTeX 模板的前提下才能进行，所以还是得会 LaTeX（笑）。使用过程中笔者也发现生成的 LaTeX 的某些细节不太合理（如 <a href="https://github.com/quarto-dev/quarto-cli/issues/3736">Issue #3736</a>，详见 SunQuarTeX 仓库 README），当然也无伤大雅，且等开发团队慢慢完善吧。</p>
</section>
<section id="blog" class="level3">
<h3 class="anchored" data-anchor-id="blog">Blog</h3>
<p>有了前面的基础，再搭博客也就容易了。以笔者一贯的风格，博客样式都是要操刀大改的（上一个甚至直接从零手撸了 XD），这次工作却意外的少。一方面考虑到毕竟不在 CS 专业，写那么多祖传代码之后维护也是麻烦事；另一方面嘛……</p>
<blockquote class="blockquote">
<p>这，谁写的这 <code>darkly</code> 这主题，绿不拉几的</p>
<p>看一眼</p>
<p><code>#00bc8c</code>，啊这样</p>
<p>草</p>
<p>这样啊这样</p>
<p>加个背景</p>
<p>……</p>
<p>？</p>
<p>？？？</p>
<p>好像还挺配的？</p>
<p>——来自考试周还在摸鱼的 sun123zxy 的惊叹</p>
</blockquote>
<p>light mode 的 <code>flatly</code> 也还不错，直接丢上去没改了。唯一的缺憾是 <a href="https://github.com/quarto-dev/quarto-cli/issues/3705">Issue #3705</a>，按开发组成员的回复来看，短期内 light mode 和 dark mode 的相互分离还不能实现。</p>
<p>此外，关于代码高亮的自定义方式，可参考以下要点：</p>
<ul>
<li><a href="https://quarto.org/docs/output-formats/html-code.html#highlighting">Quarto - HTML Code Blocks # Highlighting</a></li>
<li><code>quarto-cli</code> 下的 <code>/src/resources/pandoc/highlight-styles/</code>：内有官方样式文件，可作为模板。</li>
<li>行内高亮不能在 <code>.theme</code> 中更改，可通过覆盖 SCSS 的 <code>$code-color</code> 设置。</li>
</ul>
</section>
<section id="quarto-1.4-notes" class="level3">
<h3 class="anchored" data-anchor-id="quarto-1.4-notes">Quarto 1.4 Notes</h3>
<ul>
<li>Giscus 支持自适应夜间主题了，正式上线后可实装</li>
</ul>
</section>
</section>
<section id="画廊" class="level2">
<h2 class="anchored" data-anchor-id="画廊">画廊</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20221226-quarto-fantasia/quarto-begin.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">2022/12/26 上线前夕</figcaption>
</figure>
</div>


</section>

 ]]></description>
  <category>站点相关</category>
  <category>web</category>
  <category>LaTeX</category>
  <category>回忆</category>
  <guid>https://blog.sun123zxy.top/posts/20221226-quarto-fantasia/index.html</guid>
  <pubDate>Sun, 25 Dec 2022 16:00:00 GMT</pubDate>
</item>
<item>
  <title>SunQuarTeX 中文学术写作示例文档</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20221223-quarto-test/index.html</link>
  <description><![CDATA[ 



<section id="前言" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="前言"><span class="header-section-number">1</span> 前言</h2>
<p>具体使用方法等参见 <a href="https://github.com/sun123zxy/sunquartex">sun123zxy/sunquartex</a>。</p>
</section>
<section id="文章结构测试" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="文章结构测试"><span class="header-section-number">2</span> 文章结构测试</h2>
<p>这一节测试文章结构。</p>
<section id="文章分节" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="文章分节"><span class="header-section-number">2.1</span> 文章分节</h3>
<p>非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子。</p>
<section id="sec-test" class="level4">
<h4 class="anchored" data-anchor-id="sec-test">文章分分节</h4>
<p>Quarto 支持交叉引用。比如这一节的标题就已经被打上了标签。</p>
<section id="分分分节" class="level5">
<h5 class="anchored" data-anchor-id="分分分节">分分分节</h5>
<p>本节中我们测试交叉引用 Section&nbsp;2.1.1。</p>
<section id="分分分分节" class="level6">
<h6 class="anchored" data-anchor-id="分分分分节">分分分分节</h6>
<p>这是最小的一级了。</p>
</section>
</section>
</section>
</section>
</section>
<section id="图片表格列表测试" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="图片表格列表测试"><span class="header-section-number">3</span> 图片、表格、列表测试</h2>
<p>这是 Quarto 的图标。</p>
<div id="fig-quarto" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20221223-quarto-test/quarto.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: 这是一张插图</figcaption>
</figure>
</div>
<p>交叉引用 Figure&nbsp;1 当然也是可以的。</p>
<p>这是一个紧凑列表。</p>
<ul>
<li>自反性。</li>
<li>反对称性一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子。</li>
<li>传递性。</li>
</ul>
<p>这是一个宽松列表。</p>
<ul>
<li><p>自反性。</p></li>
<li><p>反对称性一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子。</p>
<p>还多加了一段。</p></li>
<li><p>传递性。</p></li>
</ul>
<p>当然也可以使用 markdown 表格。例如 Table&nbsp;1 (a).</p>
<p>顺便测试以下多表格并列。加上 Table&nbsp;1 (b)，它们共同组成了 Table&nbsp;1。</p>
<div id="tbl-panel-unsolved" class="tbl-parent quarto-layout-panel anchored">
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-cartesian-unsolved" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel-unsolved" style="flex-basis: 50.0%;justify-content: center;">
<table class="table">
<caption>(a) 笛卡尔积</caption>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?L_i%20%5Ctimes%20C_j"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?2"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?2"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?4"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;">?</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
<td style="text-align: center;">?</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
</tr>
</tbody>
</table>
</div>
<div id="tbl-power-unsolved" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel-unsolved" style="flex-basis: 50.0%;justify-content: center;">
<table class="table">
<caption>(b) 集合幂</caption>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?L_i%5E%7BC_j%7D"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?2"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?2"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?4"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?2%5E%7B%5Cmathbb%20R%7D"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20N"></td>
<td style="text-align: center;">?</td>
<td style="text-align: center;">?</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R"></td>
<td style="text-align: center;">?</td>
<td style="text-align: center;">?</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="panel-caption table-caption">
<p>Table&nbsp;1: 相关集合的势（不完整版）</p>
</div>
</div>
</section>
<section id="数学公式定理系统测试" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="数学公式定理系统测试"><span class="header-section-number">4</span> 数学公式、定理系统测试</h2>
<p>Quarto 的一大卖点。</p>
<p>这一节我们测试数学相关内容. HTML 中的定理标号方式目前没有方法更改，但 LaTeX 中的定理标号可通过自行修改模板中 <code>amsthm</code> 宏包的定义实现.</p>
<p>此外，根据 <a href="https://quarto.org/docs/authoring/markdown-basics.html#equations">Quarto - Markdown Basics # Equations</a> 和 <a href="https://github.com/quarto-dev/quarto-cli/discussions/1793">Defining LaTeX commands for HTML and PDF rendering - Discussion #1793</a> 和 <a href="https://quarto.org/docs/authoring/conditional.html">Quarto - Conditional Content</a>，按如下面方式自定义 macro 可确保其在 HTML、 LaTeX/PDF 和 MS Word 中都得到正确渲染。值得注意的是，由于 <code>\DeclareMathOperator</code> 只能在 LaTeX 的导言区使用，这里我们用 <code>\newcommand</code> + <code>\operatorname</code> 的方式替代。</p>
<div class="hidden">
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cnewcommand%7B%5Cran%7D%7B%5Coperatorname%7Bran%7D%7D%0A"></p>
</div>
<p>下面的公式使用了上面定义的 macro。 <img src="https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7Bran%7DA%20:=%20%5C%7B%20y%20%5Cmid%20(x,y)%20%5Cin%20A%20%5C%7D%0A"></p>
<p>两个集合 <img src="https://latex.codecogs.com/png.latex?A,%20B"> 的笛卡尔积定义为 <img src="https://latex.codecogs.com/png.latex?%0AA%20%5Ctimes%20B%20=%20%5C%7B%5Clangle%20x,y%20%5Crangle%20%5Cmid%20x%20%5Cin%20A%20%5Cland%20y%20%5Cin%20B%20%5C%7D%0A"></p>
<p>显然，笛卡尔积不满足交换律和结合律. 在势的视角下，它的表现如何呢？</p>
<div id="thm-cartesian-preserve" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (笛卡尔积的保势性) </strong></span>这是一个有 caption 的定理.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AA%20%5Cpreccurlyeq%20C%20%5Cland%20B%20%5Cpreccurlyeq%20D%20%5Cimplies%20A%20%5Ctimes%20B%20%5Cpreccurlyeq%20C%20%5Ctimes%20D%0A"></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>建立单射 <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cvarphi:%20A%20%5Ctimes%20B%20&amp;%5Cto%20C%20%5Ctimes%20D%20%5C%5C%0A%5Clangle%20x,y%20%5Crangle%20&amp;%5Cmapsto%20%5Clangle%20f(x),%20g(y)%20%5Crangle%0A%5Cend%7Baligned%7D%0A"> 即可，其中 <img src="https://latex.codecogs.com/png.latex?f"> 和 <img src="https://latex.codecogs.com/png.latex?g"> 是由 <img src="https://latex.codecogs.com/png.latex?A%20%5Cpreccurlyeq%20C"> 和 <img src="https://latex.codecogs.com/png.latex?B%20%5Cpreccurlyeq%20D"> 确定的单射.</p>
</div>
<div id="cor-random" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 </strong></span>等势意义下可用等势的集合替换参与笛卡尔积运算的集合，即 <img src="https://latex.codecogs.com/png.latex?%0AA%20%5Capprox%20C%20%5Cland%20B%20%5Capprox%20D%20%5Cimplies%20A%20%5Ctimes%20B%20%5Capprox%20C%20%5Ctimes%20D%0A"></p>
<p>这是一个没有 caption 的定理.</p>
</div>
<div id="exm-rtimesn" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 </strong></span>证明 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%20R%20%5Ctimes%20%5Cmathbb%20N%20%5Capprox%20%5Cmathbb%20N%20%5Ctimes%20%5Cmathbb%20R%20%5Capprox%20%5Cmathbb%20R%0A"></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>利用 Theorem&nbsp;1 对 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R%20%5Ctimes%202"> 和 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%20R%20%5Ctimes%20%5Cmathbb%20R"> 夹逼，立刻得到 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%20R%20%5Capprox%20%5Cmathbb%20R%20%5Ctimes%202%20%5Cpreccurlyeq%20%5Cmathbb%20R%20%5Ctimes%20%5Cmathbb%20N%20%5Cpreccurlyeq%20%5Cmathbb%20R%20%5Ctimes%20%5Cmathbb%20R%20%5Capprox%20%5Cmathbb%20R%0A%5Cimplies%20%5Cmathbb%20R%20%5Ctimes%20%5Cmathbb%20N%20%5Capprox%20%5Cmathbb%20N%20%5Ctimes%20%5Cmathbb%20R%20%5Capprox%20%5Cmathbb%20R%0A"></p>
</div>
</section>
<section id="数据可视化" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="数据可视化"><span class="header-section-number">5</span> 数据可视化</h2>
<p>Quarto 的另一大卖点。</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb1-3"></span>
<span id="cb1-4">r <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.arange(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>)</span>
<span id="cb1-5">theta <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> np.pi <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> r</span>
<span id="cb1-6">fig, ax <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> plt.subplots(</span>
<span id="cb1-7">  subplot_kw <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'projection'</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'polar'</span>} </span>
<span id="cb1-8">)</span>
<span id="cb1-9">ax.plot(theta, r)</span>
<span id="cb1-10">ax.set_rticks([<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.5</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>])</span>
<span id="cb1-11">ax.grid(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb1-12">plt.show()</span></code></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-polar" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="https://blog.sun123zxy.top/posts/20221223-quarto-test/index_files/figure-html/fig-polar-output-1.png" width="450" height="439" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: A line plot on a polar axis</figcaption>
</figure>
</div>
</div>
</div>
<p>交叉引用 Figure&nbsp;2 当然也是可以的.</p>
<p>另外，支持使用 GraphViz 或 Mermaid 绘制有向图或流程图。</p>
<div class="cell" data-fig-width="6.25" data-fig-height="2.5">
<div class="cell-output-display">
<div id="fig-real" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<div>
<svg width="600" height="240" viewbox="0.00 0.00 422.00 310.40" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 306.4)">
<title>
G
</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-306.4 418,-306.4 418,4 -4,4"></polygon> <!-- sup --> <g id="node1" class="node">
<title>
sup
</title>
<ellipse fill="none" stroke="black" cx="27" cy="-106.8" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="27" y="-102.6" font-family="Times,serif" font-size="14.00">A</text> </g> <!-- mono --> <g id="node2" class="node">
<title>
mono
</title>
<ellipse fill="none" stroke="black" cx="117" cy="-106.8" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="117" y="-102.6" font-family="Times,serif" font-size="14.00">B</text> </g> <!-- sup&#45;&gt;mono --> <g id="edge1" class="edge">
<title>
sup-&gt;mono
</title>
<path fill="none" stroke="black" d="M54.07,-106.8C62.67,-106.8 71.27,-106.8 79.87,-106.8"></path> <polygon fill="black" stroke="black" points="79.96,-110.3 89.96,-106.8 79.96,-103.3 79.96,-110.3"></polygon> </g> <!-- nested --> <g id="node3" class="node">
<title>
nested
</title>
<ellipse fill="none" stroke="black" cx="207" cy="-106.8" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="207" y="-102.6" font-family="Times,serif" font-size="14.00">C</text> </g> <!-- mono&#45;&gt;nested --> <g id="edge2" class="edge">
<title>
mono-&gt;nested
</title>
<path fill="none" stroke="black" d="M144.07,-106.8C152.67,-106.8 161.27,-106.8 169.87,-106.8"></path> <polygon fill="black" stroke="black" points="169.96,-110.3 179.96,-106.8 169.96,-103.3 169.96,-110.3"></polygon> </g> <!-- nested&#45;&gt;sup --> <g id="edge6" class="edge">
<title>
nested-&gt;sup
</title>
<path fill="none" stroke="black" d="M188.83,-93.14C172.85,-82.02 148.45,-67.2 124.5,-61 97.85,-54.1 69.61,-70.28 50.42,-85.28"></path> <polygon fill="black" stroke="black" points="48.02,-82.72 42.53,-91.78 52.47,-88.12 48.02,-82.72"></polygon> <text text-anchor="middle" x="121" y="-58.2" font-family="Times,serif" font-size="14.00">2</text> </g> <!-- bw --> <g id="node4" class="node">
<title>
bw
</title>
<ellipse fill="none" stroke="black" cx="387" cy="-106.8" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="387" y="-102.6" font-family="Times,serif" font-size="14.00">D</text> </g> <!-- nested&#45;&gt;bw --> <!-- accu --> <g id="node6" class="node">
<title>
accu
</title>
<ellipse fill="none" stroke="black" cx="297" cy="-106.8" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="297" y="-102.6" font-family="Times,serif" font-size="14.00">F</text> </g> <!-- nested&#45;&gt;accu --> <g id="edge8" class="edge">
<title>
nested-&gt;accu
</title>
<path fill="none" stroke="black" d="M234,-106.8C242.03,-106.8 250.97,-106.8 259.53,-106.8"></path> <polygon fill="black" stroke="black" points="259.71,-110.3 269.71,-106.8 259.7,-103.3 259.71,-110.3"></polygon> <text text-anchor="middle" x="252" y="-91.2" font-family="Times,serif" font-size="14.00">4</text> </g> <!-- finite --> <g id="node7" class="node">
<title>
finite
</title>
<ellipse fill="none" stroke="black" cx="252" cy="-284.4" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="252" y="-280.2" font-family="Times,serif" font-size="14.00">G</text> </g> <!-- nested&#45;&gt;finite --> <g id="edge7" class="edge">
<title>
nested-&gt;finite
</title>
<path fill="none" stroke="black" d="M211.31,-124.64C219.14,-155.19 235.74,-219.97 245.14,-256.64"></path> <polygon fill="black" stroke="black" points="241.83,-257.8 247.7,-266.61 248.61,-256.06 241.83,-257.8"></polygon> <text text-anchor="middle" x="237.5" y="-191.4" font-family="Times,serif" font-size="14.00">3</text> </g> <!-- cauchy --> <g id="node5" class="node">
<title>
cauchy
</title>
<ellipse fill="none" stroke="black" cx="228" cy="-18" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="228" y="-13.8" font-family="Times,serif" font-size="14.00">E</text> </g> <!-- bw&#45;&gt;cauchy --> <g id="edge4" class="edge">
<title>
bw-&gt;cauchy
</title>
<path fill="none" stroke="black" d="M366.78,-94.76C338.97,-79.58 288.77,-52.17 256.97,-34.82"></path> <polygon fill="black" stroke="black" points="258.59,-31.71 248.14,-29.99 255.24,-37.86 258.59,-31.71"></polygon> </g> <!-- lebesgue --> <g id="node8" class="node">
<title>
lebesgue
</title>
<ellipse fill="none" stroke="black" cx="368" cy="-195.6" rx="27" ry="18"></ellipse> <text text-anchor="middle" x="368" y="-191.4" font-family="Times,serif" font-size="14.00">H</text> </g> <!-- bw&#45;&gt;lebesgue --> <g id="edge11" class="edge">
<title>
bw-&gt;lebesgue
</title>
<path fill="none" stroke="black" d="M383.25,-124.95C380.59,-137.08 376.98,-153.58 373.94,-167.48"></path> <polygon fill="black" stroke="black" points="370.47,-166.97 371.75,-177.49 377.3,-168.47 370.47,-166.97"></polygon> <text text-anchor="middle" x="382.5" y="-147" font-family="Times,serif" font-size="14.00">7</text> </g> <!-- cauchy&#45;&gt;mono --> <g id="edge5" class="edge">
<title>
cauchy-&gt;mono
</title>
<path fill="none" stroke="black" d="M211.14,-32.18C192.72,-46.59 163.03,-69.8 141.92,-86.31"></path> <polygon fill="black" stroke="black" points="139.74,-83.58 134.02,-92.49 144.05,-89.09 139.74,-83.58"></polygon> <text text-anchor="middle" x="186.5" y="-58.2" font-family="Times,serif" font-size="14.00">1</text> </g> <!-- accu&#45;&gt;bw --> <g id="edge10" class="edge">
<title>
accu-&gt;bw
</title>
<path fill="none" stroke="black" d="M334.16,-106.8C339.24,-106.8 344.45,-106.8 349.54,-106.8"></path> <polygon fill="black" stroke="black" points="334,-103.3 324,-106.8 334,-110.3 334,-103.3"></polygon> <polygon fill="black" stroke="black" points="349.71,-110.3 359.71,-106.8 349.7,-103.3 349.71,-110.3"></polygon> <text text-anchor="middle" x="342" y="-91.2" font-family="Times,serif" font-size="14.00">6</text> </g> <!-- finite&#45;&gt;sup --> <g id="edge13" class="edge">
<title>
finite-&gt;sup
</title>
<path fill="none" stroke="black" d="M235.2,-270.29C195.96,-239.66 98.12,-163.3 51.91,-127.24"></path> <polygon fill="black" stroke="black" points="53.95,-124.39 43.91,-121 49.64,-129.91 53.95,-124.39"></polygon> <text text-anchor="middle" x="165.5" y="-191.4" font-family="Times,serif" font-size="14.00">9</text> </g> <!-- finite&#45;&gt;accu --> <g id="edge9" class="edge">
<title>
finite-&gt;accu
</title>
<path fill="none" stroke="black" d="M256.3,-266.61C264.12,-236.1 280.72,-171.32 290.13,-134.62"></path> <polygon fill="black" stroke="black" points="293.59,-135.19 292.69,-124.64 286.81,-133.46 293.59,-135.19"></polygon> <text text-anchor="middle" x="282.5" y="-191.4" font-family="Times,serif" font-size="14.00">5</text> </g> <!-- lebesgue&#45;&gt;finite --> <g id="edge12" class="edge">
<title>
lebesgue-&gt;finite
</title>
<path fill="none" stroke="black" d="M350.72,-209.6C336.77,-220.09 316.63,-235.21 299,-248.4 292.13,-253.54 284.68,-259.09 277.78,-264.23"></path> <polygon fill="black" stroke="black" points="275.35,-261.67 269.42,-270.45 279.53,-267.29 275.35,-261.67"></polygon> <text text-anchor="middle" x="322.5" y="-235.8" font-family="Times,serif" font-size="14.00">8</text> </g> </g>
</svg>
</div>
<figcaption class="figure-caption">Figure&nbsp;3: GraphViz 有向图</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="html-专用测试" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="html-专用测试"><span class="header-section-number">6</span> HTML 专用测试</h2>
<p>目前暂未处理 LaTeX/PDF 格式的代码高亮和 callout，MS Word 格式可兼容但效果不佳。本节测试内容不会在 LaTeX/PDF 格式下被渲染。</p>
<section id="代码块引用" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="代码块引用"><span class="header-section-number">6.1</span> 代码块、引用</h3>
<p>本节测试代码块和引用。</p>
<blockquote class="blockquote">
<p>这是一个引用块和一个非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子。</p>
</blockquote>
<p>Quarto 具有 5 种 callout 类型：<code>note</code>，<code>warning</code>，<code>important</code>，<code>tip</code>，和 <code>caution</code>。</p>
<p>下面是代码块。</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb2-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb2-3"></span>
<span id="cb2-4">r <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.arange(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>)</span>
<span id="cb2-5">theta <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> np.pi <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> r</span>
<span id="cb2-6">fig, ax <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> plt.subplots(</span>
<span id="cb2-7">  subplot_kw <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'projection'</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'polar'</span>} </span>
<span id="cb2-8">)</span>
<span id="cb2-9">ax.plot(theta, r)</span>
<span id="cb2-10">ax.set_rticks([<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.5</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>])</span>
<span id="cb2-11">ax.grid(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb2-12">plt.show()</span></code></pre></div>
</section>
<section id="callouts" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="callouts"><span class="header-section-number">6.2</span> Callouts</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>普通的 note callout。</p>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>这是 warning callout 和一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子。</p>
</div>
</div>
<p>这是两个 callout 中间的一个段落。</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>这是 important callout。</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
有 caption 的 callout
</div>
</div>
<div class="callout-body-container callout-body">
<p>这是有 caption 的 callout。</p>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
可折叠的 callout
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>开启 collapse 的可折叠 caution callout。</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-caution">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>simple 风格的 callout 和一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子。</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-caution no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>minimal 风格的 callout 和一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子。</p>
</div>
</div>
</div>
</section>
</section>
<section id="文献引用测试" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="文献引用测试"><span class="header-section-number">7</span> 文献引用测试</h2>
<p>人脸识别是以人面部特征作为识别个体身份的一种个体生物特征识别方法 <span class="citation" data-cites="define">[1]</span>。……人脸识别的研究最早可追溯到上世纪 60 年代，Bledsoe and Chan 研究了编程计算机识别人脸的方法<span class="citation" data-cites="history">[2]</span>。随后，萌芽期的人脸识别技术经历多轮蜕变，在发展中逐渐完善。然而，人脸识别的主要难点在于不同个体的人脸结构并无大异，而同一个体的人脸在不同表情、年龄、妆饰、光照等干扰因素下又往往差异显著<span class="citation" data-cites="technical">[3]</span>，这要求人脸识别技术既要克服类内因素的干扰，同时又要加强类间差距的显著性，而早期人脸识别方法关注人脸几何特征，识别效果不尽人意。为此，以 Eigenfaces<span class="citation" data-cites="eigenfaces">[4]</span> 为代表的子空间学习识别方法和 Gabor<span class="citation" data-cites="gabor">[5]</span>、LBP<span class="citation" data-cites="lbp">[6]</span> 等局部特征分析的滤波器提取方法在各自领域都有所突破。2014 年，应用新兴的深度卷积神经网络技术，DeepFace<span class="citation" data-cites="deepface">[7]</span> 横空出世，以 97.35% 的 LFW 基准数据集识别准确率重塑了人脸识别领域的研究格局。随后，人脸识别技术迎来爆发式增长，并逐渐走进人们的日常生活之中。……个体层面，要加强公众的权利意识，塑造个人的“数字理性”<span class="citation" data-cites="guochunzhen">[8]</span>。</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-define" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">全国信息安全标准化技术委员会, <span>“《信息安全技术远程人脸识别系统技术要求》（GB/T38671-2020）.”</span> <a href="https://std.samr.gov.cn/gb/search/gbDetailed?id=A47A713B767814ABE05397BE0A0ABB25" class="uri">https://std.samr.gov.cn/gb/search/gbDetailed?id=A47A713B767814ABE05397BE0A0ABB25</a>, 2020.</div>
</div>
<div id="ref-history" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">W. W. Bledsoe and H. Chan, <span>“A man-machine facial recognition system—some preliminary results,”</span> <em>Panoramic Research, Inc, Palo Alto, California., Technical Report PRI A</em>, vol. 19, p. 1965, 1965.</div>
</div>
<div id="ref-technical" class="csl-entry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">余璀璨 and 李慧斌, <span>“基于深度学习的人脸识别方法综述,”</span> <em>工程数学学报</em>, vol. 38, no. 4, p. 19, 2021.</div>
</div>
<div id="ref-eigenfaces" class="csl-entry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">M. Turk and A. Pentland, <span>“Eigenfaces for recognition,”</span> <em>Journal of Cognitive Neuroscience</em>, vol. 3, no. 1, pp. 71–86.</div>
</div>
<div id="ref-gabor" class="csl-entry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">C. Liu and H. Wechsler, <span>“A gabor feature classifier for face recognition,”</span> in <em>Proceedings eighth IEEE international conference on computer vision. ICCV 2001</em>, IEEE, 2001, pp. 270–275.</div>
</div>
<div id="ref-lbp" class="csl-entry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">T. Ahonen, A. Hadid, and M. Pietikäinen, <span>“Face recognition with local binary patterns,”</span> in <em>European conference on computer vision</em>, Springer, 2004, pp. 469–481.</div>
</div>
<div id="ref-deepface" class="csl-entry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">Y. Taigman, M. Yang, M. Ranzato, and L. Wolf, <span>“Closing the gap to human-level performance in face verification. deepface,”</span> in <em>Proceedings of the IEEE computer vision and pattern recognition (CVPR)</em>, p. 6.</div>
</div>
<div id="ref-guochunzhen" class="csl-entry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">郭春镇, <span>“数字人权时代人脸识别技术应用的治理,”</span> <em>现代法学</em>, vol. 42, no. 4, p. 18, 2020.</div>
</div>
</div></section></div> ]]></description>
  <category>web</category>
  <category>LaTeX</category>
  <category>站点相关</category>
  <guid>https://blog.sun123zxy.top/posts/20221223-quarto-test/index.html</guid>
  <pubDate>Thu, 22 Dec 2022 16:00:00 GMT</pubDate>
</item>
<item>
  <title>有限覆盖定理与实数理论</title>
  <dc:creator>sun123zxy </dc:creator>
  <link>https://blog.sun123zxy.top/posts/20221213-cover/index.html</link>
  <description><![CDATA[ 



<section id="example-1" class="level2">
<h2 class="anchored" data-anchor-id="example-1">Example 1</h2>
<p>为更好的证明本题，先引入 Bolzano-Weierstrass 定理的一种等价表述.</p>
<div id="def-accu" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (数列聚点) </strong></span>对任意实数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D">，若实数 <img src="https://latex.codecogs.com/png.latex?a"> 满足：对 <img src="https://latex.codecogs.com/png.latex?a"> 的任意小邻域 <img src="https://latex.codecogs.com/png.latex?U(a,%20%5Cvarepsilon)%20=%20(a%20-%20%5Cvarepsilon,%20a%20+%20%5Cvarepsilon)">，都有无穷个 <img src="https://latex.codecogs.com/png.latex?x_n"> 满足 <img src="https://latex.codecogs.com/png.latex?x_n%20%5Cin%20U(a,%20%5Cvarepsilon)">，则称 <img src="https://latex.codecogs.com/png.latex?a"> 是数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的一个聚点.</p>
</div>
<p>请注意，这里我们没有使用建立在集合之上的标准的聚点定义. 对数列单独定义聚点，是考虑到数列允许重复的元素出现，如此定义更容易展开后面的讨论.</p>
<div id="thm-accuequiv" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 </strong></span>实数 <img src="https://latex.codecogs.com/png.latex?a"> 是数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D%20%5Csubset%20%5Cmathbb%20R"> 的聚点的充要条件是：存在 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的一个收敛子列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_%7Bn_k%7D%20%5C%7D">，其极限为 <img src="https://latex.codecogs.com/png.latex?a">.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>先证充分性. 用定义写开 <img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bk%20%5Cto%20%5Cinfty%7D%20%5C%7B%20x_%7Bn_k%7D%20%5C%7D%20=%20a">，就有 <img src="https://latex.codecogs.com/png.latex?%0A(%5Cforall%20%5Cvarepsilon%20%3E%200)(%5Cexists%20K%20%5Cin%20%5Cmathbb%20N_+)(%5Cforall%20k%20%3E%20K)(%7Cx_%7Bn_k%7D%20-%20a%7C%20%3C%20%5Cvarepsilon)%0A"> 故确有无穷项 <img src="https://latex.codecogs.com/png.latex?x_n"> 落在任意小的 <img src="https://latex.codecogs.com/png.latex?U(a,%20%5Cvarepsilon)"> 中，即 <img src="https://latex.codecogs.com/png.latex?a"> 是 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的一个聚点，该方向得证.</p>
<p>下证必要性. 已知 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 有一聚点 <img src="https://latex.codecogs.com/png.latex?a">. 我们按如下方法构造子列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_%7Bn_k%7D%20%5C%7D">：</p>
<ol type="1">
<li>当 <img src="https://latex.codecogs.com/png.latex?k=1">，取 <img src="https://latex.codecogs.com/png.latex?%5Cvarepsilon_1%20=%201">，因为 <img src="https://latex.codecogs.com/png.latex?a"> 是 <img src="https://latex.codecogs.com/png.latex?E"> 的一个聚点，<img src="https://latex.codecogs.com/png.latex?%5Cexists%20n_1%20%5Cin%20%5Cmathbb%20N_+">，<img src="https://latex.codecogs.com/png.latex?%7Cx_%7Bn_1%7D%20-%20a%7C%20%3C%20%5Cvarepsilon">.</li>
<li>当 <img src="https://latex.codecogs.com/png.latex?k%20%5Cgeqslant%202">，取 <img src="https://latex.codecogs.com/png.latex?%5Cvarepsilon_k%20=%20%5Cfrac%201%20k">，因为 <img src="https://latex.codecogs.com/png.latex?a"> 是 <img src="https://latex.codecogs.com/png.latex?E"> 的一个聚点， <img src="https://latex.codecogs.com/png.latex?%5Cexists%20n_k%20%3E%20n_%7Bk-1%7D">，<img src="https://latex.codecogs.com/png.latex?%7Cx_%7Bn_k%7D%20-%20a%7C%20%3C%20%5Cvarepsilon">.</li>
</ol>
<p>这样，我们构造出 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的一个子列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_%7Bn_k%7D%20%5C%7D"> 满足 <img src="https://latex.codecogs.com/png.latex?%7Cx_%7Bn_k%7D%20-%20a%7C%20%3C%20%5Cvarepsilon_k%20=%20%5Cfrac%201%20k">. 因此其收敛于 <img src="https://latex.codecogs.com/png.latex?a">，该方向得证.</p>
</div>
<p>上述定理立刻证明了下定理与 Bolzano-Weierstrass 定理的等价性.</p>
<div id="thm-bwequiv" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 (数列聚点定理) </strong></span>任意有界实数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 至少有一个聚点.</p>
</div>
<div id="exm-finite2bw" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 </strong></span>利用有限覆盖定理证明 Bolzano-Weierstrass 定理.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>命题等价于用有限覆盖定理证明数列聚点定理. 用反证法. 假设一有界实数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 不存在聚点，设其有上界 <img src="https://latex.codecogs.com/png.latex?L"> 和下界 <img src="https://latex.codecogs.com/png.latex?l">. 对任意 <img src="https://latex.codecogs.com/png.latex?a%20%5Cin%20%5Bl,L%5D">，它都不是 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的聚点，因此总存在一个 <img src="https://latex.codecogs.com/png.latex?%5Cvarepsilon(a)%20%3E%200">，使得只有有限个 <img src="https://latex.codecogs.com/png.latex?x_n"> 落入 <img src="https://latex.codecogs.com/png.latex?U(a,%20%5Cvarepsilon(x_0))">. 这样，构造开区间族 <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathscr%7BF%7D%20=%20%5C%7B%20U(a,%20%5Cvarepsilon(a))%20%5Cmid%20a%20%5Cin%20%5Bl,L%5D%20%5C%7D%0A"> 它显然是闭区间 <img src="https://latex.codecogs.com/png.latex?%5Bl,L%5D"> 的一个开覆盖. 由有限覆盖定理，只需取其中有限个开区间就可以覆盖住 <img src="https://latex.codecogs.com/png.latex?%5Bl,L%5D">，因此覆盖 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 也只需要有限个开区间. 然而由前述构造，每一个开区间中也只包含有限个 <img src="https://latex.codecogs.com/png.latex?x_n">，因此数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 只有有限项——这显然是荒谬的. 故 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 必有聚点，原命题得证.</p>
</div>
</section>
<section id="example-2" class="level2">
<h2 class="anchored" data-anchor-id="example-2">Example 2</h2>
<div id="thm-lebesgue" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (Lebesgue 覆盖定理) </strong></span>设开区间族 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 是闭区间 <img src="https://latex.codecogs.com/png.latex?%5Ba,%20b%5D"> 的一个开覆盖，则必存在 <img src="https://latex.codecogs.com/png.latex?%5Csigma%20%3E%200">，使得只要区间 <img src="https://latex.codecogs.com/png.latex?%5COmega%20%5Csubset%20%5Ba,%20b%5D"> 且 <img src="https://latex.codecogs.com/png.latex?%5COmega"> 的长度 <img src="https://latex.codecogs.com/png.latex?%7C%5COmega%7C%20%3C%20%5Csigma">，就必有 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 中的一个开区间包含 <img src="https://latex.codecogs.com/png.latex?%5COmega">. 其中 <img src="https://latex.codecogs.com/png.latex?%5Csigma"> 称为 Lebesgue 数.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>不妨只证 <img src="https://latex.codecogs.com/png.latex?%5COmega"> 是闭区间这种最强的情况.</p>
<p>用反证法. 假设命题不成立，则对任意 <img src="https://latex.codecogs.com/png.latex?%5Csigma%20%3E%200">，都存在一个长度小于 <img src="https://latex.codecogs.com/png.latex?%5Csigma"> 的闭区间 <img src="https://latex.codecogs.com/png.latex?%5COmega%20%5Csubset%20%5Ba,b%5D">，它不被任何 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 中的开区间包含. 因此，对所有自然数 <img src="https://latex.codecogs.com/png.latex?n">，可取 <img src="https://latex.codecogs.com/png.latex?%5Csigma_n%20=%20%5Cfrac%201%20n">，按上述方法就可构造出一列闭区间 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20%5COmega_n%20%5C%7D%20=%20%5C%7B%20%5Ba_n,%20b_n%5D%20%5C%7D%20%5Csubset%20%5Ba,b%5D"> 其中每一个闭区间都不被任何 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 中的开区间包含，且区间长度 <img src="https://latex.codecogs.com/png.latex?%7C%5COmega_n%7C%20%3C%20%5Csigma_n%20=%20%5Cfrac%201%20n">，即 <img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D%20%7C%5COmega_n%7C%20=%200">.</p>
<p>因为 <img src="https://latex.codecogs.com/png.latex?%5COmega_n%20%5Csubset%20%5Ba,b%5D">，<img src="https://latex.codecogs.com/png.latex?%5C%7B%20a_n%20%5C%7D"> 有界，由 Bolzano-Weierstrass 定理，其存在一收敛子列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20a_%7Bn_k%7D%20%5C%7D">，设其极限为 <img src="https://latex.codecogs.com/png.latex?x_0">，极限保序性表明 <img src="https://latex.codecogs.com/png.latex?x_0%20%5Cin%20%5Ba,b%5D">. 注意到 <img src="https://latex.codecogs.com/png.latex?b_%7Bn_k%7D%20=%20a_%7Bn_k%7D%20+%20%7C%5COmega_%7Bn_k%7D%7C">，两端取 <img src="https://latex.codecogs.com/png.latex?k%20%5Cto%20%5Cinfty"> 即得 <img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bk%20%5Cto%20%5Cinfty%7D%20b_%7Bn_k%7D%20=%20x_0">. 综上，我们说明了 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20%5COmega_%7Bn_k%7D%20%5C%7D"> 收缩于 <img src="https://latex.codecogs.com/png.latex?x_0">.</p>
<p>但，因为 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 是闭区间 <img src="https://latex.codecogs.com/png.latex?%5Ba,b%5D"> 的一个开覆盖，故总存在一个开区间 <img src="https://latex.codecogs.com/png.latex?I_%7Bx_0%7D%20=%20(a_0,%20b_0)%20%5Cin%20%5Cmathscr%20F"> 使得 <img src="https://latex.codecogs.com/png.latex?x_0%20%5Cin%20I_%7Bx_0%7D">，而 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20%5COmega_%7Bn_k%7D%20%5C%7D"> 又收缩于 <img src="https://latex.codecogs.com/png.latex?x_0">，故存在 <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20%5Cmathbb%20N">，<img src="https://latex.codecogs.com/png.latex?%5COmega_%7Bn_k%7D%20%5Csubset%20I_%7Bx_0%7D%20%5Cin%20%5Cmathscr%20F">，这与我们构造 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20%5COmega_%7Bn_k%7D%20%5C%7D"> 的方法矛盾. 故原命题成立.</p>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>证明过程与用 Bolzano-Weierstrass 定理证明闭区间一致连续性定理类似.</p>
</div>
<div id="exm-lebesgue2bw" class="theorem example">
<p><span class="theorem-title"><strong>Example 2 </strong></span>用 Lebesgue 覆盖定理证明有限覆盖定理.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>若 <img src="https://latex.codecogs.com/png.latex?%5Csigma"> 是覆盖 <img src="https://latex.codecogs.com/png.latex?%5Ba,b%5D"> 的开覆盖 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 的勒贝格数，令 <img src="https://latex.codecogs.com/png.latex?N%20=%20%5Clceil%20%5Cfrac%7B2(b-a)%7D%7B%5Csigma%7D%20%5Crceil">，<img src="https://latex.codecogs.com/png.latex?L%20=%20%5Cfrac%20%7Bb-a%7D%7BN%7D%20%5Cleqslant%20%5Cfrac%20%5Csigma%202%20%3C%20%5Csigma">. 由 Lebesgue 覆盖定理，任意长度为 <img src="https://latex.codecogs.com/png.latex?L"> 的 <img src="https://latex.codecogs.com/png.latex?%5Ba,b%5D"> 内闭区间都包含于某个 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 中的开区间. 因此对 <img src="https://latex.codecogs.com/png.latex?n%20=%201,2,%5Cdots,N">，令 <img src="https://latex.codecogs.com/png.latex?%5COmega_n%20=%20%5Cleft%5B%20a%20+%20(n-1)L,%20a%20+%20nL%20%5Cright%5D">，总存在一个 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 中开区间 <img src="https://latex.codecogs.com/png.latex?I_n"> 满足 <img src="https://latex.codecogs.com/png.latex?%5COmega_n%20%5Csubset%20I_n">. 因为显然 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20%5COmega_n%20%5C%7D_%7Bn=1%7D%5EN"> 是 <img src="https://latex.codecogs.com/png.latex?%5Ba,b%5D"> 的一个覆盖，故 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20I_n%20%5C%7D_%7Bn=1%7D%5EN%20%5Csubset%20%5Cmathscr%20F"> 也是 <img src="https://latex.codecogs.com/png.latex?%5Ba,b%5D"> 的覆盖. 这样，我们就成功构造出了一个 <img src="https://latex.codecogs.com/png.latex?%5Cmathscr%20F"> 的有限子覆盖 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20I_n%20%5C%7D_%7Bn=1%7D%5EN">，命题得证.</p>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>在处理区间问题时，Lebsegue 覆盖定理很多时候比有限覆盖定理更好用. 例如处理闭区间一致连续性定理时，“落入两个有交点的相邻的这样的区间”<span class="citation" data-cites="lizhong">[1]</span>这种神乎其技的操作就可以省去了. （这种操作的严格叙述是：把单点连续性要求的区间半径改成 <img src="https://latex.codecogs.com/png.latex?2%20%5Cdelta_x">，但构造开覆盖还是用半径为 <img src="https://latex.codecogs.com/png.latex?%5Cdelta_x"> 的区间，这样可以有 <img src="https://latex.codecogs.com/png.latex?%7Cx_2%20-%20x%7C%20%5Cleqslant%20%7Cx_2%20-%20x_1%7C%20+%20%7Cx_1%20-%20x%7C%20%5Cleqslant%20%5Cdelta_%7Bm%7D%20+%20%5Cdelta_%7Bx%7D%20%5Cleqslant%202%20%5Cdelta_%7Bx%7D">，能把两个点放在同一个区间内了. 详细可参考 <a href="https://www.zhihu.com/question/56393706/answer/298562084" class="uri">https://www.zhihu.com/question/56393706/answer/298562084</a>. 事实上，Lebesgue 覆盖定理也可以用类似的方法证明.）</p>
</div>
<p>作为小结，下图展现了刚刚介绍的几个定理在整个实数完备性等价定理体系中的地位.</p>
<div class="cell" data-fig-width="6.25" data-fig-height="2.5">
<div class="cell-output-display">
<div id="fig-real" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<div>
<svg width="600" height="240" viewbox="0.00 0.00 808.39 310.40" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 306.4)">
<title>
G
</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-306.4 804.39,-306.4 804.39,4 -4,4"></polygon> <!-- sup --> <g id="node1" class="node">
<title>
sup
</title>
<ellipse fill="none" stroke="black" cx="40.01" cy="-106.8" rx="40.01" ry="18"></ellipse> <text text-anchor="middle" x="40.01" y="-102.6" font-family="Times,serif" font-size="14.00">确界原理</text> </g> <!-- mono --> <g id="node2" class="node">
<title>
mono
</title>
<ellipse fill="none" stroke="black" cx="170.01" cy="-106.8" rx="54.49" ry="18"></ellipse> <text text-anchor="middle" x="170.01" y="-102.6" font-family="Times,serif" font-size="14.00">单调有界定理</text> </g> <!-- sup&#45;&gt;mono --> <g id="edge1" class="edge">
<title>
sup-&gt;mono
</title>
<path fill="none" stroke="black" d="M80.12,-106.8C88.44,-106.8 96.77,-106.8 105.09,-106.8"></path> <polygon fill="black" stroke="black" points="105.24,-110.3 115.24,-106.8 105.23,-103.3 105.24,-110.3"></polygon> </g> <!-- nested --> <g id="node3" class="node">
<title>
nested
</title>
<ellipse fill="none" stroke="black" cx="314.01" cy="-106.8" rx="54.49" ry="18"></ellipse> <text text-anchor="middle" x="314.01" y="-102.6" font-family="Times,serif" font-size="14.00">闭区间套定理</text> </g> <!-- mono&#45;&gt;nested --> <g id="edge2" class="edge">
<title>
mono-&gt;nested
</title>
<path fill="none" stroke="black" d="M224.57,-106.8C232.85,-106.8 241.13,-106.8 249.41,-106.8"></path> <polygon fill="black" stroke="black" points="249.51,-110.3 259.51,-106.8 249.51,-103.3 249.51,-110.3"></polygon> </g> <!-- nested&#45;&gt;sup --> <g id="edge6" class="edge">
<title>
nested-&gt;sup
</title>
<path fill="none" stroke="black" d="M288.13,-90.8C259.06,-74.72 210.22,-53.33 166.51,-61 135.43,-66.45 101.93,-78.9 77.22,-89.45"></path> <polygon fill="black" stroke="black" points="75.64,-86.32 67.87,-93.52 78.43,-92.73 75.64,-86.32"></polygon> <text text-anchor="middle" x="177.01" y="-58.2" font-family="Times,serif" font-size="14.00">构造</text> </g> <!-- bw --> <g id="node4" class="node">
<title>
bw
</title>
<ellipse fill="none" stroke="black" cx="692.01" cy="-106.8" rx="108.26" ry="18"></ellipse> <text text-anchor="middle" x="692.01" y="-102.6" font-family="Times,serif" font-size="14.00">Bolzano-Weierstrass 定理</text> </g> <!-- nested&#45;&gt;bw --> <!-- accu --> <g id="node6" class="node">
<title>
accu
</title>
<ellipse fill="none" stroke="black" cx="476.01" cy="-106.8" rx="68.96" ry="18"></ellipse> <text text-anchor="middle" x="476.01" y="-102.6" font-family="Times,serif" font-size="14.00">（数列）聚点定理</text> </g> <!-- nested&#45;&gt;accu --> <g id="edge8" class="edge">
<title>
nested-&gt;accu
</title>
<path fill="none" stroke="black" d="M368.85,-106.8C377.82,-106.8 387.26,-106.8 396.68,-106.8"></path> <polygon fill="black" stroke="black" points="396.86,-110.3 406.86,-106.8 396.86,-103.3 396.86,-110.3"></polygon> <text text-anchor="middle" x="387.76" y="-91.2" font-family="Times,serif" font-size="14.00">构造</text> </g> <!-- finite --> <g id="node7" class="node">
<title>
finite
</title>
<ellipse fill="none" stroke="black" cx="314.01" cy="-284.4" rx="54.49" ry="18"></ellipse> <text text-anchor="middle" x="314.01" y="-280.2" font-family="Times,serif" font-size="14.00">有限覆盖定理</text> </g> <!-- nested&#45;&gt;finite --> <g id="edge7" class="edge">
<title>
nested-&gt;finite
</title>
<path fill="none" stroke="black" d="M314.01,-135.4C314.01,-168.33 314.01,-223.05 314.01,-255.92"></path> <polygon fill="black" stroke="black" points="317.51,-134.96 314.01,-124.96 310.51,-134.96 317.51,-134.96"></polygon> <polygon fill="black" stroke="black" points="310.51,-256.17 314.01,-266.17 317.51,-256.17 310.51,-256.17"></polygon> <text text-anchor="middle" x="324.51" y="-191.4" font-family="Times,serif" font-size="14.00">反证</text> </g> <!-- cauchy --> <g id="node5" class="node">
<title>
cauchy
</title>
<ellipse fill="none" stroke="black" cx="364.01" cy="-18" rx="71.84" ry="18"></ellipse> <text text-anchor="middle" x="364.01" y="-13.8" font-family="Times,serif" font-size="14.00">Cauchy 收敛原理</text> </g> <!-- bw&#45;&gt;cauchy --> <g id="edge4" class="edge">
<title>
bw-&gt;cauchy
</title>
<path fill="none" stroke="black" d="M636.86,-91.21C577.09,-75.39 482.17,-50.27 421.5,-34.22"></path> <polygon fill="black" stroke="black" points="422.26,-30.8 411.7,-31.62 420.47,-37.56 422.26,-30.8"></polygon> </g> <!-- lebesgue --> <g id="node8" class="node">
<title>
lebesgue
</title>
<ellipse fill="none" stroke="black" cx="616.01" cy="-195.6" rx="79.35" ry="18"></ellipse> <text text-anchor="middle" x="616.01" y="-191.4" font-family="Times,serif" font-size="14.00">Lebesgue 覆盖定理</text> </g> <!-- bw&#45;&gt;lebesgue --> <g id="edge12" class="edge">
<title>
bw-&gt;lebesgue
</title>
<path fill="none" stroke="black" d="M676.99,-124.95C665.68,-137.87 650.01,-155.77 637.38,-170.18"></path> <polygon fill="black" stroke="black" points="634.69,-167.95 630.73,-177.78 639.95,-172.56 634.69,-167.95"></polygon> <text text-anchor="middle" x="670.51" y="-147" font-family="Times,serif" font-size="14.00">反证</text> </g> <!-- cauchy&#45;&gt;mono --> <g id="edge5" class="edge">
<title>
cauchy-&gt;mono
</title>
<path fill="none" stroke="black" d="M330.22,-34.12C296.97,-48.99 246.19,-71.71 210.74,-87.58"></path> <polygon fill="black" stroke="black" points="208.87,-84.58 201.17,-91.86 211.73,-90.97 208.87,-84.58"></polygon> <text text-anchor="middle" x="295.51" y="-58.2" font-family="Times,serif" font-size="14.00">反证</text> </g> <!-- accu&#45;&gt;bw --> <g id="edge11" class="edge">
<title>
accu-&gt;bw
</title>
<path fill="none" stroke="black" d="M555.42,-106.8C561.27,-106.8 567.25,-106.8 573.27,-106.8"></path> <polygon fill="black" stroke="black" points="555.24,-103.3 545.24,-106.8 555.24,-110.3 555.24,-103.3"></polygon> <polygon fill="black" stroke="black" points="573.43,-110.3 583.43,-106.8 573.43,-103.3 573.43,-110.3"></polygon> <text text-anchor="middle" x="564.31" y="-91.2" font-family="Times,serif" font-size="14.00">构造</text> </g> <!-- finite&#45;&gt;sup --> <g id="edge14" class="edge">
<title>
finite-&gt;sup
</title>
<path fill="none" stroke="black" d="M289.69,-268.25C267.16,-254.18 232.74,-232.6 203.01,-213.6 156.62,-183.96 103.15,-149.13 70.47,-127.76"></path> <polygon fill="black" stroke="black" points="72.11,-124.65 61.83,-122.1 68.28,-130.51 72.11,-124.65"></polygon> <text text-anchor="middle" x="213.51" y="-191.4" font-family="Times,serif" font-size="14.00">反证</text> </g> <!-- finite&#45;&gt;mono --> <g id="edge10" class="edge">
<title>
finite-&gt;mono
</title>
<path fill="none" stroke="black" d="M300.39,-266.8C274.93,-235.75 220,-168.76 190.21,-132.43"></path> <polygon fill="black" stroke="black" points="192.6,-129.83 183.55,-124.32 187.19,-134.27 192.6,-129.83"></polygon> <text text-anchor="middle" x="267.51" y="-191.4" font-family="Times,serif" font-size="14.00">反证</text> </g> <!-- finite&#45;&gt;accu --> <g id="edge9" class="edge">
<title>
finite-&gt;accu
</title>
<path fill="none" stroke="black" d="M329.26,-266.87C357.9,-235.82 419.87,-168.65 453.38,-132.32"></path> <polygon fill="black" stroke="black" points="456.27,-134.36 460.47,-124.64 451.12,-129.61 456.27,-134.36"></polygon> <text text-anchor="middle" x="421.51" y="-191.4" font-family="Times,serif" font-size="14.00">反证</text> </g> <!-- lebesgue&#45;&gt;finite --> <g id="edge13" class="edge">
<title>
lebesgue-&gt;finite
</title>
<path fill="none" stroke="black" d="M569.29,-210.18C533.18,-220.66 481.94,-235.51 437.01,-248.4 412.84,-255.34 385.99,-262.98 363.55,-269.36"></path> <polygon fill="black" stroke="black" points="362.57,-266 353.9,-272.1 364.48,-272.73 362.57,-266"></polygon> <text text-anchor="middle" x="501.51" y="-235.8" font-family="Times,serif" font-size="14.00">构造</text> </g> </g>
</svg>
</div>
<figcaption class="figure-caption">Figure&nbsp;1: 实数完备性等价定理关系图</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="example-3" class="level2">
<h2 class="anchored" data-anchor-id="example-3">Example 3</h2>
<div id="thm-ulaccu" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4 </strong></span>设数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 有界，其上极限 <img src="https://latex.codecogs.com/png.latex?%5Cvarlimsup_%7Bn%20%5Cto%20%5Cinfty%7D%20x_n%20=%20L">，下极限 <img src="https://latex.codecogs.com/png.latex?%5Cvarliminf_%7Bn%20%5Cto%20%5Cinfty%7D%20x_n%20=%20l">，则 <img src="https://latex.codecogs.com/png.latex?L"> 是 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的最大聚点，<img src="https://latex.codecogs.com/png.latex?l"> 是 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的最小聚点.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Theorem&nbsp;1 中，我们已经知道，一个数列的收敛子列的极限也是该数列的一个聚点. 结合上下极限的子列式定义即可证明上述定理.</p>
</div>
<div id="exm-ullim" class="theorem example">
<p><span class="theorem-title"><strong>Example 3 </strong></span>设数列 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 有界且 <img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D(x_%7Bn+1%7D%20%E2%88%92%20x_n)%20=%200">，分别记 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的上下极限为 <img src="https://latex.codecogs.com/png.latex?L"> 和 <img src="https://latex.codecogs.com/png.latex?l">. 证明 <img src="https://latex.codecogs.com/png.latex?%5Bl,%20L%5D"> 上的任意点可作为 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 某个子列的极限.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>反证. 假设 <img src="https://latex.codecogs.com/png.latex?%5Bl,%20L%5D"> 上有一点 <img src="https://latex.codecogs.com/png.latex?a"> 不是任何 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的收敛子列的极限，则根据 Theorem&nbsp;1，<img src="https://latex.codecogs.com/png.latex?a"> 不是 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的聚点，即存在 <img src="https://latex.codecogs.com/png.latex?a"> 的一个邻域 <img src="https://latex.codecogs.com/png.latex?U(a,%5Cvarepsilon)">，使得只有有限个 <img src="https://latex.codecogs.com/png.latex?x_n"> 落入该邻域，换句话说，存在某个 <img src="https://latex.codecogs.com/png.latex?N%20%5Cin%20%5Cmathbb%20N_+">，当 <img src="https://latex.codecogs.com/png.latex?n%3EN"> 时，就有 <img src="https://latex.codecogs.com/png.latex?x_n%20%5Cnotin%20U(a,%5Cvarepsilon)">.</p>
<p>又，考虑到 Theorem&nbsp;4 表明上下极限 <img src="https://latex.codecogs.com/png.latex?L"> 和 <img src="https://latex.codecogs.com/png.latex?l"> 都是 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 的聚点，<img src="https://latex.codecogs.com/png.latex?L,l%20%5Cnotin%20U(a,%5Cvarepsilon)"> 显然成立，且第 <img src="https://latex.codecogs.com/png.latex?N"> 项后的 <img src="https://latex.codecogs.com/png.latex?%5C%7B%20x_n%20%5C%7D"> 完全由满足 <img src="https://latex.codecogs.com/png.latex?x_n%20%3E%20a+%5Cvarepsilon"> 和 <img src="https://latex.codecogs.com/png.latex?x_n%20%3C%20a-%5Cvarepsilon"> 的两种 <img src="https://latex.codecogs.com/png.latex?x_n"> 构成，且它们均有无穷多项. 这样，对于任意的 <img src="https://latex.codecogs.com/png.latex?M%3EN">，总可以找到一个 <img src="https://latex.codecogs.com/png.latex?m%20%3E%20M"> 使得 <img src="https://latex.codecogs.com/png.latex?x_m"> 和 <img src="https://latex.codecogs.com/png.latex?x_%7Bm+1%7D"> 分属 <img src="https://latex.codecogs.com/png.latex?U(a,%20%5Cvarepsilon)"> 的两侧，故 <img src="https://latex.codecogs.com/png.latex?%7Cx_m%20-%20x_%7Bm+1%7D%7C%20%5Cgeqslant%202%20%5Cvarepsilon">，这就与条件 <img src="https://latex.codecogs.com/png.latex?%5Clim_%7Bn%20%5Cto%20%5Cinfty%7D(x_%7Bn+1%7D%20%E2%88%92%20x_n)%20=%200"> 产生矛盾. 故不存在这样的 <img src="https://latex.codecogs.com/png.latex?a">，定理得证.</p>
</div>
</section>


<div id="quarto-appendix" class="default"><section id="acknowledgments" class="level2 appendix"><h2 class="anchored quarto-appendix-heading">Acknowledgments</h2><div class="quarto-appendix-contents">

<p>感谢史老师主持研讨课并指出讲稿的多处错误，特别是原来聚点定理的证明中数列元素可重的 bug. 史老师还提供了标准聚点定义的另一种叙述.</p>



</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body">
<div id="ref-lizhong" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">李忠 and 方丽萍, <em>数学分析教程</em>. 北京: 高等教育出版社, 2008, pp. 257–258.</div>
</div>
</div></section></div> ]]></description>
  <category>数学</category>
  <category>题解</category>
  <category>讲稿</category>
  <guid>https://blog.sun123zxy.top/posts/20221213-cover/index.html</guid>
  <pubDate>Mon, 12 Dec 2022 16:00:00 GMT</pubDate>
</item>
<item>
  <title>关于泰勒展开拉格朗日余项中值点的渐进性</title>
  <link>https://blog.sun123zxy.top/posts/20221110-taylor/index.html</link>
  <description><![CDATA[ 



<p>之前学拉格朗日中值定理的时候做到一道涉及到特定函数中值渐进性的题，感觉似乎有一般的结论，推广了一下就是这样了。</p>
<p>感谢刘导拯救 <img src="https://latex.codecogs.com/png.latex?n=1"> 都不会证的我，感谢王佬指出这是中科大《数学分析教程》第三版问题 4.3.1。</p>
<blockquote class="blockquote">
<p>设函数 <img src="https://latex.codecogs.com/png.latex?f(x)"> 在区间 <img src="https://latex.codecogs.com/png.latex?I"> 上有 <img src="https://latex.codecogs.com/png.latex?n+1"> 阶导数，<img src="https://latex.codecogs.com/png.latex?x_0%20%5Cin%20I">，<img src="https://latex.codecogs.com/png.latex?f%5E%7B(n+1)%7D(x_0)%20%5Cnot%20=%200">；定义函数 <img src="https://latex.codecogs.com/png.latex?T_n(x)"> 为 <img src="https://latex.codecogs.com/png.latex?f(x)"> 在 <img src="https://latex.codecogs.com/png.latex?x=x_0"> 处的 <img src="https://latex.codecogs.com/png.latex?n"> 阶泰勒多项式：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AT(x)%20=%20T_n(x_0+h)%20=%20%5Csum_%7Bk=0%7D%5En%20%5Cfrac%7Bf%5E%7B(k)%7D(x_0)%7D%7Bk!%7D%20h%5Ek%0A"></p>
<p>求证： <img src="https://latex.codecogs.com/png.latex?f(x)"> 在 <img src="https://latex.codecogs.com/png.latex?x=x_0"> 处带拉格朗日余项的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶泰勒展开</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Af(x)%20=%20f(x_0+h)%20=%20T_%7Bn-1%7D(x_0+h)%20+%20%5Cfrac%7Bf%5E%7B(n)%7D(x_0+%5Ctheta%20h)%7D%7Bn!%7D%20h%5En%20%5Cqquad%20%5Ctheta%20%5Cin%20(0,1)%0A"></p>
<p>中的 <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> 满足：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bh%20%5Cto%200%7D%20%5Ctheta%20=%20%5Cfrac%201%20%7Bn+1%7D%0A"></p>
</blockquote>
<p>非常漂亮的结论啊。</p>
<p>理一下思路。关键点在于怎么构造出 <img src="https://latex.codecogs.com/png.latex?%5Ctheta">，得想办法把它从 <img src="https://latex.codecogs.com/png.latex?f%5E%7B(n)%7D(x_0+%5Ctheta%20h)"> 这样的形式中拿出来。或许我们能想到构造</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7Bf%5E%7B(n)%7D(x_0+%5Ctheta%20h)%20-%20f%5E%7B(n)%7D(x_0)%7D%7B%5Ctheta%20h%7D%20%5Cto%20f%5E%7B(n+1)%7D(x_0)%20%5Cqquad%20(h%20%5Cto%200)%0A"></p>
<p>这样 <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> 就可以拿出来单独求极限了。<img src="https://latex.codecogs.com/png.latex?f%5E%7B(n)%7D(x_0+%5Ctheta%20h)"> 可以从 <img src="https://latex.codecogs.com/png.latex?f(x)"> 的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶泰勒展开的拉格朗日余项中得到，而 <img src="https://latex.codecogs.com/png.latex?f%5E%7B(n)%7D(x_0)"> 和 <img src="https://latex.codecogs.com/png.latex?f%5E%7B(n+1)%7D(x_0)"> 也可以从 <img src="https://latex.codecogs.com/png.latex?f(x)"> 的 <img src="https://latex.codecogs.com/png.latex?n+1"> 阶带皮亚诺余项的泰勒展开中拿到。于是，下面的证明就十分自然了。</p>
<p><strong>证明：</strong> 考虑 <img src="https://latex.codecogs.com/png.latex?f(x)"> 的 <img src="https://latex.codecogs.com/png.latex?n-1"> 阶带拉格朗日余项的泰勒展开</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Af(x_0%20+%20h)%20=%20T_%7Bn-1%7D(x_0%20+%20h)%20+%20%5Cfrac%7Bf%5E%7B(n)%7D(x_0+%5Ctheta%20h)%7D%7Bn!%7D%20h%5En%0A"></p>
<p>和 <img src="https://latex.codecogs.com/png.latex?f(x)"> 的 <img src="https://latex.codecogs.com/png.latex?n+1"> 阶带皮亚诺余项的泰勒展开</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Af(x_0%20+%20h)%20=%20T_%7Bn+1%7D(x_0%20+%20h)%20+%20o(h%5E%7Bn+1%7D)%20=%20T_%7Bn-1%7D(x_0%20+%20h)%20+%20%5Cfrac%7Bf%5E%7B(n)%7D(x_0)%7D%7Bn!%7D%20h%5En%20+%20%5Cfrac%7Bf%5E%7B(n+1)%7D(x_0)%7D%7B(n+1)!%7D%20h%5E%7Bn+1%7D%20+%20o(h%5E%7Bn+1%7D)%0A"></p>
<p>两式相减得</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7Bf%5E%7B(n)%7D(x_0+%5Ctheta%20h)%7D%7Bn!%7D%20h%5En%20=%20%5Cfrac%7Bf%5E%7B(n)%7D(x_0)%7D%7Bn!%7D%20h%5En%20+%20%5Cfrac%7Bf%5E%7B(n+1)%7D(x_0)%7D%7B(n+1)!%7D%20h%5E%7Bn+1%7D%20+%20o(h%5E%7Bn+1%7D)%0A"></p>
<p>移项整理得</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctheta%20%5Ccdot%20%5Cfrac%7Bf%5E%7B(n)%7D(x_0+%5Ctheta%20h)-f%5E%7B(n)%7D(x_0)%7D%7B%5Ctheta%20h%7D%20=%20%5Cfrac%7Bf%5E%7B(n+1)%7D(x_0)%7D%7Bn+1%7D%20+%20n!%20%5Ccdot%20%5Cfrac%20%7Bo(h%5E%7Bn+1%7D)%7D%7Bh%5E%7Bn+1%7D%7D%0A"></p>
<p>两侧同时取 <img src="https://latex.codecogs.com/png.latex?h%20%5Cto%200"> 即得</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bh%20%5Cto%200%7D%20%5Ctheta%20%5Ccdot%20f%5E%7B(n+1)%7D(x_0)%20=%20%5Cfrac%7Bf%5E%7B(n+1)%7D(x_0)%7D%7Bn+1%7D%0A"></p>
<p>于是由 <img src="https://latex.codecogs.com/png.latex?f%5E%7B(n+1)%7D(x_0)%20%5Cnot%20=%200">，我们有</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bh%20%5Cto%200%7D%20%5Ctheta%20=%20%5Cfrac%7B1%7D%7Bn+1%7D%0A"></p>
<p>得证。</p>
<hr>
<p>备考：</p>
<pre><code>Azpeitia A G. On the Lagrange remainder of the Taylor formula[J]. The American Mathematical Monthly, 1982, 89(5): 311-312.
Abel U. On the Lagrange remainder of the Taylor formula[J]. The American mathematical monthly, 2003, 110(7): 627-633.</code></pre>
<p>这两篇论文似乎对这种渐进性有更深入的讨论。</p>



 ]]></description>
  <category>数学</category>
  <category>题解</category>
  <guid>https://blog.sun123zxy.top/posts/20221110-taylor/index.html</guid>
  <pubDate>Tue, 01 Nov 2022 16:00:00 GMT</pubDate>
</item>
<item>
  <title>关于 Python 的 import</title>
  <link>https://blog.sun123zxy.top/posts/20220714-import/index.html</link>
  <description><![CDATA[ 



<p>好久以前就被 Python 的相对与绝对导入所困扰。去年粗浅探究后自以为完全理解，近来又因 <code>sys.path[0]</code> 和 <code>os.getcwd()</code> 的不一致而刷新了认知…</p>
<p>Python 官方文档 <a href="https://docs.python.org/3/reference/import.html">5. The import system — Python 3.10.5 documentation</a> 当然是最好的学习指南，但全部看完对我来说还是有点难度。这里只选择一些要点讨论。</p>
<section id="from-import" class="level2">
<h2 class="anchored" data-anchor-id="from-import">from import</h2>
<p><code>import A</code>、<code>import A as B</code>、<code>from A import B</code> 结构中，<code>A</code> 最小只能到 module。因此，只有使用 <code>from import</code> 结构才可以单独获取 module 里的属性。另外，相对引用必须使用 <code>from import</code> 结构。</p>
<p><code>from module import *</code> 将导入 <code>module</code> 中的所有成员（有单双下划线前导的成员除外）。对于 package 可在 <code>__init__.py</code> 中定义 <code>__all__ = ["module", "module", ...]</code> 来手动控制的实际导入内容。</p>
</section>
<section id="package-与-__init__.py" class="level2">
<h2 class="anchored" data-anchor-id="package-与-__init__.py">Package 与 __init__.py</h2>
<p>Python 3.3 以后的 package 不再硬性需要 <code>__init__.py</code>，普通文件夹等同于 <code>__init__.py</code> 留空的 namespace package。（关于 regular package 和 namespace package 的区别，参见 <a href="https://docs.python.org/3/reference/import.html#regular-packages">5. The import system — Python 3.10.5 documentation</a>）</p>
<p><code>__init__.py</code> 的作用在于当我们直接导入一个 package 的时候，实际上是执行了 <code>__init__.py</code>。换句话说，直接导入一个 package 就是把它看做一个逻辑写在 <code>__init__.py</code> 里的 module。</p>
<p>需要注意的是，对于形如 <code>A.B.C</code> 的导入，<code>A</code>、<code>A.B</code>、<code>A.B.C</code> 对应的 <code>__init__.py</code> 都会被执行。也就是说，只要导入路径经过该 package，该 package 的 <code>__init__.py</code> 就会被执行。</p>
</section>
<section id="submodules" class="level2">
<h2 class="anchored" data-anchor-id="submodules">Submodules</h2>
<blockquote class="blockquote">
<p>When a submodule is loaded using any mechanism (e.g.&nbsp;<code>importlib</code> APIs, the <code>import</code> or <code>import-from</code> statements, or built-in <code>__import__()</code>) a binding is placed in the parent module’s namespace to the submodule object. For example, if package <code>spam</code> has a submodule <code>foo</code>, after importing <code>spam.foo</code>, <code>spam</code> will have an attribute <code>foo</code> which is bound to the submodule.</p>
<p>…</p>
<p>Given Python’s familiar name binding rules this might seem surprising, but it’s actually a fundamental feature of the import system. The invariant holding is that if you have <code>sys.modules['spam']</code> and <code>sys.modules['spam.foo']</code> (as you would after the above import), the latter must appear as the <code>foo</code> attribute of the former.</p>
<p>— <a href="https://docs.python.org/3/reference/import.html#submodules">5. The import system — Python 3.10.5 documentation</a></p>
</blockquote>
<p>这是说，import 进来的 module 会被挂载到本 module 上作为其属性。</p>
<p>这个性质可以弄出来很多看上去很奇怪的玩意儿，比如说自己导入自己后可以 <code>me.me.me.me...</code> 无限嵌套之类的…</p>
<hr>
<p>另外，对于形如 <code>import A.B.C</code> 的导入，<code>A</code>、<code>A.B</code>、<code>A.B.C</code> 都会被挂载到本 module 上。然而，<code>from A.B import C</code> 却只会挂载 <code>C</code>，而 <code>import A.B.C as D</code> 也只会挂载 <code>D</code> ，即使 <code>A</code>、<code>A.B</code> 都被执行且都在 <code>sys.modules</code> 里。</p>
</section>
<section id="sys.path" class="level2">
<h2 class="anchored" data-anchor-id="sys.path">sys.path</h2>
<blockquote class="blockquote">
<p>A list of strings that specifies the search path for modules. Initialized from the environment variable <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a>, plus an installation-dependent default.</p>
<p>As initialized upon program startup, the first item of this list, <code>path[0]</code>, is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g.&nbsp;if the interpreter is invoked interactively or if the script is read from standard input), <code>path[0]</code> is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted <em>before</em> the entries inserted as a result of <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a>.</p>
<p>A program is free to modify this list for its own purposes. Only strings and bytes should be added to <a href="https://docs.python.org/3/library/sys.html#sys.path" title="sys.path"><code>sys.path</code></a>; all other data types are ignored during import.</p>
<p>— <a href="https://docs.python.org/3/library/sys.html#sys.path">sys — System-specific parameters and functions — Python 3.10.5 documentation</a></p>
</blockquote>
<p><code>sys.path</code> 是 Python 搜索 module 的基准目录（即绝对导入）。其由环境变量 <code>PYTHONPATH</code> 和一些默认路径（和安装环境有关，参见 <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHOME">PYTHONHOME</a>）组成，而在运行 script 时，<strong>script 的所在目录会被临时加入 <code>sys.path[0]</code> 中</strong>。如果运行的并不是 script（例如是交互式运行或从 stdin 中读取脚本代码），<strong><code>sys.path[0]</code> 则被设置为空字符串，代表当前工作目录</strong>。</p>
<p><code>sys.path</code> 有优先级，排在前面的优先级高。</p>
<hr>
<p>需要特别注意的是，<strong>script 的所在目录不是当前工作目录</strong>。例如，在 <code>D:\test</code> 下执行</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">python</span> path/to/file.py</span></code></pre></div>
<p>时，<code>sys.path[0]</code> 为 <code>D:\test\path\to\file.py</code>，而当前工作目录则是 <code>D:\test</code>（也即 <code>os.getcwd()</code>）。</p>
<p>当前工作目录是 Python 寻找其他文件时的基准路径，而所有绝对导入操作都只与 <code>sys.path</code> 有关，两者是完全不同的。</p>
<p><code>python -m</code> 的情况稍有不同，参见后文。</p>
</section>
<section id="python--m" class="level2">
<h2 class="anchored" data-anchor-id="python--m">python -m</h2>
<blockquote class="blockquote">
<p>Search <a href="https://docs.python.org/3/library/sys.html#sys.path" title="sys.path"><code>sys.path</code></a> for the named module and execute its contents as the <a href="https://docs.python.org/3/library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code>__main__</code></a> module.</p>
<p>Since the argument is a <em>module</em> name, you must not give a file extension (<code>.py</code>). The module name should be a valid absolute Python module name, but the implementation may not always enforce this (e.g.&nbsp;it may allow you to use a name that includes a hyphen).</p>
<p>Package names (including namespace packages) are also permitted. When a package name is supplied instead of a normal module, the interpreter will execute <code>&lt;pkg&gt;.__main__</code> as the main module. This behaviour is deliberately similar to the handling of directories and zipfiles that are passed to the interpreter as the script argument.</p>
<blockquote class="blockquote">
<p>Note</p>
<p>This option cannot be used with built-in modules and extension modules written in C, since they do not have Python module files. However, it can still be used for precompiled modules, even if the original source file is not available.</p>
</blockquote>
<p>If this option is given, the first element of <a href="https://docs.python.org/3/library/sys.html#sys.argv" title="sys.argv"><code>sys.argv</code></a> will be the full path to the module file (while the module file is being located, the first element will be set to <code>"-m"</code>). As with the <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-c"><code>-c</code></a> option, the current directory will be added to the start of <a href="https://docs.python.org/3/library/sys.html#sys.path" title="sys.path"><code>sys.path</code></a>.</p>
<p><a href="https://docs.python.org/3/using/cmdline.html#cmdoption-I"><code>-I</code></a> option can be used to run the script in isolated mode where <a href="https://docs.python.org/3/library/sys.html#sys.path" title="sys.path"><code>sys.path</code></a> contains neither the current directory nor the user’s site-packages directory. All <code>PYTHON*</code> environment variables are ignored, too.</p>
<p>Many standard library modules contain code that is invoked on their execution as a script. An example is the <a href="https://docs.python.org/3/library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code>timeit</code></a> module:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">python</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-m</span> timeit <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-s</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'setup here'</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'benchmarked code here'</span></span>
<span id="cb2-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">python</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-m</span> timeit <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-h</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># for details</span></span></code></pre></div>
<p>Raises an <a href="https://docs.python.org/3/library/sys.html#auditing">auditing event</a> <code>cpython.run_module</code> with argument <code>module-name</code>.</p>
<blockquote class="blockquote">
<p>See also</p>
<p><a href="https://docs.python.org/3/library/runpy.html#runpy.run_module" title="runpy.run_module"><code>runpy.run_module()</code></a></p>
<p>Equivalent functionality directly available to Python code</p>
</blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0338">PEP 338</a> – Executing modules as scripts</p>
<p>Changed in version 3.1: Supply the package name to run a <code>__main__</code> submodule.</p>
<p>Changed in version 3.4: namespace packages are also supported</p>
<p>— <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m">1. Command line and environment — Python 3.10.5 documentation</a></p>
</blockquote>
<p>在 <code>sys.path</code> 指定的目录中寻找 module 并以 <code>__main__</code> module 的身份执行指定 module。</p>
<p>注意不要在名字后面加 <code>.py</code>，因为我们已经把执行的文件当作 module 来看待。</p>
<p>如果指定的是一个 Package name（即目录名），将会执行 <code>&lt;pkg&gt;.__main__</code>（即 <code>&lt;pkg&gt;/__main__.py</code>）。</p>
<p>另外，如果使用 <code>python -m a.b.module</code>，<code>sys.argv</code> 的首位将被设置为被执行 module 文件的<strong>完整路径</strong>（与之相对，<code>python a/b/module.py</code> 中 <code>sys.argv[0]</code> 将会是<strong>相对当前工作目录的路径</strong>，即 <code>a/b/module.py</code>）；同时，<strong>当前工作目录</strong>会被加入 <code>sys.path</code> 的首位。</p>
<hr>
<p><code>python -m A.B.module</code> 将顺次执行 <code>A</code>、<code>A.B</code> 的 <code>__init__.py</code>，即使该 module 没有任何导入行为。</p>
<p><code>python -m</code> 对于直接执行 package 内部的代码是必要的。若直接以 script 方式运行，一旦涉及到任何高于该 script 所在目录（含该目录）的相对导入，Python 就会抛出如下错误：</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb3-1">ImportError: attempted relative import with no known parent package</span></code></pre></div>
<p>而一个 module 也不能导入超过 <code>python -m</code> 参数指定的最顶层结构的 module，否则会抛出错误：</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb4-1">ImportError: attempted relative import beyond top-level package</span></code></pre></div>
</section>
<section id="sys.modules" class="level2">
<h2 class="anchored" data-anchor-id="sys.modules">sys.modules</h2>
<blockquote class="blockquote">
<p>The first place checked during import search is <a href="https://docs.python.org/3/library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a>. This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So if <code>foo.bar.baz</code> was previously imported, <a href="https://docs.python.org/3/library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a> will contain entries for <code>foo</code>, <code>foo.bar</code>, and <code>foo.bar.baz</code>. Each key will have as its value the corresponding module object.</p>
<p>During import, the module name is looked up in <a href="https://docs.python.org/3/library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a> and if present, the associated value is the module satisfying the import, and the process completes. However, if the value is <code>None</code>, then a <a href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code>ModuleNotFoundError</code></a> is raised. If the module name is missing, Python will continue searching for the module.</p>
<p><a href="https://docs.python.org/3/library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a> is writable. Deleting a key may not destroy the associated module (as other modules may hold references to it), but it will invalidate the cache entry for the named module, causing Python to search anew for the named module upon its next import. The key can also be assigned to <code>None</code>, forcing the next import of the module to result in a <a href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code>ModuleNotFoundError</code></a>.</p>
<p>Beware though, as if you keep a reference to the module object, invalidate its cache entry in <a href="https://docs.python.org/3/library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a>, and then re-import the named module, the two module objects will <em>not</em> be the same. By contrast, <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" title="importlib.reload"><code>importlib.reload()</code></a> will reuse the <em>same</em> module object, and simply reinitialise the module contents by rerunning the module’s code.</p>
<p>— <a href="https://docs.python.org/3/reference/import.html#the-module-cache">5. The import system — Python 3.10.5 documentation</a></p>
</blockquote>
<p><code>sys.modules</code> 是一个 <code>dict</code>，Python 在导入之前会去检查 <code>sys.module</code> 里是否已经存有需要的 module 的 module object。如果有，就直接用这个；如果值为 <code>None</code>（意思是以前找过但没找到），就直接报错；如果该键值对不存在，就继续搜索过程。总之，<code>sys.modules</code> 扮演了一个类似 cache 的角色。</p>
<p>对于形如 <code>A.B.C</code> 的导入，Python 会顺次导入 <code>A</code>、<code>A.B</code> 和 <code>A.B.C</code> 并把他们加入 <code>sys.modules</code>。</p>
</section>
<section id="参考" class="level2">
<h2 class="anchored" data-anchor-id="参考">参考</h2>
<ul>
<li><p><a href="https://docs.python.org/3/reference/import.html">5. The import system — Python 3.10.5 documentation</a></p></li>
<li><p><a href="https://docs.python.org/3/tutorial/modules.html">6. Modules — Python 3.10.5 documentation</a></p></li>
<li><p><a href="https://www.pythonforthelab.com/blog/complete-guide-to-imports-in-python-absolute-relative-and-more/">Python for the Lab | Complete Guide to Imports in Python: Absolute, Relative, and More</a></p></li>
<li><p><a href="https://www.cnblogs.com/gaowengang/p/8543840.html">Python 包内的导入问题（绝对导入和相对导入） - Anonymous596 - 博客园</a></p></li>
</ul>


</section>

 ]]></description>
  <category>Python</category>
  <guid>https://blog.sun123zxy.top/posts/20220714-import/index.html</guid>
  <pubDate>Wed, 13 Jul 2022 16:00:00 GMT</pubDate>
</item>
<item>
  <title>从台体的体积公式谈起</title>
  <link>https://blog.sun123zxy.top/posts/20220327-frustum/index.html</link>
  <description><![CDATA[ 



<p>前些天做到一个猜圆台体两端电阻阻值公式的题，刚想积分乱搞时突然想起——台体不是有体积公式的吗…</p>
<p>于是就有下面的内容了。</p>
<p>台体本质上是锥体被一个平行与底面的平面所截而形成的几何体，所以可以把锥体补出来再研究。考虑从微积分的角度思考。设台体高度为 <img src="https://latex.codecogs.com/png.latex?h">，上、下底面面积分别为 <img src="https://latex.codecogs.com/png.latex?S_1,%20S_2">，上底面到锥体顶点的距离为 <img src="https://latex.codecogs.com/png.latex?x">。锥体的若干底面互相相似，而它们的的“半径”又与它们各自到锥体顶点的距离成正比，因此容易发现底面面积与该距离的平方成正比，即</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ak%20=%20%5Cfrac%7BS_1%7D%7Bx%5E2%7D%20=%20%5Cfrac%7BS_2%7D%7B(x+h)%5E2%7D%0A"></p>
<p>这是在三维空间里的情况。可以类比的写出 <img src="https://latex.codecogs.com/png.latex?n"> 维台体的式子：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ak%20=%20%5Cfrac%7BS_1%7D%7Bx%5E%7Bn-1%7D%7D%20=%20%5Cfrac%7BS_2%7D%7B(x+h)%5E%7Bn-1%7D%7D%0A"></p>
<p>（当然这里的 <img src="https://latex.codecogs.com/png.latex?S_1,S_2"> 就是“超面积”了）</p>
<p>进一步的，可以将超面积写成关于与顶点距离的函数形式：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AS_1%20&amp;=%20S(x)%20=%20k%20x%5E%7Bn-1%7D%20%5C%5C%0AS_2%20&amp;=%20S(x+h)%20=%20k%20(x+h)%5E%7Bn-1%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p>而我们要求的“超体积”，就可以顺理成章的表示为面积函数 <img src="https://latex.codecogs.com/png.latex?S(x)"> 在垂直轴线上的积分了</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AV%20=%20%5Cint_%7Bx%7D%5E%7Bx+h%7D%20S(x)%20%5Cmathrm%20d%20x%20=%20k%20%5Cint_%7Bx%7D%5E%7Bx+h%7D%20x%5E%7Bn-1%7D%20%5Cmathrm%20d%20x%20=%20%5Cfrac%20k%20n%20%5Cleft(%20%5Cleft(x+h%20%5Cright)%5En%20-%20x%5En%20%5Cright)%0A"></p>
<p>这就是用微积分求到的台体体积公式。</p>
<p>那么问题来了——这种形式的台体体积公式和几何法得到的</p>
<blockquote class="blockquote">
<p><img src="https://latex.codecogs.com/png.latex?%0AV%20=%20%5Cfrac%7B1%7D%7B3%7D%20h%20(S_1%20+%20%5Csqrt%7BS_1%20S_2%7D%20+%20S_2)%0A"></p>
</blockquote>
<p>有什么联系呢？</p>
<p>随便玩一下吧，<img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%203"> 毋庸置疑和三维有关，换成 <img src="https://latex.codecogs.com/png.latex?%5Cfrac%201%20n"> 就好；后面那一坨挺对称的还蛮好看，写个求和符号让它更好看吧（</p>
<p>于是猜测台体体积公式的 <img src="https://latex.codecogs.com/png.latex?n"> 维扩展：</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AV%20=%20%5Cfrac%201%20n%20h%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20S_1%5E%7B%5Cfrac%7Bi%7D%7Bn-1%7D%7D%20S_2%5E%7B1-%5Cfrac%7Bi%7D%7Bn-1%7D%7D%0A"></p>
<p>用 <img src="https://latex.codecogs.com/png.latex?S(x)"> 函数的形式替换 <img src="https://latex.codecogs.com/png.latex?S_1,%20S_2">，得</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AV%20=%20%5Cfrac%20k%20h%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-1-i%7D%0A"></p>
<p>哎！与前面积分得出的台体体积公式比较，发现只需证明</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A(x+h)%5En%20-%20x%5En%20=%20h%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-1-i%7D%0A"></p>
<p>试着证明一下吧。观察发现 <img src="https://latex.codecogs.com/png.latex?h"> 可以拆成 <img src="https://latex.codecogs.com/png.latex?(x+h)-x">，故右式可以写成</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0Ah%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-1-i%7D%20&amp;=%20((x+h)-x)%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-1-i%7D%20%5C%5C%0A&amp;=%20(x+h)%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-1-i%7D%20-%20x%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-1-i%7D%20%5C%5C%0A&amp;=%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-i%7D%20-%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20x%5Ei%20(x+h)%5E%7Bn-i%7D%20%5C%5C%0A&amp;=%20(x+h)%5En%20-%20x%5En%0A%5Cend%7Baligned%7D%0A"></p>
<p>得证。</p>
<p>暂时不知道这个定理有什么具体的名字，知道的大佬请告诉我（</p>
<p>所以这玩意有什么用呢？</p>
<p>首先当然是证明（超）台体体积公式，这个上面已经提到。</p>
<p>还有一个用途就是证明 <img src="https://latex.codecogs.com/png.latex?n%20%5Cin%20%5Cmathrm%7BN_+%7D"> 的幂函数 <img src="https://latex.codecogs.com/png.latex?x%5En"> 的导数公式。</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cmathrm%20d%7D%7B%5Cmathrm%20d%20x%7D%20x%5En%20=%20%5Clim_%7Bh%20%5Cto%200%7D%20%5Cfrac%7B(x+h)%5En%20-%20x%5En%7D%7Bh%7D%20=%20%5Clim_%7Bh%20%5Cto%200%7D%20%5Csum_%7Bi=0%7D%5E%7Bn-1%7D%20x%5Ei%20(x+h)%5E%7Bn-1-i%7D%20=%20n%20x%5E%7Bn-1%7D%0A"></p>
<p>看上去很方便的来着呢。</p>



 ]]></description>
  <category>数学</category>
  <category>意识流</category>
  <guid>https://blog.sun123zxy.top/posts/20220327-frustum/index.html</guid>
  <pubDate>Sat, 26 Mar 2022 16:00:00 GMT</pubDate>
</item>
<item>
  <title>原创生物必修一大题 - Creepus Explodus</title>
  <link>https://blog.sun123zxy.top/posts/20220224-creeper/index.html</link>
  <description><![CDATA[ 



<section id="problem" class="level2">
<h2 class="anchored" data-anchor-id="problem">Problem</h2>
<p>【必修一大题】假定你是李华，你的外国交换生朋友 Steve 正在水本科毕业论文，请根据高中生物所学内容，帮他完善以下论文选段。</p>
<p><strong>闪电苦力怕的 TNT 诱导及其生物发电技术实践</strong><br>
<strong>TNT-Induced Mutation of Charged Creepus Explodus and Its Bioelectricity Generating Technology</strong><br>
Steve Mahjong, Alex Macrohard. [J]MineNature Volume 817, Issue 1926. 2021. PP 9960-9961</p>
<p><strong>摘要：</strong>苦力怕（Creeper，学名 Creepus Explodus，另译爬行者）是主世界中常见的友好生物。本文回顾了前人对三硝基甲苯诱导苦力怕突变的研究成果，提出了利用闪电苦力怕实现生物发电的构想，并初步完成了闪电苦力怕发电机的建造、试运行和效率分析工作，为后续同类型研究提供借鉴。</p>
<p><img src="https://blog.sun123zxy.top/posts/20220224-creeper/tnt.jpg" style="height: 150px"> <img src="https://blog.sun123zxy.top/posts/20220224-creeper/breath.jpg" style="height: 150px"></p>
<p>（Fig 1：TNT 毒理）（Fig 2：气体含量曲线）</p>
<p><strong>引入 1：</strong>三硝基甲苯（TNT）具有相对较高的细胞毒性，其体外半数致死浓度 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BLC_%7B50%7D%7D%20%5Capprox%2025%20%5C%20%5Cmathrm%7B%5Cmu%20mol%20%5Ccdot%20L%5E%7B-1%7D%7D">​。氧化应激是被广泛认可的 TNT 中毒机制之一，其具体原理如 Fig1 所示。该理论认为，TNT 进入细胞后经过某些酶的催化，生成多种 <code>______</code>（图中 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BArNO_2%5E%7B%5Cfrac%7B%7D%7B%5Ccdot%7D%7D%7D">​、<img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BO_2%5E%7B%5Cfrac%7B%7D%7B%5Ccdot%7D%7D%7D">​）攻击和破坏细胞内各种执行正常功能的生物分子（如攻击 DNA 可能引起 <code>________</code>），导致细胞衰老或损伤。为抵消 TNT 对生物体稳态的影响，生物体体内的超氧化物歧化酶（SOD）可催化有害物质歧化并最终由 <code>__________</code>（CAT）催化分解为无害物质。CAT 在动物 <code>____</code>（填器官）中含量丰富。</p>
<p><strong>引入 2：</strong>苦力怕体内的 CAT （简记为 CrpCAT）具有极其特殊的结构。Notch Persson 的实验表明，CrpCAT 的活性高于其它动物体内的 CAT，其具体实验步骤如下：</p>
<blockquote class="blockquote">
<p>步骤 1：取 3 支洁净的试管在适宜温度下保温，分别加入 <img src="https://latex.codecogs.com/png.latex?2%20%5Cmathrm%7BmL%7D">​​ SOD 催化产物溶液。</p>
<p>步骤 2：分别向 3 支试管中滴加 2 滴一定浓度的 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BFeCl_3%7D"> 溶液（A 组）、<code>__________</code>（B 组）、<code>__________</code>（C 组）。</p>
<p>步骤 3：一段时间后，精确测定各组反应速率，测得 <img src="https://latex.codecogs.com/png.latex?v(A)%20=%209.85%20%5Ctimes%2010%5E%7B-10%7D%20v(B)%20=%202.11%20%5Ctimes%2010%5E%7B-10%7D%20v(C)">​，从而证明了实验结论。</p>
</blockquote>
<p>该实验的 B 组与 C 组相较，可以说明 CrpCAT 的 <code>____</code>（选择：A. 高效性；B. 专一性；C. 温和性；D. 以上选项均不能说明）</p>
<p><strong>引入 3：</strong>苦力怕 CrpCAT 的高活性使其可以耐受较高浓度的 TNT。用 TNT 处理苦力怕可诱导其突变为罕见的闪电苦力怕（Charged Creeper）变种。Jeb Bergensten 的研究揭示了闪电苦力怕的发电原理。在闪电苦力怕的发电器官中，电细胞细胞膜上的钠钾泵消耗细胞呼吸产生的 <code>__________</code> （填物质名称）逆浓度梯度转运钠、钾离子建立起静息电位；而动作电位时，细胞后膜上大量电压门控钠离子通道以 <code>________</code> 的方式转运钠离子进入细胞，在前后膜之间形成 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7B50%20%5C%20mV%7D"> 到 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7B150%20%5C%20mV%7D">​ 的电位差。</p>
<p><strong>实验：</strong>研究小组初步探究了利用闪电苦力怕发电器官进行生物发电的可行性。将完整的发电器官浸泡在营养液中，在其背侧和腹侧插入电极并连接电流表，整个实验器材置于密闭气缸中，测定气缸中 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BO_2%7D">​ 和 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BCO_2%7D">​ 含量的变化曲线如 Fig2 所示。据图推测闪电苦力怕无氧呼吸的有机产物为 <code>________</code>，实验时间内有氧呼吸消耗葡萄糖 <code>______</code> <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7Bmol%7D">​。该发电机输出了 <img src="https://latex.codecogs.com/png.latex?b%20%5C%20%5Cmathrm%7BkJ%7D">​ 电能，计算其发电效率为 <code>____________</code>（<img src="https://latex.codecogs.com/png.latex?%E5%8F%91%E7%94%B5%E6%95%88%E7%8E%87%20=%20%5Cfrac%7B%E8%BE%93%E5%87%BA%E7%94%B5%E8%83%BD%7D%7B%E8%BE%93%E5%85%A5%E7%9A%84%E5%8C%96%E5%AD%A6%E8%83%BD%7D%20%5Ctimes%20100%20%5C%25">​，已知 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7B1%20%5C%20mol%7D">​ 葡萄糖折合能量 <img src="https://latex.codecogs.com/png.latex?a%20%5C%20%5Cmathrm%7BkJ%7D">​​，只考虑葡萄糖的呼吸分解）。该发电机的发电效率不高，其主要原因为 <code>________________________________________</code>（从能量转化角度分析，答两点即可）</p>
<p><strong>参考文献：</strong><a href="http://www.energetic-materials.org.cn/hncl/article/html/CJEM2019068">魏桐,周阳,杨治林,等. 典型炸药的毒性效应及其作用机制研究进展[J]. 含能材料,2019,27(7):558-568.</a></p>
<p>其他参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/19901924/answer/1490619635">电鳗发电的原理是什么？ - 混乱博物馆的回答 - 知乎</a></li>
<li><a href="https://minecraft.fandom.com/zh/wiki/%E8%8B%A6%E5%8A%9B%E6%80%95">苦力怕 - Minecraft Wiki，最详细的我的世界百科</a></li>
</ul>
</section>
<section id="answer" class="level2">
<h2 class="anchored" data-anchor-id="answer">Answer</h2>
<pre><code>1) 自由基 基因突变 过氧化氢(H2O2) 肝脏
2) 2滴一定浓度的CAT溶液 2滴等浓度的CrpCAT溶液 D
3) 三磷酸腺苷 协助扩散
4) 酒精 0.5 b/a*100% 大量能量以热能的形式散失、大量能量存留在无氧呼吸产生的酒精中、呼吸作用产生的能量还需用于其它各项生命活动</code></pre>
</section>
<section id="solution" class="level2">
<h2 class="anchored" data-anchor-id="solution">Solution</h2>
<p>2 问选择题：不能说明高效性。一方面，B 组与 C 组反应速率差异仅数倍，比起酶与无机催化剂的 <img src="https://latex.codecogs.com/png.latex?10%5E7">​ - <img src="https://latex.codecogs.com/png.latex?10%5E%7B13%7D">​ 倍差异太小；另一方面，“高效性”一般只用于描述酶与无机催化剂的催化能力差异。</p>
<p>4 问，消耗 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BO_2%20%5C%203%20%5C%20mol%7D">，产生 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7BCO_2%20%5C%204%20%5C%20mol%7D">，说明有氧呼吸与无氧呼吸均存在，且无氧呼吸生成酒精。根据有氧呼吸、酒精无氧呼吸方程式，有氧呼吸消耗葡萄糖 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7B3%20%5C%20mol%20%5Ctimes%20%5Cfrac%7B1%7D%7B6%7D%20=%200.5%20%5C%20mol%7D">，无氧呼吸消耗葡萄糖 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7B%5Cleft(%204%20%5C%20mol%20-%20%5Cleft(%200.5%20%5C%20mol%20%5Ctimes%206%20%5Cright)%20%5Cright)%20%5Ctimes%20%5Cfrac%7B1%7D%7B2%7D%20=%200.5%20%5C%20mol%7D">，共消耗葡萄糖 <img src="https://latex.codecogs.com/png.latex?%5Cmathrm%7B1%20%5C%20mol%7D">，据此计算即可。</p>


</section>

 ]]></description>
  <category>高考</category>
  <category>原创题目</category>
  <guid>https://blog.sun123zxy.top/posts/20220224-creeper/index.html</guid>
  <pubDate>Wed, 23 Feb 2022 16:00:00 GMT</pubDate>
</item>
<item>
  <title>DockerCompose+VLESS+WS+TLS+Web 方式搭建 V2Ray 代理</title>
  <link>https://blog.sun123zxy.top/posts/20220204-vmagic/index.html</link>
  <description><![CDATA[ 



<p>全文参考：</p>
<ul>
<li><a href="https://guide.v2fly.org/advanced/wss_and_web.html">(VMESS) + WebSocket + TLS + Web | 新 V2Ray 白话文指南</a></li>
<li><a href="https://guide.v2fly.org/app/docker-deploy-v2ray.html">Docker 部署 V2Ray | 新 V2Ray 白话文指南</a></li>
<li><a href="https://www.v2fly.org/">V2Ray(V2Fly) 官方文档</a></li>
</ul>
<section id="原理" class="level2">
<h2 class="anchored" data-anchor-id="原理">原理</h2>
<p>VLESS 作为内部传输协议，使用 HTTP 的扩展 WebSocket 作为传输载体，外层使用 TLS 加密传输。服务器端用 Nginx 搭建正常 HTTPS 网站，收到向特定路径发送的 WebSocket 流量时充当反向代理转发至 Docker 容器内的 V2Ray 处理。</p>
<p>从外部看，服务器是货真价实的 HTTPS 服务器，客户端发出的请求也是货真价实的 HTTPS 流量；直接用浏览器访问入口路径将返回 <code>400 Bad Request</code>（由 V2Ray 返回）或 <code>404 Not Found</code>（可在 Nginx 中预检测 WebSocket 请求，增强隐蔽性）；安全性、抗干扰能力则完全由 TLS 保障，几乎无懈可击。</p>
<p>更强的技术还有 Xray 中使用的 XTLS，无缝拼接了内外两层 TLS 使得性能进一步提高。不过因为和 V2Ray 主社区分离了，还是决定先用 VLESS+WS+TLS+Web 配置。</p>
<ul>
<li><a href="https://tlanyan.pp.ua/xray-tutorial/">V2Ray V2Fly Xray 的历史</a></li>
</ul>
<p>结构上，使用 Docker 和 Docker Compose 容器化安装方便管理；而装在外层的 Nginx 可以作为所有网页服务的入口点，方便以后增加其它服务。</p>
</section>
<section id="流程" class="level2">
<h2 class="anchored" data-anchor-id="流程">流程</h2>
<p>以下所有操作在 Ubuntu 20.04 的 root 用户下进行。代码中部分需要自己填写的敏感信息会用如 <code>{[VARIABLE]}</code> 的记号标明，请自行替换。</p>
<section id="准备工作" class="level3">
<h3 class="anchored" data-anchor-id="准备工作">准备工作</h3>
<section id="安装-curl" class="level4">
<h4 class="anchored" data-anchor-id="安装-curl">安装 cURL</h4>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt</span> install curl</span></code></pre></div>
</section>
<section id="安装-docker" class="level4">
<h4 class="anchored" data-anchor-id="安装-docker">安装 Docker</h4>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">curl</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-fsSL</span> https://get.docker.com/ <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sh</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 获取脚本并交给 sh (shell) 执行</span></span>
<span id="cb2-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">systemctl</span> start docker</span></code></pre></div>
</section>
<section id="安装-docker-compose" class="level4">
<h4 class="anchored" data-anchor-id="安装-docker-compose">安装 Docker Compose</h4>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">curl</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-L</span> https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">`</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">uname</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-s</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">`</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">`</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">uname</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-m</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">`</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-o</span> /usr/local/bin/docker-compose</span>
<span id="cb3-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># docker-compose --version</span></span></code></pre></div>
</section>
<section id="安装并运行-nginx" class="level4">
<h4 class="anchored" data-anchor-id="安装并运行-nginx">安装并运行 Nginx</h4>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt</span> install nginx</span>
<span id="cb4-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">systemctl</span> start nginx</span></code></pre></div>
<p>此时通过浏览器访问服务器就能看到 Nginx 默认的欢迎界面了。</p>
</section>
<section id="调试技巧" class="level4">
<h4 class="anchored" data-anchor-id="调试技巧">调试技巧</h4>
<p>Nginx 的日志存储在 <code>/var/log/nginx</code> 目录下；V2Ray 的日志在 Docker 容器里，之后我们将把它映射到宿主机上方便操作和存储。</p>
<p>一些常用的调试命令：</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">systemctl</span> start nginx</span>
<span id="cb5-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">systemctl</span> status nginx</span>
<span id="cb5-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">systemctl</span> stop nginx</span>
<span id="cb5-4"></span>
<span id="cb5-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker-compose</span> up <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-d</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Create and start containers（-d 表示后台运行）</span></span>
<span id="cb5-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker-compose</span> down  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Stop and remove containers, networks, images, and volumes</span></span>
<span id="cb5-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker-compose</span> start <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Start services</span></span>
<span id="cb5-8"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker-compose</span> stop  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Stop services</span></span>
<span id="cb5-9"></span>
<span id="cb5-10"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker</span> ps <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 查看各容器运行状态</span></span>
<span id="cb5-11"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker</span> log {<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">[</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">CONTAINER_ID</span><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">]</span>} <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 查看某容器运行日志</span></span></code></pre></div>
</section>
</section>
<section id="安装-certbot-并以-webroot-方式获取-lets-encrypt-证书" class="level3">
<h3 class="anchored" data-anchor-id="安装-certbot-并以-webroot-方式获取-lets-encrypt-证书">安装 Certbot 并以 Webroot 方式获取 Let’s Encrypt 证书</h3>
<ul>
<li>Certbot 官方教程：<a href="https://eff-certbot.readthedocs.io/en/stable/using.html">User Guide — Certbot 1.22.0 documentation</a></li>
<li>Certbot 原理：<a href="https://www.jianshu.com/p/3ffd27b64847">HTTPS-使用Certbot自动配置Let’s Encrypt证书 - 简书</a></li>
</ul>
<p>Let’s Encrypt 是一个免费、自动化和开放的证书颁发机构，为网站提供免费的 SSL/TLS 证书。要从 Let’s Encrypt 获取某个域名的证书，需要证明拥有对该域名的控制权，而 Certbot 就是官方提供的自动化认证工具。</p>
<p>Webroot 是 Certbot 提供的一种认证方式，如果服务器上有网站运行且有能力修改其配置，就可以用该方式进行认证。使用这种方式获取证书时无需暂停网页服务端的运行。</p>
<blockquote class="blockquote">
<p>The webroot plugin works by creating a temporary file for each of your requested domains in <code>${webroot-path}/.well-known/acme-challenge</code>. Then the Let’s Encrypt validation server makes HTTP requests to validate that the DNS for each requested domain resolves to the server running certbot.</p>
</blockquote>
<p>首先安装 Certbot：</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt</span> install certbot python3-certbot</span></code></pre></div>
<p>因为之前安装的 Nginx 已经在 <code>/var/www/html</code> 下生成默认的欢迎页网站，故可直接利用该目录进行 Webroot 认证：</p>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">certbot</span> certonly <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--webroot</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-w</span> /var/www/html <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-d</span> {<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">[</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">YOUR_DOMAIN</span><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">]</span>}</span></code></pre></div>
<p>认证过程中 Certbot 的回显信息：</p>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb8-1">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span>
<span id="cb8-2">Plugins selected: Authenticator webroot, Installer None</span>
<span id="cb8-3">Obtaining a new certificate</span>
<span id="cb8-4">Performing the following challenges:</span>
<span id="cb8-5">http-01 challenge for {[YOUR_DOMAIN]}</span>
<span id="cb8-6">Using the webroot path /var/www/html for all unmatched domains.</span>
<span id="cb8-7">Waiting for verification...</span>
<span id="cb8-8">Cleaning up challenges</span>
<span id="cb8-9"></span>
<span id="cb8-10">IMPORTANT NOTES:</span>
<span id="cb8-11"> - Congratulations! Your certificate and chain have been saved at:</span>
<span id="cb8-12">   /etc/letsencrypt/live/{[YOUR_DOMAIN]}/fullchain.pem</span>
<span id="cb8-13">   Your key file has been saved at:</span>
<span id="cb8-14">   /etc/letsencrypt/live/{[YOUR_DOMAIN]}/privkey.pem</span>
<span id="cb8-15">   Your cert will expire on {[EXPIRE-DATE]}. To obtain a new or tweaked</span>
<span id="cb8-16">   version of this certificate in the future, simply run certbot</span>
<span id="cb8-17">   again. To non-interactively renew *all* of your certificates, run</span>
<span id="cb8-18">   "certbot renew"</span>
<span id="cb8-19"> - If you like Certbot, please consider supporting our work by:</span>
<span id="cb8-20"></span>
<span id="cb8-21">   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate</span>
<span id="cb8-22">   Donating to EFF:                    https://eff.org/donate-le</span></code></pre></div>
</section>
<section id="使用-docker-compose-安装并配置-v2ray" class="level3">
<h3 class="anchored" data-anchor-id="使用-docker-compose-安装并配置-v2ray">使用 Docker Compose 安装并配置 V2Ray</h3>
<p>上传 <code>docker-compose.json</code> 至适当位置（建议妥善储存该文件，以便后续管理使用）：</p>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode yml code-with-copy"><code class="sourceCode yaml"><span id="cb9-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">version</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> </span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"3.4"</span></span>
<span id="cb9-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">services</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb9-3"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">v2ray</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb9-4"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">image</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> v2fly/v2fly-core</span></span>
<span id="cb9-5"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">container_name</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> v2ray</span></span>
<span id="cb9-6"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">restart</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> always</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"> # 自动重启容器</span></span>
<span id="cb9-7"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">ports</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> </span></span>
<span id="cb9-8"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">      </span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">-</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> </span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">{</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">[YOUR_PORT_OUTER]</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">}</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">:{[YOUR_PORT_INNER]}</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"> # 端口映射，注意外左内右</span></span>
<span id="cb9-9"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">command</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> v2ray -config=/etc/v2ray/config.json</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"> # 需要指定配置文件位置</span></span>
<span id="cb9-10"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">volumes</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb9-11"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">      </span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">-</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> /etc/v2ray:/etc/v2ray</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"> # 左边宿主目录，右边容器目录</span></span>
<span id="cb9-12"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">      </span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">-</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> /var/log/v2ray:/var/log/v2ray</span></span></code></pre></div>
<p>利用 volume 技术，容器中 V2Ray 的配置文件被映射到宿主机的 <code>/etc/v2ray</code> 目录下，而日志信息被映射到 <code>/var/log/v2ray</code> 目录下。</p>
<p>故运行容器之前，我们在 <code>/etc/v2ray</code> 下放置 <code>config.json</code> 作为容器内 V2Ray 的配置文件：</p>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb10-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-2">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"log"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-3">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"loglevel"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"warning"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-4">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"access"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"/var/log/v2ray/access.log"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-5">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"error"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"/var/log/v2ray/error.log"</span></span>
<span id="cb10-6">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">},</span></span>
<span id="cb10-7">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"inbounds"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span></span>
<span id="cb10-8">        <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-9">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"port"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_PORT_INNER]}"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">容器内的监听端口</span></span>
<span id="cb10-10">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"listen"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"0.0.0.0"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Caution!</span></span>
<span id="cb10-11">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"protocol"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"vless"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-12">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"settings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-13">                <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"decryption"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"none"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-14">                <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"clients"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span></span>
<span id="cb10-15">                    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-16">                        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"id"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_UUID]}"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-17">                        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"email"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_EMAIL]}"</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">作标识用，可以随便填</span></span>
<span id="cb10-18">                    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb10-19">                <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span></span>
<span id="cb10-20">            <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">},</span></span>
<span id="cb10-21">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"streamSettings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-22">                <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"network"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ws"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-23">                <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"wsSettings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-24">                    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"path"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_PATH]}"</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">希望设定的</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">V2Ray</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">入口路径，如</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"/ray"</span></span>
<span id="cb10-25">                <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb10-26">            <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb10-27">        <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb10-28">    <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-29">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"outbounds"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span></span>
<span id="cb10-30">        <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb10-31">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"protocol"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"freedom"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb10-32">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"settings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{}</span></span>
<span id="cb10-33">        <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb10-34">    <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span></span>
<span id="cb10-35"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<blockquote class="blockquote">
<p>有一个小坑点（见 <a href="https://github.com/v2ray/v2ray-core/issues/2221">Issue #2221</a>）：与白话文指南不同，如果用 Docker 搭建 V2Ray，容器外的 Nginx 需要向容器内的 V2Ray 发送数据，因此容器内的 V2Ray 必须监听本机 IP <code>0.0.0.0</code> 而不是本地回环 IP <code>127.0.0.1</code>。</p>
<p>常见的症状是客户端报 <code>502 Bad Gateway &gt; websocket: bad handshake</code> ，Nginx 报 <code>upstream prematurely closed connection</code>，而容器内 V2Ray 没有报警日志。</p>
</blockquote>
<p>最后，在之前放置 <code>docker-compose.yml</code> 的目录下执行：</p>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker-compose</span> up <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-d</span></span></code></pre></div>
</section>
<section id="设置-nginx-反向代理" class="level3">
<h3 class="anchored" data-anchor-id="设置-nginx-反向代理">设置 Nginx 反向代理</h3>
<ul>
<li><a href="http://nginx.org/en/docs/http/configuring_https_servers.html">Nginx - Configuring HTTPS servers</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html">Nginx - Module ngx_http_ssl_module</a></li>
</ul>
<p>通常修改 Nginx 配置可以通过直接修改 <code>/etc/nginx/nginx.conf</code> 或在 <code>/etc/nginx/conf.d/</code> 目录下新建配置文件的方式进行，但根据推荐的目录结构（参见 <a href="https://wiki.debian.org/Nginx/DirectoryStructure">Nginx/DirectoryStructure - Debian Wiki</a>），这里选择在 <code>/etc/nginx/sites-available/</code> 放置配置文件后在 <code>/etc/nginx/sites-enabled/my-enabled.conf</code> 中动态引用。</p>
<p>故首先在 <code>/etc/nginx/sites-available/</code> 下新建 <code>{[YOUR_DOMAIN]}.conf</code>（文件名可自行调整）：</p>
<pre class="nginx"><code>server {
  listen 443 ssl;
  listen [::]:443 ssl;

  ssl_certificate       /etc/letsencrypt/live/{[YOUR_DOMAIN]}/fullchain.pem;
  ssl_certificate_key   /etc/letsencrypt/live/{[YOUR_DOMAIN]}/privkey.pem;
  # 利用缓存重用 session 提高性能
  ssl_session_timeout 1d;
  ssl_session_cache shared:MozSSL:10m;
  ssl_session_tickets off;

  ssl_protocols         TLSv1.2 TLSv1.3;
  # 设置加密方式，默认的已经不安全了
  ssl_ciphers           ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
  ssl_prefer_server_ciphers off; # (?) Specifies that server ciphers should be preferred over client ciphers when using the SSLv3 and TLS protocols.

  server_name           {[YOUR_DOMAIN]};
  location {[YOUR_PATH]} { # 与 V2Ray 配置中的 path 保持一致
    if ($http_upgrade != "websocket") { # WebSocket 协商失败时返回 404
        return 404;
    }
    proxy_redirect off;
    proxy_pass http://127.0.0.1:{[YOUR_PORT_OUTER]}; # 设置反向代理转发至 V2Ray
    proxy_http_version 1.1;
    # 一些 WebSocket 需要的配置
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    # Show real IP in v2ray access.log
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
# modified from (2022/01/30) https://guide.v2fly.org/advanced/wss_and_web.html#nginx-%E9%85%8D%E7%BD%AE</code></pre>
<p>然后在 <code>/etc/nginx/sites-enabled/</code> 目录下，先删除原有的 <code>default</code> 文件，然后新建 <code>my-enabled.conf</code>（文件名可自行调整）：</p>
<pre class="nginx"><code>include /etc/nginx/sites-available/default; # 继续使用 Nginx 的默认站点配置文件
include /etc/nginx/sites-available/{[YOUR_DOMAIN]}.conf; # 引用刚刚新建的配置文件</code></pre>
<ul>
<li>Update: 实际上推荐的方式是用 <code>ln -s</code> 在 <code>/etc/nginx/sites-enabled/</code> 里创建 symbolic link，当时搞的时候还不太懂，是我 naive 了（</li>
</ul>
<p>最后重新加载配置文件：</p>
<div class="sourceCode" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">nginx</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-s</span> reload</span></code></pre></div>
</section>
<section id="客户端" class="level3">
<h3 class="anchored" data-anchor-id="客户端">客户端</h3>
<p><del>用的图形化界面还没研究配置文件</del>，不过 outbounds 部分大致应如下所示：</p>
<div class="sourceCode" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb15-1"><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">"outbounds":</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span></span>
<span id="cb15-2">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb15-3">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"protocol"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"vless"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb15-4">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"settings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb15-5">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"vnext"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span></span>
<span id="cb15-6">                <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb15-7">                    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"address"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_DOMAIN]}"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb15-8">                    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"port"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">443</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb15-9">                    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"users"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span></span>
<span id="cb15-10">                        <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"id"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_UUID]}"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"email"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_EMAIL]}"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb15-11">                    <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span></span>
<span id="cb15-12">                <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb15-13">            <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span></span>
<span id="cb15-14">        <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">},</span></span>
<span id="cb15-15">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"streamSettings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb15-16">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"network"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ws"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb15-17">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"security"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"tls"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb15-18">            <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"wsSettings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb15-19">                <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"path"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"{[YOUR_PATH]}"</span></span>
<span id="cb15-20">            <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb15-21">        <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb15-22">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb15-23"><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span></span></code></pre></div>


</section>
</section>

 ]]></description>
  <category>web</category>
  <guid>https://blog.sun123zxy.top/posts/20220204-vmagic/index.html</guid>
  <pubDate>Thu, 03 Feb 2022 16:00:00 GMT</pubDate>
</item>
</channel>
</rss>
