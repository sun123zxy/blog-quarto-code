[
  {
    "objectID": "posts/20191012-ball/index.html",
    "href": "posts/20191012-ball/index.html",
    "title": "[JZOJ A组]球 题解",
    "section": "",
    "text": "球（ball）\n【问题描述】\n小 T 有 n 个桶和 2n − 1 个球，其中第 i 个桶能装前 2i − 1 个球。每个桶只能装一个球。\n现在小 T 取了 m 个桶和 m 个球，并将这些球各自放在这些桶里。问这样的方案有多少。\n两种方案不同当且仅当选择了不同的桶或球或者同一个桶在两种方案放了不同的球。\n由于方案的数量可能很大，所以只需要求方案数模 998244353 后的结果。\n【输入格式】\n从输入文件 ball.in 中读入数据。\n第一行一个整数 T，表示数据组数。\n接下来 T 行，每行两个整数 n, m，含义见【问题描述】。\n【输出格式】\n输出到文件 ball.out 中。\n输出共 T 行，每行一个整数表示一组数据的答案。\n【样例 1 输入】\n4\n1 1\n2 1\n2 2\n3 2\n【样例 1 输出】\n1\n4\n2\n18\n【样例 1 说明】\n对于 n = m = 1 的情况，只有选择第一个球和第一个桶，并将第一个球放在第一个桶里这一种方案。\n对于 n = 2, m = 2 的情况，会选择所有桶，第一个桶里放的一定是第一个球，于是第二个桶里可以放第二个或第三个球，共两种方案。\n【样例 2 输入】\n4\n1000 1\n10000 1\n100000 1\n1000000 1\n【样例 2 输出】\n1000000\n100000000\n17556470\n757402647\n【子任务】\n保证 1 ≤ T ≤ 1E5, 1 ≤ m ≤ n ≤ 1E7。\n首先看到\\(10^7\\)的数据和仅有2个参数的较多询问，马上想到这是一道和预处理阶乘有关的题。\n然后看题目，是一道计数题，结合前面的想法，预估是一道数学题，且很可能是结论题\n然后就分析一下，桶可以选择的球的区间存在包含关系，前面的桶选择一个球放入后，后面的桶可选择的球就会减1，用式子表达即 \\[\nAns= \\sum_{i_1 = 1}^n \\sum_{i_2 = i_1+1}^n \\sum_{i_3 = i_2+1}^n  ... \\sum_{i_m = i_{m-1}+1}^n (2 i_1 - 1)(2 i_2 - 2) ... (2i_m - m)\n\\] 对这种变量不重复的枚举方式，有一个常用的化法，就是反过来枚举，使每个变量的下界为\\(1\\)，方便后续化简 \\[\n\\sum_{i_m = m}^{n} \\sum_{i_{m-1} = m-1}^{i_m -1} \\sum_{i_{m-2} = m-2}^{i_{m-1} -1} ... \\sum_{i_{2} = 2}^{i_{3} -1} \\sum_{i_{1} = 1}^{i_{2} -1} (2 i_1 - 1)(2 i_2 - 2) ... (2i_m - m)\n\\] 直接把每一项提出去得 \\[\n\\sum_{i_m = m}^{n} (2i_m - m) \\sum_{i_{m-1} = m-1}^{i_m -1} (2i_{m-1} - (m-1)) ... \\sum_{i_{2} = 2}^{i_{3} -1} (2 i_2 - 2) \\sum_{i_{1} = 1}^{i_{2} -1} (2 i_1 - 1)\n\\] emm然后发现，这样的式子，从末尾开始，每一个求和都只与前一个求和给的变量有关，如果我们对最后一个求和预处理一下，然后用它来处理倒数第2个求和，然后用这来出来倒数第3个求和……处理到最后就是答案了！\n实现就一个二维的dp \\[\nf(0,j) = 1 \\\\\nf(i,i-1) = 0 \\\\\nf(i,j) = f(i,j-1) + (2j-i)f(i-1,j-1)\n\\] 那么，最终答案就是\\(f(m,n)\\)\n这样就可以获得70分\n观察推出来的式子，是不是挺像组合数的递推式？\n考虑打表出\\(f\\)矩阵找规律\n发现\\(f(i,i) = i!\\)，对每行都除掉他\n发现每一个数字都是完全平方数，开方后就成为一个近似杨辉三角的东西\n于是愉快的发现了规律。 \\[\nAns = m! (C_n^m)^2\n\\]\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=998244353;\nll QPow(ll x,ll up){\n    x%=MOD;\n    ll ans=1;\n    while(up)\n        if(up%2==0) x=x*x%MOD,up/=2;\n        else ans=ans*x%MOD,up--;\n    return ans;\n}\nll Inv(ll x){return QPow(x,MOD-2);}\nconst ll MXN=1E7+5;\n\nll fac[MXN];\nll facInv[MXN];\nvoid SpawnFac(ll sz){\n    fac[0]=1;for(ll i=1;i&lt;=sz;i++) fac[i]=fac[i-1]*i%MOD;\n    facInv[sz]=Inv(fac[sz]);\n    for(ll i=sz-1;i&gt;=1;i--) facInv[i]=facInv[i+1]*(i+1)%MOD;\n    facInv[0]=1;\n}\nll C(ll n,ll m){\n    if(n&lt;m) return 0;\n    return fac[n]*facInv[m]%MOD*facInv[n-m]%MOD;\n}\n\n\nint main(){\n    //freopen(\"ball.in\",\"r\",stdin);\n    //freopen(\"ball.out\",\"w\",stdout);\n    SpawnFac(1E7+1);\n    ll T;scanf(\"%lld\",&T);while(T--){\n        ll n,m;scanf(\"%lld%lld\",&n,&m);\n        ll ans=fac[m]*C(n,m)%MOD*C(n,m)%MOD;\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n这个结论题还是蛮有意思的，推导套路值得思考\n关于该结论的证明：\n\n\n\nprove\n\n\n反正我是没有看懂（"
  },
  {
    "objectID": "posts/20240513-isodft/index.html",
    "href": "posts/20240513-isodft/index.html",
    "title": "代数同构视角下的离散 Fourier 变换",
    "section": "",
    "text": "Fourier 变换：将给定函数 \\(f\\) 映为函数 \\(\\mathcal F[f]\\)： \\[\n\\mathcal F[f](\\lambda) := \\int_{-\\infty}^{\\infty} f(t) e^{- \\mathrm{i}\\lambda t} \\operatorname{d}\\!t\n\\]\n定义函数 \\(f\\) 和 \\(g\\) 的卷积 \\[\n(f*g)(\\lambda) := \\int_{-\\infty}^{\\infty} f(\\lambda-x) g(x) \\operatorname{d}\\!x\n\\] 则 Fourier 变换将两个函数的卷积化为逐点乘积，即 \\[\n\\mathcal F[f*g] = \\mathcal F[f] \\mathcal F[g]\n\\]\n\n\n\n\n\n离散 Fourier 变换（Discrete Fourier Transform, DFT）：线性空间 \\(\\mathbb C^n \\to \\mathbb C^n\\) 上的线性变换 \\(F\\)，将向量 \\(\\boldsymbol a  = (a_0,a_1,\\dots,a_{n-1})^\\mathrm{T}\\in \\mathbb C^n\\) 映为 \\(F \\boldsymbol a\\)，其第 \\(i\\) 个分量如下所示 \\[\n(F \\boldsymbol a)_i := \\sum_{k=0}^{n-1} \\omega_n^{ik} a_i\n\\] 这里分量下标从 \\(0\\) 开始计数，\\(\\omega_n := e^{2 \\pi \\mathrm{i}/ n}\\) 是 \\(\\mathbb C\\) 上的一个 \\(n\\) 次本原单位根．\n相仿的卷积性：两个向量 \\(\\boldsymbol a, \\boldsymbol b \\in \\mathbb C^n\\) 的循环卷积定义为 \\[\n(\\boldsymbol a * \\boldsymbol b)_k := \\sum_{i + j = k \\pmod{n}} a_i b_j\n\\] 则 DFT 将两个向量的循环卷积化为逐项乘积 \\(\\times\\)，即 \\[\nF(\\boldsymbol a * \\boldsymbol b) = (F \\boldsymbol a) \\times (F \\boldsymbol b)\n\\]\n\n\n\n\n在 \\(\\mathbb C^n\\) 的自然基下，变换 \\(F\\) 有矩阵表示 \\[\nF = \\begin{pmatrix} \\omega_n^{ij} \\end{pmatrix}_{(i,j)\\in n \\times n} = \\begin{pmatrix}\n1 & 1 & \\dots & 1 \\\\\n1 & \\omega_n & \\dots & \\omega_n^{n-1} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & \\omega_n^{n-1} & \\dots & \\omega_n^{(n-1)(n-1)}\n\\end{pmatrix}\n\\]\n\n卷积性：系数为全体复平面 \\(n\\) 次单位根的可逆 Vandermonde 矩阵\n正交性：适当单位化后为酉矩阵\n\n\n\n\n\nDFT 化卷为乘的本质？\n\n我们给出一大类具备卷积性的线性映射的构造，DFT 将作为特例推出．\n\n如何从代数角度理解 DFT？\n\n两个视角：多项式环、矩阵代数\n两种表现：求值插值、相似对角化\n一致观点：保加法、保数乘、保乘法的代数同构\n\nDFT 是否是唯一一类化卷为乘的变换？作为底层结构的 \\(\\mathbb C\\) 是否可以放宽？\n\n工程上复数乘法运算较慢且具有浮点误差，更换底层代数结构具有实际意义．例如，被称为数论变换（number theoretic transforms, NTT）的 DFT 变种就将 \\(\\mathbb C\\) 替换为有限域 \\(\\mathbb F_p\\) 而同时保留了其卷积性质．\n我们将其 DFT 扩展至任意整环并证明特定含义下的唯一性．\n\n\n\n1 [1]; [2]; [3]; [4]; [5]"
  },
  {
    "objectID": "posts/20240513-isodft/index.html#引例mathbb-cx求值插值与复数域-dft",
    "href": "posts/20240513-isodft/index.html#引例mathbb-cx求值插值与复数域-dft",
    "title": "代数同构视角下的离散 Fourier 变换",
    "section": "2.1 引例：\\(\\mathbb C[x]\\)、求值插值与复数域 DFT",
    "text": "2.1 引例：\\(\\mathbb C[x]\\)、求值插值与复数域 DFT\n\n\\(\\mathbb C[x]\\) 与循环卷积\n设不超过 \\(n-1\\) 次的多项式 \\(f(x) = \\sum_{k=0}^{n-1} a_k x^k\\)，\\(g(x) = \\sum_{k=0}^{n-1} b_k x^k\\)．二者的多项式乘积由 Cauchy 乘积给出 \\[\nf(x) g(x) = \\sum_{i=0}^{n-1} a_i x^i \\sum_{j=0}^{n-1} b_j x^j = \\sum_{k=0}^{2n-2} x^k \\sum_{i+j = k} a_i b_j\n\\] 令 \\(\\boldsymbol a := (a_0,a_1,\\dots,a_{n-1})^\\mathrm{T}\\)，\\(\\boldsymbol b := (b_0,b_1,\\dots,b_{n-1})^\\mathrm{T}\\)，回顾循环卷积定义 \\[\n(\\boldsymbol a * \\boldsymbol b)_k := \\sum_{i + j = k \\pmod{n}} a_i b_j\n\\] 可见 Cauchy 乘积与循环卷积尚有区别．稍加改动，若在模 \\(x^n - 1\\) 的意义下——即商环 \\(\\mathbb C[x]/(x^n-1)\\) 中计算，则二者相合： \\[\nf(x) g(x) = \\sum_{k=0}^{n-1} x^k \\sum_{i + j = k \\pmod{n}} a_i b_j \\pmod{x^n - 1}\n\\]\n\n\n\\(\\mathbb C[x]\\) 与复数域 DFT\nDFT 亦有在 \\(\\mathbb C[x]\\) 上的表示．给定 \\(\\boldsymbol a := (a_0,a_1,\\dots,a_{n-1})^\\mathrm{T}\\in \\mathbb C^n\\)，其对应多项式 \\(f(x) = \\sum_{k=0}^{n-1} a_k x^k\\) 次数不超过 \\(n-1\\) 次，则 \\[\n(F \\boldsymbol a)_i = \\sum_{k=0}^{n-1} \\omega_n^{ik} \\boldsymbol a_i = \\sum_{k=0}^{n-1} \\boldsymbol a_i (\\omega_n^i)^k = f(\\omega_n^i)\n\\] 恰为 \\(f(x)\\) 分别在 \\(n\\) 个 \\(\\mathbb C\\) 上 \\(n\\) 次单位根处多点求值的结果．\n\n可逆性：\\(n\\) 点唯一确定一个不超过 \\(n-1\\) 次的多项式（Lagrange 插值）\n线性性：\\((af+bg) (\\omega_n^i) = a f(\\omega_n^i) + b g(\\omega_n^i)\\)\n卷积性：将取模乘法化为点值逐项相乘，再次与 \\(\\mathbb C^n\\) 上的表现相合 \\[\n\\begin{aligned}\nF(\\boldsymbol a * \\boldsymbol b) &= (F \\boldsymbol a) \\times (F \\boldsymbol b) \\\\\n(fg)(\\omega_n^i) &= f(\\omega_n^i) g(\\omega_n^i)\n\\end{aligned}\n\\]\n\n\n\n小结\n\n\\(\\mathbb C^n\\) 与 \\(\\mathbb C[x]\\) 视角下的 DFT：\n\n\\(\\mathbb C^n\\)：作为以单位根为参数的 Vandermonde 矩阵，DFT 是 \\(\\mathbb C^n\\) 上的可逆线性变换，将向量间的循环卷积 \\(*\\) 化为逐项乘积 \\(\\times\\)．\n\\(\\mathbb C[x]\\)：作为单位根处的多点求值插值，DFT 在全体不超过 \\(n-1\\) 次的多项式和 \\(\\mathbb C^n\\) 间建立起线性同构关系，将多项式乘积化为函数值逐点乘积．\n\n化卷为乘，就是把多项式环上的取模乘法变为 \\(\\mathbb C^n\\) 上的逐项乘积，DFT 保持了两个代数结构间的乘法．\n\n\\(\\mathbb C[x]\\) 作为环结构乘法自然，在多项式环上刻画 DFT 较在 \\(\\mathbb C^n\\) 上强行定义循环卷积具有优越性．"
  },
  {
    "objectID": "posts/20240513-isodft/index.html#整环上的推广",
    "href": "posts/20240513-isodft/index.html#整环上的推广",
    "title": "代数同构视角下的离散 Fourier 变换",
    "section": "2.2 整环上的推广",
    "text": "2.2 整环上的推广\n\n代数、代数同构与直积\n\n整环：无零因子交换幺环\n设 \\(R\\) 是一整环，若 \\((A,+,\\times)\\) 为一环且配备了与乘法 \\(\\times\\) 相容的 \\(R\\)-数乘 \\(\\cdot\\)，则称 \\(A\\) 是一 \\(R\\)-代数，不至混淆时简称代数．\n\n整环 \\(R\\) 自身也可视为一个代数．\n\n我们将 \\(R^n\\) 理解为作为代数的 \\(R\\) 的直积，即 \\(R^n = R \\times R \\times \\dots \\times R\\)．直积的加法、数乘和乘法均在逐项意义下定义．\n保持代数间加法、数乘和乘法的双射被称为代数同构．\n\n\n\n几个观察与整环的优势\n\n关于引例的若干观察：\n\nDFT 是 \\(\\mathbb C[x] / (x^n-1) \\to R^n\\) 的一个代数同构，具体做法是在单位根处多点求值插值\n求值插值在任意 \\(n\\) 个不同位置进行即可，单位根不是本质要求\n商环 \\(\\mathbb C[x] / (x^n-1)\\) 带来了与循环卷积对应的多项式取模乘法，还蕴含着“不超过 \\(n-1\\) 次”为求值插值带来的单与满\n第一同构定理：设 \\(f: R \\to S\\) 是环同态，则 \\(f\\) 诱导出环同构 \\(R / \\operatorname{Ker}f \\cong \\operatorname{Im}f\\)\n\n选取整环作为底层代数结构的理由：\n\n交换：确保求值操作是同态\n保留环上整除的结构和多项式根与因子的关系（带余除法、余式定理）\n在唯一性证明中发挥作用\n\n\n\n\n商环到直积的代数同构\n下面固定 \\(R\\) 是一整环．令 \\(C\\) 是 \\(R\\) 的一有限子集，由若干不同一次多项式乘积 \\(\\prod_{c \\in C} (x-c)\\) 生成的 \\(R[x]\\) 上的理想记为 \\(\\left( \\prod_{c \\in C} (x-c) \\right)\\)．\n用记号 \\(R^C\\) 代表全体 \\(C\\) 上的 \\(R\\) 值函数构成的集合．\\(R^C\\) 与其上定义的函数逐点加法、数乘和乘法构成一个代数，自然也与 \\(R^n\\) 代数同构．\n\n\n\n\n\n\n\n命题 1 多项式商环 \\(R[x] / \\left( \\prod_{c \\in C} (x-c) \\right)\\) 与代数直积 \\(R^C\\) 代数同构．\n\n\n\n\n\n\n\n\n\n\n\n\n\nR\n[\nx\n]\nR\nC\nR\n[\nx\n]/\n(∏\nc\n∈\nC\n(\nx\n−\nc\n)\n)\n\n\nφ\n\n\n\n\n¯\nφ\n\n\n\n\n\n图 1: 命题 1 构造示意图\n\n\n\n\n\n构造\n考察 \\(R[x]\\) 到 \\(R^C\\) 上的代数同态 \\(\\varphi: f \\mapsto (C \\ni x \\mapsto f(x))\\)，其含义为在每一 \\(c \\in C\\) 处对多项式 \\(f\\) 进行求值．\n\n\\(\\varphi\\) 的核：\n\\[\n\\operatorname{Ker}\\varphi = \\{f \\in R[x]: f(C)=\\{0\\}\\} = \\left( \\prod_{c \\in C} (x-c) \\right)\n\\]\n\\(\\varphi\\) 的像：对每个 \\(c \\in C\\) 对应的理想 \\((x-c)\\) 应用中国剩余定理就有 \\(\\operatorname{Im}\\varphi = R^C\\)．\n\n故由第一同构定理，\\(\\varphi\\) 诱导的 \\[\n\\bar \\varphi: R[x] / \\left( \\prod_{c \\in C} (x-c) \\right) \\to R^C\n\\] 是一同构映射．\n\n\nDFT：代数同构的特例\n作为上一定理的特例，DFT 在单位根处求值插值．若 \\(\\omega_n\\) 为内嵌于 \\(R\\) 的某一 \\(n\\) 阶循环（乘法）群的生成元，则称其为 \\(R\\) 上的 \\(n\\) 次本原单位根．\n\n\n\n\n\n\n\n推论 1 若 \\(R\\) 上存在 \\(n\\) 次本原单位根 \\(\\omega_n\\)，则多项式 \\[\nx^n - 1 = \\prod_{k=0}^{n-1} (x - \\omega_n^k)\n\\] 故 \\(R[x] / \\left( x^n - 1 \\right)\\) 与 \\(R^n\\) 代数同构．我们便称二者间的代数同构为 \\(R\\) 上的 \\(n\\) 点 DFT．"
  },
  {
    "objectID": "posts/20240513-isodft/index.html#唯一性的讨论",
    "href": "posts/20240513-isodft/index.html#唯一性的讨论",
    "title": "代数同构视角下的离散 Fourier 变换",
    "section": "2.3 唯一性的讨论",
    "text": "2.3 唯一性的讨论\n\n全体代数同构的结构\n\n\n\n\n\n\n\n\n\nR\n[\nx\n]/(\nm\n(\nx\n))\nR\nn\n\n\n¯\nφ\n\n\n?\n\n\n\n\n\n图 2\n\n\n\n已经建立 \\(R[x]/(m(x)) \\to R^n\\) 的同构关系，这里 \\(m(x)\\) 是若干不同一次因式的乘积．但这种同构或不止一种．为研究其是否在某种意义下具有唯一性，需研究全体同构 \\(\\operatorname{Iso}(R[x]/(m(x)),R^n)\\) 的结构．该问题化归为研究 \\(R^n\\) 上全体自同构 \\(\\operatorname{Aut}(R^n)\\) 的结构．\n\n\n\n\n\n\n\n命题 2 设 \\(\\mathcal A\\) 是一与 \\(R^n\\) 同构的任一代数．固定代数同构 \\(\\varphi: \\mathcal A \\to R^n\\)，则任一 \\(\\mathcal A \\to R^n\\) 的代数同构 \\(f\\) 都具有形式 \\(f = p \\varphi\\)，这里 \\(p \\in \\operatorname{Aut}(R^n)\\)．\n\n\n\n\n\n\n\\(R^n\\) 上的自同构\n设 \\(\\boldsymbol e_1,\\dots,\\boldsymbol e_n\\) 是 \\(R^n\\) 上的自然基，设 \\(\\sigma \\in S_n\\) 是有限集 \\(\\{0,1,\\dots,n-1 \\}\\) 上的一个置换．定义 \\(R^n\\) 上由置换 \\(\\sigma\\) 诱导的模自同构 \\[\nP_\\sigma: \\boldsymbol e_k \\mapsto \\boldsymbol e_{\\sigma(k)}\n\\] 容易验证 \\(P_\\sigma\\) 保持逐项乘法，因此它也是 \\(R^n\\) 上的代数自同构．\n下面的引理刻画了 \\(R^n\\) 上代数自同构的形式．\n\n\n\n\n\n\n\n引理 1 全体 \\(P_\\sigma\\) 构成 \\(R^n\\) 上全体代数自同构，即 \\[\n\\operatorname{Aut}(R^n) = \\{ P_\\sigma : \\sigma \\in S_n \\}\n\\]\n\n\n\n\n\n\n\n只需证对任意 \\(R^n\\) 上任意代数自同构 \\(P\\)，其都可被某一置换 \\(\\sigma \\in S_n\\) 诱导得到．不妨考察 \\(P\\) 在 \\(R^n\\) 自然基下的矩阵表示 \\((p_{i,j})_{(i,j) \\in n \\times n}\\)．则 \\[\nP(\\boldsymbol e_i) \\times P(\\boldsymbol e_i) = P(\\boldsymbol e_i \\times \\boldsymbol e_i) = P(\\boldsymbol e_i)\n\\] 可分行写为对 \\(k = 0,1,\\dots,n-1\\)，都有 \\(p_{k,i}^2 = p_{k,i}\\)，因为 \\(R\\) 是整环，故 \\(p_{k,i}\\) 为 \\(0\\) 或 \\(1\\)，即矩阵各元素只能取 \\(0\\) 或 \\(1\\)．又对 \\(i \\neq j\\) 将 \\[\nP(\\boldsymbol e_i) \\times P(\\boldsymbol e_j) = P(\\boldsymbol e_i \\times \\boldsymbol e_j) = P(\\boldsymbol 0) = \\boldsymbol 0\n\\] 分行写开，得对 \\(k = 0,1,\\dots,n-1\\)，都有 \\(p_{k,i} p_{k,j} = 0\\)．于是（由 \\(R\\) 是整环）矩阵任一行至多只能由一个 \\(1\\)．假如存在第 \\(k\\) 行全为 \\(0\\)，则 \\(\\boldsymbol e_k \\notin \\operatorname{Im}P\\)，与 \\(P\\) 作为自同构的满性矛盾，故 \\(P\\) 的矩阵表示每行有且只有一个 \\(1\\)，其余为 \\(0\\)．\\(P\\) 的某两行亦不能完全相同，否则（由鸽巢原理）矩阵某列一定全为 \\(0\\)，与 \\(P\\) 作为自同构的单性矛盾．因此 \\(P\\) 的矩阵表示是一个置换矩阵，即 \\(P\\) 由一置换诱导．\n\n\nDFT 的唯一性\n\n\n\n\n\n\n\n推论 2 设 \\(f\\) 是任一 \\(R\\) 上的 \\(n\\) 点 DFT，则任何 \\(R\\) 上的 \\(n\\) 点 DFT \\(g\\) 都具有形式 \\(g = P_\\sigma f\\)，这里 \\(f\\) 是一事先固定的 \\(n\\) 点 DFT．\n\n\n\n\n作为推论，\\(n\\) 点 DFT 共有 \\(n!\\) 种．这一结果的显著性在于，只要不计求值得到的 \\(n\\) 个点值在 \\(R^n\\) 上的排列顺序，DFT 是唯一满足卷积性质的可逆线性映射．"
  },
  {
    "objectID": "posts/20230530-xiangtan/index.html",
    "href": "posts/20230530-xiangtan/index.html",
    "title": "CCPC 2023 湘潭邀请赛游记",
    "section": "",
    "text": "04:36，长沙返程的硬卧列车上。\n禁不起隔壁大叔富有特色的鼾声，对着窗外发愣。\n写写游记吧。"
  },
  {
    "objectID": "posts/20230530-xiangtan/index.html#序",
    "href": "posts/20230530-xiangtan/index.html#序",
    "title": "CCPC 2023 湘潭邀请赛游记",
    "section": "",
    "text": "04:36，长沙返程的硬卧列车上。\n禁不起隔壁大叔富有特色的鼾声，对着窗外发愣。\n写写游记吧。"
  },
  {
    "objectID": "posts/20230530-xiangtan/index.html#day--inf-0",
    "href": "posts/20230530-xiangtan/index.html#day--inf-0",
    "title": "CCPC 2023 湘潭邀请赛游记",
    "section": "Day (-inf, 0)",
    "text": "Day (-inf, 0)\n由于 UCUP Taiwan 场神奇的发挥，意外获得湘潭邀请赛名额 x1。公费旅游万岁！\n然而，飞机不给报，高铁不给报，软卧不给报，打车也不给报，路途时间高达 30h，还被迫翘掉周五周一头尾三节大课，体验并不良好。祸不单行，赛前十余日惊悉普物 27 日下午期末考试，若申请缓考，本学期的奖学金怕是无了。思量再三，还是想去，决定与队友兵分两路，考完直接空降长沙，再想办法到湘潭。晚上城铁已经收班，要是想当天到，恐怕只能高价打车了。这么算下来……\n自费金额 +1000 : (\n火车票意外地非常抢手，稍不留神，返程火车就只剩晚上 11 点半的了——赶上明天的早课是没必要再想了。不过，岳麓山橘子洲恰在长沙站西不远处，看看夜景也是不错的。\n其它队伍似乎并不太着急……\n\n\n\n你先别急\n\n\n最后竟因抢票太积极，被迫与大部队分道扬镳 : ("
  },
  {
    "objectID": "posts/20230530-xiangtan/index.html#day-0",
    "href": "posts/20230530-xiangtan/index.html#day-0",
    "title": "CCPC 2023 湘潭邀请赛游记",
    "section": "Day 0",
    "text": "Day 0\n去湘潭的路途并无太多亮点，感受是 \\[\n1000 \\text{CNY} = \\text{飞机} + \\text{打车} + \\text{也不知道怎么回事反正莫名其妙就到了的体验}\n\\]\n从半径来看，大兴机场并没有想象中的大。但其空间设计非常有意思。雪花状的航站楼中间高两头低，下站点、值机、安检全部集中在中心区域，而航站楼、廊桥、登机口通过几只触角向远端延伸，空间利用率极高，极大地节省了转场行走花费的时间。\n\n\n\n颇有商圈风范\n\n\n与队友联系，惊悉热身赛诸多不尽人意之处。这小破赛居然不用 DOMJudge？Pending 一发 20 min？评测机 32 位没 __int128？PE 是什么鬼东西？Dev C++ 只提供魔改版？VSCode 给了但机子带不动？……感觉不如校赛。希望不是所有 CCPC 都这样（\n队友给看了道热身赛题说是签到数论，飞机上吭哧吭哧半天无果，结果发现被诈骗了，赛时场内一人未过（\n到达 XX 电竞酒店，半夜。发现机子上竟有 Age of Empires 2——更神奇的是，队友竟突然指出 AoE2 是其机房的传统艺能！？小众中的小众，从未发现同好的 RTS/AoE 玩家落泪了。遗憾的是到得太晚，没来得及切磋一把。01:00 左右睡下。"
  },
  {
    "objectID": "posts/20230530-xiangtan/index.html#day-1",
    "href": "posts/20230530-xiangtan/index.html#day-1",
    "title": "CCPC 2023 湘潭邀请赛游记",
    "section": "Day 1",
    "text": "Day 1\n湖南的清晨从一碗米粉开始——味道不错，但口感并不太中意。\n一出门才感受到湖南的湿热：湿度高达 90% 的头顶烈日，走上两分钟就汗水淋漓，可不比某火炉城市好到那里。已经可以想象无法洗澡就要登上返程火车的我们会有多臭了 : ( 。更别说湘潭大学惊人的大小，坚持到开幕式现场的根本就没几个队（\n\n\n\n\n\n\n\n\n\n湘大某入口\n\n\n\n\n\n\n\n校徽版（据说存在缺漏）\n\n\n\n\n\n有气球（没有 CCPC 图标），有打印（比评测快），有汉堡套餐（没怎么认真吃），志愿者人手似乎不太够，每个考室甚至分不到一个监考。\n随便开题。两位队友秒了 I 然后 J（牛！）。随机游走开题，L 感觉是什么大力数据结构嵌套，E 数学题玩了玩感觉并没有什么思路，但发现并秒了 H，然后第一梯队的签到题好像就做完了。继续随机游走，看了 G 以为队友做过，确认后发现并没有，那应该就不太容易了。看榜开 F，干碎臭长题面发现就是个基础随机运筹学期望 dp，队友灵魂提醒需要特判 \\(B=1\\)，成功 1A。这期间两位队友也开了 A 但一发 WA 一发 TLE——怎么会 T 呢？在此之间卡壳卡爆。三人干瞪眼贡献四发罚时浪费 1h，结果竟是 \\(10^5\\) 次 printf 在老爷评测上跑的太慢！写题的队友表示以后彻底切割 C 风格读写（\n然后三人回头看之前和一位队友讨论一半的 K（J 是 K 的 checker 海星）。想到了 aa, bb, cc, …, ab, ac, ad, … 的构造方式，但在考虑后续延伸时莫名认为要继续移位构造超大置换环 abcde..., acegi...，于是开始大力计算 \\(\\sum_{i=0}^{25} \\gcd(26,i)\\)。队友打断吟唱，指出只需 \\(\\frac {25 \\times 24}{2}\\) 两位循环并在后面填充 z 即可，遂暴毙，决定先拿下汉堡套餐，然后继续游走摆烂。然而队友小脑转的比大脑快，光速敲完遗憾 WA，似乎他的特判有亿点多。调试无果，打印，换我重写。写得差不多了，两位队友合力调试突然成功，于是历经坎坷终于进入 6 题区。\n距比赛结束还有一个半小时左右。看 B 看 D，深感星穹铁道题面之博大精深，决定搏一搏 L。上了个厕所发现会二维了，三维似乎也只是颗二维线段树，维护 max/min 判断当前操作方块是否平整 + 区间覆盖的修改操作即可。然而队友思路是神奇的二维扫描线，顿感自己非常不熟悉这种非标线段树。激烈讨论后，还是让擅长数据结构的队友按他熟悉的方法实现。然而队友实现一半算法竟然假了，又紧急更换写法，此前表现正常的电脑突然开始变卡，三个人对着电脑大吼大叫，最后 2 min 写完了代码！F11！输出“No”！摆！\n第一次外出比赛就这样结束了。比较遗憾的，无疑是 A printf 吃的四发罚时了。给你校老爷评测机跪了（\n滚榜环节的操作非常迷惑，不从奖牌区滚起，又跳过了 Cu Ag 区，滚了个寂寞。因为老爷评测机的原因，封榜前后的排名也几乎没有发生变化。6 题金银铜，这是我能见着的区分度吗（\n最后冠军颁奖倒意外地有节目效果。主持人抑扬顿挫念出“梦想天生”，BGM 和掌声突然响起，恍惚有 Dream Battle 前奏噔噔咚，灵梦按在地上揍的感觉（"
  },
  {
    "objectID": "posts/20230530-xiangtan/index.html#day-1-赛后",
    "href": "posts/20230530-xiangtan/index.html#day-1-赛后",
    "title": "CCPC 2023 湘潭邀请赛游记",
    "section": "Day 1 赛后",
    "text": "Day 1 赛后\n返程继续暴汗。从湘潭乘城铁至长沙。\n\n\n\n高铁风格，地铁运营\n\n\n队友来时已经踩好点了，拉着啥也不知道的我就往五一广场走……\n\n\n\n\n\n\n\n\n\n五一广场\n\n\n\n\n\n\n\n到处都是的某神奇奶茶店\n\n\n\n\n\n队友在前面慢悠悠地寻找吃饭的地方，看上去是准备边吃边坐挨到火车到点了。还想出去逛逛，于是暂时各奔东西。街边随便点了份牛杂面（超辣！）和臭豆腐（完全不臭），乘地铁二号线至橘子洲西岸，向岳麓山前进。然而功课未做充足，到达山门才发现索道已停，大巴收班。天色已晚，爬上去显然赶不上 11 点半的火车，只好悻悻而去。\n\n\n\n\n\n\n\n\n\n岳麓山门\n\n\n\n\n\n\n\n岳麓山麓\n\n\n\n\n\n然而……\n\n\n\n年轻真好\n\n\n于是从麓山路返回，上至橘子洲大桥。由此可直接步行至江心的橘子洲。\n\n\n\n\n\n\n\n\n\n橘子洲西望\n\n\n\n\n\n\n\n橘子洲东望\n\n\n\n\n\n时间来到 10 点整。准备返程。地铁至五一广场，与队友汇合，前往长沙站。\n\n\n\n旅途的终点\n\n\n疲惫，忘记买早饭就过安检了。候车大厅已无空位，站着闲聊了小会儿，时间到了。之前车上刷夜的豪言壮语早已抛之脑后，上车一躺——Day 1, end.\nupd x1: 酒店登录过 Steam 的群友都被盗号了 \\(\\Sigma ( \\supset \\mathrm{O} _\\frown \\mathrm{O} ) \\supset\\)\nupd x2: 报销疑似仍然有戏，感谢学校感谢党 \\(\\Sigma ( \\supset \\mathrm{O} _\\smile \\mathrm{O} ) \\supset\\)"
  },
  {
    "objectID": "posts/20230530-xiangtan/index.html#补题",
    "href": "posts/20230530-xiangtan/index.html#补题",
    "title": "CCPC 2023 湘潭邀请赛游记",
    "section": "补题",
    "text": "补题\nGYM104396\n\nL\n需要注意的是，四分树 / K-D 树不存在时间复杂度优秀的区间修改。对于任意区间修改，树套树的实现是必要的。\nL 其实有基于差分的非常容易的解法，见解法二。随机分划长度的类似 hash 的解法三也非常震撼。"
  },
  {
    "objectID": "posts/20200321-burnside/index.html",
    "href": "posts/20200321-burnside/index.html",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "",
    "text": "PS: 写的时候博主比较naive，所有的变换都是向右结合的，还请谅解（"
  },
  {
    "objectID": "posts/20200321-burnside/index.html#s-0",
    "href": "posts/20200321-burnside/index.html#s-0",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "0. 引子 (update 2020/12/21)",
    "text": "0. 引子 (update 2020/12/21)\n直接上理论会有点难受，不妨先来点简单的计数题找找感觉？\n\n0.1 倒序同构序列计数\n\n长度为 \\(n\\) 的序列 \\(A\\) 满足 \\(\\forall 1 \\le i \\le n, \\ 1 \\le a_i \\le m\\) ，问有多少种不同的序列 \\(A\\) ？\n序列是无标号的，即正序和倒序记为一种方案。\n\n容易想到一种计数方式——若不考虑同构，显然有 \\(m^n\\) 种选择方案。对其中的非回文序列，可以直接计数然后除以 \\(2\\) 去重。而回文序列正反都相同，不能直接除掉，因此对每个回文序列补上“倒序”的情况再除以 \\(2\\) 即可。回文序列有 \\(m^{\\lceil \\frac n 2 \\rceil}\\) 种，故最终答案为 \\(\\frac 1 2 (m^n + m^{\\lceil \\frac n 2 \\rceil})\\) 。\nPS：现在我们可以对直链卤代烷进行计数了，答案为 \\(\\frac 1 2 (4^2 \\times 3^{n-2} + 4 \\times 3^{\\lceil \\frac n 2 \\rceil -1})\\) 。\nPPS：你也许马上想到了环卤代烷计数，它正是后面Polya所解决的问题。\n在这个小问题中，我们“补”上的回文序列正是Burnside思想的精髓。Burnside的目标便是为此类等价类计数问题找到一种通用的解决方案。欲知后事如何，请看下文分解。"
  },
  {
    "objectID": "posts/20200321-burnside/index.html#s-1",
    "href": "posts/20200321-burnside/index.html#s-1",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "1. 群",
    "text": "1. 群\n\n1.1 群的概念\n群 \\((S,\\circ)\\) 是一个元素集合 \\(S\\) 和一种二元运算 \\(\\circ\\) 的合称，其满足以下性质。\n\n封闭性\n\n对于 \\(\\forall a,b \\in S\\) ， \\(\\exists c \\in S\\) 使得 \\(c = a \\circ b\\)\n\n\n\n结合律\n\n对于 \\(\\forall a,b,c \\in S\\) ， \\(a \\circ (b \\circ c) = (a \\circ b) \\circ c\\)\n\n\n\n单位元\n\n\\(\\exists I \\in S\\) ，使得对于 \\(\\forall a \\in S\\) ， \\(a \\circ I = I \\circ a = a\\)\n\n根据定义，单位元具有唯一性，即一个群只有一个单位元。\n证明：设 \\(a,b\\) 都是 \\(S\\) 的单位元，则 \\(a = a \\circ b = b\\) ，两者实质上相同。\n\n\n逆元\n\n对于 \\(\\forall a \\in S\\) ， \\(\\exists a^{-1} \\in S\\) ，使得 \\(a \\circ a^{-1} = a^{-1} \\circ a = I\\)\n\n根据定义，逆元具有唯一性，即每个元素有且仅有一个逆元。\n证明：设 \\(a\\) 有两个逆元 \\(b,c\\) ，则 \\(b = b \\circ I  = b \\circ (a \\circ c) = (b \\circ a) \\circ c = I \\circ c  = c\\) ，两者实质相同。\n这也同时说明了不存在两个元素 \\(a, b\\) 的逆元是同一个元素 \\(c\\)，因为 \\(c\\) 只有唯一一个逆元。\n即逆元是一一对应的。\n\n\n\n1.2 更抽象的群\n我们更进一步，将 \\(S\\) 中的每一个元素视为一个函数， 默认 \\(\\circ\\) 代表函数的复合，即 \\((f \\circ g) (x) = f(g(x))\\)。所以现在一个群可以只用一个函数集合 \\(S\\) 来表示。\n例如，记 \\(r_\\theta (x)\\) 表示将 \\(x\\) 旋转 \\(\\theta\\) 度，那么 \\(S = \\{ r_{0^\\circ}, r_{90^\\circ},r_{180^\\circ},r_{270^\\circ}\\}\\) 就是一个群。\n证明一下，显然有封闭性和结合律。\n单位元是 \\(r_{0^\\circ}\\) ，因为 \\(r_{0^\\circ} (r_\\theta(x)) = r_{\\theta^\\circ} (r_0 (x)) = r_\\theta(x)\\)\n\\(S\\) 中元素 \\(r_\\theta\\) 的逆元便是 \\(r_{360^\\circ - \\theta}\\) ，因为他们两个卷起来就是 \\(I = r_{0^{\\circ}}\\)\n\n\n1.3 提示\n由于群满足封闭性，所以我们在寻找群的时候一定要“找完”所有可能的状态，例如 \\(\\{ r_{0^\\circ}, r_{90^\\circ}\\}\\) 就不是一个群。"
  },
  {
    "objectID": "posts/20200321-burnside/index.html#s-2",
    "href": "posts/20200321-burnside/index.html#s-2",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "2. Burnside",
    "text": "2. Burnside\n记号说明：通常使用 \\(a,b,c,d \\in C\\) 表示计数对象，而 \\(f,g,h \\in G\\) 表示变换。\n\n2.1 等价\n\n给定一个作用在计数集合 \\(C\\) 上的变换集合 \\(G\\)，若 \\(C\\) 中计数对象 \\(d\\) 可以由计数对象 \\(c\\) 通过 \\(G\\) 中变换得到，即 \\(\\exists f \\in G\\) 使得 \\(d = c \\circ f\\)，我们便称 \\(c\\) 与 \\(d\\) 等价，记作 \\(c \\sim d\\) 。\n\n\\(G\\) 其实就是个函数集合，其中的函数都接受 \\(C\\) 中元素作为参数，输出也是 \\(C\\) 中元素。\n类似的我们记 \\(f(c)\\) 为 \\(c \\circ f\\) ，表示对计数对象 \\(c\\) 做变换 \\(f\\) 。\n我们同样可以对一个函数做变换，即 \\(f \\circ g\\) 是允许的。请参考上文更抽象的群 。\n在Burnside中，我们要求 \\(G\\) 是一个群。这样我们可以导出一些关于等价的性质。\n\n自反性\n\n\\(a \\sim a\\)\n\n因为 \\(G\\) 是群，故有单位元 \\(I \\in G\\) ， \\(a \\circ I = a\\) ，满足等价定义。\n\n\n对称性\n\n\\(a \\sim b \\iff b \\sim a\\)\n\n设 \\(a \\circ f = b\\) ，因为 \\(G\\) 是群，故存在 \\(f^{-1}\\) 使得 \\(b \\circ f^{-1} = a\\) ，满足等价定义。同理反向再证一次即可得出充分完全性。\n\n\n传递性\n\n\\(a \\sim b , b \\sim c \\Rightarrow a \\sim c\\)\n\n设 \\(a \\circ f  = b, b \\circ g = c\\)，因为 \\(G\\) 是群，所以 \\(f \\circ g \\in G\\)（封闭性），\\(a \\circ (f \\circ g) = (a \\circ f) \\circ g = b \\circ g = c\\)，满足等价定义。\n\n\n\n2.2 等价类及等价类计数\n等价类即所有等价的计数元素的集合。计数集合 \\(C\\) 由许多个等价类构成，好比连通块。 统计 \\(C\\) 中有多少个等价类，就是等价类计数。\n如何快速的等价类计数，便是我们接下来所研究的。\n\n\n2.3 弱化版\n不妨先来研究一个弱化版本，这可以帮助我们捋清思路。\n\n2.3.1 引理\n\n若对于 \\(\\forall c \\in C,f \\in G \\quad (f \\not= I)\\) ， \\(c \\circ f \\not= c\\) 都成立，那么对于 \\(\\forall c \\in C, f \\in G,g \\in G \\quad (f \\not= g)\\) ，都有 \\(c \\circ f \\not= c \\circ g\\) ，即与 \\(\\forall c\\) 等价的元素有且仅有 \\(|G|\\) 个。\n\n利用反证法。假设 \\(\\exists c,f,g\\) 使得 \\(c \\circ f = c \\circ g\\) ，那么有 \\(c \\circ f \\circ g^{-1} = c\\) ，即 \\(c \\circ (f \\circ g^{-1}) = c\\) （同时因为 \\(f \\not= g\\) ，所以 \\(f \\circ g^{-1} \\not= I\\) ），于是与假设产生矛盾，故引理成立。\n对 \\(c\\) 做变换得到的元素两两不同，共有 \\(|G|\\) 种变换，故有且仅有 \\(|G|\\) 个元素与 \\(c\\) 等价。\n\n\n2.3.2 弱化版Burnside\n\n若对于 \\(\\forall c \\in C,f \\in G \\quad (f \\not= I)\\) ， \\(c \\circ f \\not= c\\) 都成立，那么 \\[\n等价类计数 = \\frac{|C|}{|G|}\n\\]\n\n这是肉眼可得的结论。由引理，对于 \\(\\forall c\\) ，都有且仅有 \\(|G|\\) 个互不相同的元素与其等价。由于等价的传递性，这 \\(|G|\\) 个元素是封闭的，实质上形成了许多个大小为 \\(|G|\\) 的等价类。那么等价类个数自然就是总计数元素个数 \\(|C|\\) 除以每个等价类的大小 \\(|G|\\) 了。\n\n\n\n2.4 标准版\n弱化版的关键之处在于引理， \\(c \\circ f \\not= c\\) 让我们知道每个 \\(c\\) 有 \\(|G|\\) 个互不相同的元素与其等价。我们将这个条件和这个引理做一些“推广”。\n\n2.4.1 稳定核 & 不动点\n\n稳定核 \\(G(c)\\) ：对于计数对象 \\(c\\) ，使得 \\(c \\circ f = c\\) 的所有变换 \\(f\\) 的集合，即 \\(\\{ f \\in G | c \\circ f = c \\}\\)\n不动点 \\(C(f)\\) ：对于变换 \\(f\\) ，使得 \\(c \\circ f = c\\) 的所有计数对象 \\(c\\) 的集合，即 \\(\\{ c \\in C | c \\circ f = c \\}\\)\n\n注意单个字母 \\(G\\) 代表整个变换集合；而 \\(G(c)\\) 是根据计数元素 \\(c\\) 生成的一个被 \\(G\\) 包含的变换集合；\n注意单个字母 \\(C\\) 代表整个计数集合；而 \\(C(f)\\) 是根据变换 \\(f\\) 生成的一个被 \\(C\\) 包含的计数集合。\n\n\n2.4.2 引理1\n\n\\[\n\\sum_{c \\in C} |G(c)| = \\sum_{f \\in G} |C(f)|\n\\]\n\n证明： \\[\n\\begin{aligned}\n\\sum_{c \\in C} |G(c)| &= \\sum_{c \\in C} \\sum_{f \\in G} [c \\circ f = c] \\\\\n&= \\sum_{f \\in G} \\sum_{c \\in C} [c \\circ f = c] \\\\\n&= \\sum_{f \\in G} |C(f)|\n\\end{aligned}\n\\]\n其实质是更换枚举方式。\n\n\n2.4.3 引理2\n\n对于 \\(\\forall c\\) ， \\(G(c)\\) 是个群。\n\n分别证明群的四个性质即可。\n\n封闭性\n对于 \\(\\forall f,g \\in G(c)\\) ， \\(c \\circ (f \\circ g) = (c \\circ f) \\circ g = c \\circ g = c\\) ，所以 \\(f \\circ g \\in G(c)\\) 。封闭性得证。\n\n\n结合律\n\\(G(c) \\subseteq G\\) ，结合律直接由 \\(G\\) 给出。\n\n\n单位元\n\\(c \\circ I = c\\) ，所以 \\(I \\in G(c)\\) 。（这里的 \\(I\\) 代指 \\(G\\) 的单位元）\n\n\n逆元\n对于 \\(\\forall f \\in G(c)\\) ， \\(c \\circ f^{-1} = (c \\circ f) \\circ f^{-1} = c \\circ (f \\circ f^{-1}) = c\\) ，所以 \\(f^{-1} \\in G(c)\\) 。\n\n\nExtra (update 2020/03/28)\n有个群论定理可以直接证明上述结论：\n\n有限群的非空封闭子集都是子群。\n\n另外，在后面我们将会发现 \\(|G(c)|\\) 实际上是 \\(|G|\\) 的约数，这反应了拉格朗日定理：\n\n一个有限群 \\(S\\) 的子群的大小是 \\(|S|\\) 的约数。\n\n有趣的是，拉格朗日定理的证明实际上和下文引理3的证明几乎一模一样。\n这两个定理在这里不做详细讨论，有兴趣的同学可以左转算法导论和这里（拉格朗日定理证明）\n\n\n\n2.4.4 引理3\n\n对于 \\(\\forall c\\) ，记 \\(S(c)\\) 为与 \\(c\\) 等价的计数元素的集合，有 \\[\n|S(c)| = \\frac{|G|}{|G(c)|}\n\\]\n\n这个引理与弱化版引理是对应关系。请对比起来理解。\n我们的证明思路是：对于某个计数元素 \\(c\\) ，求出 对于某个确定的变换 \\(f\\) ，有多少个变换 \\(g\\) 与其作用效果相同，即 \\(c \\circ f = c \\circ g\\) 。\n\\[\nc \\circ f = c \\circ g \\iff c \\circ f \\circ g^{-1} = c \\iff (f \\circ g^{-1}) \\in G(c)\n\\]\n即 \\(f ,g\\) 对 \\(c\\) 的作用效果相同 等价于 \\(f \\circ g^{-1}\\) 在 \\(c\\) 的稳定核内。\n于是对于一个变换 \\(h \\in G(c)\\) ，根据群的基本性质，存在唯一的 \\(g^{-1} = f^{-1} \\circ h\\) ，使得 \\(f \\circ g^{-1} = h\\) 。变换 \\(h \\in G(c)\\) ，所以有 \\(|G(c)|\\) 种取值； \\(f\\) 是确定的，根据逆元唯一性， \\(f^{-1}\\) 也是确定的；故 \\(g^{-1}\\) 有 \\(|G(c)|\\) 种取值。又由于逆元的一一对应性， \\(g\\) 有 \\(|G(c)|\\) 种取值。\n即对于 \\(\\forall f\\) ，都有且仅有 \\(|G(c)|\\) 个 \\(g\\) 与其作用效果相同。\n这说明了什么？“作用效果相同”也是一种类似等价的关系，容易证明其具有传递性，于是他们是封闭的。作用效果相同的变换实质上形成 \\(\\frac{|G|}{|G(c)|}\\) 个大小为 \\(|G(c)|\\) 的两两相连的连通块或者说“作用效果相同等价类”，合起来构成了整个 \\(G\\) 。我们便知道了 \\(c\\) 通过变换可以变出 \\(\\frac{|G|}{|G(c)|}\\) 个不同的计数元素，即与 \\(c\\) 等价的元素有 \\(\\frac{|G|}{|G(c)|}\\) 个，引理3证毕。\n\n\n2.4.5 Burnside\n\n\\[\n等价类计数 = \\frac{1}{|G|}\\sum_{f \\in G} |C(f)|\n\\]\n\n\\[\n\\begin{aligned}\n\\frac{1}{|G|}\\sum_{f \\in G} |C(f)| &= \\frac{1}{|G|}\\sum_{c \\in C} |G(c)|    \\quad &\\text{...引理1} \\\\\n&= \\frac{1}{|G|}\\sum_{c \\in C} \\frac{|G|}{|S(c)|} \\quad &\\text{...引理3} \\\\\n&= \\sum_{c \\in C} \\frac{1}{S(c)} \\\\\n&= 等价类计数\n\\end{aligned}\n\\]\n倒数第二个式子，每个元素贡献 \\(\\frac{1}{S(c)}\\) ，合起来便是等价类计数。这便是等价类计数的本质。\n\n\n\n2.5 Burnside的本质\n\n\n\n来自zkx学长的课件《Polya计数.pptx》\n\n\n\n直接除以4不行，因为前四种找不到4个等价的情况\n所以强行把它们补成4个就行了。。。\nBurnside就是“强行补”的过程\n——zkx\n\nBurnside的精髓就在于此。\nBurnside弱化版，实际上是省掉了强行补的部分，使所有有效部分都在 \\(C(I)\\) 。\n\n可以发现“群”是Burnside的唯一约束\n这个约束几乎就是没有约束。。。\n所以Burnside是非常通用的等价类计数法\n——zkx"
  },
  {
    "objectID": "posts/20200321-burnside/index.html#s-3",
    "href": "posts/20200321-burnside/index.html#s-3",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "3. 置换群",
    "text": "3. 置换群\n（Burnside的内容已经结束，这里开始是Polya了）\n\n3.1 置换\n一个置换长这样： \\[\n(\\begin{aligned}\n1&,2,3,...,n \\\\\na_1&,a_2,a_3,...,a_n\n\\end{aligned})\n\\]\n其中 \\(a_1,a_2,a_3,...,a_n\\) 是一个 \\(n\\) 排列。置换是一个接受序列，输出序列的函数，它表示对每一个 \\(i\\) ，将原序列第 \\(i\\) 个数放到第 \\(a_i\\) 个位置上。这种括号是置换的表示方式，表示多个映射关系。\n\n\n3.2 移位置换\n一个普通的移位置换长这样： \\[\n\\tau_n =\n(\\begin{aligned}\n1,2,3,...,n&-1,n \\\\\n2,3,4,...,&n,1\n\\end{aligned})\n\\]\n即全员右移 \\(1\\) 位。很自然的可以拓展到 \\(k\\) 位移位置换： \\[\n\\tau_n^k =\n(\\begin{aligned}\n1,2,3,...&,n-1,n \\\\\nk,k+1,...,n&,1,...,k-1\n\\end{aligned})\n\\]\n容易发现 \\(\\tau_n^k\\) 是 \\(k\\) 个 \\(\\tau_n\\) 的复合，所以我们写成乘方的形式。\n\n\n3.3 移位置换图\n移位置换 \\(\\tau_n^k\\) 所形成的图：考虑将 \\(n\\) 个点排成一个圆圈， \\(1\\) 连 \\(k\\) ， \\(2\\) 连 \\(k+1\\) ，…，\\(n\\) 连 \\(k-1\\) 。\n\n\n\n\\(tau_6^2\\)移位置换图\n\n\n如图便是 \\(\\tau_6^2\\) 形成的移位置换图，共有两个环。\n\n\n3.4 移位置换环个数定理\n\n\\(\\tau_n^k\\) 移位置换图中环的个数为 \\(\\gcd(k,n)\\) 。\n\n证明的思路同样是已经使用多次的：求出对于一个数 \\(a\\) ，有多少个数 \\(b\\) 与它在同一个环内。\n对于 \\(\\forall a,b\\) ， \\(a,b\\) 在同一个环内的条件为 \\[\n\\begin{aligned}\na \\equiv b + ik \\pmod n &\\iff \\exists i,j \\quad s.t. \\quad a = b + ik + jn \\\\\n&\\iff \\exists i,j \\quad s.t. \\quad ik + jn = a - b \\\\\n&\\iff \\gcd(k,n) | (a-b) \\quad \\text{...裴蜀定理}\n\\end{aligned}\n\\]\n最后两个式子之间的转化运用了二元整数解不定方程的有解条件，即裴蜀定理。\n那么这样一来，对于 \\(\\forall a\\) ，显然有且仅有 \\(\\frac{n}{\\gcd(k,n)}\\) 个数与它在同一环内，故共有 \\(\\gcd(k,n)\\) 个环。（“在同一环内”传递性导出的封闭性，这个方法在上文已经多次使用到）"
  },
  {
    "objectID": "posts/20200321-burnside/index.html#s-4",
    "href": "posts/20200321-burnside/index.html#s-4",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "4. Polya",
    "text": "4. Polya\n\n4.1 概念\nPolya是Burnside在环同构计数问题上的一个导出结论，比朴素的Burnside更加优秀。环同构的变换群 \\(G\\) 是一个移位置换群，即 \\[\nG = \\{ \\tau_n^k \\ | \\ k \\in [0,n), k \\in Z \\}\n\\]\n即在平面内旋转环能够变得相同的方案算作一种。\n显然移位置换群是一个群 废话，证明很简单，同样是证明群的四个性质，这里不再赘述。\n最简单的一类问题便是——洛谷P4980 Polya定理\n\n给定一个 \\(n\\) 个点， \\(n\\) 条边的环，有 \\(m\\) 种颜色，给每个顶点染色，问有多少种本质不同的染色方案，答案对 \\(10^9+7\\) 取模。\n本质不同定义为：只需要不能通过旋转与别的染色方案相同。\n\n\n\n4.2 推导\n有了前面那么多的铺垫，大名鼎鼎的Polya定理现在已经可以自己动手推出来了！\n先写出Burnside引理，并套入移位置换 \\[\n\\begin{aligned}\n等价类计数 &= \\frac{1}{|G|}\\sum_{f \\in G} |C(f)| \\\\\n&= \\frac{1}{n}\\sum_{i=1}^n |C(\\tau_n^i)|\n\\end{aligned}\n\\]\n注： \\(\\tau_n^n = \\tau_n^0\\) ，上面从 \\(1\\) 到 \\(n\\) 的枚举是对的\n\\(|C(\\tau_n^i)|\\) 是什么？\n\\(\\tau_n^i\\) 的不动点的个数，即要求 \\(\\tau_n^i\\) 移位置换图里同一环上点颜色相同的方案数。（为了做置换后看上去和原来一样）\n根据移位置换环个数定理， \\(\\tau_n^i\\) 有 \\(\\gcd(n,i)\\) 个环。有 \\(m\\) 种颜色给 \\(\\gcd(n,i)\\) 个环去染，显然方案数为 \\(m^{\\gcd(n,i)}\\) 。我们不局限于本题推而广之，方案数是一个关于环个数 \\(\\gcd(n,i)\\) 的函数 \\(f(\\gcd(n,i))\\) 。（也可以是关于环大小 \\(\\frac{n}{\\gcd(n,i)}\\) 的函数，反正最重要的参数是 \\(\\gcd(n,i)\\) ）\n带入原式 \\[\n\\frac{1}{n}\\sum_{i=1}^n f(\\gcd(n,i))\n\\]\n诶！这个式子里面有 \\(\\gcd\\) ！\n不用抑制住冲动，我们按照常见的莫反题目套路来。 \\[\n\\begin{aligned}\n等价类计数 &= \\frac{1}{n}\\sum_{i=1}^n f(\\gcd(n,i)) \\\\\n&= \\frac{1}{n} \\sum_{d|n} f(d) \\sum_{i=1}^n [\\gcd(n,i)=d] \\quad &\\text{...把gcd提出来枚举} \\\\\n&= \\frac{1}{n} \\sum_{d|n} f(d) \\sum_{i=1}^{\\frac{n}{d}} [\\gcd(\\frac{n}{d},i)=1] \\\\\n&= \\frac{1}{n} \\sum_{d|n} f(d) \\varphi(\\frac{n}{d}) \\quad &\\text{...欧拉函数定义}\n\\end{aligned}\n\\]\n好恭喜你可以在 \\(O(\\sqrt n)\\) 的优秀时间复杂度里求得答案了！\n2022/06/25 update: 需要指出的是，Polya 定理并不只适用于移位置换群。请读者自行思考，Polya 定理是否适用于任意置换群。（提示：任意置换都可以表示为若干个轮换的复合）\n\n\n4.3 实现\n提示一下实现上的一些细节。\n快速幂作为基本技巧就不提了；\n欧拉函数直接质因数分解求即可。这里会遇到一个小问题：外面一层枚举因数，里面一层分解质因数，这不 \\(O(\\sum_{d|n} \\sqrt d)\\) 了吗？\n用一些黑科技可以证明一个比 \\(O(n)\\) 更紧的上界是 \\(O(n^{\\frac 3 4})\\) ，实际上则有香港记者的速度（洛谷 \\(n=10^9\\) ， \\(10^3\\) 组数据可以随便跑过）\n/*\n洛谷P4980 Polya定理\nsun123zxy\n朴素写法\n洛谷共2.08s\n2019/12/24\n*/\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\nll Rd(){\n    ll ans=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9') c=getchar();\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    return ans;\n}\nconst ll MOD=1E9+7;\nll QPow(ll x,ll up){\n    x%=MOD;\n    ll ans=1;\n    while(up)\n        if(up%2==0) x=x*x%MOD,up/=2;\n        else ans=ans*x%MOD,up--;\n    return ans;\n}\nll Inv(ll x){return QPow(x,MOD-2);}\n\nll Phi(ll n){\n    ll t=n;\n    ll ans=1;\n    for(ll i=2;i*i&lt;=t;i++){\n        ll c=0;\n        while(t%i==0) t/=i,c++;\n        if(c) ans=ans*(QPow(i,c)-QPow(i,c-1)+MOD)%MOD;\n    }\n    if(t&gt;1) ans=ans*(t-1)%MOD;\n    return ans;\n}\n\nll N;\nll Polya(ll d){\n    return QPow(N,d)*Phi(N/d)%MOD;\n}\nvoid Solve(){\n    ll Ans=0;\n    for(ll i=1;i*i&lt;=N;i++){\n        if(N%i==0){\n            Ans+=Polya(i);\n            if(i!=N/i) Ans+=Polya(N/i);\n            Ans%=MOD;\n        }\n    }\n    Ans=Ans*Inv(N)%MOD;\n    printf(\"%lld\\n\",Ans);\n}\nint main(){\n    ll T=Rd();while(T--){\n        scanf(\"%lld\",&N);\n        Solve();\n    }\n    return 0;\n}\n不过当然有真正 \\(O(\\sqrt n)\\) 的写法。只需在最外层分解质因数，然后DFS的去枚举因数，这样就不用每次去分解 \\(\\frac{n}{d}\\) 啦！于是这种写法就快更多了。\n/*\n洛谷P4980 Polya定理\nsun123zxy\n更优写法\n洛谷共125ms\n2019/12/24\n*/\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\nint Rd(){\n    int ans=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9') c=getchar();\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    return ans;\n}\nconst ll MOD=1E9+7;\nll QPow(ll x,ll up,bool isM=1){\n    x%=MOD;\n    ll ans=1;\n    while(up){\n        if(up%2==0) x=x*x,up/=2;\n        else ans=ans*x,up--;\n        if(isM) x%=MOD,ans%=MOD;\n    }\n    return ans;\n}\nll Inv(ll x){return QPow(x,MOD-2);}\n\nnamespace Div{\n    int p[30],c[30];\n    int pN;\n    void Div(int nb){\n        pN=0;\n        int t=nb;\n        for(int i=2;1LL*i*i&lt;=t;i++){\n            if(t%i==0){\n                p[++pN]=i,c[pN]=0;\n                while(t%i==0) t/=i,c[pN]++;\n            }\n        }if(t&gt;1) p[++pN]=t,c[pN]=1;\n    }\n}\n\nint N;\nll Ans;\nvoid DFS(int pos,ll d,ll phi){\n    using namespace Div;\n    if(pos==pN+1){\n        Ans=(Ans+QPow(N,d)*phi)%MOD;\n        return ;\n    }\n    ll tpow=1,tphi=QPow(p[pos],c[pos],0)-QPow(p[pos],c[pos]-1,0);\n    for(int i=0;i&lt;=c[pos];i++){\n        DFS(pos+1,d*tpow,phi*tphi);\n        tpow*=p[pos];\n        if(i==c[pos]-1) tphi=1;\n        else tphi/=p[pos];\n    }\n}\nvoid Solve(){\n    Div::Div(N);\n    Ans=0;DFS(1,1,1);\n    Ans=Ans*Inv(N)%MOD;\n    printf(\"%lld\\n\",Ans);\n}\nint main(){\n    int T=Rd();while(T--){\n        scanf(\"%d\",&N);\n        Solve();\n    }\n    return 0;\n}"
  },
  {
    "objectID": "posts/20200321-burnside/index.html#s-5",
    "href": "posts/20200321-burnside/index.html#s-5",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "5. 总结",
    "text": "5. 总结\n对于大多数题目，Burnside & Polya通常是套在最表面的那一层皮，难点一般在求 \\(|C(f)|\\) 或者 \\(f(\\gcd(n,i))\\) 的部分。"
  },
  {
    "objectID": "posts/20200321-burnside/index.html#s-6",
    "href": "posts/20200321-burnside/index.html#s-6",
    "title": "等价类计数：Burnside引理 & Polya定理",
    "section": "6. 参考及后记",
    "text": "6. 参考及后记\n\nzkx / keke_046 / 彳亍 学长的 《Polya计数.pptx》\n整个PPT思路非常清晰，可以看出keke学长对Polya有极其深入的理解。我学Burnside完全是照着这个PPT一点一点的看懂的。\n彳亍来讲课的那个暑假可以说是真正让我在OI数学这一块有很多新的收获，orz orz orz\n2020/10/23 update: keke学长的PPT应该参考了《组合数学》，回头对照一下。\n\n\n《算法导论》第三版 31章 数论算法\n初稿写成后，在学习数论时偶然翻到这一节有对群的一些讨论，发现自己之前的理解不够优秀，做了一些订正。\n之前把交换群认成群了然后瞎yy了一套理论xD\n\n\n后记\nBurnside & Polya 最开始是去年暑假keke学长为我们讲授。当时云里雾里，半懂不懂。12月的时候因为PKUWC/THUWC成为机房留守儿童（雾），就花了一两天把keke的PPT慢慢看懂了，做了最初的笔记，在接下来的几个月里修订完善。\n概念多，证明绕，很容易掉进思维的陷阱。要是能一步一步把证明过程捋清楚的话，对思维能力的提升还是很大的。\n任何推导的目的都是由已知得到未知。把性质与推论构成的“有向无环图”搞清楚了，才算真正弄清楚了来龙去脉。\nBurnside弱化版是整理笔记时灵光一闪生造出来的一个中间步骤，希望对大家的理解有所帮助。\n多次用到了“将等价类计数问题转换为有多少个元素与某个确定的元素等价，并利用等价传递性导出封闭性说明形成连通块”这一思想，很具有推广性；另外遇到一些不太好证的命题可以试试反证法。"
  },
  {
    "objectID": "posts/20230928-dft/index.html",
    "href": "posts/20230928-dft/index.html",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "",
    "text": "先有 FT，再有 DFT，才有 FFT\n时频转换是最初的用途\n发现单位根优秀性质，James Cooley, John Tukey 发明现代 FFT 加速 DFT，但此前相似的发现早已有之\n后来将 DFT 与卷积定理联系，FFT 才被用于计算多项式乘法\n复数运算精度误差推动了 NTT 的发展\n应用：任何需要频率和卷积的地方．频谱、滤波器、音乐、雷达、图像处理……\nOI/XCPC 中主要关心卷积\n\n\n\n\n\n初步要求\n\n知道 DFT、FFT 可用于快速计算多项式卷积\n掌握 FFT 加速 DFT 计算的原理和实现\n会应用结论改动 FFT 加速 NTT 计算\n见识一些卷积解决的基本问题，初步了解生成函数在组合计数中的应用\n题目可选择性完成，请多花时间消化原理和思想\n\n学有余力 / 集训后继续消化\n\n系统学习生成函数\n实现多项式全家桶\n对原理感兴趣的同学可对数学部分做进一步研究．本讲内容是线性代数、抽象代数、数论等多领域的综合应用．欢迎讨论．\n学习集合幂级数相关知识点（FMT，FWT，……），体会其思想与 FFT 的同与异\n学习 FFT 在信号、频谱等非算法竞赛向实际问题中的应用\n\nLearn for fun :)\n\n\n\n\n\n记 \\([n] = \\{ 0,1,\\dots,n-1 \\}\\)，此时可用 \\(k \\in [n]\\) 代替下标取值范围 \\(k=0,1,\\dots,n-1\\) 的记法．\n\n集合论中已定义 \\(n = \\{ 0,1,\\dots,n-1 \\}\\)，这里的中括号是为了强调其集合含义．\n\n使用 Iverson 括号约定：设 \\(P\\) 是一个命题，记 \\[\n[P] := \\begin{cases}\n        1 & \\text{$P$ is true} \\\\\n        0 & \\text{otherwise}\n        \\end{cases}\n\\]\n多项式的规模定义为多项式的次数加一．特别的，零多项式的规模为 \\(0\\)．\n\n以后会混用 \\(n-1\\) 次多项式和规模为 \\(n\\) 的多项式的说法．"
  },
  {
    "objectID": "posts/20230928-dft/index.html#fft",
    "href": "posts/20230928-dft/index.html#fft",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "2.1 FFT",
    "text": "2.1 FFT\n\n多项式卷积\n给定两个至多 \\(n-1\\) 次的多项式 \\[\nA(x) = \\sum_{k=0}^{n-1} a_k x^k,\\quad B(x) = \\sum_{k=0}^{n-1} b_k x^k\n\\] 如何快速计算两者的卷积，即它们相乘得到的多项式的系数？ \\[\n\\begin{aligned}\n        (A*B)(x) = A(x)B(x) &= \\sum_{i=0}^{n-1} a_i x^i \\sum_{j=0}^{n-1} b_j x^j \\\\\n        &= \\sum_{k=0}^{2n-2} x^k \\sum_{i+j=k} a_i b_j\n    \\end{aligned}\n\\] 上式给出了 \\(O(n^2)\\) 的朴素做法．\n\n\n系数 - 点值 - 系数\n\n代入任意 \\(x\\) 可得到多项式在 \\(x\\) 处的点值\n点值意义下的多项式乘法是 \\(O(n)\\) 的 \\[\n(A*B)(x) = A(x)B(x)\n\\]\n\\(n\\) 点确定一个至多 \\(n-1\\) 次的多项式1\n\n1 一种常见的证法是使用 Vandermonde 行列式证明矩阵可逆．后面会介绍多项式环风格的证明．若计算至多 \\(n-1\\) 次的多项式的某 \\(n\\) 个点值存在快速算法，而通过多项式的某 \\(n\\) 个点值确定原多项式系数亦存在快速算法，就有通过 \\(O(n)\\) 的点值乘法加速多项式乘法计算的可能．\n\n\n系数 - 点值 - 系数 - 快速转换？\n\n朴素计算任意指定 \\(n\\) 个位置点值需要 \\(O(n^2)\\)．\nLagrange[1] 插值给出了 \\(O(n^2)\\) 将任意位置 \\(n\\) 个点值还原为多项式系数的算法．\n能否选取 \\(n\\) 个特殊的点值使系数 - 点值、点值 - 系数的变换支持快速计算？\n\n\n\nDiscrete Fourier Transform\n离散傅里叶变换（Discrete Fourier Transform, DFT）接受一个至多 \\(n-1\\) 次的多项式的 \\(n\\) 个系数，将复数域上的 \\(n\\) 个 \\(n\\) 次单位根代入系数表达式以得到给定多项式的 \\(n\\) 个点值． \\[\na_0,a_1,\\dots,a_{n-1} \\longrightarrow A(1),A(\\omega_n),\\dots,A(\\omega_n^{n-1})\n\\]\n得益于单位根的特殊运算性质，二者均有被称为快速傅里叶变换（Fast Fourier Transform, FFT）的快速算法．\n\n\n复数域单位根\n复数域上的 \\(n\\) 个 \\(n\\) 次单位根2 \\[\n\\omega_n^k := e^{\\frac {2 \\pi k}{n} i} = \\cos \\frac{2 \\pi k}{n} + i \\sin \\frac{2 \\pi k}{n},\\quad k \\in [n]\n\\] 是复平面单位圆上的 \\(n\\) 等分点，易验证它们是复数域中唯一满足方程 \\(z^n = 1\\) 的解．\n2 有的文献定义 \\(\\omega_n := e^{-\\frac {2 \\pi}{n} i}\\)，或是因为信号处理领域常用 IDFT 将信号时域采样数据变为频域信息．事实上，DFT/IDFT 的说法也常有反转，但这只是形式问题．所有单位根模长均为 \\(1\\)．第 \\(k\\) 个单位根的辐角为 \\(\\frac {2 \\pi k}{n}\\)．复数乘法”模长相乘，辐角相加”的性质告诉我们 \\(\\omega_n^i \\omega_n^j = \\omega_n^{i+j}\\)．\n\n注记 (Euler’s formula for nerds). Euler 公式 \\(e^{it} = \\cos t + i \\sin t\\) 的一种证明可用指数函数的另一定义 \\(\\exp z = \\lim_{n \\to \\infty} (1+\\frac z n)^n\\) 分析复数处极坐标的极限 [2]．严格来讲，如果三角函数和指数函数都由级数定义 [3]，Euler 公式几乎是显然的．总之，这里仅将 Euler 公式作为一种紧凑的记号使用，细节不做要求．\n\n\n\n复数域单位根 - 三个重要性质3\n\n\n\n\n\n\n\n定理 1 (消去引理) \\[\n\\omega_{dn}^{dk} = \\omega_n^k,\\quad \\forall d \\in \\mathbb N_+\n\\]\n\n\n\n\n\n\n\n\n\n\n\n定理 2 (折半引理) \\[\n\\left\\{ \\omega_{2n}^{2k} : k \\in [2n] \\right\\} = \\left\\{ \\omega_n^k : k \\in [n] \\right\\}\n\\]\n\n\n\n\n消去 / 折半引理将在 FFT 的推导中使用．\n\n3 这三个引理是《算法导论》[4] 引入的．\n复数域单位根 - 三个重要性质\n\n\n\n\n\n\n\n定理 3 (求和引理) \\[\n\\frac 1 n \\sum_{k=0}^{n-1} \\omega_n^{ik} = [n \\mid i]\n\\]\n\n\n\n\n求和引理的证明使用了等比数列求和公式．将在 IDFT 的推导中用到．\n\n\nFast Fourier Transform\n考虑将至多 \\(2n-1\\) 次的待变换多项式 \\(A(x) = \\sum_{k=0}^{2n-1} a_k x^k\\) 奇偶分项两个至多 \\(n-1\\) 次的多项式 \\(A(x) = A_0 (x^2) + x A_1(x^2)\\)，其中 \\[\nA_0 (x) = \\sum_{k=0}^{n-1} a_{2k} x^k,\\quad\nA_1 (x) = \\sum_{k=0}^{n-1} a_{2k+1} x^k\n\\] 代入 \\(x = \\omega_{2n}^k,\\, k \\in [2n]\\)，用单位根消去或折半引理（\\(\\omega_{2n}^{2k} = \\omega_n^k\\)）得 \\[\nA(\\omega_{2n}^k) = A_0 (\\omega_{n}^k) + \\omega_{2n}^k A_1 (\\omega_{n}^k)\n\\] 再用 \\(\\omega_{2n}^{n} = -1\\) 得 \\[\n\\begin{aligned}\nA(\\omega_{2n}^k) &= A_0 (\\omega_n^k) + \\omega_{2n}^k A_1 (\\omega_n^k) \\\\\nA(\\omega_{2n}^{n+k}) &= A_0 (\\omega_n^k) - \\omega_{2n}^k A_1(\\omega_n^k)\n\\end{aligned}\n,\\quad k \\in [n]\n\\] 原多项式 \\(A(x)\\) 规模为 \\(2n\\) 的 DFT 转化为规模为 \\(n\\) 的 \\(A_0(x)\\) 和 \\(A_1(x)\\) 的 DFT．递归计算就可得到 \\(O(n \\log n)\\) 的算法．\n\n\nDFT 的矩阵表示\n记 \\[\\begin{gathered}\n\\boldsymbol a =  \\begin{pmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{n-1}\\end{pmatrix},\\quad\nF = \\left( \\omega_n^{ij} \\right)_{(i,j) \\in n \\times n} = \\begin{pmatrix}\n1 & 1 & \\dots & 1 \\\\\n1 & \\omega_n & \\dots & \\omega_n^{n-1} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & \\omega_n^{n-1} & \\dots & \\omega_n^{(n-1)(n-1)}\n\\end{pmatrix}\n\\end{gathered}\n\\] 则 DFT 的变换结果（给定系数 \\(a_0,a_1,\\dots,a_{n-1}\\) 的多项式在 \\(n\\) 个 \\(n\\) 次单位根处的点值）可表示为 \\[\n\\hat{\\boldsymbol a} = \\begin{pmatrix}A(1) \\\\ A(\\omega_n) \\\\ \\vdots \\\\ A(\\omega_n^{n-1})\\end{pmatrix} = F \\boldsymbol a\n\\]\n\n\nIDFT\n由单位根的消去引理可证，DFT 矩阵 \\(F\\) 的逆矩阵为4 \\[\nF^{-1} = \\frac 1 n \\left( \\omega_n^{-ij} \\right)_{(i,j) \\in n \\times n} = \\frac 1 n \\begin{pmatrix}\n1 & 1 & \\dots & 1 \\\\\n1 & \\omega_n^{-1} & \\dots & \\omega_n^{-(n-1)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & \\omega_n^{-(n-1)} & \\dots & \\omega_n^{-(n-1)(n-1)}\n\\end{pmatrix}\n\\] 于是 IDFT 的过程可表示为 \\[\n\\boldsymbol a  = F^{-1} \\hat{\\boldsymbol a}\n\\]\n4 这也表明适当归一化后的 DFT 矩阵是一个酉矩阵．故快速计算 IDFT 的方法与 FFT 几乎一致，只需将计算 DFT 时使用的本原单位根 \\(\\omega_n\\) 替换为 \\(\\omega_n^{-1}\\) 并对最终结果除以 \\(n\\) 即可．\n\n\n梳理\n\n怎么计算卷积？\n\n把至多 \\(n-1\\) 次的多项式 \\(A(x)\\) 和至多 \\(m-1\\) 次的多项式 \\(B(x)\\) 写成至多 \\(n+m-2\\) 次的多项式（高位补 \\(0\\)）．为计算 FFT 方便，还要继续补 \\(0\\) 至一个大于其次数的 \\(2\\) 的幂．\n对 \\(A(x)\\) 和 \\(B(x)\\) 多点求值．\n把两个多项式的点值逐点相乘．\n多点插值还原 \\((A*B)(x)\\) 的系数．\n\n怎么快速求值？\n\n选点选单位根就是 DFT．\n消去引理和折半引理使我们可以用 FFT 算法递归地计算 DFT．\n推导已经给出了递归的写法，之后还会介绍常数更优的迭代实现．\n\n怎么快速插值？\n\n求和引理给出了 DFT 矩阵的逆矩阵．\n计算方法很相似，最后逐项除掉一个规模．\n\n\n\n\nFFT 递归实现 - DFT 部分\n方便起见，我们只处理 \\(n\\) 为 \\(2\\) 的幂的情形．以下 C 风格的代码实现了递归的 DFT 和 IDFT．\n#include&lt;bits/stdc++.h&gt;\n#include&lt;complex&gt;\nusing namespace std;\ntypedef long long ll; typedef complex&lt;double&gt; CP;\nconst ll MXN=4E6+5; const double PI=3.14159265358979323846l;\nCP tmp[MXN];\nvoid _DFT(CP A[],ll n,ll typ){\n    n/=2; if(n==0) return;\n    for(ll k=0;k&lt;n;k++) tmp[k]=A[2*k],tmp[n+k]=A[2*k+1];\n    for(ll k=0;k&lt;2*n;k++) A[k]=tmp[k];\n    _DFT(A,n,typ); _DFT(A+n,n,typ);\n    CP w(cos(2*PI/(2*n)),typ*sin(2*PI/(2*n))), wk=1;\n    for(ll k=0;k&lt;n;k++){\n        tmp[  k]=A[k]+wk*A[n+k];\n        tmp[n+k]=A[k]-wk*A[n+k];\n        wk*=w;\n    } for(ll k=0;k&lt;2*n;k++) A[k]=tmp[k];\n} void DFT(CP A[],ll n,ll typ){\n    _DFT(A,n,typ); if(typ==-1) for(ll i=0;i&lt;n;i++) A[i]*=1.0l/n;\n}\n\n\nFFT 递归实现 - 卷积部分\n// alternatively, use std::__lg() in GCC\nll log2ceil(ll n){ll cnt=0; for(ll t=1;t&lt;n;t&lt;&lt;=1) cnt++; return cnt;} \nCP A[MXN],B[MXN],C[MXN]; ll outC[MXN];\nll* conv(ll inA[],ll aN,ll inB[],ll bN){\n    ll n=1LL&lt;&lt;log2ceil(aN+bN-1);\n    for(ll i=0;i&lt;aN;i++) A[i]=inA[i];\n    for(ll i=0;i&lt;bN;i++) B[i]=inB[i];\n    DFT(A,n,1); DFT(B,n,1);\n    for(ll i=0;i&lt;n;i++) C[i]=A[i]*B[i];\n    DFT(C,n,-1); for(ll i=0;i&lt;n;i++) outC[i]=round(C[i].real());\n    return outC;\n}\nDrawbacks?\n\n递归实现慢\n临时数组丑\n封装性为零\n\n\n\nFFT 迭代\n迭代地实现 FFT 不仅在常数上更加优秀，亦更便于使用 C++ 的容器进行封装．这并不困难，只需自底向上模拟 FFT 递归过程即可．\n唯一的问题——最底层的顺序？\n来观察一轮 \\(2^3\\)-FFT 自顶向下的置换过程 \\[\\begin{matrix}\n2^3 & 0/000 & 1/001 & 2/010 & 3/011 & 4/100 & 5/101 & 6/110 & 7/111 \\\\\n2^2 & 0/000 & 2/010 & 4/100 & 6/110 & 1/001 & 3/011 & 5/101 & 7/111 \\\\\n2^1 & 0/000 & 4/100 & 2/010 & 6/110 & 1/001 & 5/101 & 3/011 & 7/111 \\\\\n2^0 & 0/000 & 4/100 & 2/010 & 6/110 & 1/001 & 5/101 & 3/011 & 7/111\n\\end{matrix}\n\\]\n你发现了什么？\n\n\n蝶形运算\n在计算点值前，\\(2^n\\)-FFT 事实上完成了一次 \\(n\\)-位逆序置换．分解来看，规模为 \\(2^k\\) 的层的置换完成了对 \\(2^{n-k}\\) 对应二进制位的分类．\n我们有 \\(O(n)\\) 的递推方法获得这一置换．\nvoid spawnrev(ll n){\n    rev[0]=0;\n    for(ll i=1;i&lt;(1&lt;&lt;n);i++)\n        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)+((i&1)&lt;&lt;(n-1));\n}\n\n\nFFT 迭代实现\nvoid DFT(CP A[],ll n,ll typ){ // rev[] should be spawned in advance\n    for(ll i=0;i&lt;n;i++) if(i&lt;rev[i]) swap(A[i],A[rev[i]]); // a one-to-one permutation\n    for(ll hf=1;hf&lt;n;hf*=2){\n        CP w(cos(2*PI/(2*n)),typ*sin(2*PI/(2*n))), wk=1;\n        for(ll i=0;i&lt;n;i+=hf*2){\n            CP wk=1;\n            for(ll k=0;k&lt;hf;k++){\n                CP x=A[i+k],y=wk*A[i+hf+k];\n                A[i+k]=x+y; A[i+hf+k]=x-y;\n                wk=wk*w;\n            }\n        }\n    }\n    if(typ==-1) for(ll i=0;i&lt;n;i++) A[i]*=1.0l/n;\n}\n请自行实现更易用的容器封装版本．"
  },
  {
    "objectID": "posts/20230928-dft/index.html#ntt",
    "href": "posts/20230928-dft/index.html#ntt",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "2.2 NTT",
    "text": "2.2 NTT\n\nNTT 速成5\nFFT 的缺点？浮点数带来的大常数与精度问题．\n\\(998244353=2^{23} \\times 7 \\times 17 + 1\\)，同时是一个质数．\n我们指出，在系数和点值模 \\(p=998244353\\) 的意义下，当规模 \\(n \\leq p\\) 时6，至多 \\(n-1\\) 次的多项式仍可由其 \\(n\\) 个点值唯一确定，故仍可使用系数-点值-系数的方法求得多项式卷积．\n6 否则只有 \\(p\\) 个不同元素的 \\(\\mathbb Z_p\\) 中根本取不到 \\(n\\) 个不同位置的点值．后面会深入讨论．我们指出，对于满足 \\(n \\mid p-1\\) 的 \\(n\\)，依 \\(\\omega_n := 3^{\\frac{p-1}{n}}\\) 定义的 \\(\\omega_n\\) 在模 \\(p\\) 意义下与复数域中定义的 \\(\\omega_n\\) 发挥相同的作用，仍可进行规模至多为 \\(2^{23}\\) 的 FFT 作为模 \\(p=998244353\\) 意义下 NTT 的快速算法．\n只需修改单位根定义，把复数运算改为整数取模，就得到了能算 NTT 的 FFT 的实现．\nconst PR=3,MOD=998244353;\nll w=qpow(PR,(MOD-1)/(hf*2)); if(typ==-1) w=inv(w);\n\n5 NTT 原理需较多笔墨，稍后介绍．\nFFT/NTT in a nutshell - 小结：概念区分\n\n关于 DFT\n\nDiscrete Fourier Transform, DFT, 离散傅里叶变换\nFast Fourier Transform, FFT, 快速傅里叶变换\nFFT 是计算 DFT 的快速算法\n\n关于 NTT\n\nNumber Theoretic Transform, NTT, 数论变换\nFFT 在复数域上的多项式环 \\(\\mathbb{C}[x]\\) 中进行，而 NTT 在模 \\(p\\) 剩余类域 \\(\\mathbb{Z}_p[x]\\) 上进行\n快速计算 DFT / IDFT, NTT 都用 FFT，故一般不使用”FNTT”的说法"
  },
  {
    "objectID": "posts/20230928-dft/index.html#基本应用",
    "href": "posts/20230928-dft/index.html#基本应用",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "3.1 基本应用",
    "text": "3.1 基本应用\n\n基本应用\n\n大整数乘法\n\n十进制数可拆解为多项式表示，计算卷积后处理进位即可．由于数字最大只是 \\(9\\)，合理数据范围下卷起来不会爆模数，直接用 NTT 实现即可．\n\n背包计数\n\n两个背包的合并就是多项式卷积．\n\n滤波器\n\n反转多项式的系数数组再做卷积，可以快速得到两个多项式滑动窗口式的内积．\n\n位运算\n\n有些位运算可以写成卷积的形式．模 \\(2\\) 意义下”异或”是加法，“与”是乘法，“或”可以通过取反转化为”与”．\n\n字符串\n\n通过巧妙设定字符串距离函数，FFT 可解决更广泛的字符串匹配问题．\n\n值域次数化\n\n当值域较小时，将待计算的值放在多项式次数上统计贡献次数，可以绕开某些极难求解的数值问题．例如 Vandermonde 行列式的快速计算．\n\n\n\n\n基本应用 - 分治 FFT\n对多个长度相同的多项式的卷积，分治地卷起来可降低时间复杂度．长度不一时，挑小的先卷也可减小常数（用堆维护）．\n另有一种 CDQ 风格的分治 FFT．CDQ 长于处理带偏序的二元点对贡献，在处理形如 \\(c_k = \\sum_{i&gt;j} [i+j=k] a_i b_j\\) 的带偏序卷积时可以应用．\n当卷积的前后项存在依赖关系时，也可使用此法保证处理顺序恰当．然而此类依赖问题往往也可通过解生成函数方程的方法求得封闭形式．\n时间复杂度均为 \\[\nT(n) = 2 T \\left( \\frac n 2 \\right) + O(n \\log n) = O(n \\log^2 n)\n\\]"
  },
  {
    "objectID": "posts/20230928-dft/index.html#生成函数初步",
    "href": "posts/20230928-dft/index.html#生成函数初步",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "3.2 生成函数初步",
    "text": "3.2 生成函数初步\n\n生成函数初步 - 导言\n生成函数是一种对数列的操作技巧．通过将数列表示为多项式或形式幂级数，数列间复杂的和式操作可用简单函数的乘法、复合等运算进行表示，从而大大降低了数列变换技巧的使用门槛．\n生成函数在组合数学中应用广泛，且生成函数的部分操作在组合意义下也有较为直观的理解．本节将带大家初窥其中的奥妙．限于篇幅和主讲人能力，我们仅以题带点地讲解，期冀为大家建立构造生成函数的直觉．请感兴趣的同学下来做进一步研究．\n熟悉 Taylor 展开的同学或能较快上手此部分内容．\n\n\nOrdinary Generating Function\n序列 \\(a_n\\) 的普通生成函数（Ordinary Generating Function, OGF）定义为其对应的多项式（形式幂级数）\\(A(x) = \\sum_{n=0}^{+\\infty} a_n x^n\\)．这样书写的目的是为了便于进行数列间的卷积操作．特别的，Taylor 展开（或广义二项式定理）风格的 \\(\\frac 1 {1-x} = 1 + x + x^2 + \\dots\\) 也是常用技巧之一7．\n7 多项式求逆等多项式进阶操作，我们后续讲解．\n\n\n\n\n\n\n习题 1 写出下列数列的 OGF．下标从 \\(0\\) 开始．\n\n\\(1,0,0,0\\dots\\)\n\\(1,1,1,1,\\dots\\)\n\\(1,0,1,0,\\dots\\)\n\\(1,-1,1,-1,\\dots\\)\n\\(1,2,3,4,\\dots\\)\n\\(1,2,4,8,\\dots\\)\n\n\n\n\n\n\n\nOGF 组合意义\nOGF 相乘，是背包，是卷积，是两块无标号组合对象的有序拼接．\n\n\n\n\n\n\n\n习题 2 写出下列计数问题的 OGF，均以 \\(n\\) 作为数列的下标．\n\n在 \\(m\\) 个物品中选出 \\(n\\) 个的方案数．\n容量为 \\(n\\) 的背包装下体积分别为 \\(a_i\\) 的 \\(m\\) 个物品的方案数．\n同上，但每个物品有无限个．\n\\(n\\) 个无标号球放入 \\(r\\) 个有标号盒的方案数，要求盒非空．\n同上，但盒可空．\n将整数 \\(n\\) 分拆为若干正整数之和的方案数．\n\n\n\n\n\n\n\nExponential Generating Function\n序列 \\(a_n\\) 的指数生成函数（Exponential Generating Function, EGF）定义为 \\[\nA(x) = \\sum_{n=0}^{+\\infty} a_n \\frac {x^n}{n!}\n\\]\n\n\n\n\n\n\n\n习题 3 写出下列序列的 EGF，下标从 \\(0\\) 开始．\n\n\\(1,0,0,0,\\dots\\)\n\\(1,1,1,1,\\dots\\)\n\\(1,2,4,8,\\dots\\)\n\\(0,1,0,-1,0,1,0,-1,\\dots\\)\n\\(1,0,-1,0,1,0,-1,0,\\dots\\)\n\\(0,1,-1,2!,-3!,4!,\\dots\\)\n\n\n\n\n\n\n\nEGF 组合意义\n观察两个 EGF 的乘积 \\[\n\\begin{aligned}\nA(x) B(x) &= \\sum_{i=0}^{+\\infty} a_i \\frac{x^i}{i!} \\sum_{j=0}^{+\\infty} b_j \\frac{x^j}{j!} \\\\\n&= \\sum_{i=0}^{+\\infty} \\sum_{j=0}^{+\\infty} a_i b_j \\frac{x^{i+j}}{i! j!} \\\\\n&= \\sum_{n=0}^{+\\infty} \\sum_{i=0}^n a_i b_{n-i} \\frac{x^n}{i! (n-i)!} \\\\\n&= \\sum_{n=0}^{+\\infty} \\sum_{i=0}^n a_i b_{n-i} \\binom n i \\frac{x^n}{n!}\n\\end{aligned}\n\\] EGF 的乘积，相当于两块有标号组合对象的有序拼接．\n\n\nEGF 组合意义\n\\[\nA(x) B(x) = \\sum_{i=0}^{+\\infty} a_i \\frac{x^i}{i!} \\sum_{j=0}^{+\\infty} b_j \\frac{x^j}{j!}\n= \\sum_{n=0}^{+\\infty} \\sum_{i=0}^n a_i b_{n-i} \\binom n i \\frac{x^n}{n!}\\]\n\n\n\n\n\n\n\n习题 4 写出下列计数问题的 EGF，均以 \\(n\\) 作为数列的下标．\n\n长度为 \\(n\\) 的排列的构型数．\n长度为 \\(n\\) 的圆排列的构型数．\n将 \\(n\\) 个有标号球放入 \\(r\\) 个有标号盒的方案数，要求盒非空．\n将 \\(n\\) 个有标号球放入 \\(r\\) 个无标号盒的方案数，要求盒非空．\n将 \\(n\\) 元集合划分为 \\(r\\) 个等价类的方案数．\n划分 \\(n\\) 元集合的方案数．"
  },
  {
    "objectID": "posts/20230928-dft/index.html#ntt-原理",
    "href": "posts/20230928-dft/index.html#ntt-原理",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "4.1 NTT 原理",
    "text": "4.1 NTT 原理\n\nNTT 原理 - 导言\n本节介绍 NTT 的原理．\nFFT 加速卷积算法的核心，一是多项式的求值插值原理，二是单位根带来的分治快速算法．我们将在本节中证明，模 \\(p\\) 剩余类域 \\(\\mathbb Z_p\\) 中，只要 \\(n \\leq p\\)，仍可通过 \\(n\\) 个点值唯一确定至多 \\(n-1\\) 次的 \\(\\mathbb Z_p\\) 上的多项式，这保证了系数-点值-系数方法的正确性；此外，基于原根构造出的 \\(\\mathbb Z_p\\) 上的本原单位根，使得使用与 FFT 相同的分治算法加速 NTT 的计算成为可能．\nNTT 原理涉及原根等数论内容．本讲的目标是建立 DFT 变换和 FFT 算法的通用数学框架，而非具体研究其某一特例．故我们只讲解 NTT 所需的基础数论知识，无关的细节则略过处理．对数论感兴趣的同学可前往 OI Wiki 学习．\n\n\n模 \\(p\\) 剩余类域 \\(\\mathbb Z_p\\)\n模 \\(p\\) 剩余类域 \\(\\mathbb Z_p\\) 是刻画取模运算下整数加法、乘法运算规律的代数结构，其良定义性由 \\[\n\\begin{cases}\n    a_1 \\equiv a_2 \\pmod{p} \\\\\n    b_1 \\equiv b_2 \\pmod{p}\n\\end{cases}\n  \\implies\n\\begin{cases}\n    a_1 + b_1 \\equiv a_2 + b_2 \\pmod{p} \\\\\n    a_1 b_1 \\equiv a_2 b_2 \\pmod{p}\n\\end{cases}\n\\] 保证．\n模 \\(p\\) 剩余类域的最大特点是其中每个元素都存在（唯一）逆元．这一点是数论中 Bézout 定理的直接应用．\n模 \\(p\\) 剩余类域的另一优良性质是其满足消去律，即 \\[\nab \\equiv 0 \\pmod p \\implies a \\equiv 0 \\lor b \\equiv 0 \\pmod p\n\\] 而模一般的数 \\(m\\) 形成的代数结构则不满足此性质．\n\n\n\\(\\mathbb Z_p[x]\\) 上的多点插值\n之后记系数均在 \\(\\mathbb Z_p\\) 上的多项式组成的集合为 \\(\\mathbb Z_p[x]\\)．\n\n\n\n\n\n\n\n引理 1 (\\(\\mathbb Z_p \\lbrack x \\rbrack\\) 上的多项式余式定理) 设 \\(A(x) \\in \\mathbb Z_p[x]\\)，用 \\(\\mathbb Z_p[x]\\) 中的一次多项式 \\((x-a)\\) 对 \\(A(x)\\) 进行带余除法，得到的余式为至多零次的多项式 \\(A(a)\\)．\n\n\n\n\n\n\n\\(\\mathbb Z_p[x]\\) 上的多点插值\n\n\n\n\n\n\n\n定理 4 (Lagrange 定理) 设 \\(p\\) 是一个质数，设 \\(A(x) \\in \\mathbb Z_p[x]\\)．同余方程 \\(A(x) \\equiv 0 \\pmod{p}\\) 只有至多 \\(\\deg A(x)\\) 个模 \\(p\\) 意义下不同的整数解，除非这多项式的系数全为零．\n\n\n\n\n\n\n\n\n\n\n\n推论 1 设 \\(A(x),B(x) \\in \\mathbb Z_p[x]\\) 是至多 \\(n-1\\) 次的两个多项式．若同余方程 \\(A(x) \\equiv B(x) \\pmod{p}\\) 有 \\(n\\) 个不同的模 \\(p\\) 意义下的整数解，则两多项式一定相等．\n\n\n\n\n推论告诉我们，欲确定 \\(\\mathbb Z_p\\) 上的一个至多 \\(n-1\\) 次的多项式，只需找到其 \\(n\\) 个模 \\(p\\) 意义下的点值即可．因此，使用系数 - 点值 - 系数方法加速 \\(\\mathbb Z_p[x]\\) 上的卷积是可行的．\n\n\n本原单位根\n回顾 DFT 中复数域 \\(\\mathbb C\\) 上单位根的定义 \\[\n\\omega_n^k := e^{\\frac {2 \\pi k}{n} i} = \\cos \\frac{2 \\pi k}{n} + i \\sin \\frac{2 \\pi k}{n},\\quad k \\in [n]\n\\] 其中 \\(\\omega_n\\) 是最重要的单位根，因为它生成了所有其它的单位根．\n事实上所有的 \\(\\omega_n^{k} : \\gcd(n,k)=1\\) 也都是重要的，它们的 \\(0\\) 至 \\(n-1\\) 次方也能生成所有的单位根．这也是数论中 Bézout 定理的直接应用．\n我们把这一类重要的单位根称为本原单位根．抽象的来说，\\(n\\) 次本原单位根 \\(\\omega_n\\) 可定义如下 \\[\n\\omega_n^n = 1;\\quad \\omega_n^k \\neq 1,\\quad k=1,2,\\dots,n-1\n\\]\n\n\n\\(\\mathbb Z_m\\) 上的阶\n如何定义 \\(\\mathbb Z_m\\) 上的“本原单位根”呢？\n称在模 \\(m\\) 意义下使得 \\(a^n=1\\) 的最小正整数 \\(n\\) 为 \\(a\\) 的阶，记为 \\(\\operatorname{ord}_m(a)\\)．在不至混淆的情况下，也简记为 \\(\\operatorname{ord}(a)\\)．\n\n阶最高有多高？\n\n\n\n\n\n\n\n\n定理 5 (Fermat 小定理) 若 \\(p\\) 是质数，\\(a\\) 是非零数，则 \\(a^{p-1} \\equiv 1 \\pmod{p}\\)．\n\n\n\n\n\n\n\n\n\n\n\n定理 6 (Euler 定理) 若 \\(\\gcd(a,m)=1\\)，则 \\(a^{\\varphi(m)} \\equiv 1 \\pmod{m}\\)，其中 \\(\\varphi(m)\\) 是数论中的 Euler 函数8．\n\n\n\n\n8 对质数 \\(p\\)，\\(\\varphi(p)=p-1\\)．故 Euler 定理是 Fermat 小定理的一个推广．\n\nEuler 定理的证明 - 简化剩余系\n\\(\\mathbb Z_m^R := \\{a \\in \\mathbb Z_m: \\gcd(a,m)=1 \\}\\) 被称为 \\(\\mathbb Z_m\\) 的简化剩余系．简化剩余系对模 \\(m\\) 乘法封闭．简化剩余系中的每个元素都具有模 \\(m\\) 意义下的唯一逆元，且其也在 \\(\\mathbb Z_m^R\\) 中．此二性质易由 \\(\\gcd\\) 的线性组合意义证明．\n简化剩余系的大小即 \\(\\varphi(m)\\)．这是 Euler 函数的其中一种定义．\n设 \\(a \\in \\mathbb Z_m^R\\)，其在 \\(\\mathbb Z_m\\) 中存在逆元，故我们有 \\[\n\\forall x,y \\in \\mathbb Z_m,\\quad x \\equiv y \\pmod{m} \\iff ax \\equiv ay \\pmod{m}\n\\] 当限定 \\(x,y \\in \\mathbb Z_m^R\\) 时，结合 \\(\\mathbb Z_m^R\\) 上述两个性质，就有 \\[\n\\mathbb Z_m^R = a \\mathbb Z_m^R = \\{ ax \\bmod m : x \\in \\mathbb Z_m^R \\}\n\\] 故 \\[\na^{\\varphi(m)} \\prod_{x \\in \\mathbb Z_m^R} x \\equiv \\prod_{x \\in \\mathbb Z_m^R} ax \\equiv \\prod_{x \\in a \\mathbb Z_m^R} x \\equiv \\prod_{x \\in \\mathbb Z_m^R} x \\implies a^{\\varphi(m)} \\equiv 1 \\pmod{m}\n\\]\n\n\n\\(a^n\\) 的取值 - \\(a\\), \\(m\\) 互质时\n补充讨论 \\(a^n \\bmod m,\\, n \\in \\mathbb Z_{+}\\) 可取得哪些 \\(\\mathbb Z_m\\) 中的元素．\n当 \\(\\gcd(a,m)=1\\) 时，用 \\(\\gcd\\) 的线性组合含义，有 \\[\n\\begin{aligned}\n\\gcd(a,m)=1 &\\implies \\exists x_0,\\quad a x_0 = 1 \\pmod{m} \\\\\n&\\implies \\exists x_0,\\quad a^n x_0^n = 1 \\pmod{m} \\\\\n&\\implies \\gcd(a^n,m)=1\n\\end{aligned}\n\\] 故此时 \\(a^n \\bmod m\\) 只可能取得 \\(\\mathbb Z_m\\) 的简化剩余系 \\(\\mathbb Z_m^R\\) 中的元素．\n\n\n\\(a^n\\) 的取值 - 一般情况9\n当 \\(d_1 = \\gcd(a,m) \\neq 1\\) 时，设 \\(a = d_1 a_1,\\, m = d_1 m_1\\)，当 \\(n \\geq 1\\) 时， \\[\\begin{aligned}\na^n \\bmod m &= d_1 a_1 a^{n-1} \\bmod d_1 m_1 = d_1 \\left( a_1 a^{n-1} \\bmod m_1 \\right)\n\\end{aligned}\\] 此时 \\(\\gcd(a_1,m_1)=1\\)，根据线性同余方程理论，括号内表达式的取值集合仅与 \\(a^{n-1} \\bmod m_1\\) 有关．此时若 \\(d_2 = \\gcd(a,m_1)\\) 仍不等于 \\(1\\)，则令 \\(a_1 = d_2 a_2,\\, m_1 = d_2 m_2\\)．类似地继续化归，最终有 \\(d_{k+1} = \\gcd(a,m_k) = 1\\)， \\[\na^n \\bmod m = d_1 \\left( a_1 d_2 \\left( \\dots a_{k-1} d_k (a_k a^{n-k} \\bmod m_k) \\dots \\right) \\bmod m_1 \\right)\n\\] 故当 \\(n \\geq k\\) 时，\\(a^n \\bmod m\\) 的取值集合为 \\[\n\\left\\{ d_1 d_2 \\dots d_k (a^t \\bmod m_k) : t \\in \\mathbb Z_+ \\right\\} \\subset d_1 d_2 \\dots d_k \\mathbb Z_{m_k}^R\n\\] 事实上，\\(\\prod_{i=1}^k d_i\\) 恰为 \\(\\gcd(a,m)\\) 的各素因子在 \\(m\\) 中全部成分的乘积．\n\n9 ExBSGS 求解离散对数 [5] 的推导与此相似．10 部分证明稍复杂，我们略过处理．感兴趣的同学请参考 OI Wiki [6]．\n原根10\n需要注意的是，Euler 定理只给出了 \\(\\mathbb Z_m\\) 上元素阶的一个上界．换言之，其说明 \\[\n\\forall a \\in \\mathbb Z_m^R \\implies \\operatorname{ord}_m(a) \\mid \\varphi(m)\n\\] 而对于那些使得 \\(\\gcd(a,m) \\neq 1\\) 的元素 \\(a\\)，用 \\(\\gcd\\) 的线性组合性质容易证明其永远不可能通过自乘变为 \\(1\\)．我们设定这类元素的阶为 \\(0\\)．\n称 \\(\\mathbb Z_m\\) 上那些确能达到阶数上界 \\(\\varphi(m)\\) 的元素是 \\(\\mathbb Z_m\\) 上的原根，用符号 \\(g\\) 表示．\n\n\n\n\n\n\n\n定理 7 (原根存在定理) \\(\\mathbb Z_m\\) 上存在原根，当且仅当 \\(m=2,4,p^{\\alpha},2p^{\\alpha}\\) ，其中 \\(p\\) 是一奇质数．\n\n\n\n\n\n\n求阶和原根\n\n求阶，用定理 \\(\\operatorname{ord}_m(a) \\mid \\varphi(m)\\)，求因子 + 快速幂即可 \\(O(\\sqrt m \\log m)\\)．\n找原根，从小到大用上述求阶方法暴力即可．最小原根一般不会太大．\n更快的方法请参考洛谷求原根模板题题解．\n\n下面再介绍原根的两个定理．\n\n\n\n\n\n\n\n定理 8 (原根判定定理) 若 \\(\\gcd(g,m)=1\\)，则 \\(g\\) 是 \\(\\mathbb Z_m\\) 上原根的充要条件是，对 \\(\\varphi(m)\\) 的每个素因数 \\(p\\)，都有 \\(g^{\\frac{\\varphi(m)}{p}}\\not\\equiv 1\\pmod m\\).\n\n\n\n\n必要性显然．充分性，反证出所有 \\(\\varphi(m)\\) 的非平凡因子均不是 \\(g\\) 的阶即可．\n\n\n\n\n\n\n\n定理 9 (原根个数定理) 若 \\(\\mathbb Z_m\\) 上存在原根，则它原根的个数为 \\(\\varphi(\\varphi(m))\\).\n\n\n\n\n\n\n\\(\\mathbb Z_m\\) 上的本原单位根构造\n设 \\(a\\) 是 \\(\\mathbb Z_m\\) 上一元素，当 \\(n \\mid \\operatorname{ord}_m(a)\\)，令 \\(\\omega_n = a^{\\frac{\\operatorname{ord}_m(a)}{n}}\\)，容易发现 \\(\\omega_n\\) 就是 \\(\\mathbb Z_m\\) 上的 \\(n\\) 次本原单位根．\n使用数论中 Bézout 定理，\\(\\omega_n^k\\) 是 \\(\\mathbb Z_m\\) 上的 \\(\\frac n {\\gcd(n,k)}\\) 次本原单位根．这是 \\(\\mathbb Z_m\\) 上本原单位根的消去引理．\n遗憾的是，一般的 \\(\\mathbb Z_m\\) 中，本原单位根不一定满足求和引理11 \\(\\frac 1 n \\sum_{k=0}^{n-1} \\omega_{n}^{ik} = [n \\mid i]\\)．这是因为，求和引理的证明中使用了等比数列求和和消去律，但一般的 \\(\\mathbb Z_m\\) 中消去律并不成立．\n11 这是后文所述定理“整环上的本原单位根也是主要单位根”在一般环上的一个反例．\n\n\\(\\mathbb Z_m\\) 上的 NTT - \\(m\\) 是质数\n求和引理是保障 NTT 逆变换对应矩阵确为 \\(n^{-1} \\begin{pmatrix} \\omega_n^{-ij} \\end{pmatrix}_{(i,j)\\in n \\times n}\\) 的关键性质．如果我们还想保留这一点，就必须要求 \\(m\\) 是质数．\n为保证 \\(n\\) 在 \\(\\mathbb Z_m\\) 中存在逆元，必须要求 \\(\\gcd(n,m)=1\\)．已经要求 \\(m\\) 是质数，故无需做出额外要求．\n综上，逆变换矩阵确为 \\(n^{-1} \\begin{pmatrix} \\omega_n^{-ij} \\end{pmatrix}_{(i,j)\\in n \\times n}\\) 的 \\(n\\) 点 NTT 要求 \\(m\\) 是质数，且 \\(n \\mid \\operatorname{ord}_m(a)\\)．已经要求 \\(m\\) 是质数，故 \\(\\mathbb Z_m\\) 中必存在原根，不妨直接取 \\(\\mathbb Z_m\\) 的一个原根 \\(g\\) 构造 \\(n\\) 次本原单位根 \\(\\omega_n = g^{\\frac{\\varphi(m)}{n}} = g^{\\frac{m-1}{n}}\\)，这样的构造支持至多 \\(m-1\\) 次单位根的存在，显然是最优的选择．\n\n\n\\(\\mathbb Z_m\\) 上的 FFT 与卷积加速 - 998244353\n为满足 FFT 对 \\(2^m\\) 次本原单位根的需求，只需选择 \\(p = k 2^m + 1\\) 型的奇质数 \\(p\\)，就可以在 \\(\\mathbb Z_p\\) 上支持规模至多为 \\(2^m\\) 的 NTT/FFT 及其逆变换运行．\n\\(998244353=2^{23} \\times 7 \\times 17 + 1\\)，同时是一个质数，在 int 型中的单次加减操作不会溢出，是 OI/XCPC 计数题中不可多得的优秀模数12．\n12 网传此模数由 UOJ 站长 vfleaking 提出并推广．在所有需要取模的题目中使用该模数，可使选手无法通过模数判断题目的做法．结合前述关于 \\(\\mathbb Z_p[x]\\) 上多点插值的讨论，通过 NTT/FFT 加速卷积运算的正确性得到完整证明．\n\n\n\\(\\mathbb Z_m\\) 上的 NTT - 对一般的 \\(m\\)\n当 \\(m\\) 不一定是质数时，NTT 逆变换不能表示为 \\(n^{-1} \\begin{pmatrix} \\omega_n^{-ij} \\end{pmatrix}_{(i,j)\\in n \\times n}\\) 的形式．但这并不代表 NTT 不可逆．因此，尽管不再实用，一般 \\(\\mathbb Z_m\\) 上的 NTT 变换仍有讨论价值，即研究 \\(\\begin{pmatrix} \\omega_n^{ij} \\end{pmatrix}_{(i,j)\\in n \\times n}\\) 的可逆性．\n我们找到一篇有关该问题的参考文献[7, section 3 and appendix B]，但尚不确定其证明的正确性．友情提示读者：\\(\\mathbb Z_m\\) 不是域，甚至不是整环，故线性空间中矩阵的性质不能直接应用于 \\(\\mathbb Z_m\\) 上的矩阵，讨论可逆性时还需小心谨慎．\n\n\n从分析到代数\n后续数学内容导读 NTT 原理虽已非常”数学”，但也只是 DFT 在有限域上的一个实例．本节往后，我们要尝试为多项式系数位于复数域 \\(\\mathbb C\\) 上的 DFT、位于模 \\(p\\) 剩余类域 \\(\\mathbb Z_p\\) 上的 NTT 及它们的快速算法 FFT 建立一个统一的数学框架．这需要我们剖析求值插值的基本原理，提炼出 FFT 算法成立的根本要求．\n后续数学内容不再要求掌握．望同学们在纷繁的定理定义中抓住要旨，窥见抽象数学背后蕴藏的规律．熟悉高等代数和抽象代数的同学或会对某些内容感到熟悉．抽象地讨论 FFT 的资料并不多见，后续内容多为主讲人的新进探索，或有谬误，望不吝指正．"
  },
  {
    "objectID": "posts/20230928-dft/index.html#求值与插值",
    "href": "posts/20230928-dft/index.html#求值与插值",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "4.2 求值与插值",
    "text": "4.2 求值与插值\n\n求值与插值 - 导言\n本节将重新审视已经熟知的多项式，把抽象的、代数的多项式和具体的、分析的多项式函数区分开来．我们指出，多项式和多项式函数不同但关联紧密，形式幂级数与幂级数亦有此类联系．这些抽象的讨论将帮助我们剖析多项式求值插值的基本原理．\n除常见代数书目（如[8]），也推荐参考 OI Wiki 的多项式基础[9]和 Wikipedia 的形式幂级数[10]．\n\n\n多项式\n设（无穷）序列 \\(\\{ a_n \\}\\) 是一个只有有限个非零项的序列，其元素均在环 \\(R\\) 上．环 \\(R\\) 上的多项式环13 \\(R[x]\\) 是所有满足上述条件的序列构成的集合以及在它们之间定义的两种运算 \\(+, \\times\\) 的合称．此语境下，我们也将构成 \\(R[x]\\) 的序列称为 \\(R\\) 上的多项式．序列中的元素被称为多项式的系数．序列间定义的加法和乘法是普通序列升级为多项式的关键．\n13 一般语境下讨论的多项式环是在域上的 \\(K[x]\\)，而非环上的 \\(R[x]\\)．多项式环上的加法、乘法的定义已经为大家所熟知．系数所处的环保证了多项式加法和乘法的良定义，而在这两种运算下，\\(R\\) 上多项式的集合也构成一个环的结构．\n\n注记 (群、环、域). 群、环、域都是常见的代数结构，其中的元素在给定运算下封闭，并满足特定的运算性质．简单来说，环14上定义了加法和可能不可逆的、不一定交换的乘法，域上定义了加减乘除所有四则运算．交换环中的乘法满足交换律．除环中的所有元素有乘法逆元．域是交换除环．\n14 本篇中环的定义包含乘法单位元，即幺环．\n\n\n多项式\n习惯上也会将多项式 \\(A\\) 写为 \\(A(x) = \\sum_{k=0}^{n-1} a_k x^k\\) 的形式．其中未定元 \\(x\\) 只是一个符号，仅为方便加、乘法的理解而使用，并无任何含义．\n多项式 \\(A\\) 的次数 \\(\\deg A\\) 定义为其最高非零项所处的位置下标．特别的，定义零多项式的次数为 \\(-\\infty\\)．对任意多项式 \\(A,B \\in R[x]\\)，\\(\\deg(A+B) \\leq \\max\\{ \\deg A, \\deg B \\}\\)．当 \\(R\\) 是整环15时，\\(A,B\\) 的首项乘积非零，故 \\(\\deg(A*B) = \\deg A + \\deg B\\)．\n15 无零因子的交换幺环，稍后介绍．下面额外为多项式定义一种新的运算．多项式 \\(A\\) 和多项式 \\(B\\) 的复合 \\(A \\circ B\\) 定义为 \\[\nA \\circ B := \\sum_{k=0}^{+\\infty} a_k B^k\n\\] 其中 \\(B^k\\) 代表 \\(k\\) 个多项式 \\(B\\) 的乘积．习惯上也会将多项式 \\(A\\) 和多项式 \\(B\\) 的复合写为 \\(A(B(x)) = \\sum_{k=0}^{+\\infty} a_k B^k(x)\\) 的形式．由于多项式的次数有限，复合运算中仅包含了有限次多项式加法和乘法．\n\n\n形式幂级数\n形式幂级数定义与多项式的唯一区别是其不要求 \\(\\{ a_n \\}\\) 只有有限项非零．类似的，\\(R\\) 上的形式幂级数环记为 \\(R[[x]]\\)．\n由于涉及无限次运算，形式幂级数的复合运算需考虑环 \\(R\\) 上的收敛问题．为回避此问题，一般规定复合右侧函数的常数项须为零．\n\n注记. DFT, NTT 与多项式环 DFT/FFT 加速的多项式卷积在复数域 \\(\\mathbb C\\) 上的多项式环 \\(\\mathbb C[x]\\) 中进行，NTT/FFT 加速的多项式卷积在模 \\(p\\) 剩余类域 \\(\\mathbb Z_p\\) 上的多项式环 \\(\\mathbb Z_p[x]\\) 中进行．\n\n\n\n带余除法\n整环是无零因子的交换幺环．所谓无零因子，即环中任意元素 \\(a,b\\) 满足 \\(ab = 0 \\implies a=0 \\lor b=0\\)．所有域都是整环．当 \\(R\\) 是整环时，\\(R[x]\\) 也是整环16．整环上可以定义整除相关理论．\n16 可用前述多项式乘积次数公式证明．17 试试在 \\(\\mathbb Z[x]\\) 上用 \\(2x+1\\) 去除 \\(x+1\\)．定义有带余除法的环被称为 Euclid 整环．域上的多项式环都是 Euclid 整环[8, 第 7 章第 2 节定理 3, p. 11]．值得注意的是，\\(R\\) 的 Euclid 性不可传递至 \\(R[x]\\)17．\n如在带余除法中保证除式是首一多项式18，则带余除法的良定义和进行过程也均可在整环上实现．\n18 首项为 \\(1\\) 的多项式．\n\n多项式函数 / 幂级数\n刚刚强调，多项式 / 形式幂级数只是定义了加法和乘法的序列．现在介绍多项式函数和幂级数．它们不是序列，而是映射19．\n19 函数和映射几乎是等价名词．有时函数特指值域包含于复数域 \\(\\mathbb C\\) 的映射．20 为良定义 \\(x^0\\)，环 \\(R\\) 必须有单位元．21 这里再次涉及环 \\(R\\) 上的收敛问题．由于实践中只关心形式幂级数的前有限项，后续讨论系数-点值-系数法转换卷积时不需要用到幂级数理论，可以回避．多项式 \\(A\\) 对应的环 \\(R\\) 上的多项式函数 \\(A(x)\\) 定义为映射20 \\[\nA: R \\to R,\\quad x \\mapsto \\sum_{k=0}^{+\\infty} a_k x^k\n\\] 其中 \\(\\{ a_n \\}\\) 只有有限项非零．环 \\(R\\) 上的幂级数则无此限制21．\n与多项式 / 形式幂级数不同，这里的 \\(x \\in R\\) 代表函数的自变量，是会按环 \\(R\\) 上运算法则参与运算的有意义的变量．\n多项式函数的加法和乘法定义为函数的加法和乘法，即 \\[\n\\begin{aligned}\nA+B: x &\\mapsto A(x)+B(x) \\\\\nA \\otimes B: x &\\mapsto A(x)B(x)\n\\end{aligned}\n\\]\n\n\n求值\n多项式和多项式函数似乎在许多情况下有着平行的关系．下面介绍一个较直观的结论．\n若环 \\(R\\) 是交换环，则环 \\(R\\) 上每个多项式都唯一确定一个 \\(R\\) 上的多项式函数，且该映射保持加法和乘法运算22．形式化地可以记为 \\[\n\\begin{aligned}\n    (A+B)(x) &= A(x)+B(x) \\\\\n    (A*B)(x) &= A(x)B(x)\n    \\end{aligned}\n\\] 可用于证明上述结论的定理证明见[8, 第 7 章第 1 节定理 4, p. 7]23．由于多项式的复合由多项式加法和乘法组成，而多项式函数的复合（定义为函数的复合）亦可在环上平行地展开，故上述映射也保持了复合运算．\n22 这种保持结构不变的映射被称为同态（homomorphism）．23 其证明了域上一元多项式环的通用性质．仿照该证明应可证明环上的版本，从而证明这一同态关系．多项式和多项式函数的这一关系为多项式在任意点的求值操作提供了理论基础．在多项式函数的 \\(t\\) 处求值也被称为用 \\(t\\) 代入多项式 \\(A\\)，记为 \\(A(t)\\)．\n\n\n插值\n需要注意的是，前述结论的逆命题不一定成立，即环 \\(R\\) 上的一个多项式函数不一定与 \\(R\\) 上多项式一一对应．一个经典反例是有限域上多项式环 \\(\\mathbb Z_p[x]\\) 上的 \\((x+1)^p \\equiv x^p + 1 \\pmod{p}\\)．我们指出其成立的一个充分条件是 \\(R\\) 是无限整环24．\n24 该定理是下方高亮定理的一个自然的推论．该逆命题的本质是通过多项式函数的所有函数值反过来确定多项式（系数）的过程．而如果在确定时只使用一部分函数值，就是所谓的多点插值过程．很多时候待求多项式的次数是已知的，这在相当程度上缩小了待定多项式的范围．我们指出，只要 \\(R\\) 是整环，就可以通过多项式任意 \\(n\\) 个不同位置的点值确定一个至多 \\(n-1\\) 次的多项式．\n证明的关键是用带余除法25讨论多项式根与其一次因式的关系，即多项式余式定理或小 Bézout 定理[8, 第 7 章第 6 节定理 6, p. 35]．\n25 由于一次因式均为首一多项式，可以在整环上对其使用带余除法．需要强调，上述结论只能说明，只有那些确实可通过多项式 \\(n\\) 点求值得到的点值组，才能与多项式建立保持加法和乘法运算的双射．对于任取的 \\(R\\) 中的一个 \\(n\\) 元组，则无法确定是否存在与之对应的多项式．\n\n\n求值与插值的线性表示\n到这里，多项式的求值与插值的线性表示已经呼之欲出了．若将交换环 \\(R\\) 上的至多 \\(n-1\\) 次的多项式看做模26 \\(R^n\\) 中的一个向量，则多项式多点求值的过程就是 \\(R^n\\) 上的一个线性变换（记为 \\(V\\)），其矩阵表示正是 Vandermonde 矩阵．由先前对求值的讨论，我们还知道其保持模 \\(R^n\\) 上的加法运算，并将结果不超过 \\(n-1\\) 次的卷积运算转化为 \\(R^n\\) 上的逐项乘法．\n26 模是定义在环上的“线性空间”．27 Lagrange 插值的构造用到了除法，且行列式非零推出矩阵可逆仅在域上的线性空间中适用，因此必须要求 \\(R\\) 是域．若将对 \\(R\\) 的要求加强到域，注意到 Vandermonde 行列式在参数互不相同时非零，故此时 \\(V\\) 可逆．事实上，Vandermonde 矩阵求逆的过程就是 Lagrange 插值，从而给出了将任意 \\(R^n\\) 中向量还原为其对应多项式的构造方法27．这与数论中中国剩余定理的构造有异曲同工之妙[11, section: A perspective from linear algebra]．\n\n\n求值与插值 - 小结\n本节的核心是多项式和多项式函数的区别与联系，两个方向的”确定”分别给出了多项式多点求值和多点插值的理论基础．\n由于多项式和多项式函数这种若即若离的关系，往往在记号上也有意无意地混淆了它们，某些情况下加大了区分的难度．本篇使用的记号体系将尽量用单个字母 \\(A\\) 表示多项式，用 \\(A(x)\\) 表示多项式 \\(A\\) 对应的多项式函数，用 \\(A(t)\\) 表示用 \\(t\\) 代入多项式 \\(A\\)，同时在需要区分的符号前加上适当的名词．"
  },
  {
    "objectID": "posts/20230928-dft/index.html#环上的-dft",
    "href": "posts/20230928-dft/index.html#环上的-dft",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "4.3 环上的 DFT",
    "text": "4.3 环上的 DFT\n\n环上的 DFT - 导言\n前面讨论了在多项式任意点处求值插值的基本原理，但 DFT/FFT 的运行只需在单位根处求值和插值．本节将进一步放宽对多项式环的限制，介绍定义在有主要单位根的环上的一般的 DFT 及其快速算法 FFT．\n本节内容主要参考了 [12, section 2, pp. 983–984] 和 [13]．\n\n\n环上的单位根 - 两个定义\n定义环 \\(R\\) 上的 \\(n\\) 次主要单位根（principal n-th root of unity）\\(\\omega_n\\) 是满足如下条件的环 \\(R\\) 中的一个元素： \\[\n\\omega_n^n = 1;\\quad \\sum_{k=0}^{n-1} \\omega_n^{ik} = 0,\\quad i=1,2,\\dots,n-1\n\\] 由定义立得 \\(\\sum_{k=0}^{n-1} \\omega_n^{ik} = [n \\mid i] n\\)，可见主要单位根的定义即求和引理本身．\n定义环 \\(R\\) 上的 \\(n\\) 次本原单位根（primitive n-th root of unity）\\(\\omega_n\\) 是满足如下条件的环 \\(R\\) 中的一个元素： \\[\n\\omega_n^n = 1;\\quad \\omega_n^k \\neq 1,\\quad k=1,2,\\dots,n-1\n\\]\n本原单位根在许多情况下与主要单位根等价，但亦非完全相同．\n\n\n环上的单位根 - 区别与联系\n\n\n\n\n\n\n\n命题 1 若环 \\(R\\) 是整环，则环上的本原单位根也是一个主要单位根．\n\n\n\n\n\n证明. 对任意正整数 \\(i \\in [n]\\)，令 \\(S = \\sum_{k=0}^n \\omega_n^{ik}\\)，则 \\((1-\\omega_n^i) S = S - \\omega_n^i S = 1 - \\omega_n^n = 0\\)，由 \\(R\\) 是整环及 \\(\\omega_n^i=0\\) 得 \\(S=0\\)．\n\n\n\n环上的单位根 - 区别与联系\n\n\n\n\n\n\n\n命题 2 若环 \\(R\\) 的特征28 \\(\\operatorname{char}R\\) 满足 \\(\\operatorname{char}R \\nmid n\\)，则环上的主要单位根也是一个本原单位根．\n\n\n\n\n28 使得 \\(m 1 = \\sum_{k=0}^{m-1}1 = 0\\) 的最小正整数 \\(m\\)．不存在则记为 \\(0\\)．\\(\\operatorname{char}\\mathbb C = 0\\)，\\(\\operatorname{char}\\mathbb Z_p = p\\)．可以证明域的特征一定是 \\(0\\) 或一质数[8, 第 7 章第 11 节定理 3，p. 70]．\n证明. 反证．若存在一正整数 \\(i \\in [n]\\) 使得 \\(n\\) 次主要单位根 \\(\\omega_n\\) 的某一幂次 \\(\\omega_n^i=1\\)，则 \\(\\sum_{k=0}^{n-1} \\omega_n^{ik} = \\sum_{k=0}^{n-1} 1^k = n 1 \\neq 0\\)，与主要单位根定义矛盾．\n\n\n\n环上的单位根 - 其它性质\n分别根据定义和数论中的 Bézout 定理，容易证明主要单位根和本原单位根的消去引理：设 \\(\\omega_{n}\\) 是环上的 \\(n\\) 次主要（本原）单位根，则 \\(\\omega_{n}^{k}\\) 是环上的 \\(\\frac n {\\gcd(n,k)}\\) 次主要（本原）单位根．\n注意到 \\(\\left(\\omega_{2n}^n \\right)^2=1 \\implies (\\omega_{2n}^n + 1)(\\omega_{2n}^n - 1)=0\\)，故整环上的 \\(2n\\) 次主要单位根或本原单位根 \\(\\omega_{2n}\\) 均满足 \\(\\omega_{2n}^n = -1\\)．\n环上的 \\(n\\) 次主要单位根或本原单位根 \\(\\omega_n\\) 都存在逆元 \\(\\omega_n^{-1} = \\omega_n^{n-1}\\)．\n\n\n环上的 DFT\n设 \\(\\omega_n\\) 是环 \\(R\\) 上的一个 \\(n\\) 次主要单位根，其对应的 \\(R^n\\) 上的 \\(n\\) 点 DFT 定义为线性映射（或矩阵） \\[\nF = \\left( \\omega_n^{ij} \\right)_{(i,j) \\in n \\times n} = \\begin{pmatrix}\n    1 & 1 & \\dots & 1 \\\\\n    1 & \\omega_n & \\dots & \\omega_n^{n-1} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    1 & \\omega_n^{n-1} & \\dots & \\omega_n^{(n-1)(n-1)}\n    \\end{pmatrix}\n\\] 若 \\(n 1\\) 在环 \\(R\\) 中存在乘法逆元，则 \\(R^n\\) 上的 DFT 可逆，其逆映射为29 \\[\nF^{-1} = (n 1)^{-1} \\left( \\omega_n^{-ij} \\right)_{(i,j) \\in n \\times n} = (n 1)^{-1} \\begin{pmatrix}\n    1 & 1 & \\dots & 1 \\\\\n    1 & \\omega_n^{-1} & \\dots & \\omega_n^{-(n-1)} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    1 & \\omega_n^{-(n-1)} & \\dots & \\omega_n^{-(n-1)(n-1)}\n    \\end{pmatrix}\n\\]\n29 证明使用主要单位根的定义（求和引理）即可．\n\n环上的 FFT\n除无法在任意环上使用 \\(\\omega_{2n}^n = -1\\)，现有的抽象已足够让我们写出与之前类似的推导 FFT 的过程．\n设 \\(R\\) 是任意环，\\(\\omega_{2n}\\) 是环 \\(R\\) 上的一个 \\(2n\\) 次主要单位根．由主要单位根的消去引理，\\(\\omega_{2n}^2\\) 是环 \\(R\\) 上的 \\(\\frac {2n}{\\gcd(2n,2)} = n\\) 次主要单位根．方便起见，记 \\(\\omega_n = \\omega_{2n}^2\\)．\n考虑对模 \\(R^{2n}\\) 中向量 \\(\\boldsymbol a = \\left( a_0,a_1,\\dots,a_{2n-1} \\right)^T\\) 做 \\(\\omega_{2n}\\) 对应的 \\(2n\\) 点 DFT 变换，得到向量 \\(\\hat{\\boldsymbol a} = \\left( \\hat a_0, \\hat a_1, \\dots, \\hat a_{2n-1} \\right)^T\\)，其中 \\(\\hat a_i = \\sum_{k=0}^{2n-1} a_k \\omega_{2n}^{ik}\\)．将其奇偶分项为 \\(\\hat a_i=A_0(i)+A_1(i) \\omega_{2n}^i\\)，其中 \\[\n\\begin{aligned}\n    A_0(i) &:= \\sum_{k=0}^{n-1} a_{2k} \\omega_{n}^{ik} = \\sum_{k=0}^{n-1} a_{2k} \\omega_{2n}^{2ik} \\\\\n    A_1(i) &:= \\sum_{k=0}^{n-1} a_{2k+1} \\omega_{n}^{ik} = \\sum_{k=0}^{n-1} a_{2k+1} \\omega_{2n}^{2ik}\n    \\end{aligned}\n\\]\n\n\n环上的 FFT\n注意到 \\(A_0(i)=A_0(n+i)\\)，\\(A_1(i)=A_1(n+i)\\)，故 \\[\n\\begin{aligned}\n    \\hat a_i     &= A_0(i) + A_1(i) \\omega_{2n}^i \\\\\n    \\hat a_{n+i} &= A_0(i) + A_1(i) \\omega_{2n}^{n+i}\n    \\end{aligned},\\quad i \\in [n]\n\\] 而 \\(A_0(i),\\, i \\in [n]\\) 的计算即计算向量 \\(\\boldsymbol{a_0} = \\left( a_0, a_2, \\dots, a_{2n-2} \\right)\\) 对应于 \\(\\omega_n\\) 的 \\(n\\) 点 DFT 的过程；\\(A_1(i),\\, i \\in [n]\\) 的计算即计算向量 \\(\\boldsymbol{a_1} = \\left( a_1, a_3, \\dots, a_{2n-1} \\right)\\) 对应于 \\(\\omega_n\\) 的 \\(n\\) 点 DFT 的过程．\n因此，令 \\(n = 2^m\\)，则只要环 \\(R\\) 上存在 \\(2^m\\) 次主要单位根，如上形式的 FFT 递归算法就可在 \\(O(n \\log n)\\) 的时间复杂度内快速计算 \\(R^n\\) 上的 \\(n\\) 点 DFT．而若 \\(2^k 1,\\, 0 \\leq k \\leq m\\) 在 \\(R\\) 内均存在逆元，\\(R^n\\) 上的 \\(n\\) 点 IDFT 也可类似地快速计算．"
  },
  {
    "objectID": "posts/20230928-dft/index.html#循环卷积与卷积定理",
    "href": "posts/20230928-dft/index.html#循环卷积与卷积定理",
    "title": "A Convolution-Oriented FFT Tutorial",
    "section": "4.4 循环卷积与卷积定理",
    "text": "4.4 循环卷积与卷积定理\n\n循环卷积与卷积定理 - 导言\n上一节中，我们建立了在有主要单位根的环上的 DFT 及其快速算法 FFT 的相关理论，但由于放宽了对多项式环 \\(R[x]\\) 的限制，多项式的求值插值理论无法在此直接得到应用，环上 DFT 加速多项式卷积的理论尚需重新构建．\n在求值与插值部分已经介绍求值变换 \\(V\\) 在 \\(R^n\\) 上的线性表示，其保持 \\(R^n\\) 上的加法运算，并将规模不超过 \\(n\\) 的两向量的卷积转化为 \\(R^n\\) 上的逐项乘法．本节中，我们来证明 DFT 变换 \\(F\\) 也满足同样的性质，且将这一结果推广到卷积规模超过 \\(n\\) 时的情况．\n\n\n循环卷积\n设 \\(R\\) 是交换环，我们记 \\(A \\otimes B\\) 代表模 \\(R^n\\) 上两个向量的逐项乘法．\n设 \\(F\\) 是 \\(R^n\\) 上主要单位根 \\(\\omega_n\\) 对应的 \\(n\\) 点可逆 DFT 变换，\\(A,B\\) 是 \\(R^n\\) 中两个任意取定的向量．显然 \\(F(A+B)=FA+FB\\)，故 DFT 变换保持 \\(R^n\\) 上的加法运算．现在的主要问题是，求值与插值部分计算卷积的方法 \\(F^{-1}(FA \\otimes FB)\\) 在放宽环限制的 \\(R^n\\) 上进行时，将会得到什么结果？\n令 \\[\n\\begin{gathered}\n    \\hat{\\boldsymbol a} = F \\boldsymbol a,\\quad \\hat{\\boldsymbol b} = F \\boldsymbol b \\\\\n    \\hat {\\boldsymbol c}= \\hat{\\boldsymbol a} \\otimes \\hat{\\boldsymbol b},\\quad \\boldsymbol c = F^{-1} \\hat{\\boldsymbol c}\n    \\end{gathered}\n\\] 则 \\[\n\\hat a_i = \\sum_{j=0}^{n-1} a_j \\omega_n^{ij},\\quad \\hat b_i = \\sum_{k=0}^{n-1} b_k \\omega_n^{ik}\n\\]\n\n\n循环卷积\n\\[\n\\hat c_i = \\hat a_i \\hat b_i = \\sum_{j=0}^{n-1} a_j \\omega_n^{ij} \\sum_{k=0}^{n-1} b_k \\omega_n^{ik} = \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} a_j b_k \\omega_n^{i(j+k)}\n\\] \\[\nc_i = \\sum_{t=0}^{n-1} \\omega_n^{-it} \\hat c_t =  \\sum_{t=0}^{n-1} \\omega_n^{-it} \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} a_j b_k \\omega_n^{t(j+k)}\n    = \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} a_j b_k \\sum_{t=0}^{n-1} \\omega_n^{t(j+k-i)}\n\\] 对最里侧的求和使用主要单位根的定义（求和引理），就有 \\[\nc_i = \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} a_j b_k [n \\mid j+k-i] = \\sum_{j+k \\equiv i \\bmod{n}} a_j b_k\n\\] 这便是所谓的循环卷积．以后将 \\(R^n\\) 中向量 \\(\\boldsymbol a\\) 和 \\(\\boldsymbol b\\) 的循环卷积记为 \\(\\boldsymbol a * \\boldsymbol b\\)．形象地来看，循环卷积中，次数超过 \\(n-1\\) 的卷积项被模意义地地叠加到了以次数为 \\(0\\) 为始的项上．\n\n\n卷积定理\n前述讨论已经证明30 \\[\nF(A * B) = FA \\otimes FB\n\\] 这便是一般交换环上 DFT 变换的（循环）卷积定理．\n30 虽然前面用到了 \\(F\\) 可逆的要求，但该定理在 \\(F\\) 不可逆时也成立．只需类似地验证两边相等即可．31 具体来说，该变换只能是 DFT 矩阵的某个行置换．在 \\(\\mathbb C^n\\) 上的证明可参见[14]，主讲人目前正在研究整环上的版本，欢迎讨论．我们指出，当要求所作变换可逆时，卷积定理反过来也要求所作变换是一类似 DFT 映射的变换31．\n\n\n\n\n\n\n\n习题 5 尝试将任意序列 DFT 两次，观察结果．证明你的结论．\n\n\n\n\n\n\n\n\n\n\n\n习题 6 求 DFT 矩阵的行列式．尽可能缩小可行解范围．"
  },
  {
    "objectID": "posts/20201024-treediff/index.html",
    "href": "posts/20201024-treediff/index.html",
    "title": "树上差分的两种形式（相遇 or 行程的交集 题解）",
    "section": "",
    "text": "emm，这很NOIP…\n写这个的原因是今天考试一个sb差分树题居然杠了个树剖上去，杀鸡用了牛刀。\n而且不止一次了…总是想不到子树和这种差分，淦\nAnyway，简单写写吧。"
  },
  {
    "objectID": "posts/20201024-treediff/index.html#树上差分的两种形式",
    "href": "posts/20201024-treediff/index.html#树上差分的两种形式",
    "title": "树上差分的两种形式（相遇 or 行程的交集 题解）",
    "section": "树上差分的两种形式",
    "text": "树上差分的两种形式\n\n单点修改&链查询用差分转化为单点修改&树上前缀和\nclass MPQU{public: //单点修改 & 树上前缀和 (Modify Point Query Up)\n  BIT bit;\n  MPQU(bool typ=0){if(typ==1) bit=BIT(dN);}\n  void Add(ll u,ll w){bit.Add(st[u],w); bit.Add(ed[u],-w);}\n  ll Query(ll u){return bit.Query(st[u]);}\n};\nclass MPQL{public: //单点修改 & 链查询 (Modify Point Query Link)\n  MPQU mpqu;\n  MPQL(bool typ=0){if(typ==1) mpqu=MPQU(1);}\n  void Add(ll u,ll w){mpqu.Add(u,w);}\n  ll Query(ll u,ll v){ll lca=LCA(u,v); return mpqu.Query(u)+mpqu.Query(v)-mpqu.Query(lca)-mpqu.Query(fa[lca]);}\n}mpql;\n链修改&单点查询用差分转化为单点修改&子树和\nclass MPQD{public: //单点修改 & 子树和 (Modify Point Query Down)\n  BIT bit;\n  MPQD(bool typ=0){if(typ==1) bit=BIT(dN);} \n  void Add(ll u,ll w){bit.Add(st[u],w);}\n  ll Query(ll u){return bit.Query(ed[u])-bit.Query(st[u]-1);}\n};\nclass MLQP{public: //链修改 & 单点查询 (Modify Link Query Point)\n  MPQD mpqd;\n  MLQP(bool typ=0){if(typ==1) mpqd=MPQD(1);}\n  void Add(ll u,ll v){ll lca=LCA(u,v); mpqd.Add(u,1); mpqd.Add(v,1); mpqd.Add(lca,-1); mpqd.Add(fa[lca],-1);}\n  ll Query(ll u){return mpqd.Query(u);}\n}mlqp;\n\n三重封装\n转化后的问题都能用DFS序+树状数组解决。（在上文代码中，树状数组用BIT封装，st, ed是DFS序）\n本质：\n\n树上前缀和对应序列前缀和\n子树和对应序列后缀和\n\n在序列上，前缀和、后缀和均能解决这两个问题。\n而之所以在树上这两种形式求解的问题出现不同，是因为与序列相比，树是上小下大的。"
  },
  {
    "objectID": "posts/20201024-treediff/index.html#相遇-or-行程的交集-题解",
    "href": "posts/20201024-treediff/index.html#相遇-or-行程的交集-题解",
    "title": "树上差分的两种形式（相遇 or 行程的交集 题解）",
    "section": "相遇 or 行程的交集 题解",
    "text": "相遇 or 行程的交集 题解\n这道题综合的考察了两种差分，成功把我干翻（\n[出处不明] 相遇 or 行程的交集\n\nDescription\n　　豪哥生活在一个n个点的树形城市里面，每一天都要走来走去。虽然走的是比较的多，但是豪哥在这个城市里面的朋友并不是很多。\n　　当某一天，猴哥给他展现了一下大佬风范之后，豪哥决定要获得一些交往机会来提升交往能力。豪哥现在已经物色上了一条友，打算和它（豪哥并不让吃瓜群众知道性别）交往。豪哥现在spy了一下这个人的所有行程起点和终点，豪哥打算从终点开始走到起点与其相遇。但是豪哥是想找话题的，他想知道以前有多少次行程和此次行程是有交集的，这样豪哥就可以搭上话了。这个路径与之前路径的有交集数量作为豪哥此次的交往机会。\n　　但是豪哥急着要做交往准备，所以算什么交往机会的小事情就交给你了。\nInput\n　　第一行一个正整数n表示节点个数。\n　　接下来n-1行，每行两个正整数分别是u，v表示节点u和v之间有连边。\n　　接下来一行一个 正整数m表示路径个数。\n　　然后有m行，每行两个正整数分别是u，v分别表示u到v之间有一条路径。\nOutput\n　　输出共m行，每行一个整数，第i行表示豪哥在这条路径上获得的交往机会。\nSample Input\n5\n1 2\n1 3\n3 4\n3 5\n4\n4 5\n4 2\n1 3\n1 2\nSample Output\n0\n1\n2\n2\nHint\n【数据范围与约定】\n　　对于20%的数据n，m≤2000\n　　对于另外20%的数据n，m≤50000\n　　对于另外10%的数据n，m≤200000，保证树形结构是一条链\n　　对于另外50%的数据n，m≤200000\n\n简要题意：给你一棵树，然后按顺序输入若干条路径。问每次输入路径时该路径与前面已经输入的多少条路径有交集。\n主要要想到把两条树上路径有交集转换为其中某条路径的LCA被另一条路径所覆盖。\n于是对于当前输入的路径，分当前路径覆盖了多少个之前路径的LCA和当前路径的LCA被之前多少个路径覆盖讨论即可。前者是单点修改&链查询，后者是链修改&单点查询，按前文的方法做就可以了。\n注意特判LCA重叠的情况，见代码。\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\n#include&lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef vector&lt;ll&gt; Vector;\ntypedef vector&lt;ll&gt;::iterator VecIt;\nll Rd(){\n    ll ans=0;bool fh=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9'){if(c=='-') fh=1; c=getchar();}\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    if(fh) ans=-ans;\n    return ans;\n}\n\nll Lowbit(ll x){return x&(-x);}\n\nconst ll PTN=2E5+5; \nclass BIT{public: \n    vector&lt;ll&gt; tr;ll n;\n    BIT(){}\n    BIT(ll n){this-&gt;n = n; tr=vector&lt;ll&gt;(n+1,0);}\n    void Add(ll p,ll w){\n        if(!p) return;\n        for(ll i=p;i&lt;=n;i+=Lowbit(i)) tr[i]+=w;\n    }\n    ll Query(ll p){\n        ll ans=0;\n        for(ll i=p;i&gt;=1;i-=Lowbit(i)) ans+=tr[i];\n        return ans;\n    }\n};\n\nll N;\nVector edge[PTN];\nll fa[PTN],dep[PTN],sz[PTN],son[PTN];\nll st[PTN],ed[PTN];ll dN;\nvoid DFS1(ll u,ll father,ll depth){\n    fa[u]=father;dep[u]=depth;sz[u]=1;son[u]=0;st[u]=++dN;\n    for(VecIt it = edge[u].begin(); it!=edge[u].end(); it++){\n        ll v=(*it);if(v==father) continue;\n        DFS1(v,u,depth+1);\n        sz[u]+=sz[v];\n        if(sz[v]&gt;sz[son[u]]) son[u]=v;\n    }\n    ed[u]=++dN;\n}\nll tp[PTN];\nvoid DFS2(ll u,ll toop){\n    tp[u]=toop;\n    if(son[u]) DFS2(son[u],toop);\n    for(VecIt it = edge[u].begin(); it!=edge[u].end(); it++){\n        ll v=(*it);if(v==fa[u]) continue;\n        if(v!=son[u]) DFS2(v,v);\n    }\n}\nll LCA(ll u,ll v){\n    while(tp[u]!=tp[v]){\n        if(dep[tp[u]]&lt;dep[tp[v]]) swap(u,v);\n        u=fa[tp[u]];\n    }\n    if(dep[u]&lt;dep[v]) return u;\n    else return v;\n}\n\nclass MPQU{public: //单点修改 & 树上前缀和 (Modify Point Query Up)\n    BIT bit;\n    MPQU(bool typ=0){if(typ==1) bit=BIT(dN);}\n    void Add(ll u,ll w){bit.Add(st[u],w); bit.Add(ed[u],-w);}\n    ll Query(ll u){return bit.Query(st[u]);}\n};\nclass MPQD{public: //单点修改 & 子树和 (Modify Point Query Down)\n    BIT bit;\n    MPQD(bool typ=0){if(typ==1) bit=BIT(dN);} \n    void Add(ll u,ll w){bit.Add(st[u],w);}\n    ll Query(ll u){return bit.Query(ed[u])-bit.Query(st[u]-1);}\n};\nclass MPQL{public: //单点修改 & 链查询 (Modify Point Query Link)\n    MPQU mpqu;\n    MPQL(bool typ=0){if(typ==1) mpqu=MPQU(1);}\n    void Add(ll u,ll w){mpqu.Add(u,w);}\n    ll Query(ll u,ll v){ll lca=LCA(u,v); return mpqu.Query(u)+mpqu.Query(v)-mpqu.Query(lca)-mpqu.Query(fa[lca]);}\n}mpql;\nclass MLQP{public: //链修改 & 单点查询 (Modify Link Query Point)\n    MPQD mpqd;\n    MLQP(bool typ=0){if(typ==1) mpqd=MPQD(1);}\n    void Add(ll u,ll v){ll lca=LCA(u,v); mpqd.Add(u,1); mpqd.Add(v,1); mpqd.Add(lca,-1); mpqd.Add(lca,-1);/*mpqd.Add(fa[lca],-1);*/} //特殊处理重叠LCA \n    ll Query(ll u){return mpqd.Query(u);}\n}mlqp;\nint main(){\n    //freopen(\"meet.in\",\"r\",stdin);\n    //freopen(\"meet.out\",\"w\",stdout);\n    N=Rd();\n    for(ll i=1;i&lt;N;i++){\n        ll u=Rd(),v=Rd();\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dN=0;sz[0]=0;DFS1(1,0,0);\n    DFS2(1,1);\n    st[0]=0;ed[0]=0;\n    mpql=MPQL(1);mlqp=MLQP(1); \n    ll qN=Rd();\n    for(ll q=1;q&lt;=qN;q++){\n        ll u=Rd(),v=Rd();\n        ll lca=LCA(u,v);\n        \n        printf(\"%lld\\n\",mpql.Query(u,v)+mlqp.Query(lca));\n        mpql.Add(lca,1);\n        mlqp.Add(u,v);\n    }\n    return 0;\n}"
  },
  {
    "objectID": "posts/20220714-import/index.html",
    "href": "posts/20220714-import/index.html",
    "title": "关于 Python 的 import",
    "section": "",
    "text": "好久以前就被 Python 的相对与绝对导入所困扰。去年粗浅探究后自以为完全理解，近来又因 sys.path[0] 和 os.getcwd() 的不一致而刷新了认知…\nPython 官方文档 5. The import system — Python 3.10.5 documentation 当然是最好的学习指南，但全部看完对我来说还是有点难度。这里只选择一些要点讨论。"
  },
  {
    "objectID": "posts/20220714-import/index.html#from-import",
    "href": "posts/20220714-import/index.html#from-import",
    "title": "关于 Python 的 import",
    "section": "from import",
    "text": "from import\nimport A、import A as B、from A import B 结构中，A 最小只能到 module。因此，只有使用 from import 结构才可以单独获取 module 里的属性。另外，相对引用必须使用 from import 结构。\nfrom module import * 将导入 module 中的所有成员（有单双下划线前导的成员除外）。对于 package 可在 __init__.py 中定义 __all__ = [\"module\", \"module\", ...] 来手动控制的实际导入内容。"
  },
  {
    "objectID": "posts/20220714-import/index.html#package-与-__init__.py",
    "href": "posts/20220714-import/index.html#package-与-__init__.py",
    "title": "关于 Python 的 import",
    "section": "Package 与 __init__.py",
    "text": "Package 与 __init__.py\nPython 3.3 以后的 package 不再硬性需要 __init__.py，普通文件夹等同于 __init__.py 留空的 namespace package。（关于 regular package 和 namespace package 的区别，参见 5. The import system — Python 3.10.5 documentation）\n__init__.py 的作用在于当我们直接导入一个 package 的时候，实际上是执行了 __init__.py。换句话说，直接导入一个 package 就是把它看做一个逻辑写在 __init__.py 里的 module。\n需要注意的是，对于形如 A.B.C 的导入，A、A.B、A.B.C 对应的 __init__.py 都会被执行。也就是说，只要导入路径经过该 package，该 package 的 __init__.py 就会被执行。"
  },
  {
    "objectID": "posts/20220714-import/index.html#submodules",
    "href": "posts/20220714-import/index.html#submodules",
    "title": "关于 Python 的 import",
    "section": "Submodules",
    "text": "Submodules\n\nWhen a submodule is loaded using any mechanism (e.g. importlib APIs, the import or import-from statements, or built-in __import__()) a binding is placed in the parent module’s namespace to the submodule object. For example, if package spam has a submodule foo, after importing spam.foo, spam will have an attribute foo which is bound to the submodule.\n…\nGiven Python’s familiar name binding rules this might seem surprising, but it’s actually a fundamental feature of the import system. The invariant holding is that if you have sys.modules['spam'] and sys.modules['spam.foo'] (as you would after the above import), the latter must appear as the foo attribute of the former.\n— 5. The import system — Python 3.10.5 documentation\n\n这是说，import 进来的 module 会被挂载到本 module 上作为其属性。\n这个性质可以弄出来很多看上去很奇怪的玩意儿，比如说自己导入自己后可以 me.me.me.me... 无限嵌套之类的…\n\n另外，对于形如 import A.B.C 的导入，A、A.B、A.B.C 都会被挂载到本 module 上。然而，from A.B import C 却只会挂载 C，而 import A.B.C as D 也只会挂载 D ，即使 A、A.B 都被执行且都在 sys.modules 里。"
  },
  {
    "objectID": "posts/20220714-import/index.html#sys.path",
    "href": "posts/20220714-import/index.html#sys.path",
    "title": "关于 Python 的 import",
    "section": "sys.path",
    "text": "sys.path\n\nA list of strings that specifies the search path for modules. Initialized from the environment variable PYTHONPATH, plus an installation-dependent default.\nAs initialized upon program startup, the first item of this list, path[0], is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), path[0] is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted before the entries inserted as a result of PYTHONPATH.\nA program is free to modify this list for its own purposes. Only strings and bytes should be added to sys.path; all other data types are ignored during import.\n— sys — System-specific parameters and functions — Python 3.10.5 documentation\n\nsys.path 是 Python 搜索 module 的基准目录（即绝对导入）。其由环境变量 PYTHONPATH 和一些默认路径（和安装环境有关，参见 PYTHONHOME）组成，而在运行 script 时，script 的所在目录会被临时加入 sys.path[0] 中。如果运行的并不是 script（例如是交互式运行或从 stdin 中读取脚本代码），sys.path[0] 则被设置为空字符串，代表当前工作目录。\nsys.path 有优先级，排在前面的优先级高。\n\n需要特别注意的是，script 的所在目录不是当前工作目录。例如，在 D:\\test 下执行\npython path/to/file.py\n时，sys.path[0] 为 D:\\test\\path\\to\\file.py，而当前工作目录则是 D:\\test（也即 os.getcwd()）。\n当前工作目录是 Python 寻找其他文件时的基准路径，而所有绝对导入操作都只与 sys.path 有关，两者是完全不同的。\npython -m 的情况稍有不同，参见后文。"
  },
  {
    "objectID": "posts/20220714-import/index.html#python--m",
    "href": "posts/20220714-import/index.html#python--m",
    "title": "关于 Python 的 import",
    "section": "python -m",
    "text": "python -m\n\nSearch sys.path for the named module and execute its contents as the __main__ module.\nSince the argument is a module name, you must not give a file extension (.py). The module name should be a valid absolute Python module name, but the implementation may not always enforce this (e.g. it may allow you to use a name that includes a hyphen).\nPackage names (including namespace packages) are also permitted. When a package name is supplied instead of a normal module, the interpreter will execute &lt;pkg&gt;.__main__ as the main module. This behaviour is deliberately similar to the handling of directories and zipfiles that are passed to the interpreter as the script argument.\n\nNote\nThis option cannot be used with built-in modules and extension modules written in C, since they do not have Python module files. However, it can still be used for precompiled modules, even if the original source file is not available.\n\nIf this option is given, the first element of sys.argv will be the full path to the module file (while the module file is being located, the first element will be set to \"-m\"). As with the -c option, the current directory will be added to the start of sys.path.\n-I option can be used to run the script in isolated mode where sys.path contains neither the current directory nor the user’s site-packages directory. All PYTHON* environment variables are ignored, too.\nMany standard library modules contain code that is invoked on their execution as a script. An example is the timeit module:\npython -m timeit -s 'setup here' 'benchmarked code here'\npython -m timeit -h # for details\nRaises an auditing event cpython.run_module with argument module-name.\n\nSee also\nrunpy.run_module()\nEquivalent functionality directly available to Python code\n\nPEP 338 – Executing modules as scripts\nChanged in version 3.1: Supply the package name to run a __main__ submodule.\nChanged in version 3.4: namespace packages are also supported\n— 1. Command line and environment — Python 3.10.5 documentation\n\n在 sys.path 指定的目录中寻找 module 并以 __main__ module 的身份执行指定 module。\n注意不要在名字后面加 .py，因为我们已经把执行的文件当作 module 来看待。\n如果指定的是一个 Package name（即目录名），将会执行 &lt;pkg&gt;.__main__（即 &lt;pkg&gt;/__main__.py）。\n另外，如果使用 python -m a.b.module，sys.argv 的首位将被设置为被执行 module 文件的完整路径（与之相对，python a/b/module.py 中 sys.argv[0] 将会是相对当前工作目录的路径，即 a/b/module.py）；同时，当前工作目录会被加入 sys.path 的首位。\n\npython -m A.B.module 将顺次执行 A、A.B 的 __init__.py，即使该 module 没有任何导入行为。\npython -m 对于直接执行 package 内部的代码是必要的。若直接以 script 方式运行，一旦涉及到任何高于该 script 所在目录（含该目录）的相对导入，Python 就会抛出如下错误：\nImportError: attempted relative import with no known parent package\n而一个 module 也不能导入超过 python -m 参数指定的最顶层结构的 module，否则会抛出错误：\nImportError: attempted relative import beyond top-level package"
  },
  {
    "objectID": "posts/20220714-import/index.html#sys.modules",
    "href": "posts/20220714-import/index.html#sys.modules",
    "title": "关于 Python 的 import",
    "section": "sys.modules",
    "text": "sys.modules\n\nThe first place checked during import search is sys.modules. This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So if foo.bar.baz was previously imported, sys.modules will contain entries for foo, foo.bar, and foo.bar.baz. Each key will have as its value the corresponding module object.\nDuring import, the module name is looked up in sys.modules and if present, the associated value is the module satisfying the import, and the process completes. However, if the value is None, then a ModuleNotFoundError is raised. If the module name is missing, Python will continue searching for the module.\nsys.modules is writable. Deleting a key may not destroy the associated module (as other modules may hold references to it), but it will invalidate the cache entry for the named module, causing Python to search anew for the named module upon its next import. The key can also be assigned to None, forcing the next import of the module to result in a ModuleNotFoundError.\nBeware though, as if you keep a reference to the module object, invalidate its cache entry in sys.modules, and then re-import the named module, the two module objects will not be the same. By contrast, importlib.reload() will reuse the same module object, and simply reinitialise the module contents by rerunning the module’s code.\n— 5. The import system — Python 3.10.5 documentation\n\nsys.modules 是一个 dict，Python 在导入之前会去检查 sys.module 里是否已经存有需要的 module 的 module object。如果有，就直接用这个；如果值为 None（意思是以前找过但没找到），就直接报错；如果该键值对不存在，就继续搜索过程。总之，sys.modules 扮演了一个类似 cache 的角色。\n对于形如 A.B.C 的导入，Python 会顺次导入 A、A.B 和 A.B.C 并把他们加入 sys.modules。"
  },
  {
    "objectID": "posts/20220714-import/index.html#参考",
    "href": "posts/20220714-import/index.html#参考",
    "title": "关于 Python 的 import",
    "section": "参考",
    "text": "参考\n\n5. The import system — Python 3.10.5 documentation\n6. Modules — Python 3.10.5 documentation\nPython for the Lab | Complete Guide to Imports in Python: Absolute, Relative, and More\nPython 包内的导入问题（绝对导入和相对导入） - Anonymous596 - 博客园"
  },
  {
    "objectID": "posts/20230423-stirling/index.html",
    "href": "posts/20230423-stirling/index.html",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "",
    "text": "参考："
  },
  {
    "objectID": "posts/20230423-stirling/index.html#warm-up",
    "href": "posts/20230423-stirling/index.html#warm-up",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "1 Warm up",
    "text": "1 Warm up\n\n\n\n\n\n\n\nExample 1 求 \\[\n\\lim_{n \\to \\infty} \\frac{(2n-1)!!}{(2n)!!} = \\lim_{n \\to \\infty} \\frac{1 \\times 3 \\times 5 \\times \\dots \\times (2n-1)}{2 \\times 4 \\times 6 \\times \\dots \\times 2n}\n\\]\n\n\n\n\n\nSolution. 用放缩 \\[\n2k &gt; \\sqrt{(2k-1)(2k+1)}\n\\] 拆分母即得 \\[\n\\frac{(2n-1)!!}{(2n)!!} &lt; \\frac 1 {\\sqrt{2n+1}} \\sim 0\n\\]\n\n\n\n\n\n\n\n\nExample 2 (中心二项式系数) 求 \\[\n\\lim_{n \\to \\infty} \\frac{\\binom{2n}{n}}{2^{2n}}\n\\]\n\n\n\n\n\nSolution. \\[\n\\frac{\\binom{2n}{n}}{2^{2n}} = \\frac{(2n)!}{2^{2n} (n!)^2} = \\frac{(2n)!}{(2^n n!)^2} = \\frac{(2n)!}{((2n)!!)^2} = \\frac{(2n-1)!!}{(2n)!!} &lt; \\frac 1 {\\sqrt{2n+1}} \\sim 0\n\\]\n\n上两例有没有更精确的渐进估计？这便是我们马上要研究的问题．"
  },
  {
    "objectID": "posts/20230423-stirling/index.html#wallis-公式",
    "href": "posts/20230423-stirling/index.html#wallis-公式",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "2 Wallis 公式",
    "text": "2 Wallis 公式\n\n\n\n\n\n\n\nLemma 1 (Wallis 积分公式) 定积分系列 \\[\nJ_n = \\int_0^{\\frac \\pi 2} \\sin^n x \\operatorname{d}\\!x\n\\] 满足 \\[\n\\begin{aligned}\nJ_{2n} &= \\frac{(2n-1)!!}{(2n)!!} \\cdot \\frac \\pi 2 \\\\\nJ_{2n+1} &= \\frac{(2n)!!}{(2n+1)!!} \\cdot 1\n\\end{aligned}\n\\]\n\n\n\n\n\nProof. 我们的思路是：先把一个 \\(\\sin x\\) 放进微分中，然后分部积分得到递推式．\n\\[\n\\begin{aligned}\nJ_n &= \\int_0^{\\frac \\pi 2} \\sin^n x \\operatorname{d}\\!x \\\\\n&= - \\int_0^{\\frac \\pi 2} \\sin^{n-1} x \\operatorname{d}\\!\\cos x \\\\\n&= \\left[ - \\sin^{n-1} x \\cos x \\right]_{0}^{\\frac \\pi 2} + \\int_0^{\\frac \\pi 2} \\cos x \\operatorname{d}\\!\\sin^{n-1} x \\\\\n&= (n-1) \\int_0^{\\frac \\pi 2} \\cos^2 x \\sin^{n-2} x \\operatorname{d}\\!x \\\\\n&= (n-1) \\int_0^{\\frac \\pi 2} (1 - \\sin^2 x) \\sin^{n-2} x \\operatorname{d}\\!x \\\\\n&= (n-1) \\int_0^{\\frac \\pi 2} \\sin^{n-2} x \\operatorname{d}\\!x - (n-1) \\int_0^{\\frac \\pi 2} \\sin^n x \\operatorname{d}\\!x \\\\\n&= (n-1) J_{n-2} - (n-1) J_n\n\\end{aligned}\n\\]\n故 \\[\nJ_n = \\frac{n-1}{n} J_{n-2}\n\\] 边界条件 \\[\n\\begin{aligned}\nJ_0 &= \\frac \\pi 2 \\\\\nJ_1 &= \\int_0^{\\frac \\pi 2} \\sin x \\operatorname{d}\\!x = 1\n\\end{aligned}\n\\] 代入递推式求解就得到了要证的结论．\n\n\n\n\n\n\n\n\nTheorem 1 (Wallis 公式) \\[\n\\frac \\pi 2 = \\lim_{n \\to \\infty} \\frac 1 {2n+1} \\left( \\frac{(2n)!!}{(2n-1)!!} \\right)^2\n\\]\n\n\n\n\n\nProof. 注意到在积分区间上，\\(\\sin^n x \\geq \\sin^{n+1} x\\)，由积分的单调性，\\(J_n\\) 随 \\(n\\) 单调递减，故 \\(J_{2n+1} \\leq J_{2n} \\leq J_{2n-1}\\) 成立．代入 Lemma 1 中得到的结果 \\[\n\\frac{(2n)!!}{(2n+1)!!} \\leq \\frac{(2n-1)!!}{(2n)!!} \\cdot \\frac \\pi 2 \\leq \\frac{(2n-2)!!}{(2n-1)!!}\n\\] 移项得 \\[\n\\left( \\frac{(2n)!!}{(2n-1)!!} \\right)^2 \\frac{1}{2n+1} \\leq \\frac \\pi 2 \\leq \\left( \\frac{(2n)!!}{(2n-1)!!} \\right)^2 \\frac 1 {2n}\n\\]\n现在只需说明 RHS 与 LHS 的差是一个无穷小． \\[\n\\begin{aligned}\n\\left( \\frac{(2n)!!}{(2n-1)!!} \\right)^2 \\left( \\frac 1 {2n} - \\frac 1 {2n+1}  \\right)\n&= \\left( \\frac{(2n)!!}{(2n-1)!!} \\right)^2 \\left( \\frac 1 {2n(2n+1)} \\right) \\\\\n&= \\left( \\frac{(2n-2)!!}{(2n-1)!!} \\right)^2 \\frac {2n}{(2n+1)}\n\\end{aligned}\n\\] 由 Example 1 ，\\(\\lim_{n \\to \\infty} \\frac{(2n-2)!!}{(2n-1)!!} = 0\\)，故上式确为一个无穷小，定理得证．\n\nWallis 公式还有其它表现形式： \\[\n\\frac{2^{2n}}{\\binom{2n}{n}} = \\frac{(2n)!!}{(2n-1)!!} \\sim \\sqrt{\\pi n} \\pod{n \\to \\infty}\n\\] 这里 Wallis 公式反映为对 Example 1 和 Example 2 的渐进估计．\n\n\n\n\n\n\n\nExercise 1 对 Catalan 数 \\[\nC_n = \\binom{2n}{n} - \\binom{2n}{n+1}\n\\] 做出渐进估计．\n\n\n\n\n\nSolution. 注意到 \\[\nC_n = \\binom{2n}{n} - \\binom{2n}{n+1} = \\binom{2n}{n} - \\frac n {n+1} \\binom{2n}{n} = \\frac 1 {n+1} \\binom{2n}{n}\n\\] 用 Wallis 公式计算即得 \\[\nC_n \\sim \\frac {2^{2n}}{\\sqrt{\\pi} n^{\\frac 3 2}}\n\\]\n\nWallis 公式的另一种表现形式是 \\[\n\\frac \\pi 2 = \\prod_{n=1}^\\infty \\frac{4 n^2}{4 n^2-1} = \\prod_{n=1}^\\infty \\left( \\frac{2n}{2n-1} \\cdot \\frac{2n}{2n+1} \\right)\n\\] 这表达式也被称为 Wallis product，用于近似计算 \\(\\pi\\)．\n\nRemark. 这和我们在 Example 1 中使用的放缩技巧……"
  },
  {
    "objectID": "posts/20230423-stirling/index.html#stirling-公式",
    "href": "posts/20230423-stirling/index.html#stirling-公式",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "3 Stirling 公式",
    "text": "3 Stirling 公式\n\n\n\n\n\n\n\nLemma 2 \\[\n\\left( 1+\\frac 1 n \\right)^n &lt; e &lt; \\left( 1 + \\frac 1 n \\right)^{n+1}\n\\]\n\n\n\n\n这是《数学分析 I》中大家所熟知的．\n\n\n\n\n\n\n\nTheorem 2 \\[\n\\left(\\frac n e \\right)^n &lt; \\frac {n!} e\n&lt; n \\left( \\frac n e \\right)^n\n\\]\n\n\n\n\n\nProof. 将 Lemma 2 写成 \\[\n\\frac{(n+1)^n}{n^n} &lt; e &lt; \\frac{(n+1)^{n+1}}{n^{n+1}}\n\\] 对 \\(k = 1,2, \\dots, n-1\\) 做连乘 \\[\n\\prod_{k=1}^{n-1} \\frac{(k+1)^k}{k^k} &lt; e^{n-1} &lt; \\prod_{k=1}^{n-1} \\frac{(k+1)^{k+1}}{k^{k+1}}\n\\] 注意到乘积的相邻两项中，前一项的分子与后一项的分母可以约分，中间每项只余下 \\(\\frac 1 k\\)，故上式可化为 \\[\n\\frac{n^{n-1}}{(n-1)!} &lt; e^{n-1} &lt; \\frac{n^n}{(n-1)!}\n\\] 两端再同乘 \\(\\frac{n!}{e^{n}}\\) 就得到 \\[\n\\left(\\frac n e \\right)^n &lt; \\frac {n!} e\n&lt; n \\left( \\frac n e \\right)^n\n\\]\n\n\n\n\n\n\n\n\nTheorem 3 (Stirling 公式) \\[\nn! \\sim \\sqrt{2 \\pi n} \\left( \\frac n e \\right)^n \\pod{n \\to \\infty}\n\\]\n\n\n\n\n完整证明较复杂，这里介绍证明最后一步：已知 \\(n! \\sim a \\sqrt n \\left( \\frac n e \\right)^n\\)，用 Wallis 公式对 \\(2^{2n} / \\binom{2n}{n}\\) 的渐进估计确定系数 \\(a\\)．\n\\[\n\\sqrt{\\pi n} \\sim \\frac {2^{2n}}{\\binom{2n}{n}} = \\frac{2^{2n} (n!)^2}{(2n)!} \\sim \\frac{2^{2n} (a \\sqrt n n^n e^{-n})^2}{a \\sqrt{2n} 2^{2n} n^{2n} e^{-2n}} = \\sqrt{\\frac n 2} a\n\\]\n因此 \\(a=\\sqrt{2 \\pi}\\)．\n\n\n\n\n\n\n\nExample 3 当 \\(n \\to \\infty\\)，\\(k \\to \\infty\\) 时，用 Stirling 公式渐进估计 \\(\\binom n k\\)．\n\n\n\n\n\nSolution. \\[\n\\binom n k \\sim \\sqrt{\\frac{n}{2 \\pi k (n-k)}} \\frac{n^n}{k^k (n-k)^{n-k}}\n\\]"
  },
  {
    "objectID": "posts/20230423-stirling/index.html#poisson-分布",
    "href": "posts/20230423-stirling/index.html#poisson-分布",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "4 Poisson 分布",
    "text": "4 Poisson 分布\n描述单位时间平均发生次数恒定的随机事件的概率分布．\n\n\n\n\n\n\n\nDefinition 1 (Poisson 分布) 若离散随机变量 \\(X\\) 满足 \\[\nP(X = k) = \\frac{\\lambda^k}{k!}e^{-\\lambda}\n\\] 其中 \\(\\lambda &gt; 0\\) 是确定的常数，则随机变量 \\(X\\) 服从 Poisson 分布．\n\n\n\n\n\n4.1 从二项分布的推导\n在 \\(np = \\lambda\\) 的条件下，取 \\(P(X_n = k) = \\binom n k p^k (1-p)^{n-k}\\) 在 \\(n \\to \\infty\\) 在 \\(n \\to \\infty\\) 上的逐点极限．\n\\[\n\\begin{aligned}\nP(X_n = k)\n&= \\binom{n}{k} p^k (1-p)^{n-k} \\\\\n&= \\binom{n}{k} \\frac{\\lambda^k}{n^k} \\left( 1-\\frac \\lambda n \\right)^{n-k} \\\\\n&= \\lambda^k \\left( 1-\\frac \\lambda n \\right)^n \\left( 1-\\frac \\lambda n \\right)^{-k} \\binom{n}{k} \\frac{1}{n^k} \\\\\n&\\sim \\lambda^k e^{-\\lambda}\\binom{n}{k} \\frac 1 {n^k} \\\\\n&= \\lambda^k e^{-\\lambda} \\frac {n (n-1) \\dots (n-k+1)}{k! n^k} \\\\\n&= \\frac{\\lambda^k}{k!} e^{-\\lambda} \\cdot 1 \\cdot (1-\\frac 1 n) \\dots (1 - \\frac{k-1}{n}) \\\\\n&\\sim \\frac{\\lambda^k}{k!} e^{-\\lambda}\n\\end{aligned}\n\\]\n\n\n4.2 归一性验证\n\\[\n\\sum_{k=0}^{+\\infty} P(X = k) = \\sum_{k=0}^{+\\infty} \\frac{\\lambda^k}{k!}e^{-\\lambda} =  e^{-\\lambda} \\sum_{k=0}^{+\\infty} \\frac{\\lambda^k}{k!} = e^{-\\lambda} e^{\\lambda} = 1\n\\]"
  },
  {
    "objectID": "posts/20230423-stirling/index.html#正态分布",
    "href": "posts/20230423-stirling/index.html#正态分布",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "5 正态分布",
    "text": "5 正态分布\n与 Poisson 分布不同，（标准）正态分布是在 \\(n \\to \\infty\\) 的过程中假定 \\(p\\) 不变的情况下，对归一化（即假定期望和方差不变）后的 \\(X_n\\) 取逐点极限得到的．\n\n\n\n\n\n\n\nDefinition 2 (正态分布) 若连续随机变量 \\(X\\) 的期望 \\(E(X) = \\mu\\)，方差 \\(D(X) = \\sigma\\)，且其概率分布函数为 \\[\nf(x) = \\frac 1 {\\sqrt{2 \\pi} \\sigma} \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right)\n\\] 则变量 \\(X\\) 服从正态分布，记为 \\(X \\sim N(\\mu, \\sigma^2)\\)．\n特别的，当 \\(\\mu = 0\\)，\\(\\sigma = 1\\) 时，变量 \\(X\\) 服从标准正态分布 \\[\nf(x) = \\frac 1 {\\sqrt{2 \\pi}} \\exp \\left(-\\frac{1}{2} x^2\\right)\n\\]\n\n\n\n\n\n5.1 从二项分布的推导（de Moivre-Laplace 定理）\n设随机变量 \\(X_n \\sim B(n,p)\\)．方便起见，令 \\(q = 1-p\\)．众所周知，二项分布的期望与方差满足 \\(E(X_n) = np\\)，\\(D(X_n) = npq\\)．\n对随机变量 \\(X_n\\) 做归一化： \\[\n\\bar X_n = \\frac{X_n - E(X_n)}{\\sqrt{D(X_n)}} = \\frac{X_n - np}{\\sqrt{npq}}\n\\] 考虑到 \\[\nP(\\bar X_n = x) = P(X_n = np + x \\sqrt{npq})\n\\] 令 \\(k = np + x \\sqrt{npq}\\)，则 \\[\nP(\\bar X_n = x) = P(X_n = k) = \\binom{n}{k} p^k q^{n-k}\n\\] 此时 \\(n,k\\) 均趋于无穷大，故可应用 Example 3 对二项式系数做出估计 \\[\n\\begin{aligned}\n\\binom{n}{k} p^k q^{n-k}\n&\\sim \\sqrt{\\frac{n}{2 \\pi k (n-k)}} \\frac{n^n}{k^k (n-k)^{n-k}} p^k q^{n-k} \\\\\n&= \\sqrt{\\frac{n}{2 \\pi k (n-k)}} \\left( \\frac{np}{k} \\right)^{k} \\left( \\frac{nq}{n-k} \\right)^{n-k} \\\\\n&= \\sqrt{\\frac{n}{2 \\pi k (n-k)}} \\exp{\\left( k \\ln{\\frac{np}{k}} + (n-k) \\ln{\\frac{nq}{n-k}} \\right)}\n\\end{aligned}\n\\]\n下面分别处理 \\(k \\ln{\\frac{np}{k}}\\) 和 \\((n-k) \\ln{\\frac{nq}{n-k}}\\)．\n\\[\n\\begin{aligned}\nk \\ln{\\frac{np}{k}}\n&= -(np + x \\sqrt{npq}) \\ln{\\frac{np + x \\sqrt{npq}}{np}} \\\\\n&= -(np + x \\sqrt{npq}) \\ln{\\left( 1 + x \\sqrt{\\frac q {np}} \\right)} \\\\\n&= -(np + x \\sqrt{npq}) \\left( x \\sqrt{\\frac q {np}} - \\frac{x^2 q}{2np} + o\\left( \\frac 1 n \\right) \\right) \\\\\n&= -x \\sqrt{npq} + \\frac{1}{2} x^2 q - x^2 q + o(1)\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n(n-k) \\ln{\\frac{nq}{n-k}}\n&= -(nq - x \\sqrt{npq}) \\ln{\\frac{nq - x \\sqrt{npq}}{nq}} \\\\\n&= -(nq - x \\sqrt{npq}) \\ln{\\left( 1 - x \\sqrt{\\frac p {nq}} \\right)} \\\\\n&= (nq - x \\sqrt{npq}) \\left( x \\sqrt{\\frac p {nq}} + \\frac{x^2 p}{2nq} + o\\left( \\frac 1 n \\right) \\right) \\\\\n&= x \\sqrt{npq} + \\frac{1}{2} x^2 p - x^2 p + o(1)\n\\end{aligned}\n\\]\n因此 \\[\nk \\ln{\\frac{np}{k}} + (n-k) \\ln{\\frac{nq}{n-k}} = - \\frac{1}{2} x^2 (p+q) + o(1) = - \\frac 1 2 x^2 + o(1)\n\\]\n下面处理 \\(\\sqrt{\\frac{n}{2 \\pi k (n-k)}}\\)．\n\\[\n\\begin{aligned}\n\\sqrt{\\frac{n}{2 \\pi k (n-k)}}\n&= \\sqrt{\\frac{n}{2 \\pi (np + x \\sqrt{npq}) (nq - x \\sqrt{npq})}} \\\\\n&= \\sqrt{\\frac{1}{2 \\pi (p + x \\sqrt{\\frac{pq}{n}}) (q - x \\sqrt{\\frac{pq}{n}})}} \\\\\n&= \\sqrt{\\frac{1}{2 \\pi n p q + o(1)}}\n\\end{aligned}\n\\]\n将上述结果代回，我们就得到 \\[\n\\begin{aligned}\n\\binom{n}{k} p^k q^{n-k}\n&\\sim \\sqrt{\\frac{1}{2 \\pi n p q + o(1)}} \\exp{\\left( - \\frac 1 2 x^2 + o(1) \\right)} \\\\\n&\\sim \\frac{1}{\\sqrt{2 \\pi n p q}} \\exp{\\left( - \\frac 1 2 x^2 \\right)}\n\\end{aligned}\n\\] 即 \\[\nP(\\bar X_n = x) = P(X_n = k) \\sim \\frac 1 {\\sqrt{2 \\pi npq}} \\exp \\left( -{\\frac 1 2 x^2} \\right) = \\frac 1 {\\sqrt{2 \\pi npq}} \\exp \\left( -\\frac{(k-np)^2}{2npq} \\right)\n\\] 这正是我们想要的．\n\nRemark. 细心的同学可能会对式子前边的系数仍是 \\(n \\to \\infty\\) 时的无穷小产生疑问．事实上，在将 \\(X_n\\) 归一化为 \\(\\bar X_n\\) 的过程中，我们将整个变量“压缩”至原来的 \\(\\frac{1}{\\sqrt{npq}}\\)，因此前面的系数可以理解为一种类似 \\(\\operatorname{d}\\!x\\) 的存在．关于归一化的直观理解，3Blue1Brown 的中心极限定理视频[3]提供了很好的讲解．\n更形式化的，由于归一化得到的离散型随机变量 \\(\\bar X_n\\) 在 \\(n \\to \\infty\\) 的过程中已经变成连续型随机变量 \\(X\\)，我们研究的对象也应从单点转向区间．因此，对 \\(X_n\\) 与 \\(\\bar X_n\\) 概率分布的叙述做一点变动 \\[\nP\\left(x \\leq \\bar X_n &lt; x + \\frac 1 {\\sqrt{npq}}\\right)\n= P\\left(k \\leq X_n &lt; k + 1 \\right)\n= P(X_n=k) \\sim \\frac 1 {\\sqrt{2 \\pi npq}} \\exp \\left( -{\\frac 1 2 x^2} \\right)\n\\] 令区间大小趋于 \\(0\\) 就得到 \\[\n\\begin{aligned}\nf(x) &= \\lim_{h \\to 0}{\\frac{P(x \\leq X &lt; x+h)}{h}} \\\\\n&=  \\lim_{n \\to \\infty} \\sqrt{npq} \\cdot P\\left(x \\leq \\bar X_n &lt; x + \\frac 1 {\\sqrt{npq}}\\right) \\\\\n&= \\lim_{n \\to \\infty} \\sqrt{npq} \\cdot \\frac 1 {\\sqrt{2 \\pi npq}} \\exp \\left( -{\\frac 1 2 x^2} \\right) & \\dots \\text{这里 $\\sim$ 表现为等价无穷小替换} \\\\\n&= \\frac 1 {\\sqrt{2 \\pi}} \\exp \\left( -{\\frac 1 2 x^2} \\right)\n\\end{aligned}\n\\] 这才是我们真正想要的，由二项分布归一化后取极限得到的，标准正态分布的概率密度函数．"
  },
  {
    "objectID": "posts/20230423-stirling/index.html#challenge",
    "href": "posts/20230423-stirling/index.html#challenge",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "6 Challenge",
    "text": "6 Challenge\n选讲或留作课后讨论．\n\n6.1 中心极限定理要求下正态分布的唯一性\n正态分布概率密度函数 \\(e^{-x^2}\\) 的形式是如何被确定的？怎么说明这形式是满足中心极限定理的独一无二的概率密度函数？\n3Blue1Brown 关于正态分布的系列视频较完整的解答了上述疑问，下面是推导思路的提纲．\n首先需要意识到，随机变量之和的概率分布即原变量概率密度函数的卷积．\n形式化的唯一性证明一般分为两步：\n\n使用 moment generating function 的方法证明，任一分布的概率密度函数的各次卷积所构成的函数列一定收敛，且收敛至的函数与初始选取的分布无关．\n验证正态分布概率密度函数的卷积仍有 \\(e^{-x^2}\\) 的形式．\n\n这是严谨但并不令人满意的．我们需要更“几何”化的理解来理解 \\(e^{-x^2}\\) 的这种唯一性，即为什么只有 \\(e^{-x^2}\\) 在卷积下具有形式不变性．（需要指出的是，3Blue1Brown 的系列视频中，下面部分的严谨性不够充分，有待进一步研究）\nHerschel-Maxwell derivation 指出，若二维概率分布满足以下两个条件：\n\n该分布具有各向同性，即该二维分布概率密度函数在某点处的取值只与该点离原点的距离有关\n分布关于 \\(x,y\\) 坐标轴独立，即该二维分布的概率密度函数可写为 \\(f(x)f(y)\\) 的形式．\n\n则一维情形下此分布的概率密度函数被唯一地确定为具有 \\(f(x) = e^{c x^2}\\) 的形式．当然需要假设 \\(f(x)\\) 连续，并在最后做归一化处理．\n两个随机变量 \\(X,Y\\) 的和 \\(X+Y\\) 的概率密度函数可被视为这两个随机变量的 Descartes 积 \\((X,Y)\\) 的二元概率密度函数“切片”并按面积（除掉 \\(\\sqrt 2\\) 的常数因子后）“投影”至 \\(y=-x\\) 上的结果．\n考虑中心极限定理．两个独立同分布变量相加，这已经满足了二维分布独立性的要求．若考虑要求卷积后形式不变，也有必要要求二维分布的各项同性（这样一来，沿 \\(y=-x\\) 方向的“切片”的形状与坐标轴向的“切片”只有一个常数因子 \\(\\sqrt 2\\) 的差别）．因此，中心极限定理某种意义上正好对应了 Herschel-Maxwell derivation 的要求，从而唯一确定了正态分布概率密度函数 \\(e^{-x^2}\\) 的形式．\n\n\n6.2 正态分布的归一性验证、Maxwell 速率分布与高维球体表面积\nGuass 积分： \\[\n\\int_{-\\infty}^{+\\infty} e^{-x^2} \\operatorname{d}\\!x = \\sqrt \\pi\n\\]\nMaxwell 速率分布： \\[\nf(v) = 4 \\pi v^2 \\left( \\frac{m}{2 \\pi kT} \\right)^{\\frac 3 2} \\exp \\left( - \\frac{m}{2kT}v^2 \\right)\n\\]\n以及它们与高维球体表面积的联系涉及多元积分学的内容．参见 3Blue1Brown 有关 \\(\\pi\\) 与正态分布的视频[4]．\n\n\n6.3 \\(n!\\) 的其它估计\n一种更容易想到的做法是 \\[\nn \\ln n - n - 1 = \\int_1^n \\ln x \\operatorname{d}\\!x \\leq\n\\ln n! = \\sum_{k=1}^n \\ln k\n\\leq \\int_1^{n+1} \\ln x \\operatorname{d}\\!x = (n+1) \\ln (n+1) - n - 2\n\\] 从而 \\[\n\\left( \\frac n e \\right)^n \\leq e \\cdot n! \\leq \\left(\\frac{n+1}{e}\\right)^{n+1}\n\\] 当然这比 Theorem 2 的估计稍差．\n更多估计可参考这篇文章[5]．\n\n\n6.4 Wallis 公式的其它证明\n3Blue1Brown 频道提供了一个几何风格的证明[6]，其与 Bassel 问题的 Euler 解法有着神秘的联系．事实上，Euler 对 \\(\\frac{\\sin x}{x}\\) 的无穷乘积拆解也可用于证明 Wallis product，参见 Wikipedia[7]．\n\n\n6.5 Wallis 公式视角下三阶乘与中心三项式系数的渐进估计\n\n\n\n\n\n\n\nExercise 2 求 \\[\n\\lim_{n \\to \\infty} \\frac{(3n-2)!!!}{(3n)!!!} = \\lim_{n \\to \\infty} \\frac{1 \\times 4 \\times 7 \\times \\dots \\times (3n-2)}{3 \\times 6 \\times 9 \\times \\dots \\times 3n}\n\\] 并对其做出渐进估计．\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 求 \\[\n\\lim_{n \\to \\infty} \\frac{(3n-1)!!!}{(3n)!!!} = \\lim_{n \\to \\infty} \\frac{2 \\times 5 \\times 8 \\times \\dots \\times (3n-1)}{3 \\times 6 \\times 9 \\times \\dots \\times 3n}\n\\] 并对其做出渐进估计．\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 求 \\[\n\\lim_{n \\to \\infty} \\frac{(3n)! / (n!)^3}{3^{3n}}\n\\] 并对其做出渐进估计．\n\n\n\n\n用 Stirling 公式计算得到的结果是 \\[\n\\frac{\\sqrt 3}{2 \\pi n}\n\\] 但在 Wallis 公式的视角下如何获得？"
  },
  {
    "objectID": "posts/20230423-stirling/index.html#acknowledgments",
    "href": "posts/20230423-stirling/index.html#acknowledgments",
    "title": "Wallis 公式、Stirling 公式与正态分布",
    "section": "7 Acknowledgments",
    "text": "7 Acknowledgments\n\n感谢吕老师组织我最喜欢的研讨课环节．此外，Example 1 的放缩技巧由“吸取教训”同学提供，Poisson 分布的二项分布推导是与“抱头蹲防”同学讨论的结果，在此表示感谢．"
  },
  {
    "objectID": "posts/20210817-jekyll-test/index.html",
    "href": "posts/20210817-jekyll-test/index.html",
    "title": "Jekyll 测试",
    "section": "",
    "text": "A post model.\nA link\n\n\n\na baka\n\n\n\n\nMath rendering is powered by \\(\\KaTeX\\)\n\n\n\n\\[\n\\TeX \\Rightarrow \\LaTeX \\Rightarrow \\KaTeX\n\\]"
  },
  {
    "objectID": "posts/20210817-jekyll-test/index.html#s-1",
    "href": "posts/20210817-jekyll-test/index.html#s-1",
    "title": "Jekyll 测试",
    "section": "",
    "text": "A post model.\nA link\n\n\n\na baka\n\n\n\n\nMath rendering is powered by \\(\\KaTeX\\)\n\n\n\n\\[\n\\TeX \\Rightarrow \\LaTeX \\Rightarrow \\KaTeX\n\\]"
  },
  {
    "objectID": "posts/20210817-jekyll-test/index.html#s-2",
    "href": "posts/20210817-jekyll-test/index.html#s-2",
    "title": "Jekyll 测试",
    "section": "2. Block",
    "text": "2. Block\n\n2.1. Blockquote\n\nThis is a blockquote.\n\n\n\n2.2. Code\n// c++ code\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nint main(){\n    scanf(\"%d%d\",a,b);\n    printf(\"%lld\",a+b);\n    return 0;\n}"
  },
  {
    "objectID": "posts/20230306-national-museum-tour/index.html",
    "href": "posts/20230306-national-museum-tour/index.html",
    "title": "国家博物馆兼东单良乡骑行一日游",
    "section": "",
    "text": "“来北京，当然要逛逛啊！”嘴上这么说，充实的学习生活却总能带来无数个宅在宿舍的理由。恰逢本学期思政课需亿点社会实践，国家博物馆乃官方推荐之所，而东可游长安街、王府井，南可观东交民巷，完成任务而了却游园之心，岂不美哉？虽开学未几，春景未至，然天气渐暖，今日不去，更待何时？不妨早做打算。遂与室友相约，周日出游。\n乘地铁至天安门东，一路罚站。当然毕竟是淡季，车上并不拥挤。惊奇地发现一号线已非昔日模样：站台已加装护栏，而列车的内饰也早已翻新。\n例行排队安检，上至天安门广场东侧。国家博物馆就在眼前，隔天安门广场与人民大会堂遥相呼应。馆子很大，上上下下一共六层，尚分南北两区，一整天或许也很难逛完，故我们只选取少量展馆参观。\n\n\n\n博物馆外侧\n\n\n展览当然是相当不错的，但具体说来却没啥好写。博物馆这种地方，始终还是得自己去看。常设的《复兴之路》展区是标准的《中国近现代史纲要》，最近也新开了新时代展区，但我们去的时候……空无一人……（逃）\n\n\n\n神州十三号返回舱（左）；复兴之路“新时代”展厅（右）\n\n\n总之，逛逛逛拍拍拍，出来已经一点半了。讨论一下，准备往东单走找地儿吃饭。走在东长安街的人行道上，公安部、生态环境部、长安俱乐部滚滚而来，赫赫有名的北京饭店也映入眼帘。\n\n\n\n挺敦实一栋楼\n\n\n王府井的人气似乎已经恢复了八成。我们并无兴致逛街，草草填饱肚子，往南向东交民巷前进。\n\n\n\n王府井步行街\n\n\n比起嘈杂的天安门广场，东交民巷可谓意外的宁静。从东侧进入东交民巷，街上行人三三两两，似乎都是本地居民。往东前进，法国邮政局、西班牙领事馆等欧式建筑在街边排列，但均未开放游览，亦无游客驻足。灰黑色的砖瓦在紧闭的大门后默默不语，枯树残影的映衬下略显凄凉。教堂倒是小有人气，时有新人在此拍摄婚纱。行至天安门广场前最后一个路口，有警卫把守，似乎已不得入内。查看地图，前面已是公安局地界。也许得从天安门广场方向步行进入才可进一步游览吧。（事后调查，不少使馆的入口其实在前门大街一侧，许多建筑也已商业运行，除外观保持原样外，已无太多历史可寻。）\n\n\n\n东交民巷的教堂\n\n\n室友突然提议骑回良乡——英雄所见略同啊（笑）。从学校骑至主城一直是我的计划之一，现在离天黑尚有三四小时光景，晚 7:00 之前骑回学校并无不可。已有一室友因事先行离开，另一位室友苦于舟车劳顿，计划地铁回程。于是和提议的室友开启了近 40km 的骑行之旅。\n已在东交民巷南边，我们没有选择卢沟桥路线，而是往京良路方向前进。二环可不小，出了前门公园，在狭窄的胡同间穿行，不一会就有点小累了。室友事后表示他没意识到 40km 的严重性（\n渐行至三、四环外。偶然拐离干道，驶入普通道路。路上房屋低矮，矮墙垛垛，货车辆辆，尘土飞扬，加之今日有霾，揉眼一看，好似来到某西部偏远地区的乡间小路上。偌大的北京城也有如此“土里土气”的地方……之前在房山线上看到的壮美秋景，似乎也不在本次路线之上。况且春天尚未到来，即使经过也别无二致吧。\n\n\n\n胡同、“乡道”与分界处\n\n\n至京良路。室友体力已下降不少，速度逐渐放缓。然而调高座椅、换用前脚掌蹬车的我似乎还能一战。室友表示你个山区居民怎么这么能蹬，虽然中途因未知原因迷路多绕出几公里的路程，最终还是在 7:00 之前赶回了学校。\n买了面包和咖啡匆匆赶去参加组会，坐下的瞬间，突然感觉如断电般困倦……"
  },
  {
    "objectID": "posts/20201204-catalan/index.html",
    "href": "posts/20201204-catalan/index.html",
    "title": "卡特兰数 题解",
    "section": "",
    "text": "bsoj7107 ，来源不明。\n\n卡特兰数\n题目描述\n今天，接触信息学不久的小A刚刚学习了卡特兰数。\n卡特兰数的一个经典定义是，将 \\(n\\) 个数依次入栈，合法的出栈序列个数。\n小A觉得这样的情况太平凡了。于是，他给出了 \\(m\\) 组限制，每个限制形如 \\((f_i,g_i)\\) ，表示 \\(f_i\\) 不能在 \\(g_i\\) 之后出栈。\n他想求出：在满足了这 \\(m\\) 组限制的前提下，共有多少个合法的出栈序列。他不喜欢大数，你只需要求出答案在模 \\(998244353\\) 意义下的值即可。\n输入格式\n输入第一行为两个非负整数 \\(n\\) 、 \\(m\\) ，含义题面已给出。\n接下来 \\(m\\) 行，每行两个正整数， \\((f_i,g_i)\\) 表示一组限制。\n输出格式\n输出一行，为一个非负整数，表示你求得的答案 \\(\\mod 998244353\\) 。\n样例输入\n3 1\n2 3\n样例输出\n3\n样例解释\n可以验证 \\(\\{1,2,3 \\}\\) ， \\(\\{2,1,3 \\}\\) ， \\(\\{2,3,1 \\}\\) 都是合乎条件的。\n数据规模\n\\(n \\le 300\\) , \\(m \\le \\frac{n(n-1)}{2}\\) , \\(f_i,g_i \\le n\\) 。\n部分数据的 \\(m\\) 较小。\n\n考前一天写题解会不会涨RP\n套路但是还是感觉很巧妙的转换。关键在于把限制形式化的写出来方便观察。\n考虑Catalan数的递推公式推导方式——枚举最后出栈的元素 \\(k\\) 。其递推式为 \\[\n\\begin{aligned}\nc_0 &= 1 \\\\\nc_n &= \\sum_{k=1}^n c_{k-1} c_{n-k}\n\\end{aligned}\n\\] 加入限制后无法使用排列的相对顺序dp，故需改造原来的递推。定义 \\(h_{l,r}\\) 为排列 \\([l,r]\\) 不同的出栈序列方案数，若暂不考虑限制，有 \\[\nh_{l,r} = \\sum_{k=l}^r h_{l,k-1} h_{k+1,r}\n\\] 显然 \\(c_n = h_{1,n}\\) 。\n递推中，出栈序列的相对顺序为 \\(([l,k-1],[k+1,r],\\{ k \\})\\) 。限制 \\((f_i, g_i)\\) 要求 \\(f_i\\) 在 \\(g_i\\) 之前出栈。故满足 \\(g_i \\in [l,k-1], \\ f_i \\in [k,r]\\) 或者 \\(g_i \\in [k+1,r], \\ f_i = k\\) 的 \\(k\\) 都不合法，不应对 \\(h_{l,r}\\) 产生贡献。故在此dp中枚举所有限制判断合法性即可获得 \\(O(n^3 m)\\) 的算法。\n这种方法看着就很naive，考虑优化合法性判断。容易发现把 \\((f_i,g_i)\\) 投到二维平面上后，判断合法性只需询问 \\((k,l) - (r,k-1)\\) 、 \\((k,k+1) - (k,r)\\) 两个矩形中是否有点。二维前缀和处理即可 \\(O(1)\\) 判断。于是这样就可以 \\(O(n^3)\\) 通过本题了。\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\ntypedef long long ll;\nll Rd(){\n    ll ans=0;bool fh=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9'){if(c=='-') fh=1; c=getchar();}\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    if(fh) ans=-ans;\n    return ans;\n}\nconst ll MOD=998244353;\n#define _ %MOD\nll PMod(ll x){\n    if(x&gt;=MOD) return x-MOD;\n    else if(x&lt;0) return x+MOD;\n    else return x;\n}\n\nconst ll MXN=305;\nll N,M;\nll A[MXN][MXN];\nll S[MXN][MXN];\nvoid SpawnSum(){\n    for(ll i=1;i&lt;=N;i++)\n        for(ll j=1;j&lt;=N;j++)\n            S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+A[i][j];\n}\nbool Check(ll x1,ll y1,ll x2,ll y2){\n    return S[x2][y2]-S[x1-1][y2]-S[x2][y1-1]+S[x1-1][y1-1];\n}\nll f[MXN][MXN];\nvoid Solve(){\n    for(ll i=0;i&lt;=N;i++) f[i+1][i]=1;\n    for(ll len=1;len&lt;=N;len++){\n        for(ll l=1;l+len-1&lt;=N;l++){\n            ll r=l+len-1;\n            for(ll k=l;k&lt;=r;k++){\n                if(Check(k,l,r,k-1)) continue;\n                if(Check(k,k+1,k,r)) continue;\n                f[l][r]=(f[l][r]+f[l][k-1]*f[k+1][r])_;\n            }\n        }\n    }\n    cout&lt;&lt;f[1][N];\n}\nint main(){\n    N=Rd();M=Rd();\n    for(ll i=0;i&lt;=N;i++) for(ll j=0;j&lt;=N;j++) A[i][j]=S[i][j]=0;\n    for(ll i=1;i&lt;=M;i++){\n        ll x=Rd(),y=Rd();\n        A[x][y]=1;\n    }\n    SpawnSum();\n    Solve();\n    return 0;\n}"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html",
    "href": "posts/20221223-quarto-test/index.html",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "",
    "text": "具体使用方法参见 sun123zxy/sunquartex．"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#前言",
    "href": "posts/20221223-quarto-test/index.html#前言",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "",
    "text": "具体使用方法参见 sun123zxy/sunquartex．"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#文章结构测试",
    "href": "posts/20221223-quarto-test/index.html#文章结构测试",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "2 文章结构测试",
    "text": "2 文章结构测试\n这一节测试文章结构．\n\n2.1 文章分节\n非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．\n\n文章分分节\nQuarto 支持交叉引用．比如这一节的标题就已经被打上了标签．\n\n分分分节\n本节中我们测试交叉引用 小节 2.1.1．\n\n分分分分节\n这是最小的一级了．"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#图片表格列表测试",
    "href": "posts/20221223-quarto-test/index.html#图片表格列表测试",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "3 图片、表格、列表测试",
    "text": "3 图片、表格、列表测试\n这是 Quarto 的图标．\n\n\n\n\n\n\n图 1: 这是一张插图\n\n\n\n交叉引用 图 1 当然也是可以的．\n这是一个紧凑列表．\n\n自反性．\n反对称性一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．\n传递性．\n\n这是一个宽松列表．\n\n自反性．\n反对称性一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．\n还多加了一段．\n传递性．\n\n这是一个定义列表．\n\n自反性\n\n\\(a \\sim a\\)\n\n反对称性\n\n\\(a \\leq b \\land b \\leq a \\implies a=b\\)\n\n传递性\n\n\\(a \\leq b \\land b \\leq c \\implies a \\leq c\\)\n\n\n当然也可以使用 Markdown 表格．例如 表 1 (a).\n多表格并列．加上 表 1 (b)，它们共同组成了 表 1．\n\n\n\n\n\n\n\n\n\n\n\n\\(L_i \\times C_j\\)\n\\(2\\)\n\\(\\mathbb N\\)\n\\(\\mathbb R\\)\n\n\n\\(2\\)\n\\(4\\)\n\\(\\mathbb N\\)\n\\(\\mathbb R\\)\n\n\n\\(\\mathbb N\\)\n\\(\\mathbb N\\)\n\\(\\mathbb N\\)\n?\n\n\n\\(\\mathbb R\\)\n\\(\\mathbb R\\)\n?\n\\(\\mathbb R\\)\n\n\n\n\n\n(a) 笛卡尔积\n\n\n\n\n\n\n\n\n\n\n\n\\(L_i^{C_j}\\)\n\\(2\\)\n\\(\\mathbb N\\)\n\\(\\mathbb R\\)\n\n\n\\(2\\)\n\\(4\\)\n\\(\\mathbb R\\)\n\\(2^{\\mathbb R}\\)\n\n\n\\(\\mathbb N\\)\n\\(\\mathbb N\\)\n?\n?\n\n\n\\(\\mathbb R\\)\n\\(\\mathbb R\\)\n?\n?\n\n\n\n\n\n(b) 集合幂\n\n\n\n\n\n\n\n表 1: 相关集合的势（不完整版）"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#数学公式定理系统测试",
    "href": "posts/20221223-quarto-test/index.html#数学公式定理系统测试",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "4 数学公式、定理系统测试",
    "text": "4 数学公式、定理系统测试\n这一节我们测试数学相关内容．直接在源文件中写 raw LaTeX 就可声明公式所需的宏定义．由于 \\DeclareMathOperator 只能在 LaTeX 的导言区使用，这里我们用 \\newcommand + \\operatorname 的方式替代．\n下面的公式使用了上面定义的 macro． \\[\n\\operatorname{ran}A := \\{ y \\mid (x,y) \\in A \\}\n\\]\n两个集合 \\(A, B\\) 的笛卡尔积定义为 \\[\nA \\times B = \\{\\langle x,y \\rangle \\mid x \\in A \\land y \\in B \\}\n\\]\n显然，笛卡尔积不满足交换律和结合律. 在势的视角下，它的表现如何呢？\n\n\n\n\n\n\n\n定理 1 (笛卡尔积的保势性) 这是一个有 caption 的定理.\n\\[\nA \\preccurlyeq C \\land B \\preccurlyeq D \\implies A \\times B \\preccurlyeq C \\times D\n\\]\n\n\n\n\n\n证明. 建立单射 \\[\n\\begin{aligned}\n\\varphi: A \\times B &\\to C \\times D \\\\\n\\langle x,y \\rangle &\\mapsto \\langle f(x), g(y) \\rangle\n\\end{aligned}\n\\] 即可，其中 \\(f\\) 和 \\(g\\) 是由 \\(A \\preccurlyeq C\\) 和 \\(B \\preccurlyeq D\\) 确定的单射.\n\n\n\n\n\n\n\n\n推论 1 等势意义下可用等势的集合替换参与笛卡尔积运算的集合，即 \\[\nA \\approx C \\land B \\approx D \\implies A \\times B \\approx C \\times D\n\\]\n这是一个没有 caption 的定理.\n\n\n\n\n\n\n\n\n\n\n\n例 1 证明 \\[\n\\mathbb R \\times \\mathbb N \\approx \\mathbb N \\times \\mathbb R \\approx \\mathbb R\n\\]\n\n\n\n\n\n证明. 利用 定理 1 对 \\(\\mathbb R \\times 2\\) 和 \\(\\mathbb R \\times \\mathbb R\\) 夹逼，立刻得到 \\[\n\\mathbb R \\approx \\mathbb R \\times 2 \\preccurlyeq \\mathbb R \\times \\mathbb N \\preccurlyeq \\mathbb R \\times \\mathbb R \\approx \\mathbb R\n\\implies \\mathbb R \\times \\mathbb N \\approx \\mathbb N \\times \\mathbb R \\approx \\mathbb R\n\\]\n\n\n解. 这是一个解．\n\n\n注记. 这是一个注记．"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#数据可视化table-figure-diagram",
    "href": "posts/20221223-quarto-test/index.html#数据可视化table-figure-diagram",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "5 数据可视化（Table, Figure & Diagram）",
    "text": "5 数据可视化（Table, Figure & Diagram）\nQuarto 的另一大卖点．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nfig.patch.set_alpha(0)\nax.patch.set_alpha(0)\n\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n图 2: A line plot on a polar axis\n\n\n\n\n\n交叉引用 图 2 当然也是可以的.\n这里再测试一些较复杂的并列效果．（表 2, 表 2 (a), 表 2 (b), 图 3, 图 3 (a), 图 3 (b)）\n\n\nCode\nimport numpy as np\nimport math\nfrom IPython.display import Markdown, display\nfrom tabulate import tabulate\nimport matplotlib.pyplot as plt\n\nR = np.array([0,100,200,300,400,500,600,700,800,900,1000,\n1100,1110,1120,1130,1140,1150,1160,1170,1180,1190,\n1200,1210,1220,1230,1240,1250,1260,1270,1280,1290,\n1300,1400,1500,2000,4000,math.inf])\nU = np.array([24.2E-3, 0.386,0.747,1.104,1.460,1.813,2.16,2.51,2.86,3.19,3.48,\n3.70,3.75,3.77,3.78,3.80,3.81,3.83,3.84,3.85,3.86,\n3.87,3.90,3.92,3.93,3.94,3.95,3.95,3.96,3.97,3.98,\n3.99,4.08,4.16,4.39,4.66,4.85])\nI = np.array([3.6,3.6,3.6,3.6,3.6,3.5,3.5,3.5,3.5,3.5,3.4,\n3.3,3.4,3.4,3.4,3.4,3.3,3.3,3.3,3.3,3.3,\n3.2,3.2,3.2,3.2,3.2,3.2,3.2,3.1,3.1,3.1,\n3.0,2.9,2.7,2.2,1.130,47.7E-3])\nP = U*I\n\n\n\nCode\ntable = [[R[i], U[i], I[i], P[i]] for i in list(range(0, 11)) + [11,21,31,32,33,34,35,36]]\ndisplay(Markdown(tabulate(table, headers=[\"R (Ω)\", \"U (V)\", \"I (mA)\", \"P (mW)\"])))\ntable = [[R[i], U[i], I[i], P[i]] for i in range(12, 31)]\ndisplay(Markdown(tabulate(table, headers=[\"R (Ω)\", \"U (V)\", \"I (mA)\", \"P (mW)\"])))\n\n\n\n\n\n\n\n\n\n\n\n\nR (Ω)\nU (V)\nI (mA)\nP (mW)\n\n\n\n\n0\n0.0242\n3.6\n0.08712\n\n\n100\n0.386\n3.6\n1.3896\n\n\n200\n0.747\n3.6\n2.6892\n\n\n300\n1.104\n3.6\n3.9744\n\n\n400\n1.46\n3.6\n5.256\n\n\n500\n1.813\n3.5\n6.3455\n\n\n600\n2.16\n3.5\n7.56\n\n\n700\n2.51\n3.5\n8.785\n\n\n800\n2.86\n3.5\n10.01\n\n\n900\n3.19\n3.5\n11.165\n\n\n1000\n3.48\n3.4\n11.832\n\n\n1100\n3.7\n3.3\n12.21\n\n\n1200\n3.87\n3.2\n12.384\n\n\n1300\n3.99\n3\n11.97\n\n\n1400\n4.08\n2.9\n11.832\n\n\n1500\n4.16\n2.7\n11.232\n\n\n2000\n4.39\n2.2\n9.658\n\n\n4000\n4.66\n1.13\n5.2658\n\n\ninf\n4.85\n0.0477\n0.231345\n\n\n\n\n\n(a) （粗）\n\n\n\n\n\n\n\n\n\n\n\nR (Ω)\nU (V)\nI (mA)\nP (mW)\n\n\n\n\n1110\n3.75\n3.4\n12.75\n\n\n1120\n3.77\n3.4\n12.818\n\n\n1130\n3.78\n3.4\n12.852\n\n\n1140\n3.8\n3.4\n12.92\n\n\n1150\n3.81\n3.3\n12.573\n\n\n1160\n3.83\n3.3\n12.639\n\n\n1170\n3.84\n3.3\n12.672\n\n\n1180\n3.85\n3.3\n12.705\n\n\n1190\n3.86\n3.3\n12.738\n\n\n1200\n3.87\n3.2\n12.384\n\n\n1210\n3.9\n3.2\n12.48\n\n\n1220\n3.92\n3.2\n12.544\n\n\n1230\n3.93\n3.2\n12.576\n\n\n1240\n3.94\n3.2\n12.608\n\n\n1250\n3.95\n3.2\n12.64\n\n\n1260\n3.95\n3.2\n12.64\n\n\n1270\n3.96\n3.1\n12.276\n\n\n1280\n3.97\n3.1\n12.307\n\n\n1290\n3.98\n3.1\n12.338\n\n\n\n\n\n(b) （细）\n\n\n\n\n\n\n\n表 2: 太阳能电池的负载特性\n\n\n\n\nCode\nfig, ax = plt.subplots()\nfig.patch.set_alpha(0)\nax.patch.set_alpha(0)\n\nax.set_xlabel(\"U (V)\")\nax.set_ylabel(\"I (mA)\")\n\nax.plot(U, I, marker=\"o\")\nax.grid(True)\nax.set_xlim(0)\nax.set_ylim(0)\n\nplt.show()\n\n\nfig, ax = plt.subplots()\nfig.patch.set_alpha(0)\nax.patch.set_alpha(0)\n\nax.set_xlabel(\"R (Ω)\")\nax.set_ylabel(\"P (mW)\")\n\nax.plot(R, P, marker=\"o\")\nax.grid(True)\nax.set_xlim((0, 2000))\nax.set_ylim(0)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n(a) 输出电流与电压关系曲线\n\n\n\n\n\n\n\n\n\n\n\n(b) 输出功率与负载电阻关系曲线\n\n\n\n\n\n\n\n图 3: 太阳能电池的负载特性"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#diagrams",
    "href": "posts/20221223-quarto-test/index.html#diagrams",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "6 Diagrams",
    "text": "6 Diagrams\nQuarto 原生支持使用 GraphViz 或 Mermaid 绘制有向图或流程图．我们还额外支持 TikZ / tikzcd 的渲染！\n\n\n\n\n\n\n\n\n\nC\n[\nx\n]\n离散\nFourier\n变换\nC\nC\nf\n(\nx\n)\n∑\nn\n−\n1\ni\n=0\na\ni\nx\ni\n(\nf\n(\nω\nk\n))\nn\n−\n1\nk\n=0\n(\nfg\n)(\nx\n)\n∑\nn\n−\n1\nk\n=0\nx\nk\n∑\ni\n+\nj\n=\nk\na\ni\nb\nj\n(\nf\n(\nω\nkn\n)\ng\n(\nω\nkn\n))\nn\n−\n1\nk\n=0\ng\n(\nx\n)\n∑\nn\n−\n1\nj\n=0\nb\nj\nx\nj\n(\ng\n(\nω\nk\n))\nn\n−\n1\nk\n=0\n\n\nDFT\n\n\n\n\n\n\nDFT\n-1\n\n\nDFT\n\n\n\n\n\n\n\n\n\n图 4: 带中文的 tikzcd 测试图片\n\n\n\n\n\n\n\n\n\n\n\n\nB\nA\n⇝\nB\nA\n\n\n\ng\n\n\nf\n\n\nh\n\n\nh\n\n\nf\n\n\n\nα\n\n\n\nβ\n\n\n\nβ\n◦\n1\nα\n\n\n\n\n\n图 5: quiver 风格的 tikzcd 测试图片\n\n\n\n\n\n\n\n\n\n\n\n\nR\n[\nx\n]\nR\nC\nR\n[\nx\n]/\n(∏\nc\n∈\nC\n(\nx\n−\nc\n)\n)\n\n\nφ\n\n\n\n\n¯\nφ\n\n\n\n\n\n图 6: 小心多 SVG 可能产生的样式冲突"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#layout",
    "href": "posts/20221223-quarto-test/index.html#layout",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "7 Layout",
    "text": "7 Layout\n如 Quarto - Article Layout 所述，有时可让文章某些部分超出常规的宽度限制．此功能主要在 HTML 中使用，PDF 中部分生效，其它格式不生效．\n\n\n\n\n\n\n\n\n\n\n\n\n\\(n\\) 个球\n\\(r\\) 个盒\n空盒\n递推或封闭形式\n生成函数\n备注\n\n\n\n\n有标号\n无标号\n不允许\n\\[{n \\brace r} = r {n-1 \\brace r} + {n-1 \\brace r-1}\\]\n\\[\\mathrm{EGF}(x)=\\frac {(e^x - 1)^r}{r!}\\]\n第二类 Stirling 数"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#代码块和引用",
    "href": "posts/20221223-quarto-test/index.html#代码块和引用",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "8 代码块和引用",
    "text": "8 代码块和引用\n下面是代码块．\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n下面是引用块和一个非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．\n\n这是一个引用块和一个非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#html-专用测试",
    "href": "posts/20221223-quarto-test/index.html#html-专用测试",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "9 HTML 专用测试",
    "text": "9 HTML 专用测试\n目前暂未处理 LaTeX/PDF 格式的 callout，MS Word 格式可兼容但效果不佳．本节后续内容将不会在 LaTeX/PDF 格式下被渲染．\n\n9.1 Callouts\nQuarto 具有 5 种 callout 类型：note，warning，important，tip，和 caution．\n\n\n\n\n\n\nNote\n\n\n\n普通的 note callout．\n\n\n\n\n\n\n\n\nWarning\n\n\n\n这是 warning callout 和一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．\n\n\n这是两个 callout 中间的一个段落．\n\n\n\n\n\n\nImportant\n\n\n\n这是 important callout．\n\n\n\n\n\n\n\n\n有 caption 的 callout\n\n\n\n这是有 caption 的 callout．\n\n\n\n\n\n\n\n\n可折叠的 callout\n\n\n\n\n\n开启 collapse 的可折叠 caution callout．\n\n\n\n\n\n\n\n\n\nsimple 风格的 callout 和一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．\n\n\n\n\n\n\n\n\n\nminimal 风格的 callout 和一个和非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的句子．"
  },
  {
    "objectID": "posts/20221223-quarto-test/index.html#引用脚注测试",
    "href": "posts/20221223-quarto-test/index.html#引用脚注测试",
    "title": "SunQuarTeX-cnart 测试文档",
    "section": "10 引用、脚注测试",
    "text": "10 引用、脚注测试\n这是一个脚注1．\n1 参见 Quarto - Citations & Footnotes人脸识别是以人面部特征作为识别个体身份的一种个体生物特征识别方法 [1]．……人脸识别的研究最早可追溯到上世纪 60 年代，Bledsoe and Chan 研究了编程计算机识别人脸的方法[2]．随后，萌芽期的人脸识别技术经历多轮蜕变，在发展中逐渐完善．然而，人脸识别的主要难点在于不同个体的人脸结构并无大异，而同一个体的人脸在不同表情、年龄、妆饰、光照等干扰因素下又往往差异显著[3]，这要求人脸识别技术既要克服类内因素的干扰，同时又要加强类间差距的显著性，而早期人脸识别方法关注人脸几何特征，识别效果不尽人意．为此，以 Eigenfaces[4] 为代表的子空间学习识别方法和 Gabor[5]、LBP[6] 等局部特征分析的滤波器提取方法在各自领域都有所突破．2014 年，应用新兴的深度卷积神经网络技术，DeepFace[7] 横空出世，以 97.35% 的 LFW 基准数据集识别准确率重塑了人脸识别领域的研究格局．随后，人脸识别技术迎来爆发式增长，并逐渐走进人们的日常生活之中．……个体层面，要加强公众的权利意识，塑造个人的“数字理性”[8]．"
  },
  {
    "objectID": "posts/20201127-deconstruct/index.html",
    "href": "posts/20201127-deconstruct/index.html",
    "title": "树的解构 题解",
    "section": "",
    "text": "bsoj7076，没找到出处…\n\n树的解构\nMivik 喜欢 Eprom 的解构俱乐部，于是他想解构一棵树。\nMivik 找到了一棵以 \\(1\\) 为根的有 \\(n\\) 个结点的有根外向树。Mivik 会进行 \\((n−1)\\) 次操作，每次 Mivik 都会从未删掉的边中等概率选择一条边将其删去。记这条边为 \\(a \\to b\\) ，则删去这条边的代价是删边时 \\(b\\) 的子树大小（包括 \\(b\\) 自己）；删去这条边后 \\(b\\) 为根的子树会形成一棵新的以 \\(b\\) 为根的有根树。\nMivik 想知道，他进行这 \\((n−1)\\) 次操作后期望的代价总和是多少。由于 Mivik 不喜欢太大的数，你只需要输出期望的值对 \\(10^9 + 7\\) 取模的结果。\n对于所有测试点，满足 \\(1 \\le n \\le 2 \\times 10^6\\) 。保证给出的有根树合法。\n\n一道并不是特别难但没有切掉的期望题。\n考场写了链过后就一直在想怎么拆树，无果而终。然后想到解决排列问题的一个常见的思路是考虑所有排列方案的贡献和，最后乘个 \\(\\frac{1}{(n-1)!}\\) 就可以了。尝试在树形dp边的排列顺序，同样无果而终。\n对整体dp不好做，那就转而思考每个点对答案的贡献。\n考虑从树上某个深度（到根需经过的边数）为 \\(d_u\\) 的点 \\(u\\) ，其向上到根的路径上各边的相对删除顺序可以用一个阶为 \\(d_u\\) 的排列 \\(P\\) 表示。若只考虑该路径，设此时对答案的贡献为 \\(f_u(P)\\) ，我们尝试化简 \\(\\sum_{P \\in \\mathrm{perm(d_u)}} f_u(P)\\) 。（其中 \\(\\mathrm{perm(n)}\\) 表示所有 \\(n\\) 阶排列的集合）\n对于其中某条位置为 \\(i\\) 的边，若其被删除时点 \\(u\\) 可对答案产生贡献，则必须保证删除该边时该边与 \\(u\\) 仍然连通，也就是对于任意位置为 \\(j\\) 且 \\(j &lt; i\\) 的的边，有 \\(P_j &gt; P_i\\) 。换句话说，若从后往前 （从上至下）决定边的删除时间，那么一条删除时间为 \\(x\\) 的边必须在 \\([1,x]\\) 中最后被选中才能满足上述条件。显然其发生概率为 \\(\\frac{1}{x}\\) ，故在所有排列中 \\(x\\) 产生贡献的次数为 \\(\\frac{d_u !}{x}\\) 。因此 \\[\n\\sum_{P \\in \\mathrm{perm(d_u)}} f_u(P) = \\sum_{x=1}^{d_u} \\frac{d_u!}{x}\n\\] \\(P\\) 的相对顺序已经确定，而在整棵树中还有其他边的相对顺序未被决定，因此点 \\(u\\) 的总贡献还要再乘上对 \\(P\\) 消序后的全部排列方案数 \\[\n\\frac{(n-1)!}{d_u!} \\sum_{x=1}^{d_u} \\frac{d_u!}{x} = (n-1)! \\sum_{x=1}^{d_u} \\frac{1}{x}\n\\] 整合所有点的贡献并乘上概率就是最终的期望 \\[\n\\begin{aligned} \\mathrm{ans} &= \\frac{1}{(n-1)!} \\sum_{u=1}^n (n-1)! \\sum_{x=1}^{d_u} \\frac{1}{x} \\\\ &= \\sum_{u=1}^n \\sum_{x=1}^{d_u} \\frac{1}{x} \\end{aligned}\n\\] 意外的约掉了好多玩意儿呢\n线性求逆元并前缀和即可 \\(O(n)\\) 解决。\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\n#include&lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\nll Rd(){\n    int ans=0;bool fh=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9'){if(c=='-') fh=1; c=getchar();}\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    if(fh) ans=-ans;\n    return ans;\n}\ntypedef vector&lt;ll&gt; Vec;\ntypedef vector&lt;ll&gt;::iterator IVec;\n#define foreach(it,v) for(IVec it=v.begin();it!=v.end();it++)\nconst ll MOD=1E9+7;\n#define _ %MOD\nll PMod(ll x){\n    if(x&lt;0) return x+MOD;\n    else if(x&gt;=MOD) return x-=MOD;\n    else return x;\n}\n\nconst ll MXN=2E6+5;\nll N;Vec chd[MXN];\n\nll dep[MXN];\nvoid InfoDFS(ll u,ll depth){\n    dep[u]=depth;\n    foreach(it,chd[u]) InfoDFS((*it),depth+1); \n}\n\nll inv[MXN],sInv[MXN];\nvoid SpawnInv(){\n    inv[1]=1;for(ll i=2;i&lt;=N;i++) inv[i]=PMod(-(MOD/i)*inv[MOD%i]_); \n    sInv[1]=inv[1];for(ll i=2;i&lt;=N;i++) sInv[i]=PMod(sInv[i-1]+inv[i]);\n}\nvoid Solve(){\n    SpawnInv(); \n    InfoDFS(1,0);\n    ll ans=0;\n    for(ll u=1;u&lt;=N;u++) ans=PMod(ans+sInv[dep[u]]);\n    printf(\"%lld\",ans); \n}\nint main(){\n    //freopen(\"deconstruct.in\",\"r\",stdin);\n    //freopen(\"deconstruct.out\",\"w\",stdout);\n    N=Rd();\n    for(ll i=2;i&lt;=N;i++) chd[Rd()].push_back(i);\n    Solve();\n    return 0;\n}"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html",
    "href": "posts/20201206-csps2020noip2020travel/index.html",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "",
    "text": "走了，回来了。不管如何，这条路似乎已经延伸得很漫长了。从兴趣，变成兼修，变成接近专修，又变回兴趣，这中间的路太长，以至于虽然百味杂陈，却说不出什么感想。\n——《noip2020复习总结》 by p9t6g\n\n谨以此文，或是完全退役前的最后一点日记和随想，纪念即将结束的5年OI生涯。"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#序",
    "href": "posts/20201206-csps2020noip2020travel/index.html#序",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "",
    "text": "走了，回来了。不管如何，这条路似乎已经延伸得很漫长了。从兴趣，变成兼修，变成接近专修，又变回兴趣，这中间的路太长，以至于虽然百味杂陈，却说不出什么感想。\n——《noip2020复习总结》 by p9t6g\n\n谨以此文，或是完全退役前的最后一点日记和随想，纪念即将结束的5年OI生涯。"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#开始了",
    "href": "posts/20201206-csps2020noip2020travel/index.html#开始了",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "开始了？",
    "text": "开始了？\n\n2020/09/??\n大部分半退役选手调转枪头停晚自习了。\n表示一点都不慌，学文化使我快乐 这么早停干啥啊"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#初赛",
    "href": "posts/20201206-csps2020noip2020travel/index.html#初赛",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "2020/10/11 初赛",
    "text": "2020/10/11 初赛\n打开选择题…\n就这？就这？毒瘤的组合计数和概率期望去哪里了？？？\n话说考初赛前几天学校翻修科技楼时把几个计算机科学大佬挂在走廊上增加逼格，结果上面有个香农…\n于是选择题就AK了。\n有点小飘，一看程序题…这画风不太对劲…\n于是差点没做完。nth_element看了半天当成快排了，字符串转圈算不来。二进制dp考场都硬是没看懂，被迫与ABCD斗智斗勇；对完答案发现前面又离奇错一堆，复杂度还算错，当场掉到70+，感觉凉凉。\nAnyway，又没复习又没刷题，文化课选手也不指望考得好好，过线万岁吧。"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#开始了-1",
    "href": "posts/20201206-csps2020noip2020travel/index.html#开始了-1",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "开始了。",
    "text": "开始了。\n\n2020/10/19\n复赛线只有40pt啊\n申请了晚自习停课，回到了熟悉的小机房里。进门就被亲切的垃圾发酵气味欢迎…\n坐到机房最后一个机位上，位置比去年还要摸鱼。清理了桌上堆成小山的垃圾，使用成吨的纸巾擦去了成吨的灰尘，托p9t6g装了个win10，终于坐到了位置上。\n观察一下周围… 怎么你们比去年还颓啊\n\n\n2020/10/26\n模拟赛被各种虐爆，主席树sb题写了2h，被高一选手吊打。\n感觉很菜，但心态良好（\n颓废方面的话，只是隔几天打一小会妖妖梦或者随机绀而已。说实话有一段时间没碰东方了，以前收率拉满的反魂蝶现在都有点吃力。\n记得初三高一的时候还时常能看到肝正作的同学（那时还有几个上一届的学长），不知不觉的就剩我一个了…\n下一届学弟学妹不太了解，不知道东方的火炬能不能继续传下去。\n\n\n2020/11/04\n嗯，我知道过几天就CSP了，但突然有点学不进去…\n于是在机房学了波Jekyll，装了Git开始手撸新博客前端…"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#csp-s2020",
    "href": "posts/20201206-csps2020noip2020travel/index.html#csp-s2020",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "CSP-S2020",
    "text": "CSP-S2020\n\n2020/11/06 Day 0\n试机日。\n以前NOIP都在宇宙名校举行，地方都不用挪。这回换到了NK的一个奇远无比的校区，于是很新奇的有了一次集体旅行的经历。\n坐上车才发现CCF早就给了一等分数线，emmm 70pt…那我尽量和六年级小朋友度长絜大一下吧（笑） flag x1\n后来发现70pt是初赛一等奖线，白高兴一场\n大巴一路东行。不知不觉，窗外已是高低起伏的绿色的海洋。明明是条正规的国家高速公路，居然到处坑坑洼洼。大巴前侧小一届的学弟们在棋牌娱乐，车后一众老年人却沉迷手游。 好像不太符合社会规律？\nPC玩家只能往窗外望。一路上又是架桥又是隧道的，让人不禁怀疑这是哪门子鬼地方。忍不住开始吐槽：\n\n试机 \\(\\iff\\) 去郊游\n前往LJNK中学为山区孩子送去温暖\n…\n\n摇摇晃晃四十多分钟，到了。还没下车，只见一座巨型空心扁平圆柱建筑矗立校园中央…\n“这是……土楼？”\n山区少数民族聚居地学校\n整个学校独占了一个极大的街区，旁边是一些附属建筑和一个标准体育场，在巨大的圆柱面前显得额外渺小。\n说实话修的还是蛮好的，但确实太偏僻了，周围全都是些巨型吊车，没啥人烟。\n考试场地——伯苓体育馆 爆零体育馆\n合了影就进去试机了。虽然停不下来吐槽，但还是得给考试场地点个赞。体育馆就是不一样，里面非常宽敞明亮，几百台电脑的大型阵列让人印象深刻。\n随便写了个 a+b problem 就开始玩这里的局域网，差点搭了个FTP起来。\nWaper爷和disangan233在我的怂恿之下开始快乐联机CS1.6（\n总之试机日就这样过去了，堵车堵了快2h才到家，颓了会儿 Portal 2 就睡觉了。\n\n\n2020/11/07 Day 1\n睡了10个小时，早上9点以饱满的精神状态醒来开始撸博客前端，吃完午饭才感觉有点慌，去敲了个倍增LCA压压惊，然后慢摇摇的坐车到了考场。\n开考后断局域网好评，分片区上厕所好评，发的三明治馅料十足好评（\nT1瞪了2min直接跳了，30min切了T2（这回长记性了，开了unsigned long long），T3想了会儿感觉应该不会做，于是就开了T4。\n一开始感觉直接就顺着for一道随便模拟+博弈一下就可以了，没怎么细想就开始敲代码。调了调然后发现过不了大样例，总有个 \\(\\pm 1\\) 的误差。再次思考发现之前的做法有一点逻辑上的漏洞，正着for完一道还要回溯做博弈，于是又写又改，还是没过大样例。\n此时已过2.5hour，有点小慌，回头去敲T1。时间紧张，忘记了开考时想到的更好写的前缀和+二分，直接糊了个一堆if的 \\(O(q)\\) 上去结果半天没调过（赛后还发现以为能过的40pt部分都有锅），炸裂。\n出考场交流了一下，似乎T4人均写错误解法然后观察大样例用奇偶性水过了，有点不爽。Waper爷讲了讲T3的做法，听了个大概，确实是我做不起的题，溜了溜了。\n分数有点惨，丢人啊。真就和六年级小朋友度长絜大是吧…\n暂时别想了，回去颓吧。于是晚上又是 Portal 2 和搭博客。\n…\n\n\n2020/11/08 赛后\n个人认为考试时精神状态还可以，开题策略上也没啥问题，跳过码农T1和八成不会做的T3都是很正确的选择。但是应该先把跳了的题的各种idea记录下来的。\nT4考场代码已经将近正解了，但是因为少发现了个关键性质没有搞出来。还是莽撞了，没多想就开始敲压轴题是大忌啊。不熟悉四道题的赛制、过分低估CSP-S的难度也是一个原因。 谁叫教练考前一直奶我们人均AK\n也不知道是否会计入省选成绩，不过作为一个月后就该退役的文化课选手也没啥好担心的对吧？\n当给NOIP攒RP吧。\nupd: 初评出来了，居然没有挂分（ 分也就那么一点"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#要来了",
    "href": "posts/20201206-csps2020noip2020travel/index.html#要来了",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "要来了。",
    "text": "要来了。\n\n2020/11/23\n开始停课了。 翘了期中考试\n没有什么特别的感想，除了不用上早自习能多睡一会儿。\n天天都考四道题，感觉还是做不完，而且考后也做不完…\n教练让我们每个人出道题出来和别的学校换题，莫名感觉这次又要像之前的两次互测一样咕掉。\n说实话搞了那么久OI一次校内互测都没有举行，真的感觉非常遗憾，好想把自己的idea分享给别人，好想在校内OJ上留下点自己的印记…\n一年前准备投给互测的 白银之春 老std一堆bug，干脆重构了一遍。顺便一起给半退役后摸出来的 GCD卷积 造了数据，挂Github上准备投题。\nUPD: 真的咕了 sb教练再次欺骗了我的感情 。反正没机会了就挂在博客上了，希望有人看到了拿来玩（\n\n\n2020/11/29\n周五晚上和Waper、p9t6g在机房颓完CS1.6，回家时和Waper爷聊到我们长长的OI生涯。今天突然看到了他的 OI回忆录 ，有点小感伤。\n我校最早接触OI的10个所谓“信息特长生”，最终也只剩下了Waper一个人孤军奋战。看到昔日的战友一个个离去，我不知道Waper内心的感受。\n死人并没有什么悲伤，只有活着的人在承受离别的痛苦。\nWaper爷平时看上去像个大老粗人，但他对五年OI生涯的感情是非常细腻的。平时和他交流不算太多，但作为离开的九位同学中坚持得还算长的，我也是看着Waper默默努力了5年，达到了现在的高度。初一初二的时候，总是他，一个人在机房后面学习更高更难的算法，横眉冷对初中竞赛教练的鄙夷和其他同学的不解。现在他又要和更多更强的选手竞争，承受文化课和竞赛成绩的双重压力…\n也不知道Waper会不会看到这篇博客，在这里向你表达衷心的祝愿，希望能在明年NOI的Au榜上看到你的身影。\n\n\n2020/12/02\n又是 Day -2 ，又是考前信心赛，又是T2换根dp，又没调出来，又是倒数第一…\n历史总是惊人的相似\n自闭了，撸了一天的前端（"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#noip2020",
    "href": "posts/20201206-csps2020noip2020travel/index.html#noip2020",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "NOIP2020",
    "text": "NOIP2020\n\n2020/12/04 Day 0\n因为考场和CSP一样就没去试机。\n大清早刚到机房不久halfway就来打气，听了还是蛮开心的。这回没有可乐和士力架差评\n中午机房出现了6人联机CS1.6的空前盛况，玩的很开心。\n觉得自己八成回不来了，于是给机房电脑擦除了数据，回家打了一小会CSGO，睡了。\n争取明天给自己画上一个完美的句号吧。\n\n\n2020/12/05 Day 1\n早上6:15起来往考场赶，又在学校里晃了半个多小时才进考场。LJNK的操场台阶很适合躺着睡觉啊 (?)\nT1是个什么沙包题啊，封装一下分数吧，20min切了。\n然后T2就把我最后一次NOIP埋葬了。\n字符串？NOIP不是几百年没考字符串了吗？？\n有点慌，看懂题意想了想，奇偶性随便预处理一下能解决，应该是要枚举字符串 \\(C\\) 的，然后发现要判循环节大小。然后发现自己只会 \\(O(n \\sqrt n)\\) 判，外面还要多乘上个 \\(O(n)\\) ，不如暴力。然后想到KMP，但好久没做字符串了，不敢确定它真的能判，就丢了。上了个厕所想到哈希过后怎么dp搞搞，但从厕所回来就忘掉思路了，一直觉得没有比暴力更优的思路。呆呆了看了10min，回头再看吧，跳题了。\n两种正确做法想到了都没打，不愧是我。\nT3是几百年没出现过的乱搞+构造+SPJ。随便画了画出了个类似汉诺塔移法的东西，看到 \\(n\\) 、 \\(m\\) 不大就准备开写。脑中闪过爆炸的CSP-S T4，又仔细的把算法的细节完善了一下才开敲。\n于是90分钟过去了，甚至还没有开始调试。慌张的一批，开T4了。嗯，30分是能暴力+二分判的，40分来点除法也是能骗的，后面的暂时别管吧，于是现在面临敲T4暴力、敲应该是正解的T3、回头看T2的选择。\n我选择了敲T3。\n又写了30min，前三个样例过了。又调了30min，还是过不了最大的样例。此时只剩40min，丢掉去敲T4的30分，过了。茫然的瞪了5分钟T2，比赛结束了。\n1=不保，惨淡退役。\n因为之前做过心理准备，所以情绪还算稳定。出考场听说T2人均KMP \\(O(26 \\times n \\ln n)\\)，但脑子已经不好使了，还是不太会做。坐在车上想起厕所里想到的hash，发现似乎直接暴力调和级数跳就可以处理循环节了，emmm…\n又想起自己打了那么久的T3好像还是 \\(O(n m^2)\\) 的，算法没假时间复杂度却假了，呵呵。\nT1卡不卡高精、入度出度什么的，已经不重要了。\np9t6g说他30min切了T1、T2，惹不起打扰了。Waper爷T2、T4都拿了不少的分，不知道能不能上省队线。高三来划水的的Ag爷trrb倒是很低调的拿了个340，膜膜膜。\n和Waper、trrb坐车回家了。\n某一瞬间，似乎有点恍惚。\n回过神来，发现自己正哼着《さくらさくら ～ Japanize Dream…》。\n\n\n\n赛后 （Update 2020/12/08）\n初评出来了。T1居然卡了40分的通分 a*b 爆 long long，向出题人致以诚挚的问候。\n去年和今年的CSP-S都设了坑，第一题考察数据范围细节也许会成为NOIP新常态吧。\n无脑 long long 的时代结束了。\n…\n要是运气好一点，也许路上哼的就是《紅楼 ～ Eastern Dream…》了吧。\n作为垃圾退役选手，考场降智秒不掉T2也算可以接受，当T3把锐气削减后，结局基本就没有悬念了。遗憾的是没有回头去看一眼T2，不仅没能切掉，白送的45分暴力也丢掉了。T3玩了那么长的时间也没调得出来。\n其实这样的结局也不完全是运气所致。本来就只是抱着划水的心态，为竞赛生涯画个句号罢了，考前的那么多次模拟赛，似乎也并没有特别努力的去得分。本想着可以和去年一样轻松拿奖，怎料划着划着就翻船了呢。\n也许真的是去年手感太顺了吧。"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#结束了",
    "href": "posts/20201206-csps2020noip2020travel/index.html#结束了",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "结束了。",
    "text": "结束了。\n名正言顺的退役了。\n学了那么多年OI还是个小透明，要说给别人留下了什么印象，也就初三考省选时给保安讲哈希的神奇经历了吧。\n很早以前就意识到自己和别的OIer不太一样了。别人的颓废是打游戏水知乎，而我喜欢瞎学点没用的东西。\nOI是我的兴趣，但不是唯一的兴趣，而我也没有凭兴趣使然就有学上的天赋。本来想得就比别人慢，本来题量就没有别人大，本来就知道自己是不务正业的OIer，这也许就决定了我在OI上的高度了吧。学了那么几年撞到一次省一，我已经满足了。\n五年的OI生涯已经不算短了，虽然没有碰到几个知心朋友，但是收获是不可估量的。OI保持并强化了我对计算机的兴趣，也让我对这个世界更加好奇了。我想若是没有OI的经历，或许我不会为了搭博客去学前端和网络原理，不会那样从容的在Unity里使用C#，不会用Python在Minecraft里造红石音乐，不会有支持所有前述整活的码力；也不会在学孟德尔的豌豆时想到FMT，学有机化学时想到Burnside和生成函数；更永远不会为了搞懂生成树计数独立证明行列式的几大定理，不会翻开《算法导论》惊叹于“没用的”数论在RSA加密里的美妙运用，永远不知道“理性愉悦”是多么的让人快乐……我甚至觉得OI间接的帮助我入坑了东方——我们享受解决问题带来的快感，我们分享题解为后人搭桥，我们把有趣的idea出成题目给大家分享，我们还用爱发电，建立并维护了洛谷、UOJ、LOJ、etc. 那么多规模可观的OI社区，这份热爱和同人精神的本质是一样的啊。\n我相信这五年带给我的成长在更远的将来是有价值的。\n完全投身文化课的学习，我知道这并不是条容易的路，但我会尽力在其中找到乐趣。还有战友在OI这条船里奋斗，祝愿你们在接下来的省选和NOI取得满意的分数，过一个轻松一点的高三。\n退役不代表完全离开OI。还有几篇未完成的学习笔记（有一篇写了20多k了舍不得丢掉（笑）），咱尽量找时间填上。也许闲暇时也会继续学点东西理性愉悦一下。\n我们在各自的道路上奋斗，我们都有光明的未来。\n\n——NOIP2020赛后 记"
  },
  {
    "objectID": "posts/20201206-csps2020noip2020travel/index.html#section-7",
    "href": "posts/20201206-csps2020noip2020travel/index.html#section-7",
    "title": "终末之章——CSP-S2020&NOIP2020退役记",
    "section": "???",
    "text": "???\n\n惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。\n客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。\n\n——《赤壁赋》\n\n\nNext Phantasm…"
  },
  {
    "objectID": "posts/20190701-gift/index.html",
    "href": "posts/20190701-gift/index.html",
    "title": "洛谷P5364 [SNOI2017]礼物 题解",
    "section": "",
    "text": "传送门\n\n题目描述\n热情好客的小猴子请森林中的朋友们吃饭，他的朋友被编号为 1~N，每个到来的朋友都会带给他一些礼物：大香蕉。其中，第一个朋友会带给他 1 个大香蕉，之后，每一个朋友到来以后，都会带给他之前所有人带来的礼物个数再加他的编号的K次方那么多个。所以，假设K=2，前几位朋友带来的礼物个数分别是：\n1,5,15,37,83,…\n假设K=3，前几位朋友带来的礼物个数分别是：\n1,9,37,111,…\n现在，小猴子好奇自己到底能收到第 N 个朋友多少礼物，因此拜托于你了。\n已知 N,K，请输出第 N 个朋友送的礼物个数 mod 10^9+7。\n输入格式\n第一行，两个整数 N,K。\n输出格式\n一个整数，表示第 N 个朋友送的礼物个数 mod 10^9+7 。\n输入输出样例\n输入 #1\n4 2\n输出 #1\n37\n输入 #2\n2333333 2\n输出 #2\n514898185\n输入 #3\n1234567890000 3\n输出 #3\n891659731\n输入 #4\n66666666 10\n输出 #4\n32306309\n100% 的数据：\\(N \\le 10^{18}, K \\le 10\\)\n\n\n暴搞通项公式\n蒟蒻想了一上午弄出来个\\(O(k^2)\\)的算法\n这道题比较裸，就是甩给你个递推式让你求第\\(n\\)项 \\[\nA_1 = 1,A_n = \\sum_{i=1}^{n-1} A_i + n^k\n\\]\n那首先我们来手动打个表qwq\n\n\n\n\n\n\n\n\n\n\n\n\n\\(A_i\\)  \\(i^k\\)\n\\(1^k\\)\n\\(2^k\\)\n\\(3^k\\)\n\\(4^k\\)\n\\(5^k\\)\n\\(6^k\\)\n\n\n\n\n\\(A_1\\)\n1\n\n\n\n\n\n\n\n\\(A_2\\)\n1\n1\n\n\n\n\n\n\n\\(A_3\\)\n2\n1\n1\n\n\n\n\n\n\\(A_4\\)\n4\n2\n1\n1\n\n\n\n\n\\(A_5\\)\n8\n4\n2\n1\n1\n\n\n\n\\(A_6\\)\n16\n8\n4\n2\n1\n1\n\n\n\n表中第\\(i\\)行的系数乘上对应列标后的和就是\\(A_i\\)\n于是我们发现了这一显然的规律\n\\[\nA_1 = 1,A_n = 2 A_{n-1} + n^k - (n-1)^k\n\\]\n我们就非常优秀的把这个递推式化简了:p\n\n2020/05/16 update\n当时太菜了没学数列，实际上这个规律根本就不需要找，可以直接推出。\n设 \\(S_n = \\sum_{i=1}^n a_n\\) ，根据题意 \\(a_n = S_{n-1} + n^k\\) 。\n用上式减去 \\(a_{n-1} = S_{n-2} + (n+1)^k\\) 得\n\\[\n\\begin{aligned}\na_n - a_{n-1} &= a_{n-1} + n^k - (n+1)^k \\\\\na_n &= 2 a_{n-1} + n^k - (n+1)^k\n\\end{aligned}\n\\]\n得到上式。\n\n总感觉它有个通项公式什么的吧，我们来胡乱瞎推一波\n观察递推式，右式那坨\\(n^k - (n-1)^k\\)看着就恶心，我们想找个办法把它消掉，使它的形式变成一个等比数列，这样通项公式就容易得到了\n显然\\(n^k - (n-1)^k\\)是一个\\(k-1\\)次多项式，所以我们构造数列\\(U\\)和\\(k-1\\)次多项式\\(B\\)\n\\[\n\\begin{aligned}\nU_n = A_n + B(n) \\\\\nB(n) = \\sum_{i=0}^{k-1} b_i n^i\n\\end{aligned}\n\\]\n对数列\\(U\\)的定义式移项得\n\\[\nA_n = U_n - B(n)\n\\]\n带回\\(A\\)的递推式，得 \\[\n\\begin{aligned}\nU_n - B(n) = 2(U_{n-1} - B(n-1)) + n^k - (n-1)^k \\\\\nU_n = 2U_{n-1} + B(n) - 2B(n-1) + n^k - (n-1)^k\n\\end{aligned}\n\\]\n我们想让\\(U_n=2U_{n-1}\\)，只需使\n\\[\nB(n) - 2B(n-1) + n^k - (n-1)^k = 0\n\\]\n即 \\[\n- B(n) + 2B(n-1) = n^k - (n-1)^k\n\\]\n现在我们要求解多项式\\(B\\)，试着将多项式的每一项，也就是\\(b_i\\)，都表示出来\n先看右式，用二项式定理展开\\((n-1)^k\\)，右式变为\n\\[\n\\quad  n^k - \\sum_{i=0}^{k} C_k^i (-1)^{k-i} n^i\n\\]\n提出和式中的\\(k\\)次项与\\(n^k\\)消掉\n\\[\n= - \\sum_{i=0}^{k-1} C_k^i (-1)^{k-i} n^i\n\\]\n再来看左式，将多项式展开得\n\\[\n- \\sum_{i=0}^{k-1} b_i n^i + 2 \\sum_{i=0}^{k-1} b_i (n-1)^i\n\\]\n也用二项式定理展开\\((n-1)^i\\)\n\\[\n= - \\sum_{i=0}^{k-1} b_i n^i + 2 \\sum_{i=0}^{k-1} b_i \\sum_{j=0}^i C_i^j (-1)^{i-j} n^j\n\\]\n转换枚举\n\\[\n\\begin{aligned}\n&= - \\sum_{i=0}^{k-1} b_i n^i + 2 \\sum_{i=0}^{k-1} \\sum_{j=0}^i  b_iC_i^j (-1)^{i-j} n^j \\\\\n&= - \\sum_{i=0}^{k-1} b_i n^i + 2 \\sum_{j=0}^{k-1} \\sum_{i=j}^{k-1}  b_iC_i^j (-1)^{i-j} n^j \\\\\n&= - \\sum_{i=0}^{k-1} b_i n^i + 2 \\sum_{i=0}^{k-1} \\{ \\sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} \\} n^i\n\\end{aligned}\n\\]\n（这里大括号只是为了标明系数，没有实际意义）\n现在把左右式合在一起写\n\\[\n- \\sum_{i=0}^{k-1} b_i n^i + 2 \\sum_{i=0}^{k-1} \\{ \\sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} \\} n^i = - \\sum_{i=0}^{k-1} C_k^i (-1)^{k-i} n^i\n\\]\n消掉负号\n\\[\n\\sum_{i=0}^{k-1} b_i n^i + 2 \\sum_{i=0}^{k-1} \\{ \\sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} \\} n^i = \\sum_{i=0}^{k-1} C_k^i (-1)^{k-i} n^i\n\\]\n所以\n\\[\nb_i + 2 \\sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} = C_k^i (-1)^{k-i}\n\\]\n于是我们非常愉快艰难的得到了\\(b_i\\)的表示，高斯消元即可得到\\(b_i\\)。\n仔细观察发现这是个上三角矩阵，所以我们可以直接\\(O(k^2)\\)求解！\n于是我们解出了多项式\\(B\\)。\n回过头来看数列\\(U\\)的定义，\\(U_n = A_n + B(n)\\)\n现在解出了\\(B\\)，我们又知道\\(A_1 = 1\\)，就能知道\n\\[\nU_1 = A_1 + B(1) = B(1) +1\n\\]\n于是我们得到了数列\\(U\\)的完整递推式\n\\[\nU_1=B(1) + 1,U_n=2U_{n-1}\n\\]\n现在就容易知道\\(U\\)的通项公式了，它是\n\\[\nU_n = ( B(1) + 1 )2^{n-1}\n\\]\n又因为\\(A_n = U_n - B(n)\\)，\\(A\\)的通项公式就出来了！\n\\[\nA_n = ( B(1) + 1 )2^{n-1} - B(n)\n\\]\n完了\n//洛谷P5364 [SNOI2017]礼物\n//Author:sun123zxy\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;queue&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1E9+7;\n\nll QPow(ll x,ll up){//快速幂 \n    x%=MOD;\n    ll ans=1;\n    while(up){\n        if(up%2==0){\n            x=x*x%MOD;\n            up/=2;\n        }else{\n            ans=ans*x%MOD;\n            up--;\n        }\n    }\n    return ans;\n}\nll Inv(ll x){//逆元 \n    return QPow(x,MOD-2);\n}\n\nconst ll MXK=2005;\nll fac[MXK],facInv[MXK];\nvoid FacInit(ll n){\n    fac[0]=1;for(ll i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%MOD;//求阶乘 \n    facInv[n]=Inv(fac[n]);\n    for(ll i=n-1;i&gt;=1;i--) facInv[i]=facInv[i+1]*(i+1)%MOD;//线性求阶乘逆元 \n    facInv[0]=1;\n}\nll C(ll n,ll k){//组合数 \n    if(n&lt;k) return 0;\n    return fac[n]*facInv[n-k]%MOD*facInv[k]%MOD;\n}\n\nll N,K;\nll c,B[MXK];//2^(n-1)的系数c和多项式B \nll GetY(ll x){//获取B(x)\n    x%=MOD;\n    ll y=0;\n    ll xPow=1;\n    for(int i=0;i&lt;=K-1;i++){\n        y=(y+B[i]*xPow)%MOD;\n        xPow=xPow*x%MOD;\n    }\n    return y;\n}\nll mtx[MXK][MXK];\nvoid GetFormula(){\n    for(ll i=0;i&lt;=K-1;i++) for(ll j=0;j&lt;=K;j++) mtx[i][j]=0;\n    for(ll i=0;i&lt;=K-1;i++){//初始化方程组 \n        mtx[i][i]=1;\n        for(ll j=i;j&lt;=K-1;j++){\n            ll p=-1;if((j-i)%2==0) p=1;\n            mtx[i][j]+=(-2*C(j,i)%MOD*p+MOD)%MOD;\n        }\n        ll p=-1;if((K-i)%2==0) p=1;\n        mtx[i][K]=(C(K,i)*p+MOD)%MOD;\n    }\n    for(ll i=K-1;i&gt;=0;i--){//上三角高斯消元\n        B[i]=mtx[i][K]*Inv(mtx[i][i])%MOD;\n        for(ll j=i-1;j&gt;=0;j--){\n            mtx[j][K]=(mtx[j][K]-B[i]*mtx[j][i]%MOD+MOD)%MOD;\n            mtx[j][i]=0;\n        }\n    }\n    c=(GetY(1)+1)+MOD%MOD;\n}\nint main(){\n    cin&gt;&gt;N&gt;&gt;K;\n    FacInit(K);\n    GetFormula();\n    cout&lt;&lt;(c*QPow(2,N-1)%MOD-GetY(N)+MOD)%MOD;\n    return 0;\n}\n和洛谷题解里rqy聚聚的解法似乎有一些关联（"
  },
  {
    "objectID": "posts/20230213-strwithmath/index.html",
    "href": "posts/20230213-strwithmath/index.html",
    "title": "str 学数学 题解",
    "section": "",
    "text": "Example 1 (str 学数学) str 同学因为名字里含有一个 str，所以觉得字符串对于他来说太简单了，于是他开始了他的数学之旅。\n在旅途中str遇到了刚抽到胡桃的 lyl，而 lyl 同学正沉浸在出货的喜悦之中，为了能收获双倍喜悦，他便询问 str，他选的区间内有多少个幸运数字，str觉得这个问题和字符串一样简单，于是把这个问题交给了你。\n共有 \\(T\\) 组询问，每次给出两个正整数 \\(L,R\\)，你需要判断有多少 \\(n\\)，\\(L \\leq n \\leq R\\) 使得方程 \\[\n\\sum_{i=1}^n \\sum_{j=1}^n \\left \\lfloor \\frac {ij} {n+1} \\right \\rfloor = \\frac {n^2 (n-1)}{4}\n\\] 成立。\n请输出你得到的答案。\n数据范围：\\(1 \\leq T \\leq 10000\\)，\\(1 \\leq L \\leq R \\leq 10^7\\)\n样例输入：\n4\n1 4\n2 8\n1 10\n1 100\n样例输出：\n3\n3\n5\n26\n来源：2023 年寒假集训 B 组总结赛\n考场上当然是打表找规律了，但非常愚钝地没看出来……\n结论是，\\(n\\) 是一个幸运数字，当且仅当 \\(n+1\\) 是一个质数。下面提供两种证明方法。"
  },
  {
    "objectID": "posts/20230213-strwithmath/index.html#official-solution",
    "href": "posts/20230213-strwithmath/index.html#official-solution",
    "title": "str 学数学 题解",
    "section": "Official Solution",
    "text": "Official Solution\n出题人提供的非常有技巧性的解法。\n\\[\n\\sum_{i=1}^n \\sum_{j=1}^n \\left \\lfloor \\frac {ij} {n+1} \\right \\rfloor = \\frac {n^2 (n-1)}{4}\n\\]\n考虑为 \\(\\lfloor \\frac {ij} {n+1} \\rfloor\\) 配对，\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n \\sum_{j=1}^n \\left \\lfloor \\frac {ij} {n+1} \\right \\rfloor + \\left \\lfloor \\frac {i(n-j+1)} {n+1} \\right \\rfloor &= \\frac {n^2 (n-1)}{2} \\\\\n\\sum_{i=1}^n \\sum_{j=1}^n \\left \\lfloor \\frac {ij} {n+1} \\right \\rfloor + \\left \\lfloor i - \\frac {ij} {n+1} \\right \\rfloor &= \\frac {n^2 (n-1)}{2} \\\\\n\\sum_{i=1}^n \\sum_{j=1}^n i - [ n+1 \\nmid ij ] &= \\frac {n^2 (n-1)}{2} \\\\\n\\frac{n^2 (n+1)}{2} - \\sum_{i=1}^n \\sum_{j=1}^n [ n+1 \\nmid ij ] &= \\frac {n^2 (n-1)}{2} \\\\\n\\sum_{i=1}^n \\sum_{j=1}^n [ n+1 \\nmid ij ] &= n^2\n\\end{aligned}\n\\]\n即要求 \\(n+1 \\nmid ij\\) 对任意 \\(1 \\leq i,j \\leq n\\) 成立。因此根据质数定义，\\(n+1\\) 就是且只能是质数了。"
  },
  {
    "objectID": "posts/20230213-strwithmath/index.html#alternative-solution",
    "href": "posts/20230213-strwithmath/index.html#alternative-solution",
    "title": "str 学数学 题解",
    "section": "Alternative Solution",
    "text": "Alternative Solution\n考场上推了一半的想法。\n\\[\n\\sum_{i=1}^n \\sum_{j=1}^n \\left \\lfloor \\frac {ij} {n+1} \\right \\rfloor = \\frac {n^2 (n-1)}{4}\n\\]\n注意到 \\(a \\bmod b = a - b \\lfloor \\frac a b \\rfloor\\)，考虑构造取模\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n \\sum_{j=1}^n (n+1) \\left \\lfloor \\frac {ij} {n+1} \\right \\rfloor = \\frac {n^2 (n-1)(n+1)}{4} \\\\\n\\sum_{i=1}^n \\sum_{j=1}^n ij - ij \\bmod (n+1) = \\frac {n^2 (n-1)(n+1)}{4} \\\\\n\\left( \\frac {n(n+1)}{2} \\right)^2 - \\sum_{i=1}^n \\sum_{j=1}^n ij \\bmod (n+1) = \\frac {n^2 (n-1)(n+1)}{4} \\\\\n\\sum_{i=1}^n \\sum_{j=1}^n ij \\bmod (n+1) = \\frac {n^2 (n+1)} {2}\n\\end{aligned}\n\\]\n考虑固定 \\(i\\)，研究 \\(j\\) 变化下左式的情况。方便起见，我们将上式左侧 \\(j\\) 的取值范围扩展至 \\(0\\) 到 \\(n\\)： \\[\n\\sum_{i=1}^n \\sum_{j=0}^n ij \\bmod (n+1) = \\frac {n^2 (n+1)} {2}\n\\] 细心的读者或许已经发现，当 \\(\\gcd(i,n+1) = 1\\) 恒成立，即 \\(n+1\\) 为质数时，\\(ij \\bmod (n+1)\\) 将取遍 \\(0\\) 到 \\(n\\)，此时左右两式相等。下面我们证明这是上式相等的充分必要条件。\n仍从 \\(ij \\bmod (n+1)\\) 的取值下手，我们研究如下以 \\(j\\) 和 \\(t\\) 为变量的不定方程的解 \\[\nij + (n+1) t = m \\pod{0 \\leq m &lt; n+1}\n\\] 由裴蜀定理（Bézout’s identity），方程有解的充分必要条件为 \\(\\gcd(i,n+1) \\mid m\\)。不妨记 \\(d = \\gcd(i,n+1)\\)，\\(m = k d\\)，方程变为 \\[\nij + (n+1) t = kd \\pod{0 \\leq k &lt; \\frac {n+1} d}\n\\] 写出该不定方程的通解 \\[\n\\left \\{\n\\begin{aligned}\nj &= j_0 + s \\cdot \\frac{n+1}{d}\\\\\nt &= t_0 - s \\cdot \\frac{i}{d}\n\\end{aligned}\n\\right . \\pod{s \\in \\mathbb Z}\n\\] 不难发现，对 \\(0 \\le k &lt; \\frac n d\\)，上述不定方程在 \\(0 \\leq j \\leq n\\) 的范围内总有 \\(d\\) 个解，这意味着 \\(ij \\bmod (n+1)\\) 将有 \\(d\\) 次取到 \\(kd\\)。故我们有 \\[\n\\begin{aligned}\n\\sum_{i=1}^n \\sum_{j=1}^n ij \\bmod (n+1)\n&= \\sum_{i=1}^n d \\sum_{k=0}^{\\frac {n+1}{d} -1} kd \\\\\n&= \\sum_{i=1}^n d^2 \\sum_{k=0}^{\\frac {n+1}{d} -1} k \\\\\n&= \\frac 1 2 \\sum_{i=1}^n d^2 \\left( \\frac {n+1} d - 1 \\right) \\frac {n+1} d \\\\\n&= \\frac {n+1} 2 \\sum_{i=1}^n (n+1-d) = \\frac{n^2 (n+1)}{2}\n\\end{aligned}\n\\] 化简即得 \\[\n\\begin{aligned}\n\\sum_{i=1}^n (n+1-d) &= n^2 \\\\\n\\sum_{i=1}^n d &= n \\\\\n\\sum_{i=1}^n \\gcd(i, n+1) &= n\n\\end{aligned}\n\\] 显然上式等价于对任意 \\(1 \\leq i \\leq n\\)，\\(\\gcd(i, n+1) = 1\\) 恒成立。因此我们证明了 \\(n+1\\) 是质数是原方程成立的充分必要条件。"
  },
  {
    "objectID": "posts/20200220-factor/index.html",
    "href": "posts/20200220-factor/index.html",
    "title": "约数个数函数的一个性质证明，以及其推广",
    "section": "",
    "text": "洛谷P3327 [SDOI2015]约数个数和\n洛谷P4619 [SDOI2018]旧试题\n要用到这个性质，而且网上几乎没有能看的证明，所以特别提出来整理一下。"
  },
  {
    "objectID": "posts/20200220-factor/index.html#original",
    "href": "posts/20200220-factor/index.html#original",
    "title": "约数个数函数的一个性质证明，以及其推广",
    "section": "Original",
    "text": "Original\n\n二维\n\n\\[\nd(AB) = \\sum_{x|A} \\sum_{y|B} [\\gcd (x,y) = 1]\n\\]\n其中 \\(d\\) 是约数个数函数，即 \\(d (n) = \\sum_{d|n} 1\\)\n\n（看上去比较不可思议对吧）\n右侧的枚举，一部分因子算多了（比如当 \\(\\gcd(x,y)=1\\) 且额外有 \\(x|B,y|A\\) 时，可以枚举出 \\(x*y = y*x\\) ），一部分因子又没有算（比如当 \\(\\gcd(A,B) \\not= 1\\) 时的 \\(A*B\\) ）。但是算多和算少之间达成了诡异的平衡。\n首先考虑 \\(A,B\\) 互质的情况。显然此时右式中的 \\([\\gcd (x,y) = 1]\\) 恒成立。而左式可以通过积性函数的性质拆开。两侧都为 \\(d(A)*d(B)\\) ，成立。（其实并没有按是否互质讨论的必要，但是这样想能让我们的思路更加清晰）\n那么考虑 \\(\\gcd(A,B) \\not= 1\\) 时的情况。不妨先证明 \\(A = p^a, B = p^b\\) （ \\(p\\) 是素数，这两个 \\(p\\) 是同一个数）时等式成立。\n这部分的证明是容易的。根据约数个数的定义，左式显然为 \\(a+b+1\\)。对于右式，设 \\(x = p^c, y= p^d\\) ，若要使 \\([\\gcd (x,y) = 1]\\) 成立， \\(c,d\\) 中至少有一个为 \\(0\\) 。那么当 \\(b=0\\)时，\\(c \\in [0, a]\\)；当 \\(a=0\\) 时， \\(c \\in [0,b]\\) ；其他情况都不满足条件。排除重复的 \\(c=0, d=0\\) ，共有 \\(a+b+1\\) 个情况成立，与左式相同，故等式成立。\n讨论更加一般的情况。有了前面的证明，我们考虑将 \\(AB\\) 分解质因数后食用，分解后的每一项的形式为 \\(p^{a+b}\\) 。左边根据约数个数基本性质“指数加一连乘积”，即每一个 \\(p\\) 对应的 \\((a+b+1)\\) 之积。对于右侧，前证说明对于每个 \\(p\\) ，合法的 \\(c,d\\) 的选择有对应的 \\(a+b+1\\) 种，要让 \\([\\gcd(x,y)=1]\\) 需要每一个 \\(p\\) 都是合法情况。而每个 \\(p\\) 相对独立，其本质就是许多个“选择”，直接用乘法原理合并起来即可，于是也与左式相同。\n用通俗一点的说法，我不管其他的 \\(p\\) 到底需要让 \\(x,y\\) 满足什么样的条件才能使 \\([\\gcd(x,y)=1]\\) ，反正在我这个 \\(p\\) 这里只有 \\(a+b+1\\) 个方案有合法的可能性。\n总之这样就证毕了。\n证明思路很像积性函数的合并，也许对其他一些积性函数命题的证明这种方法也管用。\n参考：\nhttps://www.luogu.com.cn/blog/_post/89727\nhttps://www.luogu.com.cn/blog/_post/39908\n\n\n高维\n对于形如 \\[\nd(ABC) = \\sum_{x|A} \\sum_{y|B} \\sum_{z|C} [\\gcd (x,y) = 1] [\\gcd (y,z) = 1] [\\gcd (x,z) =1]\n\\]\n的高维拓展，证明思路基本相同，不再赘述。（如果觉得有点迷可以先跳过，Extended里的证明更加接近本质）"
  },
  {
    "objectID": "posts/20200220-factor/index.html#extended-update-20200308",
    "href": "posts/20200220-factor/index.html#extended-update-20200308",
    "title": "约数个数函数的一个性质证明，以及其推广",
    "section": "Extended (update 2020/03/08)",
    "text": "Extended (update 2020/03/08)\n下面研究 Original 推广到广义约数个数函数的形式。\n\n二维\n\n\\[\n\\sigma_k (AB) = \\sum_{x|A} \\sum_{y|B} [\\gcd(x,y)=1] (x \\frac{B}{y})^k = \\sum_{x|A} \\sum_{y|B} [\\gcd(x,\\frac{B}{y})=1] (x y)^k\n\\]\n其中 \\(\\sigma_k\\) 是广义的约数个数函数，即 \\(\\sigma_k (n) = \\sum_{d|n} d^k\\)\n\n显然中式和右式是等价的。现证明左式和右式等价。\n证明思路与上面基本一致。同样的，我们先解决 \\(A=p^a, B=p^b\\) 的情况。\n首先，直接由定义得出左式： \\[\n左式 = \\sum_{i=0}^{a+b} p^{ik}\n\\]\n同样设 \\(x=p^c, y=p^d\\) 。分析 \\([\\gcd(x,\\frac{B}{y})=1]\\) 的意义，它的意思是若 \\(x\\) 中不含 \\(p\\) （ \\(c=0\\) ），则 \\(y\\) 可以随便选（ \\(d \\in [0,b]\\) ）；若 \\(x\\) 中含 \\(p\\) （ \\(c \\in [1,a]\\) ），则 \\(y\\) 就必须包含所有的 \\(p\\) （ \\(d=b\\) ），否则 \\(\\frac{B}{y}\\) 里就含有 \\(p\\) 了；其他情况不满足条件 。\n即合法的情况为 \\((0,[0,b])\\) 和 \\(([1,a],b)\\) 。\n那么，根据右式的形式，可以得出 \\[\n\\begin{aligned}\n右式 &= \\sum_{i=0}^b p^0 p^i + \\sum_{i=1}^a p^i p^b \\\\\n&= \\sum_{i=0}^b p^i + \\sum_{i=1}^a p^{b+i}\n\\end{aligned}\n\\]\n该式实际上只是将左式的枚举从 \\(b\\) 那里切开了。两式是等价的。\n那么和上面一样的，对于一般的情况分解质因数，对每一个 \\(p\\) 分别考虑，积性合并即可。全部乘起来的依据也是乘法原理（ \\(\\sum * \\sum\\) 就是在枚举所有的方案对应贡献乘积之和）。可能有人问：这里的 \\(B\\) 不是发生变化了吗？其实 \\(B\\) 充当的是一个 \\(y\\) 的全集，不是 \\(p^b\\) 了也不影响 \\(x,y\\) 的取值，所以是没有关系的。可以参考一下 Original 里“通俗一点的说法”。\n\n\n高维\n形如 \\[\n\\sigma_k (ABC) = \\sum_{x|A} \\sum_{y|B} \\sum_{z|C} [\\gcd(x,\\frac{B}{y})=1] [\\gcd(y,\\frac{C}{z})=1] [\\gcd(x, \\frac{C}{z}=1)] (x y z)^k\n\\]\n的高维拓展， \\(\\gcd\\) 部分就是如 \\(x-y\\) ， \\(x-z\\) ， \\(y-z\\) 两两配对的形式，这样来限制取值范围。\n证明思路基本相同，同样写出合法情况 \\((0,0,[0,c])\\) ， \\((0,[1,b],c)\\) ， \\(([1,a],b,c)\\) ，对应 \\(p^{a+b+c+1}\\) ，就容易证明了。\n没看到过要用这个的题，已对拍检验正确性。"
  },
  {
    "objectID": "posts/20201116-ratio/index.html",
    "href": "posts/20201116-ratio/index.html",
    "title": "CodeChef-RNDRATIO Mysterious Ratio 题解",
    "section": "",
    "text": "CodeChef-RNDRATIO Mysterious Ratio\n\n题意简述：\n对每个 \\(1 \\le i \\le n\\) ，随机选择一个数 \\(A_i\\) ，满足 \\(L_i \\le A_i \\le R_i\\) ，求 \\(\\mathrm{lcm}_{i=1}^n A_i\\) 的期望。\n\\(1 \\le n \\le 10^5\\) ， \\(1 \\le L_i \\le R_i \\le 10^5\\) 。\nExample Input:\n2\n1\n1 3\n2\n2 4\n5 5\nExample Output:\n1\n15\n\n好久没做毒瘤式子题，推错好几次…\n不过后面用到的乘法差分还是比较新颖，记录一下吧。\n答案显然是这个式子—— \\[\n\\prod_{i=1}^n (R_i-L_i+1)^{-1} \\sum_{\\begin{aligned}L_i \\le &A_i \\le R_i \\\\ 1 \\le &i \\le n\\end{aligned}} \\frac{\\prod_{i=1}^n A_i}{\\gcd_{i=1}^{n} A_i}\n\\] 前面的 \\(\\prod\\) 是常数可以先抛开，后面就暴算吧。（等式右边 \\(\\cdots\\) 后有少许说明） \\[\n\\begin{aligned}\n\\sum_{L_i \\le A_i \\le R_i} \\frac{\\prod A_i}{\\gcd A_i}\n&= \\sum_{k=1}^{\\min R_i} \\sum_{L_i \\le A_i \\le R_i} [\\gcd A_i = k] \\frac{\\prod A_i}{k} \\\\\n&= \\sum_k k^{n-1} \\sum_{\\lceil \\frac{L_i}{k} \\rceil \\le B_i \\le \\lfloor \\frac{R_i}{k} \\rfloor} [\\gcd B_i = 1] \\prod B_i \\qquad \\qquad \\cdots ( \\ k B_i = A_i \\ ) \\\\\n&= \\sum_k k^{n-1} \\sum_{\\lceil \\frac{L_i}{k} \\rceil \\le B_i \\le \\lfloor \\frac{R_i}{k} \\rfloor} \\sum_{d|\\gcd B_i} \\mu(d) \\prod B_i \\qquad \\qquad \\cdots ( \\ \\sum_{d|n} \\mu(d) = [n=1] \\ ) \\\\\n&= \\sum_k k^{n-1} \\sum_{d=1}^{\\lfloor \\frac{\\min R_i}{k} \\rfloor} \\mu(d) d^n \\sum_{\\lceil \\frac{L_i}{kd} \\rceil \\le C_i \\le \\lfloor \\frac{R_i}{kd} \\rfloor} \\prod C_i \\qquad \\quad \\ \\cdots ( \\ d C_i = B_i , \\ \\frac{\\lfloor \\frac{a}{b} \\rfloor}{c} = \\lfloor \\frac{a}{bc} \\rfloor \\ ) \\\\\n&= \\sum_k k^{n-1} \\sum_{d} \\mu(d) d^n \\prod_{i=1}^n \\sum_{\\lceil \\frac{L_i}{kd} \\rceil \\le x \\le \\lfloor \\frac{R_i}{kd} \\rfloor} x \\\\\n&= \\sum_k k^{n-1} \\sum_{d} \\mu(d) d^n \\prod_{i=1}^n \\left( S(\\lfloor \\frac{R_i}{kd} \\rfloor) - S(\\lceil \\frac{L_i}{kd} \\rceil -1) \\right) \\qquad \\qquad \\qquad \\cdots ( \\ S(n) = \\sum_{x=1}^n x \\ ) \\\\\n&= \\sum_{T=1}^{\\min R_i} \\left( \\sum_{d|T} \\mu(d) (\\frac{T}{d})^{n-1} d^n \\right) \\prod_{i=1}^n \\left( S(\\lfloor \\frac{R_i}{T} \\rfloor) - S(\\lceil \\frac{L_i}{T} \\rceil -1) \\right) \\qquad \\ \\cdots ( \\ T = kd \\ ) \\\\\n&= \\sum_T T^{n-1} \\left( \\sum_{d|T} \\mu(d) d \\right) \\prod_{i=1}^n \\left( S(\\lfloor \\frac{R_i}{T} \\rfloor) - S(\\lceil \\frac{L_i}{T} \\rceil -1) \\right)\n\\end{aligned}\n\\]\n所以最终的式子便是\n\\[\n\\prod_{i=1}^n (R_i-L_i+1)^{-1} \\sum_{T=1}^{\\min R_i} T^{n-1} f(T) \\prod_{i=1}^n \\left( S(\\lfloor \\frac{R_i}{T} \\rfloor) - S (\\lceil \\frac{L_i}{T} \\rceil -1) \\right)\n\\] 其中 \\[\nS(n) = \\frac{n(n+1)}{2}\n\\]\n\\[\nf(n) = \\sum_{d|T} \\mu(d) d\n\\]\n显然 \\(f(n)\\) 是个积性函数，故可以用线性筛预处理出其前 \\(n\\) 项，只需用到如下的性质\n\\[\nf(p^c) = \\sum_{i=0}^c \\mu(p^i) p^i = 1 - p \\quad (c \\ge 2)\n\\]\n其实如果所有 \\(Li,R_i\\) 都相等的话就可以直接上杜教筛 / min25筛之类的黑科技把复杂度优化到 \\(O(n^{1-\\omega})\\) 了，但这道题很不套路的不相等，所以我们需要找到方法对所有 \\(T\\) 快速计算后面的 \\(\\prod\\) 。\n正解巧妙的使用了乘法差分。首先 \\(O(n \\sqrt n)\\) 对所有 \\(i\\) 都整除分块一次得到区间，然后在 \\(T\\) 上做乘法差分，每个分块区间乘上贡献 \\(S(\\lfloor \\frac{R_i}{T} \\rfloor) - S (\\lceil \\frac{L_i}{T} \\rceil -1)\\) 。最后计算的时候扫一遍就能拿到每个 \\(T\\) 对应的 \\(\\prod\\) 的值了。\n注意对 \\(0\\) 的特殊处理。\nCodeChef上跑不过，懒得卡常了。\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\n#include&lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nll Rd(){\n    ll ans=0;bool fh=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9'){if(c=='-') fh=1; c=getchar();}\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    if(fh) ans=-ans;\n    return ans;\n}\n\nll CD(ll a,ll b){return (a-1)/b+1;} //CeilDiv\nconst ll MOD=998244353,INF=1E18;\n#define _ %MOD\nll PMod(ll x){\n    if(x&gt;=MOD) return x-MOD;\n    else if(x&lt;0) return x+MOD;\n    else return x;\n}\nll QPow(ll x,ll up){\n    PMod(x _);ll ans=1;\n    while(up){\n        if(up%2==0) x=x*x _,up/=2;\n        else ans=ans*x _,up--;\n    }\n    return ans;\n}\nll Inv(ll x){return QPow(x,MOD-2);}\nconst ll INV2=Inv(2);\n\nconst ll MXN=1E5+5;\nll P[MXN],pN;\nbool notP[MXN];\nll f[MXN];//\\sum_{d|n} \\mu(d) d\nvoid LinearSieve(ll n){\n    notP[1]=1;for(ll i=2;i&lt;=n;i++) notP[i]=0;\n    pN=0;f[1]=1;\n    for(ll i=2;i&lt;=n;i++){\n        if(!notP[i]){\n            P[++pN]=i;\n            f[i]=PMod(1-i);\n        }\n        for(ll j=1;j&lt;=pN&&i*P[j]&lt;=n;j++){\n            notP[i*P[j]]=1;\n            if(i%P[j]==0){\n                f[i*P[j]]=f[i];\n                break;\n            }\n            f[i*P[j]]=f[i]*f[P[j]]_;\n        }\n    }\n}\nll S(ll n){return n*(n+1)_*INV2 _;}\nll N,MI;\nll L[MXN],R[MXN];\n/*namespace Normal{\n    void Solve(){\n        ll Ans=0;\n        for(ll t=1;t&lt;=MI;t++){\n            ll pdt=1;for(ll i=1;i&lt;=N;i++) pdt=pdt*PMod(S(R[i]/t)-S(CD(L[i],t)-1))_;\n            Ans=(Ans+QPow(t,N-1)*f[t]_*pdt)_;\n        }\n        ll pdt=1;for(ll i=1;i&lt;=N;i++) pdt=pdt*Inv(R[i]-L[i]+1)_;\n        Ans=Ans*pdt _;\n        printf(\"%lld\\n\",Ans);\n    }\n}*/\nnamespace Lunatic{\n    ll diff[MXN],zero[MXN];\n    ll bl[MXN],br[MXN],blN,brN;\n    void PutDiff(){\n        for(ll k=1;k&lt;=MI;k++) diff[k]=1,zero[k]=0;\n        for(ll i=1;i&lt;=N;i++){\n            brN=0;for(ll t=1;t&lt;=R[i];t=R[i]/(R[i]/t)+1) br[++brN]=R[i]/(R[i]/t);\n            br[++brN]=MI;\n            blN=0;for(ll t=MI;t&gt;=1;t=CD(L[i],CD(L[i],t))-1) bl[++blN]=t;\n            for(ll j=blN,k=1,st=1,ed;st&lt;=MI;st=ed+1){\n                if(bl[j]&lt;br[k]||k&gt;brN) ed=bl[j--];\n                else ed=br[k++];\n                ll t=ed;\n                ll val=PMod(S(R[i]/t)-S(CD(L[i],t)-1));\n                if(val){\n                    diff[st]=diff[st]*val _;\n                    diff[ed+1]=diff[ed+1]*Inv(val)_;\n                }else{\n                    zero[st]++;\n                    zero[ed+1]--;\n                }\n            }\n        }\n    }\n    void Solve(){\n        PutDiff();\n        ll Ans=0;\n        ll pdt=1,zn=0;\n        for(ll t=1;t&lt;=MI;t++){\n            zn+=zero[t];pdt=pdt*diff[t]_;\n            if(!zn) Ans=(Ans+QPow(t,N-1)*f[t]_*pdt)_;\n        }\n        pdt=1;for(ll i=1;i&lt;=N;i++) pdt=pdt*Inv(R[i]-L[i]+1)_;\n        Ans=Ans*pdt _;\n        printf(\"%lld\\n\",Ans);\n    }\n}\nint main(){\n    LinearSieve(MXN-1);\n    ll T=Rd();while(T--){\n        N=Rd();\n        MI=INF;\n        for(ll i=1;i&lt;=N;i++){\n            L[i]=Rd();R[i]=Rd();\n            MI=min(MI,R[i]);\n        }\n        //Normal::Solve();\n        Lunatic::Solve();\n    }\n    return 0;\n}"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html",
    "href": "posts/20230621-cpmodel/index.html",
    "title": "算法 & 数学碎碎念",
    "section": "",
    "text": "前半部分主要为公式、推导、证明等速成提纲，大部分实现、模板、表格放在文末．"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#数论",
    "href": "posts/20230621-cpmodel/index.html#数论",
    "title": "算法 & 数学碎碎念",
    "section": "1 数论",
    "text": "1 数论\n\n1.1 ExGCD\n\n\n\n\n\n\n\n定理 1 (ExGCD) 给定线性方程组 \\(ax+by=\\gcd(a,b)\\)，其解可递归地由下式求得 \\[\na y_1 + b \\left( x_1 - \\left\\lfloor \\frac a b \\right\\rfloor y_1 \\right) = \\gcd(b, a \\bmod b)\n\\] 其中 \\(x_1, y_1\\) 是 \\(b x + (a \\bmod b) y = \\gcd(b, a \\bmod b)\\) 的一组解．\n\n\n\n\n\n\n1.2 CRT\n\n\n\n\n\n\n\n定理 2 (CRT) 给定 \\(n\\) 个同余方程 \\[\nx \\equiv a_i \\pmod{m_i} \\pod{i = 1, \\dots, n}\n\\]\n其中各 \\(m_i\\) 两两互质，则上式等价于 \\[\nx \\equiv \\sum_{i=1}^n a_i M_i \\operatorname{inv}_{m_i}(M_i) \\pmod M\n\\] 其中 \\(M = \\prod_{i=1}^n m_i\\)，\\(M_i = \\frac{M}{m_i}\\)．\n\n\n\n\n\n注记. \\[\nM_i \\operatorname{inv}_{m_i}(M_i) \\mod m_j = [i = j]\n\\]\n\n\nExCRT\n对一般的情况，考虑合并两个同余方程．给定 \\(2\\) 个同余方程 \\[\n\\left\\{\n\\begin{aligned}\n  x &\\equiv a_1 \\pmod{m_1} \\\\\n  x &\\equiv a_2 \\pmod{m_2}\n\\end{aligned}\n\\right.\n\\] 考虑化为不定方程形式 \\[\n\\begin{aligned}\n  x = k_1 m_1 + a_1 \\\\\n  x = k_2 m_2 + a_2\n\\end{aligned}\n\\] 合并得到 \\[\nk_1 m_1 + a_1 = k_2 m_2 + a_2\n\\] 即 \\[\nk_1 m_1 - k_2 m_2 = a_2 - a_1\n\\] 此即关于 \\(k_1, k_2\\) 的不定方程．若 \\(\\gcd(m_1, m_2) \\mid a_2 - a_1\\)，则可应用 ExGCD 求得方程的一组解，带回即得 \\[\nx \\equiv k_1 m_1 + a_1 \\pmod{\\operatorname{lcm}(m_1, m_2)}\n\\] 否则同余方程组无解．\n\n注记. 若一组同余方程两两可合并，则全部均可合并．当判断大规模同余方程组是否有解时可能用到．\n\n\n\n\n1.3 BSGS\n求 \\(a^x \\equiv b \\pmod{m}\\) 的一个特解，其中 \\(\\gcd(a,m) = 1\\)．\n实质是非常暴力的根号分治．根据 Euler 定理，只需检测连续 \\(\\varphi(m)\\) 个 \\(x\\) 就可判定是否有解．令 \\(x = q \\left\\lceil \\sqrt m \\right\\rceil -r\\)，其中 \\(q,r \\in [1,\\left\\lceil \\sqrt m \\right\\rceil]\\)，于是 \\(x \\in [0,\\left\\lceil \\sqrt m \\right\\rceil^2)\\)．代入原方程移项即得 \\(a^{q \\left\\lceil \\sqrt m \\right\\rceil} \\equiv b a^r \\pmod{m}\\)，右边使用 map 提前存下即可．时间复杂度 \\(O(\\sqrt m)\\)．\n\n\n1.4 Miller-Rabin【TODO】\n\n\n1.5 Pollard-Rho【TODO】\n\n\n1.6 原根、Euler 定理等\n见 FFT/NTT 讲稿．\n\n\n1.7 Lucas 定理\n\n\n\n\n\n\n\n定理 3 (Lucas 定理) \\[\n\\binom{n}{m} \\equiv \\prod_{i} \\binom{n_i}{m_i} \\equiv \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p \\right\\rfloor} \\binom{n \\bmod p}{n \\bmod p} \\pmod p\n\\]\n其中 \\(p\\) 是质数，\\(n_i\\) 和 \\(m_i\\) 是 \\(n\\) 和 \\(m\\) 的 \\(p\\) 进制表示下的各数位．\n\n\n\n\n证明的要点有二：一是 \\(\\binom {p^i} m \\bmod {p} = [m = 0 \\land m = p^i]\\)，即 \\((1+x)^{p^i} \\equiv 1 + x^{p^i} \\pmod p\\)；二是 Vandermonde 卷积按 \\(p\\) 进制拆分．生成函数食用风味更佳．\n参考：\n\nLucas’s theorem - Wikipedia\n卢卡斯定理 - OI Wiki\n\n\n\n1.8 Legendre 公式和 Kummer 定理\n\n\n\n\n\n\n\n定理 4 (Legendre 公式) \\[\n\\nu_p (n!) = \\sum_{i=1}^{+\\infty} \\left\\lfloor \\frac n {p^i} \\right\\rfloor = \\frac{n-S_p(n)}{p-1}\n\\]\n其中 \\(p\\) 是质数，\\(S_p(n)\\) 是 \\(n\\) 在 \\(p\\) 进制下各数位数字之和．\\(\\nu_p (n!)\\) 为 \\(n!\\) 中质因子 \\(p\\) 的含量，即所谓的 \\(p\\)-adic valuation of \\(n!\\)．\n\n\n\n\n左侧显然，按和式统计贡献即证．对于右侧， \\[\n\\begin{aligned}\n\\sum_{i=1}^{+\\infty} \\left\\lfloor \\frac n {p^i} \\right\\rfloor &= \\sum_{i=1}^{+\\infty} \\sum_{k=0}^{+\\infty} n_{k+i} p^k \\\\\n&= \\sum_{j=1}^{+\\infty} n_j \\sum_{k=0}^{j-1} p^k \\\\\n&= \\sum_{j=1}^{+\\infty} n_j \\frac{p^j-1}{p-1} \\\\\n&= \\frac 1 {p-1} \\left(\\sum_{j=1}^{+\\infty} n_j p^j - \\sum_{j=1}^{+\\infty} n_j\\right) \\\\\n&= \\frac 1 {p-1} \\left(\\sum_{j=0}^{+\\infty} n_j p^j - \\sum_{j=0}^{+\\infty} n_j\\right) \\\\\n&= \\frac {n - S_p(n)}{p-1}\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n定理 5 (Kummer 定理) \\(\\binom {a+b} a\\) 中质因子 \\(p\\) 的含量等于 \\(p\\) 进制下加法 \\(a+b\\) 发生的进位次数，也可表示为 \\[\n\\nu_p \\left( \\binom {a+b}{a} \\right) = \\frac{S_p(a)+S_p(b)-S_p(a+b)}{p-1}\n\\]\n\n\n\n\n大力使用 定理 4 考察 \\(\\binom {a+b}{a}\\) 的含 \\(p\\) 量： \\[\n\\begin{aligned}\n\\nu_p \\left( \\binom {a+b}{a} \\right) &= \\nu_p((a+b)!) - \\nu_p(a!) - \\nu_p(b!) \\\\\n&= \\sum_{k=1}^\\infty \\left( \\left\\lfloor \\frac {a+b}{p^k} \\right\\rfloor - \\left\\lfloor \\frac {a}{p^k} \\right\\rfloor - \\left\\lfloor \\frac {b}{p^k} \\right\\rfloor \\right)\n\\end{aligned}\n\\] 该公式恰好对 \\(a+b\\) 在 \\(p\\) 进制计算过程中每一位发生的进位进行了求和．定理的 \\(S_p\\) 形式容易通过 定理 4 的另一形式得到．\n研究该定理 \\(a+b = p^m\\) 的特例．用下降阶乘幂形式考虑二项式系数中 \\(k\\) 递增的过程，注意到 \\(\\nu_p (p^m-k) = \\nu_p(k)\\)，可以发现分子新增的 \\(n-k+1\\) 和分母新增的 \\(k\\) 恰好错一位，于是 \\[\n\\nu_p \\left( \\binom {p^m} k \\right) = m - \\nu_p (k),\\quad k = 1,2,\\dots,p^m\n\\]\n作为 Kummer 定理和上述特殊情况的推论，我们有 \\[\n\\gcd_{k=1}^{n-1} \\binom{n}{k} = \\begin{cases}\np & n = p^m \\\\\n1 & \\text{otherwise}\n\\end{cases}\n\\] 其中 \\(p\\) 是某一质数．这符合 Kummer 定理的直观描述．得到 \\(p^m\\) 的加法必然会出现进位，在加法 \\(p^{m-1} + (p-1) p^{m-1}\\) 时达到最小进位次数 \\(1\\)；否则在任一质数进制 \\(p\\) 下，都可以取加法 \\(\\operatorname{lowbit}_p (n) + (n - \\operatorname{lowbit}_p (n))\\) 使得不发生进位．\n参考：\n\nLegendre’s formula - Wikipedia\nKummer’s theorem - Wikipedia\n\n\n\n1.9 扩展 Euler 定理\n\\[\na^b \\equiv a^{b \\bmod \\varphi(m) + \\varphi(m)} \\pmod{m}\n\\]\n进入循环所需步骤其实很少，一定小于 \\(\\varphi(m)\\)．（疑似量级在 \\(\\log m\\) 以下，存疑，见 FFT 讲稿）\n\n\n1.10 Lagrange 定理\n\n\n\n\n\n\n\n定理 6 (Lagrange 定理) 设 \\(p\\) 是质数，\\(A(x) \\in \\mathbb Z_p[x]\\)．同余方程 \\(A(x) \\equiv 0 \\pmod p\\) 只有至多 \\(\\operatorname{deg} A(x)\\) 个模 \\(p\\) 意义下不同的整数解，除非这多项式的系数在模 \\(p\\) 意义下全为零．\n\n\n\n\n这是域上的多项式理论在模 \\(p\\) 整数域上的应用．\n\n\n1.11 Wilson 定理\n\n\n\n\n\n\n\n定理 7 (Wilson 定理) 对质数 \\(p\\)， \\[\n(p-1)! \\equiv -1 \\pmod p\n\\]\n\n\n\n\n\\(p=2\\) 容易特判证明．现在只考虑 \\(p\\) 是奇质数的情况．\n\\((p-1)!\\) 中，互为逆元的数相互抵消，仅剩下逆元为自身的数 \\(\\pm 1\\)，立得上述定理．\n另一种证法注意到 \\(x^{p-1} - 1 = \\prod_{k=1}^{p-1} (x-k)\\)．这是因为 Fermat 小定理指出 \\(1\\) 至 \\(p-1\\) 的所有数的 \\(p-1\\) 次幂均为 \\(1\\)，而 Lagrange 定理又保证了多项式点值到系数映射的唯一性．随后代入 \\(x=0\\) 立得结论．\n参见 Wilson’s theorem - Wikipedia．\n\n\n1.12 线性预处理\n\n线性求逆元\n现欲求出 \\(a\\) 模质数 \\(p\\) 意义下的逆元 \\(a^{-1}\\)．用 \\(a\\) 对 \\(p\\) 做带余除法，\\(p=qa+r\\)，于是 \\(-qa \\equiv r \\pmod p\\)．两侧同时乘 \\(r\\) 的逆元 \\(r^{-1}\\) 得 \\(-q r^{-1} a \\equiv 1 \\pmod p\\)，故 \\[\na^{-1} = - q r^{-1} = - \\left\\lfloor \\frac p a \\right\\rfloor \\cdot (p \\bmod a)^{-1}\n\\]\n\n\n线性阶乘逆\n\\[\n\\frac 1 {n!} = (n+1) \\cdot \\frac 1 {(n+1)!}\n\\]"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#积性函数",
    "href": "posts/20230621-cpmodel/index.html#积性函数",
    "title": "算法 & 数学碎碎念",
    "section": "2 积性函数",
    "text": "2 积性函数\n\n2.1 整除分块\nll ans=0;\nfor(ll l=1,r,d;l&lt;=N;l=r+1){\n    d=N/l, r=N/d;\n    ans+=(S_mu(r)-S_mu(l-1))*d;\n}\n此 \\(O(\\sqrt n)\\) 较满，极大劣于因子个数的 \\(O(\\sqrt n)\\)．\n另有变种枚举 \\(\\left\\lfloor \\frac n {d^2} \\right\\rfloor\\) 的整除分块如下，复杂度为 \\(O(n^{1/3})\\)．\nll ans=0;\nfor(ll l=1,r,d;l*l&lt;=N;l=r+1){\n    d=N/(l*l),r=sqrt(N/d);\n    ans+=(S_mu(r)-S_mu(l-1))*d;\n}\n\n上取整整除分块\nll cdiv(ll a,ll b){ //ceil(a/b)\n    return (a&lt;0||a%b==0)?a/b:a/b+1;\n}\nll ans=0;\nfor(ll l,r=N,d;r&gt;=1;r=l-1){\n    d=cdiv(N,r), l=cdiv(N,d);\n    ans+=(S_mu(r)-S_mu(l-1))*d;\n}\n\n\n\n2.2 杜教筛\n设 \\(f\\) 为一数论函数，我们希望快速求得其前缀和 \\(\\hat f (n) = \\sum_{i=1}^n f(i)\\). 考虑数论函数 \\(g\\) 和 \\(h = g * f\\)， \\[\nh(n) = \\sum_{d \\mid n} g(d) f(\\frac n d)\n\\] 两端做前缀和得 \\[\n\\begin{aligned}\n\\hat h (n)\n&= \\sum_{i=1}^n h(i) \\\\\n&= \\sum_{i=1}^n \\sum_{d \\mid i} g(d) f(\\frac i d) \\\\\n&= \\sum_{d=1}^n g(d) \\sum_{i=1}^{\\left\\lfloor \\frac n d \\right\\rfloor} f(i) \\\\\n&= \\sum_{d=1}^n g(d) \\hat f (\\left\\lfloor \\frac n d \\right\\rfloor) \\\\\n&= g(1) \\hat f (n) + \\sum_{d=2}^n g(d) \\hat f (\\left\\lfloor \\frac n d \\right\\rfloor)\n\\end{aligned}\n\\] 因此 \\[\n\\hat f (n) = \\frac 1 {g(1)} \\left( \\hat h (n) - \\sum_{d=2}^n g(d) \\hat f (\\left\\lfloor \\frac n d \\right\\rfloor) \\right)\n\\]\n故若 \\(g\\)、\\(h\\) 的前缀和可 \\(O(1)\\) 算得，根据上式整除分块即可递归地计算出 \\(f\\) 的前缀和．预处理前 \\(O(n^{2/3})\\) 项并记忆化得到的时间复杂度为 \\(O(n^{2/3})\\)．外层整除分块不会增加时间复杂度．\n关于时间复杂度证明可参考 sun123zxy’s blog - OI 数论中的上界估计与时间复杂度证明 # 杜教筛．\n\\[\n\\begin{gathered}\nf = \\mu, g = I, h = \\varepsilon \\\\\nf = \\varphi, g = I, h = \\operatorname{id}\\\\\nf = \\operatorname{id}^k \\mu, g = \\operatorname{id}^k, h = \\varepsilon \\\\\nf = \\operatorname{id}^k \\varphi, g = \\operatorname{id}^k, h = \\operatorname{id}^{k+1}\n\\end{gathered}\n\\]\n\n注记. 杜教筛的这种化法事实上也是 Eratosthenes 筛法的应用．一般的我们有 \\[\n\\sum_{d=1}^n f(d) \\hat g( \\left\\lfloor \\frac n d \\right\\rfloor ) = \\sum_{i=1}^n \\sum_{d \\mid i} f(d) g(\\frac i d) = \\sum_{i=1}^n \\sum_{d \\mid i} f(\\frac i d) g(d)   = \\sum_{d=1}^n g(d) \\hat f( \\left\\lfloor \\frac n d \\right\\rfloor )\n\\]\n\nunordered_map&lt;ll,ll&gt; s_mu;\nll S_mu(ll n){\n    if(n&lt;=MXG){\n        return mu[n]; // already accumulated\n    }else if(s_mu.count(n)){\n        return s_mu[n];\n    }\n    ll ans=0;\n    for(ll l=2,r,d;l&lt;=n;l=r+1){\n        d=n/l,r=n/d;\n        ans+=S_mu(d)*(r-l+1);\n    }\n    return s_mu[n]=1-ans;\n}\n\n\n2.3 杂式\n无平方因子数计数： \\[\n\\sum_{i=1}^n \\mu^2(i) = \\sum_{i=1}^{\\left\\lfloor \\sqrt n \\right\\rfloor} \\mu(i) \\left\\lfloor \\frac n {i^2} \\right\\rfloor\n\\]\n约数个数函数的一个性质：\n\\[\nd(ab) = \\sum_{x|a} \\sum_{y|b} [\\gcd (x,y) = 1]\n\\]\n\\[\nd(abc) = \\sum_{x|a} \\sum_{y|b} \\sum_{z|c} [\\gcd (x,y) = 1] [\\gcd (y,z) = 1] [\\gcd (x,z) =1]\n\\]\n广义约数个数函数性质扩展：\n\\[\n\\sigma_k (ab) = \\sum_{x|a} \\sum_{y|b} [\\gcd(x,y)=1] (x \\frac{b}{y})^k = \\sum_{x|a} \\sum_{y|b} [\\gcd(x,\\frac{b}{y})=1] (x y)^k\n\\]\n\\[\n\\sigma_k (abc) = \\sum_{x|a} \\sum_{y|b} \\sum_{z|c} [\\gcd(x,\\frac{b}{y})=1] [\\gcd(y,\\frac{c}{z})=1] [\\gcd(x, \\frac{c}{z}=1)] (x y z)^k\n\\]"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#组合",
    "href": "posts/20230621-cpmodel/index.html#组合",
    "title": "算法 & 数学碎碎念",
    "section": "3 组合",
    "text": "3 组合\n\n3.1 容斥 / 二项式反演\n\n形式一\n容斥原理的第一种形式给出了“子集和变换”的逆变换．\n\n\n\n\n\n\n\n定理 8 (容斥原理，形式一，集合) \\[\ng(S) = \\sum_{T \\subset S} f(T) \\iff f(S) = \\sum_{T \\subset S} (-1)^{|S| - |T|} g(T)\n\\]\n\n\n\n\n证明的关键是 \\(\\sum_{k=0}^n \\binom n k (-1)^k = (1-1)^n = [n=0]\\)．\n\n\n\n\n\n\n\n定理 9 (容斥原理，形式一，二项式反演) \\[\ng(n) = \\sum_{k=0}^n \\binom n k f(k) \\iff f(n) = \\sum_{k=0}^n (-1)^{n-k} \\binom n k g(k)\n\\]\n若设 \\(F(x)\\) 和 \\(G(x)\\) 分别为 \\(f(n)\\) 和 \\(g(n)\\) 的指数生成函数（EGF），则结论可等价地表示为\n\\[\nG(x) = e^x F(x) \\iff F(x) = e^{-x} G(x)\n\\]\n\n\n\n\n生成函数的形式使我们可在 \\(O(n \\log n)\\) 的优秀时间复杂度之内在 \\(f(n)\\) 和 \\(g(n)\\) 间做出变换．\n\n\n形式二\n形式一的补集形式，给出了全集 \\(U\\) 下“超集和变换”的逆变换．\n\n\n\n\n\n\n\n定理 10 (容斥原理，形式二，集合) \\[\ng(S) = \\sum_{S \\subset T \\subset U} f(T) \\iff f(S) = \\sum_{S \\subset T \\subset U} (-1)^{|T| - |S|} g(T)\n\\]\n\n\n\n\n\n\n\n\n\n\n\n定理 11 (容斥原理，形式二，二项式反演) \\[\ng(n) = \\sum_{k=0}^{N-n} \\binom {N-n} k f(n+k) \\iff f(n) = \\sum_{k=0}^{N-n} (-1)^k \\binom {N-n} k g(n+k)\n\\]\n\n\n\n\n\n\n应用\n\n\n\n\n\n\n\n例 1 (不太常见的“容斥原理”) 满足全部性质的元素数量可容斥地通过下式计算 \\[\n\\begin{aligned}\n\\operatorname{card}\\left( \\bigcap_{i \\in U} A_i \\right) &= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\operatorname{card}\\left( A - \\bigcup_{i \\in U-S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\operatorname{card}\\left( \\bigcup_{i \\in S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{i_1 &lt; \\dots &lt; i_k} \\operatorname{card}\\left( A_{i_1} \\cup \\dots \\cup A_{i_k} \\right)\n\\end{aligned}\n\\] 其中 \\(A\\) 代表全集，\\(A_i\\) 代表满足第 \\(i\\) 个性质的元素构成的集合，\\(U\\) 是非空有限的性质指标集．\n\n\n\n\n\n证明. 令 \\(f(S)\\) 为恰好只满足 \\(S\\) 中各性质的元素数量，\\(g(S)\\) 为至多只满足 \\(S\\) 中各性质的元素数量，即 \\[\n\\begin{gathered}\nf(S) := \\operatorname{card}\\left( \\left( A \\cap \\bigcap_{i \\in S} A_i \\right) - \\bigcup_{i \\in U-S} A_i \\right) \\\\\ng(S) := \\operatorname{card}\\left( A - \\bigcup_{i \\in U-S} A_i \\right)\n= \\operatorname{card}\\left(A - \\bigcup_{i \\in U} A_i \\right) + \\operatorname{card}\\left( \\bigcup_{i \\in S} A_i \\right)\n\\end{gathered}\n\\] 取 \\(S=U\\) 代入 定理 8 右侧就得到结论第一行的等式．继续化简 \\[\n\\begin{aligned}\n\\operatorname{card}\\left( \\bigcap_{i \\in U} A_i \\right) &= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\operatorname{card}\\left( A - \\bigcup_{i \\in U-S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\left( \\operatorname{card}\\left(A - \\bigcup_{i \\in U} A_i \\right) + \\operatorname{card}\\left( \\bigcup_{i \\in S} A_i \\right) \\right) \\\\\n&= \\operatorname{card}\\left(A - \\bigcup_{i \\in U} A_i \\right) \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\binom{|U|}{k} + \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\operatorname{card}\\left( \\bigcup_{i \\in S} A_i \\right)\n\\end{aligned}\n\\] 注意到 \\[\n\\sum_{k=0}^{|U|} (-1)^{|U|-k} \\binom{|U|}{k} = [|U| = 0]\n\\] 而 \\(U \\neq \\varnothing\\)，故上式左项为 \\(0\\)，即得结论式第二行．\n\n\n\n\n\n\n\n\n例 2 (有点常见的“容斥原理”) 不满足任何性质的元素数量可容斥地通过下式计算 \\[\n\\begin{aligned}\n\\operatorname{card}\\left( A - \\bigcup_{i \\in U} A_i \\right)\n&= \\sum_{k=0}^{|U|} (-1)^k \\sum_{|S| = k} \\operatorname{card}\\left( A \\cap \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\operatorname{card}A + \\sum_{k=1}^{|U|} (-1)^k \\sum_{|S| = k} \\operatorname{card}\\left( \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\operatorname{card}A + \\sum_{k=1}^{|U|} (-1)^k \\sum_{i_1 &lt; \\dots &lt; i_k} \\operatorname{card}\\left( A_{i_1} \\cap \\dots \\cap A_{i_k} \\right)\n\\end{aligned}\n\\] 其中 \\(A\\) 代表全集，\\(A_i\\) 代表满足第 \\(i\\) 个性质的元素构成的集合，\\(U\\) 是非空有限的性质指标集．\n\n\n\n\n\n证明. 令 \\(f(S)\\) 为恰好只满足 \\(S\\) 中各性质的元素数量，\\(g(S)\\) 为至少满足 \\(S\\) 中各性质的元素数量，即 \\[\n\\begin{gathered}\nf(S) := \\operatorname{card}\\left( \\left( A \\cap \\bigcap_{i \\in S} A_i \\right) - \\bigcup_{i \\in U-S} A_i \\right) \\\\\ng(S) := \\operatorname{card}\\left( A \\cap \\bigcap_{i \\in S} A_i \\right)\n= \\begin{cases}\n\\operatorname{card}A & S = \\varnothing \\\\\n\\operatorname{card}\\left( \\bigcap_{i \\in S} A_i \\right) & \\text{otherwise}\n\\end{cases}\n\\end{gathered}\n\\] 取 \\(S=\\varnothing\\) 代入 定理 10 右侧就得到结论．\n\n\n\n\n\n\n\n\n习题 1 (错排) 计算 \\(n\\) 元错排的数量．\n\n\n\n\n\n解. 设 \\(A_i\\) 表示第 \\(i\\) 个位置配对正确的置换构成的集合．直接应用 例 2 立得\n\\[\n\\begin{aligned}\n\\operatorname{card}\\left( A - \\bigcup_{i \\in U} A_i \\right) &= \\sum_{k=0}^{|U|} (-1)^k \\sum_{|S| = k} \\operatorname{card}\\left( A \\cap \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^k \\binom n k (n-k)! \\\\\n&= n! \\sum_{k=0}^{|U|} (-1)^k \\frac 1 {k!} \\sim \\frac{n!}{e}\n\\end{aligned}\n\\]\n\n这说明随机取一排列，其错排的概率趋近于 \\(\\frac 1 e\\)．\n\n\n\n\n\n\n\n例 3 (常见的“容斥原理”) 满足至少 \\(1\\) 个性质的元素数量可容斥地通过下式计算 \\[\n\\begin{aligned}\n\\operatorname{card}\\left( \\bigcup_{i \\in U} A_i \\right)\n&= \\sum_{k=1}^{|U|} (-1)^{k-1} \\sum_{|S| = k} \\operatorname{card}\\left( \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\sum_{k=1}^{|U|} (-1)^{k-1} \\sum_{i_1 &lt; \\dots &lt; i_k} \\operatorname{card}\\left( A_{i_1} \\cap \\dots \\cap A_{i_k} \\right)\n\\end{aligned}\n\\] 其中 \\(A_i\\) 代表满足第 \\(i\\) 个性质的元素构成的集合，\\(i \\in U\\)．\n\n\n\n\n\n证明. 对 例 2 做简单移项即得．\n\n\n\n\n3.2 球盒问题\n组合数学的万恶之源．\n\n\n\n\n\n\n\n\n\n\n\n\n\nID\n\\(n\\) balls\n\\(r\\) boxes\nallow empty?\nrecurrence / closed-form\ngenerating functions\nnotes\n\n\n\n\n\\[{1,1,0}\\]\nLabeled\nLabeled\nMAY empty\n\\[r^n\\]\n\\[\\begin{aligned}\\mathrm{EGF}_r(x) &= (e^{x})^r = e^{rx} \\\\ \\mathrm{OGF}_r(x) &= \\frac{1}{1-rx}\\end{aligned}\\]\n# \\([n] \\to [r]\\) mappings\n\n\n\\[{1,1,1}\\]\nLabeled\nLabeled\nNON empty\n\\[r! {n \\brace r} = \\sum_{k=0}^r (-1)^{r-k} \\binom r k k^n\\]\n\\[\\begin{aligned} \\mathrm{EGF}_r(x)&=(e^x - 1)^r \\\\ \\mathrm{EGF}_n(x) &= e^{-x} \\sum_{r=0}^{+\\infty} r^n \\frac{x^r}{r!} \\end{aligned}\\]\n# \\([n] \\to [r]\\) surjections\n\n\n\\[{1,1/\\Sigma,1}\\]\nLabeled\nLabeled; \\(r\\)-disabled\nNON empty\n\\[\\sum_{k=0}^n k! {n \\brace k}\\]\n\\[\\mathrm{EGF}_r(x)=\\frac{1}{2-e^x} = \\frac{1}{1-(e^x-1)}\\]\nordered Bell number; # weak orderings / ordered set partitions on \\([n]\\)\n\n\n\\[{1,0,0}\\]\nLabeled\nUNLabeled\nNON empty\n\\[\\sum_{k=0}^r {n \\brace k}\\]\n\\[\\mathrm{EGF}_r(x) = \\sum_{k=0}^r \\frac {(e^x - 1)^k}{k!}\\]\n\n\n\n\\[{1,0,1}\\]\nLabeled\nUNLabeled\nNON empty\n\\[\\begin{aligned} {n \\brace r} &= \\sum_{k=0}^r \\frac{k^n}{k!} \\cdot \\frac{(-1)^{r-k}}{(r-k)!} \\\\ {n+1 \\brace r} &= r {n \\brace r} + {n \\brace r-1} \\end{aligned}\\]\n\\[\\begin{aligned} \\mathrm{EGF}_r(x) &= \\frac{(e^x - 1)^r}{r!} \\\\ \\mathrm{OGF}_n(x) &= e^{-x} \\sum_{r=0}^{+\\infty} r^n \\frac{x^r}{r!} \\\\ \\sum_{n=1}^\\infty {n+r \\brace r} x^n &= \\prod_{k=1}^r \\frac 1 {1-kx} \\\\ \\sum_{n=1}^\\infty {n \\brace r} x^{\\underline{r}} &= x^n \\end{aligned}\\]\nStirling number of the second kind\n\n\n\\[{1,0/\\Sigma,1}\\]\nlabeled\nUNLabeled; \\(r\\)-disabled\nNON empty\n\\[\\begin{aligned} B(n) &= \\sum_{k=0}^n {n \\brace k} \\\\ B(n+1) &= \\sum_{k=0}^n \\binom n k B(k) \\end{aligned}\\]\n\\[\\mathrm{EGF}(x)=e^{e^x - 1}\\]\nBell number; # equivialent relations / set partitions on \\([n]\\)\n\n\n\\[{0,1,0}\\]\nUNLabeled\nLabeled\nMAY empty\n\\[\\binom{n+r-1}{r-1}\\]\n\\[\\mathrm{OGF_r}(x) = \\left(\\frac 1 {1-x}\\right)^r\\]\n\\(r\\) 元不定方程非负整数解个数\n\n\n\\[{0,1,1}\\]\nUNLabeled\nLabeled\nNON empty\n\\[\\binom{n-1}{r-1}\\]\n\\[\\begin{aligned} \\mathrm{OGF_r}(x) &= \\left(\\frac x {1-x}\\right)^r \\\\ &= x^r \\left(\\frac 1 {1-x}\\right)^r \\end{aligned}\\]\n\\(r\\) 元 \\(n\\) 次单项式构型数\n\n\n\\[{0,1/\\Sigma,1}\\]\nUNLabeled\nLabeled; \\(r\\)-disabled\nNON empty\n\\[a(n)=\\begin{cases}1 & n=0 \\\\ 2^{n-1} & n\\geq 1 \\end{cases}\\]\n\\[\\mathrm{OGF}(x) = 1+\\frac{x}{1-2x} = \\frac{1}{1-\\frac{x}{1-x}}\\]\n考虑“是否向前拼接”的 \\(n-1\\) 个选择\n\n\n\\[{0,0,0}\\]\nUNLabeled\nUNLabeled\nMAY empty\n\\[\\sum_{k=0}^r p(n,k)\\]\n\\[\\mathrm{OGF}_r(x)=\\prod_{k=1}^r \\frac{1}{1-x^k}\\]\n\\(r\\) 元 \\(n\\) 次单项对称多项式（monomial symmetric polynomial）构型数\n\n\n\\[{0,0,1}\\]\nUNLabeled\nUNLabeled\nNON empty\n\\[p(n,r)=p(n-1,r-1)+p(n-r,r)\\]\n\n\\(r\\) 部分拆数\n\n\n\\[{0,0/\\Sigma,1}\\]\nUNLabeled\nUNLabeled; \\(r\\)-disabled\nNON empty\n\\[\\begin{aligned} p(n) &= \\sum_{\\substack{k \\in \\mathbb Z}} (-1)^k p_{n-k(3k-1)/2} \\\\ &= p_{n-1} + p_{n-2} - p_{n-5} - p_{n-7} + \\dots \\end{aligned}\\]\n\\[\\begin{aligned} \\mathrm{OGF}(x)&=\\prod_{k=1}^{+\\infty} \\frac 1 {1-x^k} \\\\ &= \\left( \\sum_{k \\in \\mathbb Z} (-1)^k x^{k(3k-1)/2} \\right)^{-1} \\end{aligned}\\]\npartition function（分拆数）; # partitions of \\(n\\); \\(n\\) 元（含）以上 \\(n\\) 次单项对称多项式构型数\n\n\n\n\n以后我们约定：\n\n形如 \\(\\mathrm{BB_{1,1,0}}\\) 的记号表示代号 \\(1,1,0\\) 对应球盒问题的方案数；\n形如 \\(\\mathrm{EGF}_n^{1,1,0}(x)\\) 代表代号 \\(1,1,0\\) 对应 \\(n\\) 球球盒问题的指数生成函数；\n形如 \\(\\mathrm{EGF}_r^{1,1,0}(x)\\) 代表代号 \\(1,1,0\\) 对应 \\(r\\) 球球盒问题的指数生成函数；\n普通生成函数 \\(\\mathrm{OGF}_r^{1,1,0}(x)\\) 同理．\n\n在不至混淆的情况下，也可省略下标或上标上的代号．\n\n通用性质\n\n\n\n\n\n\n\n命题 1 (非空盒数量不限制) \\[\n\\begin{gathered}\n\\mathrm{BB}_{*,*/\\Sigma,1}(n) = \\sum_{k=0}^n \\mathrm{BB}_{*,*,1}(n,k) \\\\\n\\mathrm{EGF}^{*,*/\\Sigma,1}(x) = \\sum_{k=0}^{+\\infty} \\mathrm{EGF}_{r=k}^{*,*,1}(x)\n\\end{gathered}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n命题 2 (有标号盒空置) \\[\n\\begin{gathered}\n\\mathrm{BB}_{*,1,0}(n,r) = \\sum_{k=0}^r \\binom r k \\mathrm{BB}_{*,1,1}(n,k) \\\\\n\\mathrm{EGF}_n^{*,1,0}(x) = e^x \\mathrm{EGF}_n^{*,1,1}(x)\n\\end{gathered}\n\\]\n\n\n\n\n对有标号盒的二项式反演．在 \\(1,1,0\\)-球盒问题中，上式体现为第二类 Stirling 数的通项公式；在 \\(0,1,0\\)-球盒问题中，上式体现为 Vandermonde 卷积．\n\n\n\n\n\n\n\n命题 3 (无标号盒空置) \\[\n\\begin{gathered}\n\\mathrm{BB}_{*,0,0}(n,r) = \\sum_{k=0}^r \\mathrm{BB}_{*,0,1}(n,k) \\\\\n\\mathrm{OGF}_n^{*,0,0}(x) = \\frac 1 {1-x} \\mathrm{OGF}_n^{*,0,1}(x)\n\\end{gathered}\n\\]\n\n\n\n\n对无标号盒，直接求和即可．\n\n\n\n3.3 第二类 Stirling 数\n第二类 Stirling 数的组合定义即 \\(1,0,1\\)-球盒问题的方案数 \\(\\mathrm{BB}_{1,0,1}(n,r) = {n \\brace r}\\)，亦作将 \\(n\\) 个元素划分入 \\(r\\) 个集合的方案数．\n\n递推\n由组合意义，考虑在已有 \\(n\\) 个球时加入新球，此时面临将其放入原有的 \\(r\\) 个集合或新开辟一个集合的两种选择，由此得递推式 \\[\n{n+1 \\brace r} = r {n \\brace r} + {n \\brace r-1}\n\\] 边界在 \\[\n{n \\brace 0} = [n = 0],\\quad {n \\brace n} = 1\n\\]\n\n\n第二类 Striling 数同行计算：\\(\\mathrm{OGF}_n^{1,0,1}(x)\\) 或 \\(\\mathrm{EGF}_n^{1,1,1}(x)\\)\n来考虑用两种方法得到 \\(1,1,1\\)-球盒问题的方案数．\n我们的第一种方法注意到，上述问题的方案数恰好是 \\(1,0,1\\)-球盒问题方案数 \\(r!\\) 倍——这是对后者的盒进行标号的结果．我们得到 \\[\n\\mathrm{BB}_{1,1,1}(n,r) = r! \\mathrm{BB}_{1,0,1}(n,r) = r! {n \\brace r}\n\\]\n第二种方法考虑用容斥非空盒的方法与 \\(1,1,0\\)-球盒问题 \\(\\mathrm{BB}_{1,1,0}(n,r) = r^n\\) 建立联系．我们有 \\[\n\\mathrm{BB}_{1,1,0}(n,r) = \\sum_{k=0}^r \\binom r k \\mathrm{BB}_{1,1,1}(n,k)\n\\] 即 \\[\nr^n = \\sum_{k=0}^r \\binom r k k! {n \\brace k}\n\\] 二项式反演即得 \\[\nr! {n \\brace r} = \\sum_{k=0}^r (-1)^{r-k} \\binom r k k^n\n\\] 即 \\[\n{n \\brace r} = \\sum_{k=0}^r \\frac{(-1)^{r-k} k^n}{k! (r-k)!} = \\sum_{k=0}^r \\frac{k^n}{k!} \\cdot \\frac{(-1)^{r-k}}{(r-k)!}\n\\] 这正是第二类 Stirling 数的通项公式．注意到其具有卷积的形式，由此可快速计算出同一行的第二类 Stirling 数．事实上，二项式反演的生成函数形式已向我们道尽一切 \\[\n\\mathrm{OGF}_n^{1,0,1}(x) = \\mathrm{EGF}_n^{1,1,1}(x) = e^{-x} \\mathrm{EGF}_n^{1,1,0}(x) = e^{-x} \\sum_{k=0}^{+\\infty} k^n \\frac{x^k}{k!}\n\\]\n\n\n第二类 Striling 数同列计算：\\(\\mathrm{EGF}_r^{1,0,1}(x)\\)，\\(\\mathrm{EGF}_r^{1,1,0}(x)\\) 与 \\(\\mathrm{EGF}^{1,0/\\Sigma,1}(x)\\)\n为快速计算同一列的第二类 Stirling 数，考虑用生成函数的思路构造 \\(1,1,0\\)-球盒问题和 \\(1,0,1\\)-球盒问题的方案数．前者将大小为 \\(n\\) 的有标号集合划分为 \\(r\\) 个有标号等价类，这相当于有序拼接 \\(r\\) 个非空有标号集合；后者则是前者除掉 \\(r!\\) 消序的版本．写成生成函数即 \\[\n\\begin{aligned}\n\\mathrm{EGF}_r^{1,1,0}(x) &= (e^x - 1)^r \\\\\n\\mathrm{EGF}_r^{1,0,1}(x) &= \\frac{(e^x - 1)^r}{r!}\n\\end{aligned}\n\\tag{1}\\]\n\n\nBell 数\nBell 数 \\(B(n)\\) 的组合定义即 \\(1,0/\\Sigma,1\\)-球盒问题的方案数 \\(\\mathrm{BB}_{1,0/\\Sigma,1}\\)，亦可描述为 \\(n\\) 元集合上等价关系（划分）的数量．\n注意到 \\(1,0,1\\)-球盒问题和 \\(1,0/\\Sigma,1\\)-球盒问题的关系 \\[\n\\mathrm{BB}_{1,0/\\Sigma,1}(n) = \\sum_{r=0}^{n} \\mathrm{BB}_{1,0,1}(n,r) = \\sum_{r=0}^{+\\infty} \\mathrm{BB}_{1,0,1}(n,r)\n\\] 我们首先有 \\[\nB(n) = \\sum_{r=0}^n {n \\brace r}\n\\] 其次，根据 式 1 写出此关系的 EGF 形式就有 \\[\n\\mathrm{EGF}^{1,0/\\Sigma,1}(x) = \\sum_{r=0}^{+\\infty} \\mathrm{EGF}_r^{1,0,1}(x) = \\sum_{r=0}^{+\\infty} \\frac{(e^x - 1)^r}{r!} = e^{e^x - 1}\n\\] 我们得到 Bell 数的可用于快速计算的 EGF．\n\n注记. 有标号集合的无序划分是指数型生成函数的一类重要应用．例如，有标号连通图计数可视为对有标号一般图的无序划分，故有标号连通图的 EGF \\(G(x)\\) 和有标号一般图的 EGF \\(F(x)\\) 间有着 \\(e^{G(x)} = F(x)\\) 的关系．\n\nBell 数还有递推形式 \\[\nB(n+1) = \\sum_{k=0}^n \\binom n k B(k)\n\\] 边界 \\(B(0)=1\\)．组合的解释是，枚举第 \\(n+1\\) 个元素被放入的集合的大小，再对除该集合之外的元素进行划分．从指数生成函数的角度来看，设 \\(B(n)\\) 的 EGF 为 \\(F(x)\\)，由 EGF 的移位性质和二项式反演的 EGF 形式，上式等价于 \\(F'(x) = e^x F(x)\\)，解此微分方程也能得到 Bell 数的生成函数．\n\n\n第一类 Stirling 数、Stirling 数与阶乘幂【TODO】\n更多参考：\n\nStirling number - Wikipedia\n斯特林数 - OI Wiki\n\n\n\n\n3.4 分拆数【TODO】\n关于 \\(k\\) 部分拆数，\n\nBy taking conjugates, the number \\(p_k(n)\\) of partitions of \\(n\\) into exactly \\(k\\) parts is equal to the number of partitions of \\(n\\) in which the largest part has size \\(k\\).\n\n\nPartition (number theory) - Wikipedia\n分拆数 - OI Wiki\n组合数学（2）分拆数 - 知乎\n\n\n\n3.5 背包计数\n通式： \\[\n\\prod_{i=1}^n (1+ s_i x^{v_i})^{m_i} = \\exp \\sum_{i=1}^n m_i \\ln (1 + s_i x^{v_i}) = \\exp \\sum_{i=1}^n m_i \\sum_{k=1}^{+\\infty} (-1)^{k-1} \\frac {s_i^k}{k} x^{k v_i}\n\\] 其中 \\(v_i\\) 互不相同（相同者体现在 \\(m_i\\) 上）．后者可以埃筛调和级数计算贡献 + 多项式 \\(\\exp\\) 地在 \\(O(t \\log t)\\)（这里的 \\(t\\) 指我们所关心的体积上限）内快速计算．\n下面问题的 OGF 都可化归至通式，从而 \\(O(t \\log t)\\) 地得到计算．\n设有 \\(n\\) 种可区分的物品，体积分别为 \\(v_i\\)．当每种物品只有一件时，方案数 OGF 为 \\[\n\\prod_{i=1}^n (1+ x^{v_i})\n\\] 当每种物品有无限件时，方案数 OGF 为 \\[\n\\prod_{i=1}^n (1+ x^{v_i} + x^{2 v_i} + \\dots) = \\prod_{i=1}^n (1 - x^{v_i})^{-1}\n\\] 当每种物品分别有 \\(c_i\\) 件时，方案数 OGF 为 \\[\n\\prod_{i=1}^n (1+ x^{v_i} + x^{2 v_i} + \\dots + x^{c_i v_i}) = \\prod_{i=1}^n \\frac{1 - x^{(c_i+1) v_i}}{1 - x^{v_i}} = \\prod_{i=1}^n (1 - x^{(c_i+1) v_i}) \\prod_{i=1}^n (1 - x^{v_i})^{-1}\n\\]\nex：普通的最优化背包也有卷积视角的理解，见 Knapsack, Subset Sum and the (max,+) Convolution - Codeforces．\n\n\n3.6 各种图计数\n\n有（无）标号有（无）根树计数【TODO】\n\n\n有标号 DAG 计数\n\\[\nf_n=\\sum_{i=1}^n(-1)^{i+1}\\binom{n}{i}2^{i(n-i)}f_{n-i}\n\\] 思路是对 DAG 的入度为零的点做容斥．进一步推导可拆出卷积形式，再用类似分治 FFT 的生成函数方法可得封闭形式．\n\nWikipedia\nOEIS\nOI-Wiki\ncjyyb 题解\n\n\n\n有标号偏序图计数\n问得好，但这是个著名的 open problem．各种类型的偏序图计数参考 Partially ordered set - Wikipedia # Number of partial orders．\n\nStack Exchange\nOEIS\nErné, M., Stege, K. Counting finite posets and topologies. Order 8, 247–265 (1991)（内有研究历史综述）\n\n\n\n有标号连通图计数\n标准的有标号无序划分．EGF 是有标号一般图计数 EGF 的 \\(\\ln\\)．\n\n\n竞赛图\n强连通的竞赛图一定存在 Hamilton 回路（归纳证明）；无环的竞赛图是全序图．两者结合可推出竞赛图一定存在 Hamilton 路径．同时，强连通竞赛图中存在所有大小的环路．\n\n\n有标号划分为 \\(k\\) 个全序图\nLah 数 \\[\nL(n,k) = \\frac{n!}{k!} \\binom{n-1}{k-1}\n\\] 思路是先 \\(n!\\) 排个大序，再无标号球入非空有标号桶，再除 \\(k!\\) 给桶消序．\n生成函数的思路是，考虑非空全序计数的 EGF 为 \\(\\frac 1 {1-x} - 1 = \\frac x {1-x}\\)，\\(k\\) 次有序拼接再消序即得 \\[\n\\sum _{n\\geq k}L(n,k){\\frac {x^{n}}{n!}}={\\frac {1}{k!}}\\left({\\frac {x}{1-x}}\\right)^{k}\n\\]\n更多信息参考 Wikipedia．\n\n\n有根树拓扑序计数\n对于外向树，\\(\\frac{n!}{\\prod_{u \\in V} \\operatorname{size}(u)}\\)，其中 \\(V\\) 是所有节点的集合，\\(n\\) 是树大小，\\(\\operatorname{size}(u)\\) 是以 \\(u\\) 为根的子树大小．\n树形 DP 风格的归纳证明是可以的．下面的链接中提供了一个有趣的组合理解，其思路是从全序出发，逐步按照拓扑序的要求对每个节点下的子树消序．\n题目常见要求对每个节点作为根节点求出方案数，换根 DP 即可．\n注意到每个合法的外向树拓扑序 reverse 后立刻与内向树拓扑序形成一一对应，故内向树拓扑序计数与外向树相同．\n\n[Insight] Number of Topological Orderings of a Directed Tree - Codeforces\n\n\n\nDAG 拓扑序计数\n对一般的 DAG 上的拓扑序计数，其本质上是偏序上线性扩张的计数问题，这被证明是 #P-complete 的问题（总之就是很困难）．\n\nHow many topological orderings exist for a graph? - Mathematics Stack Exchange\nTopological sorting - Wikipedia # Relation to partial orders\nLinear extension - Wikipedia\n\n\n\n无向图的色多项式（chromatic polynomial）和无环定向（acyclic orientations）\n色多项式是对图的 \\(k\\)-colorings 的数量在 \\(k=0,1,\\dots,n\\) 进行 Lagrange 插值后得到的多项式．\\(k&gt;n\\) 的 \\(k\\)-colorings 的数量也可通过在色多项式的 \\(x=k\\) 处求值得到．这一证明主要依赖所谓的 deletion–contraction 递推关系式．\n对一般的图而言，色多项式的大部分系数和求值问题都是 “NP” 相关的，但在一些特殊的图上有好的形式：\n\n完全图 \\(K_n\\)：\\(x^{\\underline{n}}\\)（下降阶乘幂）\n无边图 \\(\\overline K_n\\)：\\(x^n\\)\n链 / 树：\\(P_n\\)：\\(x(x-1)^{n-1}\\)\n环：\\((x-1)^n + (-1)^n (x-1)\\)\n\n多个连通分量拼接时，色多项式满足乘法性．\n关于图的无环定向的方案数，Richard Stanley 在一篇 1973 年的论文中证明其恰为图的色多项式在 \\(-1\\) 处的取值．\n\nChromatic Polynomial - from Wolfram MathWorld\nChromatic polynomial - Wikipedia\nOrientation (graph theory) - Wikipedia\nStanley, R. P. “Acyclic Orientations of Graphs.” Disc. Math. 5, 171-178, 1973.\n\n\n\n\n3.7 矩阵树定理\n\n无向图的情形\n对无向图，度数矩阵 \\(D = \\operatorname{diag} \\{ \\operatorname{deg}(i) \\}\\)，邻接矩阵 \\(A\\) 定义为 \\[\nA_{i,j} = \\begin{cases}\n0 & i=j \\\\\ne(i,j) & i \\neq j\n\\end{cases}\n\\] 其中 \\(e(i,j)\\) 表示点 \\(i\\) 到点 \\(j\\) 的边的数量（对无向图，\\(e(i,j) = e(j,i)\\)）．\n定义 Laplace 矩阵（Kirchhoff 矩阵）\\(L=D-A\\)．\nLaplace 矩阵有性质 \\(L= B B^T\\)，其中关联矩阵 \\(B\\) 按如下方式定义 \\[\nB_{i,j} = \\begin{cases}\n1 & \\text{node $i$ is the ID-smaller endpoint of edge $j$} \\\\\n-1 & \\text{node $i$ is the ID-larger endpoint of edge $j$} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\n这里 \\(1\\) 与 \\(-1\\) 的引入完成了一种对边的“手动定向”，其用途将在后文介绍．\n\n\n\n\n\n\n\n定理 12 (矩阵树定理，无向图) \\(n\\) 点无向图的生成树的个数与该图的 Laplace 矩阵 \\(L\\) 的任意主子式的值相等．其也与 \\(L\\) 所有 \\(n-1\\) 个非零特征值乘积的 \\(\\frac 1 n\\) 倍相等．\n\n\n\n\nLaplace 矩阵同行的代数余子式均相等（这性质由行和为 \\(0\\) 得到），因此去掉任意一行一列均可得到正确的无向图生成树计数．此外，由于 \\(L = B B^T\\) 至少半正定，\\(L\\) 的所有特征值非负．\n证明的要点在于对 \\(L = B B^T\\) 的某个主子式（一般选择去掉第一行第一列）应用 Cauchy-Binet 公式，随后说明行列式的组合意义中，环的情况一定相互抵消．关于特征值的结论可从特征多项式、各 \\(n-1\\) 阶主子式与韦达定理的关系中得到（依此方法能进一步得到有关 \\(k\\) - 生成森林的一些结论）．\n事实上，去掉第 \\(i\\) 行第 \\(i\\) 列，即是统计以 \\(i\\) 为根的根向生成树的数量．先前定义关联矩阵 \\(B\\) 时“手动定向”，是为了使换向过程中环的情况相互抵消，只留下树的唯一一种情况．当然，因为是无向图，这里树的朝向和根的具体位置并不重要．\n\n\n有向图的情形\n对有向图，我们明确统计的对象为根向（或叶向）生成树的数量．根向树形图与出度 Laplace 矩阵相关，\\(L^{out} = D^{out} - A\\)，其中 \\(D^{out}\\) 是出度矩阵．\n为体现有向图的要求，出度 Laplace 矩阵对应的关联矩阵需要一些修改．令矩阵 \\(B\\) 满足 \\[\nB_{i,j} = \\begin{cases}\n1 & \\text{node $i$ is the head of edge $j$} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\] 矩阵 \\(C\\) 满足 \\[\nC_{i,j} = \\begin{cases}\n1 & \\text{node $i$ is the head of edge $j$} \\\\\n-1 & \\text{node $i$ is the tail of edge $j$} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\] 则出度 Laplace 矩阵满足性质 \\(L^{out} = B C^T\\)．我们构造的矩阵 \\(B\\) 体现了对出边方向的要求，在此基础上矩阵 \\(C\\) 进一步完成了“手动定向”的工作．\n\n\n\n\n\n\n\n定理 13 (矩阵树定理，根向树形图) \\(n\\) 点有向图以 \\(i\\) 为根的生成根向树形图的数量与该图出度 Laplace 矩阵 \\(L^{out}\\) 去掉第 \\(i\\) 行第 \\(i\\) 列的 \\(n-1\\) 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 \\(L^{out}\\) 的所有 \\(n-1\\) 个非零特征值的乘积相等．\n\n\n\n\n由于 \\(L^{out}\\) 的行和仍为 \\(0\\)，其同行代数余子式仍然相等．\n关于叶向树形图，我们有类似的结论：\n\n\n\n\n\n\n\n定理 14 (矩阵树定理，叶向树形图) \\(n\\) 点有向图以 \\(i\\) 为根的生成叶向树形图的数量与该图入度 Laplace 矩阵 \\(L^{in}\\) 去掉第 \\(i\\) 行第 \\(i\\) 列的 \\(n-1\\) 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 \\(L^{in}\\) 的所有 \\(n-1\\) 个非零特征值的乘积相等．\n\n\n\n\n由于 \\(L^{in}\\) 的列和（而非行和）为 \\(0\\)，其同列（而非同行）代数余子式均相等．\n更多内容，参考\n\nLaplacian matrix - Wikipedia\n矩阵树定理 - OI Wiki\nKirchhoff’s theorem - Wikipedia\n\n\n\n\n3.8 Polya 计数\n\n\n\n\n\n\n\n定理 15 (Burnside) \\[\n\\begin{aligned}\n等价类计数 &= \\frac{1}{|G|}\\sum_{f \\in G} |C(f)|\n\\end{aligned}\n\\] 其中 \\(G\\) 是等价操作群，\\(C(f)\\) 是操作 \\(f\\) 下的不动点集合．\n\n\n\n\n\n\n3.9 杂数选提\n\nCatalan 数\n\\[\nC_n = \\binom{2n}{n} - \\binom{2n}{n+1} = \\frac 1 {n+1} \\binom{2n}{n} = \\prod_{k=2}^n \\frac{n+k}{k}\n\\]\nSegner’s recurrence relation: \\[\nC_0 = 1;\\quad C_{n+1} = \\sum_{i=0}^n C_i C_{n-i}\n\\]\nOGF: \\[\nA(z) = 1 + z A^2(z) \\implies A(z) = \\frac{1-\\sqrt{1-4z}}{2z}\n\\]\n注意下面组合意义间的前后逻辑顺序．\n\nnumber of full binary tree with \\(n\\) interior nodes / \\(n+1\\) leaves / \\(2n+1\\) nodes\n在数内点意义下可以导出 Catalan 数的生成函数．\nnumber of ways of associating \\(n\\) binary operators / parenthesizing \\(n+1\\) factors completely\nnumber of proper parenthesis sequences with \\(n\\) pairs of parentheses\n【TODO】暂时不知道怎么从上面推过来的．另一种理解是长度为 \\(n\\) 的出栈序列的数量．\nnumber of ordered trees with \\(n+1\\) vertices\n最外层要补一对括号．\nnumber of binary trees with \\(n\\) vertices\nby left-child right-sibling encoding of ordered trees. 最后删去只有左儿子的根．\n该组合意义可以导出 Catalan 数的生成函数．\n\nCatalan 数的组合意义并不止如此几种．cf. Wikipedia\n\n\n\n3.10 代数组合【TODO】\n\n\\(q\\)-analog\n\n\n有限域上的线性空间\n\n\n有限群构型计数"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#多项式",
    "href": "posts/20230621-cpmodel/index.html#多项式",
    "title": "算法 & 数学碎碎念",
    "section": "4 多项式",
    "text": "4 多项式\n此部分详细介绍请移步 FFT/NTT 讲稿．\n\n4.1 通用\n\n\n4.2 FFT / FNTT / 卷积\n\nDFT：（本原）单位根构造 \\(\\omega_n = e^{\\frac {2 \\pi}{n}i}\\)．\nNTT：\\(P=998244353 = 7 \\times 17 \\times 2^{23} + 1\\)，\\(\\mathrm{PR} = 3\\) 是它的一个原根．（本原）单位根构造 \\(\\omega_{n} = \\mathrm{PR}^{\\frac{P-1}{n}} \\bmod P\\)．\n\\(P=1004535809 = 479 \\times 2^{21} + 1\\)，\\(\\mathrm{PR} = 3\\)\n\\(P=469762049 = 7 \\times 2^{26}+1\\)，\\(\\mathrm{PR} = 3\\)\n\n考虑将待变换多项式 \\[\nA(x) = \\sum_{k=0}^{2n-1} a_k x^k\n\\] 奇偶分项为两个多项式 \\[\nA(x) = A_0 (x^2) + x A_1(x^2)\n\\] 其中 \\[\n\\begin{aligned}\nA_0 (x) &= \\sum_{k=0}^{n-1} a_{2k} x^k \\\\\nA_1 (x) &= \\sum_{k=0}^{n-1} a_{2k+1} x^k\n\\end{aligned}\n\\] 代入 \\(x = \\omega_{2n}^k \\pod{k = 0,\\dots, 2n-1}\\)，用单位根消去 / 折半性质（\\(\\omega_{2n}^{2k} = \\omega_n^k\\)） \\[\nA(\\omega_{2n}^k) = A_0 (\\omega_{n}^k) + \\omega_{2n}^k A_1 (\\omega_{n}^k)\n\\] 用 \\(\\omega_{2n}^{n+k} = - \\omega_{2n}^k\\) \\[\n\\begin{aligned}\nA(\\omega_{2n}^k) &= A_0 (\\omega_n^k) + \\omega_{2n}^k A_1 (\\omega_n^k) \\\\\nA(\\omega_{2n}^{n+k}) &= A_0 (\\omega_n^k) - \\omega_{2n}^k A_1(\\omega_n^k)\n\\end{aligned}\n\\pod{k = 0, \\dots, n-1}\n\\] 即得 FFT/FNTT 递归算法．用单位根求和性质 \\[\n\\frac 1 n \\sum_{k=0}^{n-1} \\omega^{ik} = [i \\mid n]\n\\] 可知 DFT/NTT 变换矩阵 \\(F = \\begin{pmatrix}\\omega_{n}^{ij}\\end{pmatrix}_{(i,j) \\in n \\times n}\\) 满足 \\(F F^H = F^H F = n I_n\\)，故 \\(F^{-1} = \\frac 1 n F^H = \\begin{pmatrix} \\frac 1 n \\omega_{n}^{-ij}\\end{pmatrix}_{(i,j) \\in n \\times n}\\)，此即 DFT/NTT 逆变换矩阵．\n\n蝶形运算与迭代算法\n为使用迭代算法，需要快速得到递归算法向下深入过程中 \\(\\{ a_n \\}\\) 置换后的最终结果．观察知该置换是位逆序置换，可按如下方法线性求出．\nrev[0]=0; for(ll i=1;i&lt;(1&lt;&lt;n);i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)+((i&1)&lt;&lt;(n-1));\n\n\n\n4.3 多项式方程求解（Newton 迭代法）【TODO】\n给定一多项式 \\(A(x)\\)，求解满足 \\(A(B(x)) = 0 \\pmod{x^n}\\) 的多项式 \\(B(x)\\)．\n显然 \\(B(x)\\) 只有前 \\(n\\) 项有效．目前我们尚不清楚解的存在性、唯一性等性质，但注意到 \\[\nA(B(x)) = 0 \\pmod{x^{2n}} \\implies A(B(x)) = 0 \\pmod{x^n}\n\\] 故考虑递推求解．首先，边界条件 \\(A(b_0) = 0\\) 需要单独求解．在确定某一 \\(b_0\\) 的基础上，我们开始递推．考虑已经获得 \\(A(B(x)) = 0 \\pmod{x^n}\\) 的一个解 \\(B(x) = B_0(x)\\)，下面尝试得到方程 \\(A(B(x)) = 0 \\pmod{x^{2n}}\\) 的解．\n将待求解方程 \\(A(B(x)) = 0 \\pmod{x^{2n}}\\) 左式多项式 \\(A\\) 在 \\(B_0\\) 处 Taylor 展开 \\[\n\\begin{split}\nA(B(x)) = A(B_0(x)) &+ A'(B_0(x)) (B(x)-B_0(x)) \\\\ &+ \\frac{A''(B_0(x))}{2!} (B(x)-B_0(x))^2 + \\dots\n= 0 \\pmod{x^{2n}}\n\\end{split}\n\\] 假若 \\(B(x)-B_0(x) = 0 \\pmod{x^n}\\)，那么模 \\(x^{2n}\\) 意义下二次方以上的项可以舍去，上式等价于 \\[\nA(B_0(x)) + A'(B_0(x)) (B(x)-B_0(x)) = 0 \\pmod{x^{2n}}\n\\] 移项即可解出待求 \\(B(x)\\) \\[\nB(x) =  B_0(x) - \\frac{A(B_0(x))}{A'(B_0(x))} \\pmod{x^{2n}}\n\\] 这里要求 \\(A'(B_0(x))\\) 需在 \\(x^{2n}\\) 意义下可逆，即 \\[\n\\begin{split}\n[x^0] A'(B_0(x)) = [x^0] A'(b_0) &= \\sum_{k=0}^\\infty \\left( [x^k] A' \\right) b_0^k \\\\\n&= \\sum_{k=0}^\\infty (k+1) a_{k+1} b_0^k \\neq 0 \\pmod{x^{2n}}\n\\end{split}\n\\] 注意到 \\(B(x) - B_0(x) = -\\frac{A(B_0(x))}{A'(B_0(x))} = 0 \\pmod{x^{n}}\\)，故满足上述“假若”的解存在且唯一．然而，若不要求这一“假若”成立，则每步迭代解的唯一性无法得到保证．考虑到边界条件 \\(b_0\\) 的解亦不一定唯一，故一般的 Newton 迭代法解唯一性的讨论较为复杂．当然，上述推导至少为我们提供了一种寻找特解的方法．\nNewton 迭代法作为通用求解框架，可涵盖几乎所有多项式初等运算．【TODO】\n\n\n4.4 多项式求逆\n给定一多项式 \\(A(x)\\)，求解满足 \\(A(x) B(x) = 1 \\pmod{x^{n}}\\) 的多项式 \\(B(x)\\)．\n多项式逆元存在的充分必要条件是其常数项非零（这是因为边界条件 \\(b_0 = \\frac 1 {a_0}\\)），若存在则在模意义下一定唯一．这结论可直接由下述求解方法得到．不失一般性，我们只研究 \\(A(x)\\) 的次数为奇数 \\(2n-1\\) 的情况．设 \\[\n\\begin{aligned}\nA(x) &= A_0(x) + x^n A_1(x) \\\\\nB(x) &= B_0(x) + x^n B_1(x)\n\\end{aligned}\n\\] 下述两种方法均递归地在已知 \\[\nA(x) B_0(x) = A_0(x) B_0(x) = 1 \\pmod{x^n}\n\\] 的基础上求解 \\(A(x)\\) 的逆元．时间复杂度均为 \\[\nT(n) = T(\\frac n 2) + O(n \\log n) = O(n \\log n)\n\\]\n以下简记 \\(A(x)\\) 为 \\(A\\)，其它多项式同理．\n\n倍增法一（原创）\n\\[\n\\begin{aligned}\n& A B = 1 \\pmod{x^{2n}} \\\\\n\\iff& (A_0 + x^n A_1)(B_0 + x^n B_1) = 1 \\pmod{x^{2n}} \\\\\n\\iff& x^n(A_1 B_0 + A_0 B_1) + A_0 B_0 = 1 \\pmod{x^{2n}} \\\\\n\\iff& A_1 B_0 + A_0 B_1 + \\left\\lfloor \\frac{A_0 B_0}{x^n} \\right\\rfloor = 0 \\pmod{x^{n}} \\\\\n\\iff&  A_0 B_1 = -\\left\\lfloor \\frac{A_0 B_0}{x^n} \\right\\rfloor - A_1 B_0 \\pmod{x^{n}} \\\\\n\\iff&  B_1 = - B_0 \\left( \\left\\lfloor \\frac{A_0 B_0}{x^n} \\right\\rfloor + A_1 B_0 \\right) \\pmod{x^{n}}\n\\end{aligned}\n\\]\n常数偏大，这里就不放代码了．\n\n\n倍增法二\n注意到 \\[\n\\begin{cases}\nA B_0 = 1 \\pmod{x^n} \\\\\nA B = 1 \\pmod{x^n}\n\\end{cases} \\implies A (B-B_0) = 0 \\pmod{x^n}\n\\] 由于 \\(A\\) 的常数项非零，故 \\[\nB-B_0 = 0 \\pmod{x^n}\n\\] （这证明了逆元在不同模数下的前缀保持一致）\n两边平方得 \\[\nB^2 - 2 B B_0 + B_0^2 = 0 \\pmod{x^{2n}}\n\\] 两侧同乘 \\(A\\) 并移项得 \\[\nB = 2 B_0 - A B_0^2 \\pmod{x^{2n}}\n\\]\n\n\n\n4.5 多项式开方【TODO】\n和多项式求逆类似的推导可得递推方程 \\[\nB = \\frac 1 2 \\left(\\frac A {B_0} + B_0 \\right) \\pmod{x^{2n}}\n\\] 有一些和 Newton 法一样麻烦的边界条件讨论，也会出现复杂的多解情况．\\(a_0 = 1\\) 时 \\(b_0 = \\pm 1\\)，按 \\(b_0 = 1\\) 的实现如下．\n亦可 \\(\\sqrt A = \\exp \\left( \\frac 1 2 \\ln A \\right)\\)，此法可处理多项式任意幂指数运算．\n\n\n4.6 多项式 \\(\\ln\\)\n给定一多项式 \\(A(x)\\)，求解满足 \\(B(x) = \\ln A(x) \\pmod{x^{n}}\\) 的多项式 \\(B(x)\\)．\n次数为 \\(+\\infty\\) 的多项式 \\(\\ln\\) 存在的充分必要条件为其常数项非零（这是因为边界条件 \\(b_0 = \\ln a_0\\)），同样一旦存在则唯一．注意到仅整数 \\(a_0=1\\) 时，\\(\\ln a_0\\) 可取得整数，故合理的 \\(a_0\\) 只能是 \\(1\\)．另一种解释参见多项式初等函数 - OI Wiki # 多项式对数函数 & 指数函数．\n推导是容易的．方程两侧同时求导得 \\[\nB'(x) = \\frac{A'(x)}{A(x)} \\pmod{x^{n-1}}\n\\] 两侧再积分得 \\[\nB(x) = \\int \\frac{A'(x)}{A(x)} \\operatorname{d}\\!x + C \\pmod{x^{n}}\n\\] 其中 \\(C= \\ln a_0\\)．多项式求逆、求导、积分即可．时间复杂度 \\(O(n \\log n)\\)．\n\n\n4.7 多项式 \\(\\exp\\)【TODO】\nNewton 迭代法可推出 \\[\nB = B(1 - \\ln B_0 + A) \\pmod{x^{2n}}\n\\] 时间复杂度 \\[\nT(n) = T(\\frac n 2) + O(n \\log n) = O(n \\log n)\n\\]\n存在的充要条件是 \\(a_0=0\\)．唯一性证明暂不明确．\n\n\n4.8 多项式快速幂\n普通的多项式快速幂实现当然是 \\(O(n \\log n \\log k)\\) 的．下面介绍基于指对数性质的 \\(O(n \\log n)\\) 求法．\n对常数项 \\(a_0=1\\) 的 \\(n-1\\) 次多项式 \\(A(x)\\)， \\[\nA^k(x) = e^{k \\ln A(x)}\n\\]\n我们指出，在系数对质数 \\(p\\) 取模的意义下，当我们关心的多项式长度 \\(n \\leq p\\) 时，有 \\[\nA^p(x) \\equiv a_0 \\equiv 1 \\pmod p\n\\] 这是因为 \\[\n(a+b)^p \\equiv a^p + b^p \\pmod p\n\\] 故 \\[\nA^p(x) = (a_0 + x A_1 (x))^p \\equiv a_0^p + x^p A_1^p(x) \\pmod p\n\\] 由费马小定理，\\(a_0^p = a_0\\)，而 \\(n \\leq p\\) 表明 \\(x^p A_1^p(x)\\) 一项可被忽略，故上述结论得到证明．这些讨论可用于处理幂指数 \\(k \\geq p\\) 的情况．\n一般的，当常数项非 \\(1\\) 时，为满足多项式 \\(\\ln\\) 的要求，设多项式 \\(A(x)\\) 的最低次项为 \\(a_t x^t\\)，则 \\[\nA^k(x) = (a_t x^t)^k \\left( \\frac{A(x)}{a_t x^t} \\right)^k\n\\] 右侧的多项式常数项归一，故可再应用上述方法计算．\n关于多项式，更代数的内容参考 Formal power series - Wikipedia"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#集合幂级数todo",
    "href": "posts/20230621-cpmodel/index.html#集合幂级数todo",
    "title": "算法 & 数学碎碎念",
    "section": "5 集合幂级数【TODO】",
    "text": "5 集合幂级数【TODO】"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#矩阵",
    "href": "posts/20230621-cpmodel/index.html#矩阵",
    "title": "算法 & 数学碎碎念",
    "section": "6 矩阵",
    "text": "6 矩阵\n\n6.1 矩阵乘法\n普通的 \\(O(n^3)\\) 实现．\n\n\n6.2 矩阵快速幂\n普通的 \\(O(n^3 \\log k)\\) 实现．\n\n\n6.3 行列式\n普通的实现是使用逆元进行高斯消元，可用于域上的线性空间．若求解逆元的时间复杂度为 \\(O(\\log p)\\)，则时间复杂度为 \\(O(n^3+ n^2 \\log p)\\)．\n这里给出另一种做法．该做法在消去时使用辗转相除法，可用于任意 Euclid 整环（Euclidean domain，有带余除法的无零因子的交换幺环）上的模（环上的线性空间），且时间复杂度不会增加．一个常见的应用是模 \\(m\\) 整数环 \\(\\mathbb Z_m\\) 上的行列式求值，其中 \\(m\\) 不是质数．\n消去各目标行第 \\(c\\) 列元素时，以第 \\(c\\) 行的 \\(a_{c,c}\\) 为除数与目标行的第 \\(c\\) 列元素辗转相除，最终使 \\(a_{c,c}\\) 变为 \\(0\\)，再做一次行交换将其换至目标行，就完成了一次行消去过程．注意到当 \\(a_{c,c}\\) 非零时，一次行消去操作结束后 \\(a_{c,c}\\) 单调不增，且过程中 \\(a_{c,c}\\) 不会从非零变为零，故辗转相除带来的 \\(\\log p\\) 次额外操作开销被分摊到整轮对第 \\(c\\) 列的消去过程中，因此时间复杂度仍为 \\(O(n^3+ n^2 \\log p)\\)．"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#字符串-自动机",
    "href": "posts/20230621-cpmodel/index.html#字符串-自动机",
    "title": "算法 & 数学碎碎念",
    "section": "7 字符串 / 自动机",
    "text": "7 字符串 / 自动机\n基于 DFA 理论，OI-Wiki 上有对 KMP / AC 自动机，SAM / GSAM 和 PAM 简明扼要的概括．OI-Wiki 的后缀自动机讲解亦值得参考．"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#图论todo",
    "href": "posts/20230621-cpmodel/index.html#图论todo",
    "title": "算法 & 数学碎碎念",
    "section": "8 图论【TODO】",
    "text": "8 图论【TODO】\n\n8.1 最短路\n\n\n8.2 强连通分量\n\n\n8.3 网络流"
  },
  {
    "objectID": "posts/20230621-cpmodel/index.html#杂项",
    "href": "posts/20230621-cpmodel/index.html#杂项",
    "title": "算法 & 数学碎碎念",
    "section": "9 杂项",
    "text": "9 杂项\n\n9.1 模板\n见 model.cpp, model_temp.cpp．\n\n\n9.2 对拍\n\nWindows Batch\n:loop\n    gen.exe&gt;dat.in\n    my.exe&lt;dat.in&gt;my.out\n    std.exe&lt;dat.in&gt;std.out\n    fc my.out std.out\n    if not errorlevel 1 goto loop\npause\n\n\nLinux Shell\nwhile true; do\n    ./gen&gt;dat.in\n    ./std&lt;dat.in&gt;std.out\n    ./my&lt;dat.in&gt;my.out\n    if diff std.out my.out; then\n        printf OK\n    else\n        printf DIFF\n        exit 0\n    fi\ndone\n\n\n\n9.3 表\n\n质数表\n1e2     1e3     1e4       1e5       1e6\n101         1009        10007       100003      1000003\n\n1e7       1e8         1e9         1e10        1e11          \n10000019    100000007   1000000007  10000000019 100000000003\n\n1e12          1e13            1e14            1e15\n1000000000039   10000000000037  100000000000031 1000000000000037\n\n1e16              1e17                1e18\n10000000000000061   100000000000000003  1000000000000000003\n\n\n典列\nindex         0   1   2   3   4   5   6   7   8     9     10\nCatalan       1   1   2   5   14  42  132 429 1430  4862  16796\nBell          1   1   2   5   15  52  203 877 4140  21147 115975\npartition     1   1   2   3   5   7   11  15  22    30    42\ngroup         0   1   1   1   2   1   2   1   5     2     2\nbinomial\nx   0   1   2   3   4   5\n0 | 1\n1 | 1   1\n2 | 1   2   1\n3 | 1   3   3   1\n4 | 1   4   6   4   1\n5 | 1   5   10  10  5  1\n\nStirling I\nx   0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     1   1\n3 |     2   3   1\n4 |     6   11  6   1\n5 |     24  50  355 10  1\n\nStirling II\nx   0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     1   1\n3 |     1   3   1\n4 |     1   7   6   1\n5 |     1   15  25  10  1\n\nLah\nx   0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     2   1\n3 |     6   6   1\n4 |     24  36  12  1\n5 |     120 240 120 20  1\n\nk-partition\n    0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     1   1\n3 |     1   1   1\n4 |     1   2   1   1\n5 |     1   2   2   1   1"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html",
    "href": "posts/20210501-diophantine/index.html",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "",
    "text": "Example 1 求将 \\(n\\) 个无标号元素用 \\(m-1\\) 个隔板分入 \\(m\\) 个有标号可空集合的方案数。\n此问题的另一个等价表述是，求不定方程 \\[\nx_1 + x_2 + \\dots + x_m = n \\quad (m,n \\in N_+, m \\le n)\n\\] 的非负整数解的个数。\n\n\n\n\n是一个非常经典的组合问题，众所周知其答案为组合数 \\({n+m-1 \\choose m-1}\\) ，这可以根据其组合意义结合隔板法容易的得到。\n然而，笔者发现还有很多有趣的方法可以得到上式，值得探讨一番。"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html#序",
    "href": "posts/20210501-diophantine/index.html#序",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "",
    "text": "Example 1 求将 \\(n\\) 个无标号元素用 \\(m-1\\) 个隔板分入 \\(m\\) 个有标号可空集合的方案数。\n此问题的另一个等价表述是，求不定方程 \\[\nx_1 + x_2 + \\dots + x_m = n \\quad (m,n \\in N_+, m \\le n)\n\\] 的非负整数解的个数。\n\n\n\n\n是一个非常经典的组合问题，众所周知其答案为组合数 \\({n+m-1 \\choose m-1}\\) ，这可以根据其组合意义结合隔板法容易的得到。\n然而，笔者发现还有很多有趣的方法可以得到上式，值得探讨一番。"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html#组合意义",
    "href": "posts/20210501-diophantine/index.html#组合意义",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "2 组合意义",
    "text": "2 组合意义\n如上所述，组合意义可以结合隔板法容易的得到。考虑将 \\(n\\) 个无标号元素用 \\(m-1\\) 个隔板分入 \\(m\\) 个有标号非空集合，其方案数为 \\({n-1 \\choose m-1}\\) 。然而我们需要的是各集合可空情况下的方案数。考虑新增 \\(m\\) 个元素，先给每个集合放一个元素垫底，再做各组可空的分配。这个小Trick让我们将问题转化为求 \\(n+m\\) 个无标号元素分入 \\(m\\) 个非空有标号集合的方案数。再用隔板法，得到答案 \\({n+m-1 \\choose m-1}\\) 。\n形式化的，我们令 \\(y_i = x_i + 1\\) ，则我们现在只需求 \\(y_1 + y_2 + \\dots + y_m = n + m\\) 的正整数解，隔板法得到答案 \\({n+m-1 \\choose m-1}\\) 。"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html#枚举空位vandermonde-卷积公式",
    "href": "posts/20210501-diophantine/index.html#枚举空位vandermonde-卷积公式",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "3 枚举空位——Vandermonde 卷积公式",
    "text": "3 枚举空位——Vandermonde 卷积公式\n我们使用另一种方法将隔板法应用到可空集合上。\n枚举 \\(m\\) 个集合中有几个是空集，可以得到下式\n\\[\n\\mathrm{ans} = \\sum_{k=0}^{m-1} {m \\choose k} {n-1 \\choose m-k-1}\n\\]\n又由\n\n\n\n\n\n\n\nTheorem 1 (Vandermonde 卷积公式) \\[\n{n+m \\choose k} = \\sum_{i=\\max(0,k-m)}^{\\min(n,k)} {n \\choose i} {m \\choose k-i}\n\\]\n\n\n\n\n（该定理易由 \\((1+x)^{n+m} = (1+x)^n (1+ x)^m\\) 的二项式展开说明）\n可直接得到（ \\(k' = m-1\\) ， \\(n' = m\\) ， \\(m' = n-1\\) ）\n\\[\n\\mathrm{ans} = \\sum_{k=\\max(0,(m-1)-(n-1))}^{\\min(m,m-1)} {m \\choose k} {n-1 \\choose m-k-1} = {n+m-1 \\choose m-1}\n\\]"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html#递推杨辉三角",
    "href": "posts/20210501-diophantine/index.html#递推杨辉三角",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "4 递推——杨辉三角",
    "text": "4 递推——杨辉三角\n这固然很妙，但要是我想不到这些Trick怎么办？\n作为完全不虚递推的 OIer，我们考虑 dp。\n设状态 \\(f(n,m)\\) 表示将 \\(n\\) 个无标号元素放入 \\(m\\) 个有标号可空集合的方案数。\n考虑当前正在为第 \\(n\\) 个元素确定所属集合。既然元素是无标号的，不妨按升序排列集合。于是放入新的元素时，只需决定要先跳过多少个集合再放入。易得下面的递推式\n\\[\nf(n,m) = \\sum_{k=1}^m f(n-1,k)\n\\]\n初始状态满足\n\\[\n\\begin{aligned}\n&f(0,m)=1 \\\\\n&f(n,0)=[n=0]\n\\end{aligned}\n\\quad (n,m \\in N)\n\\]\n（中括号是艾弗森括号）\n不妨列出 \\(f\\) 的前几项——\n    m0   m1   m2   m3   m4\nn0  1    1    1    1    1\nn1  0    1    2    3    4\nn2  0    1    3    6    10\nn3  0    1    4    10   20\n很熟悉…这是杨辉三角！\n可以由递推式得到杨辉三角的特征——\n\\[\n\\begin{aligned}\nf(n,m) &= f(n-1, m) + \\sum_{k=1}^{m-1} f(n-1,k) \\\\\n&= f(n-1, m) + f(n, m-1)\n\\end{aligned}\n\\]\n那么，只需观察并将表格的每一项映射到杨辉三角，我们就能得到 \\(f(n,m) = {n+m+1 \\choose m-1}\\) 。"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html#生成函数广义二项式定理",
    "href": "posts/20210501-diophantine/index.html#生成函数广义二项式定理",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "5 生成函数——广义二项式定理",
    "text": "5 生成函数——广义二项式定理\n要是我连杨辉三角都没看出来怎么办\n方便起见，此处我们不研究 \\(m=0\\) 的情况。不妨设\n\\[\ng(n,m) = f(n,m+1)\n\\]\n显然， \\(g\\) 的递推式为\n\\[\ng(n,m) = \\sum_{k=0}^m g(n-1,k)\n\\]\n据此我们发现，每一排是其前一排的前缀和数组，或者换句话说，每一排是其后一排的向前差分数组。我们先拿出 \\(n=0\\) 一排的OGF\n\\[\ng_0(x) = \\frac{1}{1-x}\n\\]\n又根据差分\n\\[\ng_n(x) = g_{n+1}(x) - x g_{n+1}(x) \\iff g_{n+1}(x) = \\frac{1}{1-x} g_n(x)\n\\]\n得\n\\[\ng_n(x) = (1-x)^{-(n+1)}\n\\]\n又由\n\n\n\n\n\n\n\nTheorem 2 (广义二项式定理) \\[\n(x+y)^\\alpha = \\sum_{k=0}^{\\infty} {\\alpha \\choose k} x^k y^{\\alpha - k}\n\\]\n其中\n\\[\n{\\alpha \\choose k} = \\frac{\\alpha(\\alpha-1)\\dots(\\alpha-k+1)}{k!}\n\\]\n\n\n\n\n展开，得到\n\\[\ng_n(x) = \\sum_{k=0}^{\\infty} {-n-1 \\choose k} (-x)^k\n\\]\n故\n\\[\n\\begin{aligned}\ng_n(x)[x^k] &= (-1)^k {-n-1 \\choose k} \\\\\n&= (-1)^k \\frac{(-n-1)(-n-2)\\dots(-n-k)}{k!} \\\\\n&= \\frac{(n+1)(n+2)\\dots(n+k)}{k!} \\\\\n&= {n+k \\choose k}\n\\end{aligned}\n\\]\n即\n\\[\ng(n,k) = {n+k \\choose k}\n\\]\n换回 \\(f\\) 表示就得到答案\n\\[\nf(n,m) = g(n,m-1) = {n+m-1 \\choose m-1}\n\\]\n\n5.1 2023/03/10 update\n事实上，直接从组合意义思考就能直接得到该计数问题的生成函数形式\n\\[\n(1 + x + x^2 + \\dots)^m = \\left( \\frac 1 {1-x} \\right)^m = (1-x)^{-m}\n\\]\n按前述方法展开即可得到相同的结果。"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html#burnsidepolya第一类斯特林数",
    "href": "posts/20210501-diophantine/index.html#burnsidepolya第一类斯特林数",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "6 Burnside(Polya)——第一类斯特林数",
    "text": "6 Burnside(Polya)——第一类斯特林数\n如果要分组的 \\(n\\) 个元素是有标号的，问题将会简单很多——直接枚举每个元素的所属集合即可，显然方案数为 \\(m^n\\) 。\n但关键是它们没有标号。\n无标号的本质是认为任意置换标号前后是同构的。这启发我们将所有 \\(n\\) 元置换（即置换群）作为变换集，使用等价类计数Burnside来解决该问题。\n根据Burnside引理（或Polya定理）\n\n\\[\n\\mathrm{ans} = \\frac{1}{|G|} \\sum_{f \\in G} C(f)\n\\]\n其中 \\(G\\) 是变换集， \\(C(f)\\) 是变换 \\(f\\) 的不动点。\n\n可以写出\n\\[\n\\mathrm{ans} = \\frac{1}{n!} \\sum_{p \\in \\mathrm{perm}(n)} m^{\\mathrm{cyc}(p)}\n\\]\n其中 \\(\\mathrm{perm}(n)\\) 表示所有 \\(n\\) 元置换的集合，而 \\(\\mathrm{cyc}(p)\\) 指置换 \\(p\\) 的形成的置换图中环的个数。\n在外层枚举 \\(\\mathrm{cyc}(p)\\) ，得\n\\[\n\\mathrm{ans} = \\frac{1}{n!} \\sum_{k=1}^n m^k \\sum_{p \\in \\mathrm{perm}(n)} [\\mathrm{cyc}(p) = k]\n\\]\n\\(\\sum_{p \\in \\mathrm{perm}(n)} [\\mathrm{cyc}(p) = k]\\) 是什么？\n\n第一类斯特林数 \\({n \\brack k}\\) 表示将 \\(n\\) 个有标号元素分成 \\(k\\) 个无标号圆排列的方案数。\n\n在置换图中， \\(p_i\\) 表示节点 \\(i\\) 的下一个节点是 \\(p_i\\) 。而枚举置换的过程，正是枚举置换图的过程，也正是枚举圆排列的过程！而 \\([\\mathrm{cyc}(p) = k]\\) 则为我们确定了环，或者说圆排列的个数。\n惊讶的，我们发现\n\\[\n{n \\brack k} = \\sum_{p \\in \\mathrm{perm}(n)} [\\mathrm{cyc}(p) = k]\n\\]\n带入其中，答案式变为\n\\[\n\\mathrm{ans} = \\frac{1}{n!} \\sum_{k=1}^n {n \\brack k} m^k\n\\]\n于是，根据第一类斯特林数性质之一\n\n\\[\n\\sum_{k=1}^n {n \\brack k} m^k  = m(m+1)\\dots(n+m-1)\n\\]\n（该性质可以结合第一类斯特林数的递推式做数学归纳得出）\n\n我们愉快的得到了答案\n\\[\n\\mathrm{ans} = \\frac{m(m+1)\\dots(n+m-1)}{n!} = {n+m-1 \\choose m-1}\n\\]\n用Burnside解决无标号问题的思路极具启发性，例如烷基计数问题的Burnside解法。"
  },
  {
    "objectID": "posts/20210501-diophantine/index.html#后记致谢",
    "href": "posts/20210501-diophantine/index.html#后记致谢",
    "title": "从不定方程的非负整数解个数谈起",
    "section": "7 后记&致谢",
    "text": "7 后记&致谢\n同分异构体计数带我重回OI\n感谢TbYangZ菊苣全程提供技术支持。\n感谢神仙化学老师提供组合意义解释。"
  },
  {
    "objectID": "posts/about/index.html",
    "href": "posts/about/index.html",
    "title": "About",
    "section": "",
    "text": "说是 About，但莫名其妙写成了近况杂谈（笑）\n其它平台账户请见 Other Links 栏．\n关于博客本身的想法，请移步\nNext Phantasm…"
  },
  {
    "objectID": "posts/about/index.html#sep.-2023",
    "href": "posts/about/index.html#sep.-2023",
    "title": "About",
    "section": "Sep. 2023",
    "text": "Sep. 2023\n填坑的一年。\n\nXCPC participant，数数爱好者。\nQuarto / LaTeX 模板库继续完善。\n妖 LNB 达成。\n\n春日兴起，一发入魂。\n后停飞数月。夏，园体验版出。疾梦机甚棍，遂转魔。风驰电掣，摧枯拉朽，俄而手熟，甚爱之。然此机甚胖，游走未几，擦挂无数；况诱导不复，中道加险，平日疏于背板，以至事故频发。痛定思痛，乃知其不易。披甲上阵，还需练习。\n坊间有言，机者三年而至其极。然避弹乃皆出于兴，乘兴而至，兴尽而反，何必至其极耶？且吟且行，无惧蹉跎。\n\n目前对从代数角度研究 DFT 卷积性质感兴趣。"
  },
  {
    "objectID": "posts/about/index.html#dec.-2022",
    "href": "posts/about/index.html#dec.-2022",
    "title": "About",
    "section": "Dec. 2022",
    "text": "Dec. 2022\n仍然是退役 OIer 的 sun123zxy。\n啥你说 XCPC？校队啥时候招人？\n他还是老样子。整天就抱着他那电脑敲敲敲，要不就是抱着他那堆数学书看看看，天天在寝室走过来走过去的不知道在想什么。\n你说他爱学习吧，他又不刷题又不卷综测，看本书半年都看不完，敲的也不像什么正经玩意儿，整天嚷嚷着好忙时间不够。大作业研讨课他倒挺热衷，一有机会就开始熬夜，结果每到考试就原形毕露，考得比人家专业外的人还差。还能咋地，没刷题呗！跟他说也没用，他知道了也不会改。\n其它的变化也没有太多，无非是车龄增加 1 年，STG 继续退步罢了。之前红石音乐自动化他趁暑假重新写了一版，明明代码和存档都快做完了，他却突然放弃，我们也不知道是怎么回事。现在他在搞那个什么 LaTeX，整天盯着论文改改改，我们也不懂。\n反正他就是那种人了。不过不管怎么说，他自己还算满意现在的生活。\n说不定有人喜欢这种性格呢。"
  },
  {
    "objectID": "posts/about/index.html#aug.-2021",
    "href": "posts/about/index.html#aug.-2021",
    "title": "About",
    "section": "Aug. 2021",
    "text": "Aug. 2021\n退役 OIer，喜欢在电脑面前发呆。\n刷题不多，数学将就，整活还行。总的来说就是不务正业（\n常用的语言除了 C++ 就应该是 Python 和 C# 吧。\n码风偏工程向，经常封装强迫症发作把一车数据结构封到 class 里去结果一点都不好用，现在一般用 namespace 封装不需要实例化的数据结构。\n特别讨厌可读性低的代码，甚至因此放弃毒瘤卡常题。\n整活方面的话，最近在填坑研究基于 Python 和 MIDI 的自动红石音乐生成，当然还有正在搭的博客啦。一放假 github 就一堆小绿点（\n东方众。熟悉的作品大概从下图能看出来吧\n2021/08/23 原曲认知测验 弹幕作 0.5s 100题\n\n\n\n原曲认知测验\n\n\nSTG 打的还行，妖妖梦专精，Hard 稳通 Lunatic 混关的水准吧。打过 Extra、Phantasm 的 NMNBNR。目前在懒散的尝试 Lunatic NB。差不多咕了\n远古年代打过 Dancing Line 的全关卡完美。"
  },
  {
    "objectID": "posts/20240922-pr/index.html",
    "href": "posts/20240922-pr/index.html",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "",
    "text": "这次来聊聊原根．何谓原根？本原单位根是也．何谓本原单位根？自乘若干次而归于一者，谓之单位根．若兼为乘法生成元，则称其本原，以示强调．原根有三定理，一是判定原根的方法，二是原根存在的条件，三是对原根的计数1．其中原根存在定理最难证明．固然有初等数论的证法，然而技巧性较强，或有碍阅读，亦难于记忆．使用代数方法研究原根，虽对基础有一定要求，证明亦不短，但胜在自然流畅，更具启发性．本文宗旨，应用代数工具，对模 \\(m\\) 剩余类环 \\(\\mathbb Z / m \\mathbb Z\\) 的乘法结构做出流畅的刻画，兼以部分随性的发散讨论，原根存在定理则作为推论导出．我们介绍的内容对有经验的读者或属“自证不难”，但完整证明的逻辑链条较长，需要了解原根的人群亦不一定有系统的代数基础（如 OI / XCPC 算法竞赛选手），故整理于此，供略知代数一二的同学按图索骥．\n1 这三个定理的提法来自 OI Wiki 的原根介绍．篇幅所限，无法完全做到 self-contained，故如下阅读建议供读者参考：\n\n完全没有抽象代数基础：\n可能在阅读中遇到较大的困难。\n有朴素的抽象代数基础：\n\n如数学基础不错的 OIer / XCPCer\n如上过一学期计算机系离散数学课程\n如会证 Polya 计数 / 理解群论的 Lagrange 定理 / 用抽代观点思考过初等数论问题\n\n小节 2 讨论原根三定理，小节 3 讨论中国剩余定理，小节 4 介绍了看待模 \\(p^\\alpha\\) 乘法的 \\(p\\) 进制观点，小节 5 用 Dirichlet 卷积和 Möbius 反演证明了很强的结果，小节 6 讨论了二项式系数的含 \\(p\\) 量，大部分内容基础要求不高，有料有用，亦可提升观点，敬请放心食用．其余涉及 Sylow 定理、直积识别等进阶知识的内容，请据个人基础、兴趣和胆识酌情阅读．\n有抽象代数基础：\n\n如上过一学期抽象代数课程\n\n应可顺畅阅读全文．模 \\(m\\) 剩余类环 \\(\\mathbb Z / m \\mathbb Z\\) 有较简单的显式表达，其乘法结构却不甚平凡，是操练抽象代数的良好玩具．本文大部分内容整合改编自 [1]，有经验的读者可参考本文查漏补缺、按图索骥．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#序",
    "href": "posts/20240922-pr/index.html#序",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "",
    "text": "这次来聊聊原根．何谓原根？本原单位根是也．何谓本原单位根？自乘若干次而归于一者，谓之单位根．若兼为乘法生成元，则称其本原，以示强调．原根有三定理，一是判定原根的方法，二是原根存在的条件，三是对原根的计数1．其中原根存在定理最难证明．固然有初等数论的证法，然而技巧性较强，或有碍阅读，亦难于记忆．使用代数方法研究原根，虽对基础有一定要求，证明亦不短，但胜在自然流畅，更具启发性．本文宗旨，应用代数工具，对模 \\(m\\) 剩余类环 \\(\\mathbb Z / m \\mathbb Z\\) 的乘法结构做出流畅的刻画，兼以部分随性的发散讨论，原根存在定理则作为推论导出．我们介绍的内容对有经验的读者或属“自证不难”，但完整证明的逻辑链条较长，需要了解原根的人群亦不一定有系统的代数基础（如 OI / XCPC 算法竞赛选手），故整理于此，供略知代数一二的同学按图索骥．\n1 这三个定理的提法来自 OI Wiki 的原根介绍．篇幅所限，无法完全做到 self-contained，故如下阅读建议供读者参考：\n\n完全没有抽象代数基础：\n可能在阅读中遇到较大的困难。\n有朴素的抽象代数基础：\n\n如数学基础不错的 OIer / XCPCer\n如上过一学期计算机系离散数学课程\n如会证 Polya 计数 / 理解群论的 Lagrange 定理 / 用抽代观点思考过初等数论问题\n\n小节 2 讨论原根三定理，小节 3 讨论中国剩余定理，小节 4 介绍了看待模 \\(p^\\alpha\\) 乘法的 \\(p\\) 进制观点，小节 5 用 Dirichlet 卷积和 Möbius 反演证明了很强的结果，小节 6 讨论了二项式系数的含 \\(p\\) 量，大部分内容基础要求不高，有料有用，亦可提升观点，敬请放心食用．其余涉及 Sylow 定理、直积识别等进阶知识的内容，请据个人基础、兴趣和胆识酌情阅读．\n有抽象代数基础：\n\n如上过一学期抽象代数课程\n\n应可顺畅阅读全文．模 \\(m\\) 剩余类环 \\(\\mathbb Z / m \\mathbb Z\\) 有较简单的显式表达，其乘法结构却不甚平凡，是操练抽象代数的良好玩具．本文大部分内容整合改编自 [1]，有经验的读者可参考本文查漏补缺、按图索骥．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#sec-prthm",
    "href": "posts/20240922-pr/index.html#sec-prthm",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "2 原根三定理：代数观点速通",
    "text": "2 原根三定理：代数观点速通\n研究模 \\(m\\) 加法和乘法的结构，便是研究模 \\(m\\) 剩余类环 \\(Z_m := \\mathbb Z / m \\mathbb Z\\) 的性质．特别地，若仅关心其上乘法的结构，可取 \\(Z_m\\) 全体乘法可逆元构成的乘法群（亦作简化剩余系） \\[\nZ_m^\\times = \\{ a \\in Z_m : \\gcd(a,m) = 1 \\}\n\\] 做研究，事实上，\\(Z_m^\\times\\) 恰由全体 \\(Z_m\\) 作为加法群的生成元构成，而 Euler totient 函数 \\(\\varphi(m)\\) 恰为此群的大小——这些都是数论中经典的 Bézout 定理的简单推论．\n\n注记. 值得一提，我们现在虽专注于模 \\(m\\) 乘法的研究，但 \\(Z_m\\) 乘法与加法并非相互割裂．环上的每一乘法可逆元 \\(a\\) 自然诱导出加法群的自同构 \\(x \\mapsto ax\\)，故有 \\(Z_m^\\times \\hookrightarrow \\operatorname{Aut}(Z_m)\\)2．事实上，由于 \\(Z_m\\) 作为 \\(m\\) 阶加法循环群结构简单，仅乘法可逆元便可诱导出其加法群的全部自同构，因此上述单同态亦具有满性：\\(Z_m^\\times \\cong \\operatorname{Aut}(Z_m)\\)3．综上，\\(Z_m\\) 上的可逆乘除操作，同 \\(Z_m\\) 作为加法群的自同构存在一一对应关系；探明模 \\(m\\) 乘法的结构，亦对研究模 \\(m\\) 加法有所裨益．这种观点将立刻在 定理 2（原根个数定理）的证明中发挥效用．\n2 以后使用 \\(\\hookrightarrow\\) 表单同态，\\(\\twoheadrightarrow\\) 表满同态，\\(\\operatorname{Aut}(Z_m)\\) 为 \\(Z_m\\) 作为加法群的全体自同构所构成的群．3 读者自证不难．亦可参见 [1, section 4.4, proposition 16, p. 135]\n柿子挑软的捏，我们自然关心那些较为简单的模 \\(m\\) 乘法的结构．何谓简单？\\(Z_m^\\times\\) 是循环群便是简单——因其只需一个元素便可生成——而这一元素，即（定义）为原根．译为白话，模 \\(m\\) 意义下的原根 \\(g\\) 定义为满足 \\[\ng^{k} = 1 \\pmod m \\iff \\varphi(m) \\mid k\n\\] 的某一非零整数．\n\\(\\mathrm{P} \\subseteq \\mathrm{NP}\\)，故在寻找原根前先讨论如何判定原根．原根判定定理给出了判定某一 \\(g \\in Z_m^\\times\\) 是否为原根的简易方法：\n\n\n\n\n\n\n\n定理 1 (原根判定定理) \\(g\\) 是乘法群 \\(Z_m^\\times\\) 的生成元当且仅当对每个 \\(\\varphi(m)\\) 的素因子 \\(p\\)，都有 \\(g^{\\varphi(m)/p} \\neq 1\\)．\n\n\n\n\n\n证明. 读者自证不难．\n\n\n注记. 这一定理可以认为是有限循环群上的 Lagrange 定理的一个应用：对任意 \\(d \\mid n\\)，任意 \\(n\\) 阶循环群都保有一个 \\(d\\) 阶子群；反之，任意子群的阶一定是 \\(n\\) 的因子．\n\n假定已知模数 \\(m\\) 保有一原根，我们进而关心其所有原根之间的相互结构．特别地，我们关心原根有多少个：\n\n\n\n\n\n\n\n定理 2 (原根个数定理) 若 \\(Z_m^\\times\\) 是循环群，则其恰有 \\(\\varphi(\\varphi(m))\\) 个生成元．\n\n\n\n\n\n证明. 在我们的叙述下，原根个数定理成为一句废话．根据条件，作为乘法群的 \\(Z_m^\\times\\) 与加法群 \\(Z_{\\varphi(m)}\\) 同构，而 \\(Z_{\\varphi(m)}\\) 当然可以根据其上的加法定义出乘法，进而升级为环．正如前文提到的，\\(Z_{\\varphi(m)}\\) 全体（加法）生成元恰为 \\(Z_{\\varphi(m)}^\\times\\) ．再通过上述同构关系，我们便得到 \\(Z_m^\\times\\) 中的所有生成元的数量及其相互关系．\n\n\n注记. 从计算原根的角度来看，上述结果并未给出显式给出 \\(Z_m^\\times\\) 的生成元，这是因为 \\(Z_m^\\times\\) 与 \\(Z_{\\varphi(m)}\\) 之间同构的具体形式尚不明确．但我们可以利用原根判定定理（和快速幂）从小到大逐一验证．由于原根数量高达 \\(\\varphi(\\varphi(m))\\) 个，一般很快就能找到．事实上当模数为质数 \\(p\\) 时，最小原根有渐进上界估计 \\(O(n^{1/4 + \\varepsilon})\\) 和下界估计 \\(\\Omega(\\log p)\\)．OI Wiki 给出了上述结果的一些参考文献．\n\n当然，并非每个 \\(Z_m^\\times\\) 都是循环群，因此不是所有模数 \\(m\\) 都保有原根．原根存在定理给出了使得 \\(Z_m^\\times\\) 确为循环群的所有 \\(m\\)：\n\n\n\n\n\n\n\n定理 3 (原根存在定理) 使得 \\(Z_m^\\times\\) 成为循环群的正整数 \\(m\\) 有且只有 \\(2,4, p^\\alpha, 2 p^\\alpha\\)，这里 \\(p\\) 是奇质数，\\(\\alpha\\) 是正整数．\n\n\n\n\n这一定理不如前两个定理显然，需要我们对环 \\(Z_m\\) 的结构做更深的探讨．事实上，与其只关心 \\(Z_m^\\times\\) 是不是循环群，不如更进一步，看看 \\(Z_m^\\times\\) 究竟同构于哪些循环群的直积；与其只关心 \\(Z_m\\) 的乘法结构，不如将本来就与乘法紧密相关的加法结构一并纳入考虑．在之后的讨论中，我们将先解剖出模 \\(m\\) 剩余类环 \\(Z_m\\) 的结构，随后具体讨论 \\(Z_m^\\times\\) 的结构，顺带产生关于原根存在性的结果．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#sec-crt",
    "href": "posts/20240922-pr/index.html#sec-crt",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "3 \\(Z_m\\) 的结构：中国剩余定理",
    "text": "3 \\(Z_m\\) 的结构：中国剩余定理\n既然是研究环与同余的结构，就必然要提到中国剩余定理．回忆数论中最常见的中国剩余定理：\n\n\n\n\n\n\n\n定理 4 (中国剩余定理：数论) 给定 \\(n\\) 个同余方程 \\[\nx \\equiv a_i \\pmod{m_i}\n\\]\n其中各 \\(m_i\\) 两两互质，\\(i = 1, \\dots, n\\)．记 \\[\n\\delta_i = \\prod_{j \\neq i} m_j \\operatorname{inv}_{m_i}(m_j)\n\\] 则上述方程组等价于 \\[\nx \\equiv \\sum_{i=1}^n a_i \\delta_i \\pmod{\\prod_{i=1}^n m_i}\n\\] 这里 \\(\\operatorname{inv}_{m_i}(m_j)\\) 代表 \\(m_j\\) 在模 \\(m_i\\) 意义下的逆元．\n\n\n\n\n注意到4 \\[\n\\delta_i \\bmod m_k = \\delta (i=k)\n\\] 这是中国剩余定理的神髓所在：构造一组强力的“基底”，其中每一元素在其对应模数下的表现恰似单位元，而在其它模数下全无效力．我们指出，这一构造在中国剩余定理的环论版本中同样管用．先将数论中的中国剩余定理用环论的语言重述：\n4 这里我们记 \\[\\delta(P) = \\begin{cases}1 & P \\text{ is true} \\\\ 0 & \\text{otherwise}\\end{cases}\\]\n\n\n\n\n\n\n定理 5 (中国剩余定理：数论，但环论语言) 设 \\(m_1 \\mathbb Z, m_2 \\mathbb Z, \\dots, m_n \\mathbb Z\\) 是环 \\(\\mathbb Z\\) 的若干（双边）理想，且 \\(m_1,m_2,\\dots,m_n\\) 两两互素．由 Bézout 定理，可设对任意互异的 \\(i,j\\)，存在 \\(x_{i,j} \\in m_i \\mathbb Z\\) 和 \\(y_{i,j} \\in m_j \\mathbb Z\\) 满足 \\(x_{i,j} + y_{i,j} = 1\\)．我们声称如下环同态 \\[\n\\pi: \\begin{aligned}\n\\mathbb Z &\\to \\mathbb Z / m_1 \\mathbb Z \\times \\mathbb Z / m_2 \\mathbb Z \\times \\dots \\times \\mathbb Z / m_n \\mathbb Z \\\\\na &\\mapsto (a+m_1 \\mathbb Z,a+m_2 \\mathbb Z,\\dots,a+m_n \\mathbb Z)\n\\end{aligned}\n\\] 具有满性，这一满性由如下构造给出： \\[\na := \\sum_{i=1}^n a_i \\delta_i\n\\] 是使得 \\(\\pi(a) = (a_1,a_2,\\dots,a_n)\\) 成立的一个解，这里 \\[\n\\delta_i := \\prod_{j \\neq i} y_{i,j}\n\\] 经由上述环同态，我们有（由环的第一同构定理） \\[\n\\begin{aligned}\n\\mathbb Z / (\\prod_{i=1}^n m_i) \\mathbb Z = \\mathbb Z / (\\bigcap_{i=1}^n m_i \\mathbb Z) \\cong \\prod_{i=1}^n (\\mathbb Z /m_i \\mathbb Z)\n\\end{aligned}\n\\]\n\n\n\n\n\n证明. 仅需对构造中使用的“基底” \\(\\delta_i\\) 作一点说明．请读者关注以下等式 \\[\n1 = \\prod_{j \\neq i} (x_{i,j} + y_{i,j})\n\\] 注意到右侧乘积展开后，除 \\(\\prod_{j \\neq i} y_{i,j}\\) 一项外，其余各项均至少含有一个 \\(x_{i,j} \\in m_i \\mathbb Z\\)，故 \\(\\prod_{j \\neq i} y_{i,j} = 1 \\pmod{m_i \\mathbb Z}\\)．同时，由于 \\(y_{i,j} \\in m_j \\mathbb Z\\)，亦有 \\(\\prod_{j \\neq i} y_{i,j} = 0 \\pmod{m_k \\mathbb Z}\\) 对所有 \\(k \\neq i\\) 成立．综上知 \\[\n\\delta_i = \\delta(i=k) \\pmod{m_k \\mathbb Z}\n\\]\n\n\n\n\n\n\n\n\n定理 6 (中国剩余定理：环论) 设 \\(R\\) 是任意有单位元的环，\\(I_1,I_2,\\dots,I_n\\) 是 \\(R\\) 的若干（双边）理想，且 \\(I_1,I_2,\\dots,I_n\\) 两两“互素”（comaximal，即 \\(i \\neq j \\implies I_i + I_j = R\\)），此时可设对任意互异的 \\(i,j\\)，存在 \\(x_{i,j} \\in I_i\\) 和 \\(y_{i,j} \\in I_j\\) 满足 \\(x_{i,j} + y_{i,j} = 1\\)．则如下环同态 \\[\n\\pi: \\begin{aligned}\nR &\\to R/I_1 \\times R/I_2 \\times \\dots \\times R/I_n \\\\\nr &\\mapsto (r+I_1,r+I_2,\\dots,r+I_n)\n\\end{aligned}\n\\] 具有满性，这一满性由如下构造给出： \\[\na := \\sum_{i=1}^n a_i \\delta_i\n\\] 是使得 \\(\\pi(a) = (a_1,a_2,\\dots,a_n)\\) 成立的一个解，这里 \\[\n\\delta_i := \\prod_{j \\neq i} y_{i,j}\n\\] 经由上述环同态，我们有（由环的第一同构定理） \\[\n\\begin{aligned}\nR/(\\bigcap_{i=1}^n I_i) \\cong \\prod_{i=1}^n (R/I_i)\n\\end{aligned}\n\\]\n\n\n\n\n\n证明. 请读者仿照上例练习．\n\n\n注记. 这里得到的环论版本的中国剩余定理的证明将是构造式的．常见的代数书目在叙述证明时一般诉诸数学归纳法——固然是严谨的选择，但牺牲了一点神韵．我们给出两个参考：\n\n[1, section 7.17, theorem 17, p. 265]：是本文主要参考的证明，但是有单位元的交换环上的特化版本．环上的交换性并不是中国剩余定理的本质要求，其作用仅为使得环上理想 \\(I,J\\) 满足 \\(I J = I \\cap J\\)．特别地，这使得应用在整数环上的中国剩余定理的在计算上更为简洁： \\[\n\\mathbb Z / (\\prod_{i=1}^n m_i) \\mathbb Z = \\mathbb Z / (\\bigcap_{i=1}^n m_i \\mathbb Z)\n\\]\n[2, theorem 2.25, p. 131]：给出了不要求环上单位元存在的更加一般的中国剩余定理．\n\n环论版本的中国剩余定理功用强大．除了在数论领域的经典应用，在多项式环上，中国剩余定理将多项式多点求值与多点插值联系起来，某种程度上为离散 Fourier 变换提供了同构视角下的理解．感兴趣的读者敬请移步此处．最强大的中国剩余定理可以扩展到模上：\n\n\n\n\n\n\n\n\n定理 7 (中国剩余定理：模论) 设环 \\(R\\)、理想 \\(I_1,I_2,\\dots,I_n\\)、元素 \\(x_{i,j} \\in I_i\\) 和 \\(y_{i,j} \\in I_j\\) 的要求与 定理 6 中一致．设 \\(M\\) 为一 \\(R\\)-模，则如下模同态 \\[\n\\pi: \\begin{aligned}\nM &\\to M / I_1 M \\oplus M/I_2 M \\oplus \\dots \\oplus M / I_n M \\\\\nr &\\mapsto (r+I_1 M,r+I_2 M,\\dots,r+I_n M)\n\\end{aligned}\n\\] 具有满性，这一满性由如下构造给出： \\[\na := \\sum_{i=1}^n \\delta_i a_i\n\\] 是使得 \\(\\pi(a) = (a_1,a_2,\\dots,a_n)\\) 成立的一个解，这里 \\[\n\\delta_i := \\prod_{j \\neq i} y_{i,j} \\in R\n\\] 经由上述模同态，我们有（由模的第一同构定理） \\[\n\\begin{aligned}\nM/(\\bigcap_{i=1}^n I_i M) \\cong \\bigoplus_{i=1}^n (M/I_i M)\n\\end{aligned}\n\\]\n\n\n\n\n回到正题．我们在研究环 \\(Z_m = \\mathbb Z / m\\mathbb Z\\) 的结构，而 定理 5 已经做出了巨大的贡献：设 \\(m\\) 有质因子分解 \\(m = p_1^{\\alpha_1} p_2^{\\alpha_2} \\dots p_k^{\\alpha_k}\\)，则环 \\(Z_m\\) 便可被拆分成若干大小互素的环的直积： \\[\nZ_m \\cong Z_{p_1^{\\alpha_1}} \\times Z_{p_2^{\\alpha_2}} \\times \\dots \\times Z_{p_k^{\\alpha_k}}\n\\] 作为环的附属结构，\\(Z_m\\) 的乘法群也得到自然的拆解： \\[\nZ_m^\\times\n\\cong \\left( Z_{p_1^{\\alpha_1}} \\times Z_{p_2^{\\alpha_2}} \\times \\dots \\times Z_{p_k^{\\alpha_k}} \\right)^\\times\n= Z_{p_1^{\\alpha_1}}^\\times \\times Z_{p_2^{\\alpha_2}}^\\times \\times \\dots \\times Z_{p_k^{\\alpha_k}}^\\times\n\\] 余下的工作，是解剖环 \\(Z_{p^{\\alpha}}\\) 的乘法群 \\(Z_{p^{\\alpha}}^\\times\\) 的结构．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#sec-zpat",
    "href": "posts/20240922-pr/index.html#sec-zpat",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "4 \\(Z_{p^\\alpha}^\\times\\) 的结构：分裂的商同态",
    "text": "4 \\(Z_{p^\\alpha}^\\times\\) 的结构：分裂的商同态\n加法和乘法运算，但对 \\(p^\\alpha\\) 取模，似乎不太熟悉？事实上，将 \\(0\\) 到 \\(p^\\alpha -1\\) 间的所有整数写为 \\(\\sum_{i=0}^{\\alpha - 1} a_i p^i\\) 的 \\(p\\) 进制形式，是刻画该剩余类环的一种良好方法，其实质为以 \\(p \\in Z_{p^\\alpha}\\) 带入整系数多项式环得到的一个 \\(\\mathbb Z[x] \\to Z_{p^\\alpha}\\) 的环同态．读者可在接下来的探究中借其指导直觉．\n首先，粗略地看看哪些环 \\(Z_{p^\\alpha}\\) 元素（在乘法意义下）可逆——自然是与 \\(p^\\alpha\\) 互素——即不被 \\(p\\) 整除——即 \\(p\\) 进制表示下 \\(a_0 \\neq 0\\) 的那些数——即 \\(Z_{p^\\alpha}^\\times = Z_{p^\\alpha} \\setminus p Z_{p^\\alpha}\\)．简单的计数就得到其大小为 \\(\\varphi(p^\\alpha) = p^\\alpha - p^{\\alpha - 1} = p^{\\alpha - 1} (p - 1)\\)．一个受此启发的想法是，如果仅在模 \\(p\\) 意义下考虑 \\(Z_{p^\\alpha}\\) 中的运算——即只看 \\(p\\) 进制表示下 \\(a_0\\) 的变化情况，自然得到商同态 \\(\\pi\\)： \\[\n\\begin{aligned}\nZ_{p^\\alpha} &\\twoheadrightarrow Z_{p^\\alpha} / p Z_{p^\\alpha} \\cong Z_p \\\\\na \\bmod p^\\alpha &\\mapsto a \\bmod p\n\\end{aligned}\n\\] 注意环同态保持可逆元，故若只考虑乘法结构，\\(\\pi\\) 也给出了交换群 \\(Z_{p^\\alpha}^\\times \\twoheadrightarrow Z_p^\\times\\) 的一个满同态，其核 \\(\\ker \\pi\\) 为模 \\(p\\) 余 \\(1\\)——即 \\(p\\) 进制表示下 \\(a_0 = 1\\)，其余位置任取——的那些数构成的 \\(p^{\\alpha-1}\\) 阶乘法子群．此外我们还有 \\(Z_{p^\\alpha}^\\times / \\ker \\pi \\cong Z_p^\\times\\)．\n使用商同态研究交换群的结构，最好的情况是这个同态分裂5——在这里即希望 \\(Z_{p^\\alpha}^\\times / \\ker \\pi\\) 或者说 \\(Z_p^\\times\\) 在 \\(Z_{p^\\alpha}^\\times\\) 中有一个同构的拷贝．此时由子群直积的识别定理 [1, section 5.4, theorem 9, p. 171] 我们有 \\(Z_{p^\\alpha}^\\times \\cong \\ker \\pi \\times Z_p^\\times\\)．但真的可以吗？我们另从 \\(Z_{p^\\alpha}^\\times\\) 的大小——\\(p^{\\alpha - 1} (p - 1)\\)——的角度下手试试．固然 \\(p^\\alpha\\) 与 \\(p-1\\) 互素，故\n5 关于正合列，见 [1, section 10.5]\n如果你了解有限交换群的基本结构：由有限交换群基本定理 [1, section 5.2]\n如果你学过有限群的 Sylow 定理 [1, section 4.5]：考虑到 \\(Z_{p^\\alpha}^\\times\\) 是交换群，其所有子群均为正规子群，熟记如下结果 [1, section 6.1, theorem 3, p. 191]\n\n\n\n\n\n\n\n定理 8 (有限幂零群的部分等价条件) 设 \\(G\\) 是一有限群，则如下条件等价：\n\n对任意质数 \\(p \\mid |G|\\)，\\(G\\) 的 Sylow \\(p\\)-子群存在且唯一．\n\\(G\\) 的 Sylow 子群均为正规子群．\n\\(G\\) 是其全体 Sylow 子群的（内）直积．\n\n\n\n\n\n\n证明. 考虑 Sylow 定理关于 Sylow \\(p\\)-子群共轭性的结果和子群直积的识别定理，有经验的读者应不难证明，此处略去．\n\n如果你了解主理想整环上模的基本结构：考虑将交换群 \\(Z_{p^\\alpha}^\\times\\) 视为 \\(\\mathbb Z\\)-模，则其被 \\(p^{\\alpha-1} (p-1) \\in \\mathbb Z\\) 消灭，由于 \\(\\gcd(p^{\\alpha-1}, p-1) = 1\\)，根据核分解定理，\\(Z_{p^\\alpha}^\\times = \\ker p^{\\alpha-1} \\oplus \\ker (p-1)\\)\n\n便知道 \\(Z_{p^\\alpha}^\\times\\) 是其两个大小分别为 \\(p^{\\alpha - 1}\\) 和 \\(p-1\\) 的子群（记为 \\(Q\\) 和 \\(S\\)）的（内）直积．现在结合上一段构造的乘法群商同态 \\(\\pi: Z_{p^\\alpha}^\\times \\to Z_p^\\times\\) 对 \\(Q\\) 和 \\(S\\) 作考察：\n\n考虑到 \\(Z_{p^\\alpha}^\\times \\cong Q \\times S\\)，故 \\(Z_{p^\\alpha}\\) 的 \\(p^\\alpha\\) 阶子群只有 \\(Q\\) 唯一一个．而已经知道 \\(|\\ker \\pi| = p^{\\alpha-1} = |Q|\\)，故立得 \\(Q = \\ker \\pi\\)．\n将 \\(\\pi\\) 限制在 \\(S\\) 上得到新同态 \\(\\pi \\vert_S : S \\to Z_p^\\times\\)，其核为 \\(S \\cap \\ker \\pi\\)．注意 \\(|S| = p-1\\) 且 \\(|\\ker \\pi| = p^\\alpha\\)，故这个核只能是平凡的，即 \\(\\pi \\vert_S\\) 是单同态．再考虑到 \\(|Z_p^\\times| = p - 1 = |S|\\)，我们得到 \\(S \\cong Z_p^\\times\\)．\n\n故真的有 \\[\nZ_{p^\\alpha}^\\times \\cong \\ker \\pi \\times Z_p^\\times\n\\] 而 \\(Z_p^\\times\\) 在 \\(Z_{p^\\alpha}\\) 中的像恰为 \\(p\\) 进制表示下 \\(a_0 \\in Z_p^\\times\\)，其余为 \\(0\\) 的那些数．接下来的工作是分别研究 \\(\\ker\\pi\\) 和 \\(Z_p^\\times\\)．\n\n注记. 本节内容，另可参考 [1, section 9.5, corollary 20, p. 314]．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#sec-zpt",
    "href": "posts/20240922-pr/index.html#sec-zpt",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "5 \\(Z_p^\\times\\) 的结构：域的有限乘法子群",
    "text": "5 \\(Z_p^\\times\\) 的结构：域的有限乘法子群\n因为 \\(Z_2^\\times\\) 是平凡群，故只需研究 \\(p \\ge 3\\) 的情况．事实上我们已经比较清楚环 \\(Z_p\\) 的结构——它是一个域．[1, section 9.5, pp. 313–314] 给出了一种利用域上多项式环性质证明 \\(Z_p^\\times\\) 是循环群的神奇做法．我们知道，域上的 \\(n\\) 阶多项式至多只能有 \\(n\\) 个根（数论中又名 Lagrange 定理），而 \\(Z_p^\\times\\) 内满足 \\(x^d = 1\\) 的元素（即 \\(d\\) 次单位根）都是多项式 \\(x^d - 1\\) 的根，故 \\(d\\) 次单位根的个数至多为 \\(d\\) 个．令人惊奇的是，如此松弛的估计足以确定 \\(Z_p^\\times\\) 的结构．请看如下定理 [1, section 6.1, proposition 5, p. 192]．\n\n\n\n\n\n\n\n定理 9 (循环群判定：基于单位根数量上限) 设 \\(G\\) 是一有限群，满足对任意正整数 \\(n\\)，\\(n\\) 次单位根的个数至多为 \\(n\\) 个，则 \\(G\\) 是循环群．\n\n\n\n\n我们提供 2.5 种不同的证明．\n\n证明 (Sylow 定理向). 首先注意到对任意正整数 \\(n\\)，\\(G\\) 中若存在 \\(n\\) 阶子群则必定唯一，且恰为 \\(G_n := \\{ g \\in G: g^n = 1 \\}\\)．这是因为任何 \\(n\\) 阶子群内的元素均为 \\(n\\) 次单位根，数量已达到条件中给出的 \\(n\\) 个的上限，故无法再支撑另一 \\(n\\) 阶子群的存在．特别地，\\(G\\) 的 Sylow \\(p\\)-子群 \\(S_p\\) 存在且唯一．由 定理 8，\\(G\\) 为 \\(G\\) 的各个 Sylow \\(p\\)-子群 \\(S_p\\) 的（内）直积．于是只需证每个 \\(S_p\\) 都是循环群．记 \\(\\alpha\\) 是 \\(p\\) 在 \\(n\\) 中的指数．由 Sylow 定理，\\(S_p\\) 有一个 \\(p^{\\alpha - 1}\\) 阶子群 \\(H_p\\)，据前述观察 \\[\nH_p = \\{ g \\in G : g^{p^{\\alpha-1}} = 1\\} &lt; \\{g \\in G : g^{p^\\alpha} = 1\\} = S_p\n\\] 故任取 \\(g \\in S_p \\setminus H_p\\) 就得到一个 \\(p^{\\alpha}\\) 阶元，故 \\(S_p\\) 是循环群．\n\n下面是一个使用 Dirichlet 卷积 / Möbius 反演的数论风格的证明 [1, section 9.5, exercise 6, p. 315]．\n\n证明 (数论向). 记 \\[\n\\begin{aligned}\ng(n) &:= \\#\\{ x \\in G: x^n = 1 \\} \\\\\nh(n) &:= \\#\\{ x \\in G: \\operatorname{ord}(x) = n \\}\n\\end{aligned}\n\\] 则 \\[\ng(n) = \\sum_{d \\mid n} h(n)\n\\] 依次应用 Möbius 反演、条件假设和 Dirichlet 卷积 \\(\\varphi = \\mu * \\mathrm{id}\\) 得 \\[\nh(n) = \\sum_{d \\mid n} \\mu(\\frac n d)g(d) \\leq \\sum_{d \\mid n} \\mu(\\frac n d) d = \\varphi(n)\n\\] 但根据 \\(h\\) 的定义和 Dirichlet 卷积 \\(\\varphi * I = \\mathrm{id}\\) 有 \\[\n\\sum_{n \\mid |G|} h(n) = |G| = \\sum_{n \\mid |G|} \\varphi(n)\n\\] 这逼迫 \\(h(n)=\\varphi(n)\\) 对所有 \\(n \\mid |G|\\) 成立．特别地，\\(h(|G|) = \\varphi(|G|) \\geq 1\\)，故 \\(G\\) 是循环群．\n\n最后半种证明方法相对简明，但需增加群 \\(G\\) 交换的条件．\n\n证明 (交换群的特例). 由有限交换群基本定理，\\(G\\) 内存在阶为群 \\(G\\) 的指数（exponent） \\[\n\\exp G := \\min \\{n \\in \\mathbb N_+ : g^n = 1,\\, \\forall g \\in G \\}\n\\] 的元素．故只需证 \\(\\exp G = |G|\\)．根据定义，\\(G\\) 中所有元素都是 \\(\\exp G\\) 次单位根，故由关于单位根数量上限的假设，\\(|G| \\leq \\exp G \\leq G\\)，故 \\(\\exp G = |G|\\)，得证．\n\n结合前述讨论，我们已经证明 \\(Z_p^\\times\\) 是循环群，并事实上导出了如下广为人知的结果 [1, section 9.5, proposition 18, p. 314]\n\n\n\n\n\n\n\n推论 1 域 \\(F\\) 的任意有限乘法子群 \\(G \\leq F^\\times\\) 均为循环群．\n\n\n\n\n\n证明. 与本节开始的讨论相仿．考察 \\(G\\) 中所有 \\(d\\) 次单位根，它们均为 \\(F[x]\\) 中多项式 \\(x^d - 1\\) 的根，但域上的 \\(d\\) 次多项式至多只有 \\(d\\) 个根，故 定理 9 的条件得到满足．\n\n\n注记. 对 \\(F\\) 的要求甚至还可进一步减弱为整环 \\(R\\)——这是因为在关于多项式根数量上限的 Lagrange 定理的证明中，带余除一个首一多项式并不需要可逆元的参与．这一结果亦可通过取 \\(R\\) 的分式域直接弱化得到．\n设整环 \\(R\\) 的 \\(n\\) 次单位根子群 \\(U_n := \\{ x \\in R: x^n = 1 \\} \\leq \\operatorname{Tor}R^\\times \\leq R^\\times\\)，它们的并构成了 \\(R\\) 的乘法群 \\(R^\\times\\) 的挠子群（torsion subgroup）\\(\\operatorname{Tor}R^\\times\\)．我们的推导实际上说明：\n\n每个 \\(U_n\\) 都是循环群，也是乘法群 \\(R^\\times\\) 唯一的 \\(n\\) 阶子群．\n若 \\(d | n\\)，则 \\(U_d \\leq U_n\\)．特别地，阶数互素的两群之交平凡．\n使用 \\(\\mathbb Z\\)-模风格的记号， \\[\n\\operatorname{Tor}R^\\times = \\bigoplus_{p \\in \\text{prime}} \\bigcup{\\alpha=1}^{+\\infty} U_{p^\\alpha}\n\\] 故 \\(\\operatorname{Tor}R^\\times\\) 的结构似乎和 \\(\\mathbb Q/\\mathbb Z\\) 和 \\(p\\) 进数 \\(\\mathbb Z_p\\) 有一定联系．笔者能力有限，有机会再填坑．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#sec-nup",
    "href": "posts/20240922-pr/index.html#sec-nup",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "6 \\(\\ker \\pi\\) 的结构：二项式定理与含 \\(p\\) 量估计",
    "text": "6 \\(\\ker \\pi\\) 的结构：二项式定理与含 \\(p\\) 量估计\n这里处理 \\(\\ker \\pi\\) 的结构的办法相当暴力 [1, section 2.4, exercises 21–23, p. 60]：\n\n当 \\(p\\) 是奇质数时，我们将直接找到一个 \\(\\ker \\pi \\le Z_{p^\\alpha}^\\times\\) 中的一个 \\(p^{\\alpha-1}\\) 阶元，据此得到 \\(\\ker \\pi \\cong Z_{p^{\\alpha - 1}}\\)；\n当 \\(p = 2\\) 时（此时 \\(Z_p^\\times\\) 是平凡群，故 \\(\\ker \\pi = Z_{2^\\alpha}^\\times\\)），我们将直接找到一个 \\(\\ker \\pi\\) 中的 \\(2^{\\alpha-2}\\) 阶元，再找到两个不同的 \\(2\\) 阶元，据此证明 \\(\\ker \\pi \\cong Z_2 \\times Z_{2^{\\alpha - 2}}\\)．\n\n先介绍一个关于二项式含 \\(p\\) 量的有趣结果．\n\n\n\n\n\n\n\n命题 1 (Kummer 定理的一个特例) 设 \\(p\\) 是质数，\\(\\alpha \\ge 0\\) 是非负整数，\\(1 \\le k\\le p^\\alpha\\)，则 \\[\n\\nu_p (\\binom{p^\\alpha}{k}) = \\alpha - \\nu_p (k)\n\\] 这里 \\(\\nu_p\\) 是所谓的 \\(p\\)-adic valuation 函数，其返回因子分解中素因子 \\(p\\) 对应的指数，以后简称含 \\(p\\) 量．\n\n\n\n\n\n证明. 基本的想法是将二项式系数展开写为 \\[\n\\binom{p^\\alpha}{k} = \\frac{p^\\alpha (p^\\alpha -1) \\dots (p^\\alpha -k+1)}{1 \\times 2\\times  \\dots \\times k}\n\\] 并观察从 \\(\\nu_p\\) 从 \\(\\binom{p^\\alpha}{k-1}\\) 到 \\(\\binom{p^\\alpha}{k}\\) 取值的变化．注意到 \\(\\nu_p(k) = \\nu_p (p^\\alpha - k)\\) 对 \\(1 \\le k \\le p^\\alpha - 1\\) 成立，故 \\[\n\\nu_p (\\binom{p^\\alpha}{k}) - \\nu_p (\\binom{p^\\alpha}{k-1}) = \\nu_p (p^\\alpha -k+1) - \\nu_p(k) = \\nu_p(k-1) - \\nu_p(k)\n\\] 连同初值 \\(\\nu_p (\\binom{p^\\alpha}{0}) = \\alpha\\)，命题得证．\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef nu(p,x):\n  cnt = 0\n  while x and x%p == 0:\n    x //= p\n    cnt += 1\n  return cnt\n\n\na = 3\np = 3\n\nnpk = [0]\nfor k in range(1,p**a+1):\n  npk.append(a-nu(p,k))\n\nfig, ax = plt.subplots()\nax.plot(list(range(0,p**a+1)),npk)\nax.grid(True)\nax.set_aspect('equal', 'box')\nax.set_xticks(range(0,27+1))\nax.set_yticks(range(0,3+1))\nax.set_xlim((0, 27))\nax.set_ylim((0, 3))\nplt.show()  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n图 1: \\(p^\\alpha = 3^3\\) 时 \\(\\binom{p^\\alpha}{k}\\) 的含 \\(p\\) 量\n\n\n\n继续证明前我们再做一些观察：\n\nCode\nlim = 20\nfig, ax = plt.subplots()\nx = np.array(range(1,lim+1))\nax.plot(x,list(map(lambda k: nu(3,k), x)), label = \"$\\\\nu_3(k)$\")\nax.plot(x,list(map(lambda k: nu(2,k), x)), label = \"$\\\\nu_2(k)$\")\nax.plot(x,x-1, linestyle=\"dashed\", label = \"$k-1$\")\nax.plot(x,2*x-2, linestyle=\"dotted\", label = \"$2k-2$\")\nax.grid(True)\nax.set_aspect('equal', 'box')\nax.set_xticks(x)\nax.set_yticks(range(-2,4))\nax.set_xlim(1,lim)\nax.set_ylim(-2,4)\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n图 2: 若干含 \\(p\\) 量比较\n\n\n\n受 图 2 启发，容易证明：\n\n\\(k-1 \\ge \\nu_p (k)\\) 对所有质数 \\(p\\) 和 \\(k \\ge 1\\) 成立；\n\\(k-2 \\ge \\nu_p (k)\\) 对所有奇质数 \\(p \\ge 3\\) 和 \\(k \\ge 2\\) 成立；\n\\(2k-2 \\ge \\nu_2 (k)\\) 对所有 \\(k \\ge 1\\) 成立．\n\\(2k-3 \\ge \\nu_2 (k)\\) 对所有 \\(k \\ge 2\\) 成立．\n\n这四个不等式的微妙区别是导致奇质数和 \\(2\\) 需要分别讨论的罪魁祸首之一．\n\n\n\n\n\n\n\n命题 2 设 \\(p\\) 是奇质数，\\(\\alpha \\ge 1\\) 是正整数，则元素 \\(1+p \\in \\ker \\pi \\le Z_{p^\\alpha}^\\times\\) 的阶为 \\(p^{\\alpha-1}\\)．\n\n\n\n\n\n证明. 首先考察 \\[\n(1+p)^{p^{\\alpha-1}} = 1 + \\sum_{k=1}^{p^{\\alpha-1}} \\binom{p^{\\alpha-1}}{k} p^k\n\\] 应用 命题 1 大力考察求和每一项的含 \\(p\\) 量，得到 \\[\n\\nu_p(\\binom{p^{\\alpha-1}}{k} p^k) = \\alpha - 1 - \\nu_p (k) + k\n\\] 注意 \\(k-1 \\ge \\nu_p (k)\\) 对 \\(k \\ge 1\\) 永远成立，故求和每一项的含 \\(p\\) 量均至少为 \\(\\alpha\\)，故 \\[\n(1+p)^{p^{\\alpha-1}} \\equiv 1 \\pmod{p^\\alpha}\n\\] 若 \\(\\alpha = 1\\)，则命题已经得证．下面来看为什么 \\(p \\ge 3\\), \\(\\alpha \\ge 2\\) 时会有 \\[\n1 + \\sum_{k=1}^{p^{\\alpha-2}} \\binom{p^{\\alpha-2}}{k} p^k = (1+p)^{p^{\\alpha-2}} \\not \\equiv 1 \\pmod{p^\\alpha}\n\\] 同样的方法计算含 \\(p\\) 量 \\[\n\\nu_p(\\binom{p^{\\alpha-2}}{k} p^k) = \\alpha - 2 - \\nu_p (k) + k\n\\] 由上述不等式关系，右式仅在 \\(k=1\\) 时小于 \\(\\alpha\\)，因此和式中只有 \\(\\binom{p^{\\alpha-2}}{1} p = p^{\\alpha - 1}\\) 一项在模 \\(p^\\alpha\\) 意义下产生了额外贡献——当然 \\(1 + p^{\\alpha-1} \\not \\equiv 1 \\pmod{p^\\alpha}\\)，得证．\n\n\n\n\n\n\n\n\n推论 2 设 \\(p\\) 是奇质数，\\(\\alpha \\ge 1\\) 是正整数，则 \\(\\ker \\pi \\cong Z_{p^{\\alpha-1}}\\)．\n\n\n\n\n\n\n\n\n\n\n\n命题 3 设正整数 \\(\\alpha \\ge 2\\)．元素 \\(5 = 1+ 2^2 \\in \\ker \\pi = Z_{2^\\alpha}^\\times\\) 的阶为 \\(2^{\\alpha-2}\\)．\n\n\n\n\n\n证明. 请读者仿照上例练习．考虑利用二项式定理展开 \\((1+2^2)^{2^{\\alpha-2}}\\) 和 \\((1+2^2)^{2^{\\alpha-3}}\\) 并利用 图 2 下方的后两个不等式．\n\n\n\n\n\n\n\n\n命题 4 设 \\(\\alpha \\ge 2\\) 是正整数，则元素 \\(-1\\) 和 \\(1+2^{\\alpha-1}\\) 在 \\(\\ker \\pi = Z_{2^\\alpha}^\\times\\) 的阶为 \\(2\\)．当 \\(\\alpha \\ge 3\\) 时两者互异．\n\n\n\n\n\n证明. 显然 \\(-1\\) 阶为 \\(2\\)．而 \\[\n(1+2^{\\alpha-1})^2 \\equiv 1 + 2 \\times 2^{\\alpha-1} + 2^{2(\\alpha-1)} \\equiv 1 \\pmod{2^\\alpha}\n\\]\n\n\n\n\n\n\n\n\n推论 3 设 \\(\\alpha \\ge 2\\) 是正整数，则 \\(Z_{2^\\alpha}^\\times = \\ker \\pi \\cong Z_2 \\times Z_{2^{\\alpha-2}}\\)．\n\n\n\n\n\n证明. 当 \\(\\alpha = 2\\)，\\(|\\ker \\pi| = 2\\)，平凡．当 \\(\\alpha \\ge 3\\)，命题 4 给出了两个无交且生成整个 \\(\\ker \\pi\\) 的循环群，使用子群直积的识别定理即可．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#结论",
    "href": "posts/20240922-pr/index.html#结论",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "7 结论",
    "text": "7 结论\n综合 小节 5 和 小节 6 的结果，我们将结果总结如下 [1, section 9.5, corollary 20, p. 314]：\n\n\n\n\n\n\n\n定理 10 (模 \\(m\\) 剩余类乘法群 \\(Z_m^\\times\\) 的结构性定理) 设 \\(n \\geq 2\\) 为一正整数，其质因子分解为 \\(n = \\prod_{i=1}^k p_i^{\\alpha_i}\\)，则有如下群同构 \\[\nZ_m^\\times \\cong \\prod_{i=1}^k Z_{p_i^{\\alpha_i}}^\\times \\\\\n\\] 对分解中满足 \\(p \\geq 3\\) 的 \\(Z_{p^\\alpha}^\\times\\) ，有 \\[\nZ_{p^\\alpha}^\\times \\cong Z_{p-1} \\times Z_{p^{\\alpha-1}} \\cong Z_{p^{\\alpha-1}(p-1)}\n\\] 对分解中的 \\(Z_{2^\\alpha}^\\times\\)，有 \\[\nZ_{2^\\alpha}^\\times \\cong Z_2 \\times Z_{2^{\\alpha-2}}\n\\]\n\n\n\n\n据此，原根存在定理成为简单的推论．\n\n证明 (定理 3). 注意群同构 \\(Z_a \\times Z_b \\cong Z_{ab}\\) 当且仅当 \\(\\gcd(a,b) = 1\\)，这将组成证明各项讨论的核心．\n对奇质数 \\(p \\geq 3\\) 和正整数 \\(\\alpha\\)，有如下群同构关系 \\[\n\\begin{aligned}\nZ_2^\\times &\\cong Z_1 \\\\\nZ_4^\\times &\\cong Z_2 \\\\\nZ_{p^\\alpha}^\\times &\\cong Z_{p^{\\alpha-1}(p-1)} \\\\\nZ_{2p^\\alpha}^\\times &\\cong Z_2^\\times \\times Z_{p^\\alpha}^\\times \\cong Z_1 \\times Z_{p^{\\alpha-1}(p-1)} \\cong Z_{p^{\\alpha-1}(p-1)}\n\\end{aligned}\n\\] 故 \\(m = 2,4,p^\\alpha,2p^\\alpha\\) 时 \\(Z_m^\\times\\) 为循环群．\n对任意互异的奇质数 \\(p,q \\ge 3\\) 和正整数 \\(\\alpha, \\beta\\)，有 \\[\nZ_{p^\\alpha q^\\beta}^\\times \\cong Z_{p^\\alpha}^\\times \\times Z_{q^\\beta}^\\times \\cong Z_{p-1} \\times Z_{p^{\\alpha-1}} \\times Z_{q-1} \\times Z_{q^{\\alpha-1}}\n\\] 但 \\(p-1\\) 和 \\(q-1\\) 均为偶数，故含有两个互异奇质因子的 \\(m\\) 对应的 \\(Z_m^\\times\\) 都不是循环群．\n对奇质数 \\(p \\geq 3\\)、正整数 \\(\\alpha \\geq 3\\) 和正整数 \\(\\beta\\)，有如下群同构关系 \\[\nZ_{2^\\alpha p^\\beta}^\\times\n\\cong Z_{2^\\alpha}^\\times \\times Z_{p^\\beta}^\\times\n\\cong Z_2 \\times Z_{2^{\\alpha-2}}^\\times \\times Z_{p-1} \\times Z_{p^{\\beta-1}}\n\\] 但 \\(p-1\\) 和 \\(2\\) 均为偶数，故含有一个奇质因子和质因子 \\(2\\) 的 \\(m\\) 对应的 \\(Z_m^\\times\\) 也不是循环群．\n综上，仅当 \\(m = 2,4,p^\\alpha,2p^\\alpha\\) 时 \\(Z_m^\\times\\) 为循环群．"
  },
  {
    "objectID": "posts/20240922-pr/index.html#番外相关数论结果选谈todo",
    "href": "posts/20240922-pr/index.html#番外相关数论结果选谈todo",
    "title": "原根、原根存在定理和模 m 剩余类环的乘法结构",
    "section": "8 番外：相关数论结果选谈【TODO】",
    "text": "8 番外：相关数论结果选谈【TODO】\n\n8.1 Fermat 骗子群，Carmichael 函数与 Carmichael 数\n笔者能力所限，暂时在乘法群里讨论问题．模 \\(m\\) 的 Fermat 骗子（Fermat liar）群 \\(\\mathcal L_m^\\times\\) 定义为所有使得 \\(m\\) 通过 Fermat 素性测试 \\(a^{m} \\equiv a \\pmod m\\) 的模 \\(m\\) 乘法群 \\(Z_m^\\times\\) 中的元素，即 \\[\n\\begin{aligned}\n\\mathcal L_m^\\times :&= \\{ a \\in Z_m^\\times : \\operatorname{ord}(a) \\mid m-1 \\} \\\\\n&= \\{ a \\in Z_m^\\times : \\operatorname{ord}(a) \\mid m-1 \\} \\\\\n&= \\{ a \\in Z_m^\\times : \\operatorname{ord}(a) \\mid \\gcd(\\varphi(m),m-1) \\} \\\\\n&= \\{ a \\in Z_m^\\times : a^{\\gcd(\\varphi(m),m-1)} = 1 \\}\n\\end{aligned}\n\\] 容易验证 \\(\\mathcal L_m^\\times \\leq Z_m^\\times\\) 确为群．\nCarmichael 函数 \\(\\lambda(m)\\) 定义为群 \\(Z_m^\\times\\) 的指数（exponent），即群内各元素阶的最小公倍数： \\[\n\\lambda(m) := \\operatorname{lcm}_{a \\in Z_m^\\times} \\operatorname{ord}(a)\n\\] 显然 \\(\\lambda(m) \\mid \\varphi(m)\\)．下面的习题给出了计算 Carmichael 函数的方法．\n\n\n\n\n\n\n\n习题 1 证明 Carmichael 函数和 \\(\\operatorname{lcm}\\) 交换．\n\n\n\n\n\n\n\n\n\n\n\n习题 2 利用 \\(Z_m^\\times\\) 的结构证明 Carmichael 函数在奇素数幂 \\(p^\\alpha\\) 处的取值为\n\\[\n\\lambda(p^\\alpha) = p^\\alpha - p^{\\alpha-1}\n\\] 在 \\(2^\\alpha\\), \\(\\alpha \\geq 3\\) 处的取值为 \\[\n\\lambda(2^\\alpha) = 2^{\\alpha-2}\n\\] 并且 \\[\n\\lambda(2) = \\lambda(4) = 2\n\\]\n\n\n\n\nCarmichael 数定义为使得 \\(\\lambda(m) = \\varphi(m)\\) 的合数 \\(m\\)．此时所有乘法群内的元素都是 Fermat 骗子，即 \\(\\mathcal L_m^\\times = Z_m^\\times\\)．我们指出（因为证明似乎不甚轻松，例如需要使用下面的 Korselt’s criterion），合数 \\(m\\) 成为 Carmichael 数的充分必要条件是，\\(m\\) 通过了所有整数 \\(a\\) 的 Fermat 素性测试（即 \\(a^m \\equiv a \\pmod{m}\\) 对所有 \\(a\\) 成立，或所有 \\(a\\) 都是模 \\(m\\) 的 Fermat 骗子）．\n\n\n\n\n\n\n\n习题 3 (Korselt’s criterion) 合数 \\(m\\) 是 Carmichael 数当且仅当其无平方因子，且 \\(p-1 \\mid m-1\\) 对所有 \\(m\\) 的素因子 \\(p\\) 成立．\n\n\n\n\n\n\n8.2 二次剩余\n一般来讲这是个复杂繁琐的问题．我们暂时局限在乘法群 \\(\\mathbb Z_m^\\times\\) 中寻找二次剩余．则全体乘法群内二次剩余构成的集合 \\(\\mathcal R_m^\\times\\) 就是群同态 \\(a \\mapsto a^2\\) 的像，故 \\(\\mathcal R_m^\\times \\leq Z_m^\\times\\) 是子群．"
  },
  {
    "objectID": "posts/20211023-potion/index.html",
    "href": "posts/20211023-potion/index.html",
    "title": "原创生物选修一大题 - 药水酿造",
    "section": "",
    "text": "“夜视药水”常用于治疗误食夜雀所致的夜盲症。Steve 领导的研究小组正在探究 Minecraft Java Edition 1.13+ 夜视药水的各项理化“特性”。\n \n（图1: 部分药水酿造系统）（图2：某品牌“下界疣”粉的包装袋）\n\n小酌怡情，大饮伤身。为提高团队工作效率，Steve 称取 1g “下界疣”粉置于 50mL 玻璃瓶中，加入 10mL 蒸馏水，用玻璃棒搅拌均匀，静置 1h 后得到糊状“粗制的药水”。向“粗制的药水”中加入葡萄糖并在 20 摄氏度环境中培养数天，得到速度加成为 20% 的“迅捷药水”。使用酸性重铬酸钾溶液对产品进行检测，发现溶液由橙色变为灰绿色，由此推断“下界疣”粉中主要微生物的代谢类型为 ______________。制备“粗制的药水”的实验过程也被称为 __________。组装仪器时，Steve 在玻璃瓶上额外加装一段长而弯曲的胶管，其目的是 __________________。\n\\(\\beta\\)​​​​​ - 胡萝卜素是“夜视药水”的主要有效成分，推测“夜视药水”治疗夜盲症的原理可能为 ____________________________。“金胡萝卜”富含天然胡萝卜素，成本低廉，不仅是各大工业 MOD 中制取“夜视药水”的主要原料，也是代替“金苹果”治疗僵尸村民的不二之选。在最新研究中，小组成员向虚弱的僵尸村民喂食“金胡萝卜”，一段时间后取其细胞检测，发现癌胚抗原和甲胎蛋白的表达量明显减少，这说明“金胡萝卜”具有 ______________________ 的作用。\n小组成员 Alex 在《探究“红石粉”对“夜视药水”作用时间的影响》的实验中，错将“蜘蛛眼”当作“红石粉”加入已制好的“夜视药水”，随后密封于泡菜坛，在燃烧的熔炉附近发酵 8d，意外的得到了粗制的“隐身药水”。但此方法制备的“隐身药水”常因亚硝酸盐含量过高而使人虚弱甚至中毒。Alex 计划通过改变发酵过程的各项参数来降低成品中亚硝酸盐的含量，请写出你的建议 ________________________________（任写两点即可）。\n更新至 Minecraft Java Edition 1.14.4 后，小组成员 Iron Golem 了解到使用“虞美人”（一种植物）制作的“迷之炖菜”同样具有极佳的夜视效果。“虞美人”精油易挥发、难水解，常使用水蒸气蒸馏法提取。提取过程中，需先后在油水混合物中加入 ____________ 两种盐。蒸馏过程中 __________________（从两方面作答），产品的质量就会下降。"
  },
  {
    "objectID": "posts/20211023-potion/index.html#problem",
    "href": "posts/20211023-potion/index.html#problem",
    "title": "原创生物选修一大题 - 药水酿造",
    "section": "",
    "text": "“夜视药水”常用于治疗误食夜雀所致的夜盲症。Steve 领导的研究小组正在探究 Minecraft Java Edition 1.13+ 夜视药水的各项理化“特性”。\n \n（图1: 部分药水酿造系统）（图2：某品牌“下界疣”粉的包装袋）\n\n小酌怡情，大饮伤身。为提高团队工作效率，Steve 称取 1g “下界疣”粉置于 50mL 玻璃瓶中，加入 10mL 蒸馏水，用玻璃棒搅拌均匀，静置 1h 后得到糊状“粗制的药水”。向“粗制的药水”中加入葡萄糖并在 20 摄氏度环境中培养数天，得到速度加成为 20% 的“迅捷药水”。使用酸性重铬酸钾溶液对产品进行检测，发现溶液由橙色变为灰绿色，由此推断“下界疣”粉中主要微生物的代谢类型为 ______________。制备“粗制的药水”的实验过程也被称为 __________。组装仪器时，Steve 在玻璃瓶上额外加装一段长而弯曲的胶管，其目的是 __________________。\n\\(\\beta\\)​​​​​ - 胡萝卜素是“夜视药水”的主要有效成分，推测“夜视药水”治疗夜盲症的原理可能为 ____________________________。“金胡萝卜”富含天然胡萝卜素，成本低廉，不仅是各大工业 MOD 中制取“夜视药水”的主要原料，也是代替“金苹果”治疗僵尸村民的不二之选。在最新研究中，小组成员向虚弱的僵尸村民喂食“金胡萝卜”，一段时间后取其细胞检测，发现癌胚抗原和甲胎蛋白的表达量明显减少，这说明“金胡萝卜”具有 ______________________ 的作用。\n小组成员 Alex 在《探究“红石粉”对“夜视药水”作用时间的影响》的实验中，错将“蜘蛛眼”当作“红石粉”加入已制好的“夜视药水”，随后密封于泡菜坛，在燃烧的熔炉附近发酵 8d，意外的得到了粗制的“隐身药水”。但此方法制备的“隐身药水”常因亚硝酸盐含量过高而使人虚弱甚至中毒。Alex 计划通过改变发酵过程的各项参数来降低成品中亚硝酸盐的含量，请写出你的建议 ________________________________（任写两点即可）。\n更新至 Minecraft Java Edition 1.14.4 后，小组成员 Iron Golem 了解到使用“虞美人”（一种植物）制作的“迷之炖菜”同样具有极佳的夜视效果。“虞美人”精油易挥发、难水解，常使用水蒸气蒸馏法提取。提取过程中，需先后在油水混合物中加入 ____________ 两种盐。蒸馏过程中 __________________（从两方面作答），产品的质量就会下降。"
  },
  {
    "objectID": "posts/20211023-potion/index.html#answer",
    "href": "posts/20211023-potion/index.html#answer",
    "title": "原创生物选修一大题 - 药水酿造",
    "section": "Answer",
    "text": "Answer\n(1) 异养兼性厌氧型 （酵母细胞的）活化 排气、防止杂菌污染\n(2) （一分子）beta-胡萝卜素在体内被转化（氧化）为（两分子）维生素A 使癌变细胞恢复成正常细胞\n(3) 适当降低温度、发酵前加入食盐（增加食盐用量）、加长腌制时间\n(4) NaCl、（无水）Na2SO4 温度太高、时间太短"
  },
  {
    "objectID": "posts/20201118-coin/index.html",
    "href": "posts/20201118-coin/index.html",
    "title": "CodeChef-LECOINS Little Elephant and Colored Coins 题解",
    "section": "",
    "text": "CodeChef-LECOINS Little Elephant and Colored Coins\n妙题啊。"
  },
  {
    "objectID": "posts/20201118-coin/index.html#可达性",
    "href": "posts/20201118-coin/index.html#可达性",
    "title": "CodeChef-LECOINS Little Elephant and Colored Coins 题解",
    "section": "可达性",
    "text": "可达性\n如果有个 \\(C_i \\le 1\\) 的SubTask的话会更容易想到正解。\n我们先不考虑颜色，只考虑是否能找到一种方案把硬币总面值凑成 \\(S\\) 。\n有一种非常朴素的想法是从 \\(0\\) 到 \\(S\\) 做可达性dp： \\(f_{x+V_i} = f_{x+V_i} | f_x\\) ，不过因为 \\(S \\le 10^{18}\\) ，显然这是天方夜谭。\n可达性dp只有 \\(0/1\\) 两种状态，非常浪费；发现 \\(V_i\\) 的值域很小，这启示我们将 \\(V_i\\) 作为状态减少有效状态数。但究竟如何设置呢？\n这里是最巧妙的地方。不失一般性，设 \\(V_1 = \\min V_i\\) 。我们尝试把 \\(V_1\\) 孤立出来考虑。 假设保证过程中最终选择的总面额永远不会比 \\(S\\) 大（换句话说，允许选择负数个硬币），那么只需知道硬币集合 \\(V - \\{ V_1 \\}\\) 中是否存在一种方案其总面值模 \\(V_i\\) 与 \\(S\\) 同余即可。这样就只需对去掉 \\(V_1\\) 的硬币集合做 \\(1\\) 到 \\(V_1- 1\\) 的可达性dp就好了。\n考虑把前面那个假设干掉。之前提到 \\(f\\) 只有 \\(0/1\\) 两种状态，明显可以再塞点东西进去。于是令 \\(f_x\\) 为硬币集合 \\(V - \\{ V_1 \\}\\) 中所有总面值模 \\(V_1\\) 等于 \\(x\\) 的选择方案中最小的总面值。容易写出状态转移\n\\[\n\\mathrm{relax} \\ f_{(x+V_i)\\% V_1} \\ \\mathrm{by} \\ f_x + V_i\n\\]\n（ \\(\\%\\) 代表取模， \\(\\mathrm{relax} \\ A \\ \\mathrm{by} \\ B\\) 即 \\(A = \\min(A,B)\\) ）\n这样一来，若 \\(f_{S \\% V_1} \\le S\\) ，那么 \\(S\\) 就是可以被组成的。\n发现这个dp就是个最短路，形成了一个 \\(|V| = V_1, |E| = (n-1) V_1\\) 的图。于是 Dijkstra 一下就可以了。不过这个图还有更好的性质。\n首先，路径中边的顺序可以任意调换而不影响可达性和最短路，所以我们可以分开考虑每一种边的松弛。而一分开看就非常明朗了，根据数论常识，所有 \\(x\\) 到 \\((x + V_i) \\% m\\) 的边会在图上形成 \\(\\gcd(V_i, m)\\) 个大小为 \\(\\frac{V_1}{\\gcd({V_i, m})}\\) 的环，于是现在我们又可以分别考虑每一个环。只需从环上当前距离值最小的点绕环一圈就可以做到松弛了。于是现在预处理的时间复杂度是 \\(O(|E|) = O(nV_1)\\) ，比直接 Dijkstra 少了个 \\(\\log\\) 。询问当然是 \\(O(1)\\) 的。"
  },
  {
    "objectID": "posts/20201118-coin/index.html#考虑颜色",
    "href": "posts/20201118-coin/index.html#考虑颜色",
    "title": "CodeChef-LECOINS Little Elephant and Colored Coins 题解",
    "section": "考虑颜色",
    "text": "考虑颜色\n把颜色放到dp状态里面去就好了。设 \\(f_{x, c}\\) ，\\(c\\) 记录了选取的颜色种类数，其余与前述相同。\n比较懒，不写代码了。实在需要可以看官方题解。"
  },
  {
    "objectID": "posts/20201118-coin/index.html#参考",
    "href": "posts/20201118-coin/index.html#参考",
    "title": "CodeChef-LECOINS Little Elephant and Colored Coins 题解",
    "section": "参考",
    "text": "参考\n官方题解\n这篇题解基本上是官方题解的简化翻译版本"
  },
  {
    "objectID": "posts/20220224-creeper/index.html",
    "href": "posts/20220224-creeper/index.html",
    "title": "原创生物必修一大题 - Creepus Explodus",
    "section": "",
    "text": "【必修一大题】假定你是李华，你的外国交换生朋友 Steve 正在水本科毕业论文，请根据高中生物所学内容，帮他完善以下论文选段。\n闪电苦力怕的 TNT 诱导及其生物发电技术实践\nTNT-Induced Mutation of Charged Creepus Explodus and Its Bioelectricity Generating Technology\nSteve Mahjong, Alex Macrohard. [J]MineNature Volume 817, Issue 1926. 2021. PP 9960-9961\n摘要：苦力怕（Creeper，学名 Creepus Explodus，另译爬行者）是主世界中常见的友好生物。本文回顾了前人对三硝基甲苯诱导苦力怕突变的研究成果，提出了利用闪电苦力怕实现生物发电的构想，并初步完成了闪电苦力怕发电机的建造、试运行和效率分析工作，为后续同类型研究提供借鉴。\n \n（Fig 1：TNT 毒理）（Fig 2：气体含量曲线）\n引入 1：三硝基甲苯（TNT）具有相对较高的细胞毒性，其体外半数致死浓度 \\(\\mathrm{LC_{50}} \\approx 25 \\ \\mathrm{\\mu mol \\cdot L^{-1}}\\)​。氧化应激是被广泛认可的 TNT 中毒机制之一，其具体原理如 Fig1 所示。该理论认为，TNT 进入细胞后经过某些酶的催化，生成多种 ______（图中 \\(\\mathrm{ArNO_2^{\\frac{}{\\cdot}}}\\)​、\\(\\mathrm{O_2^{\\frac{}{\\cdot}}}\\)​）攻击和破坏细胞内各种执行正常功能的生物分子（如攻击 DNA 可能引起 ________），导致细胞衰老或损伤。为抵消 TNT 对生物体稳态的影响，生物体体内的超氧化物歧化酶（SOD）可催化有害物质歧化并最终由 __________（CAT）催化分解为无害物质。CAT 在动物 ____（填器官）中含量丰富。\n引入 2：苦力怕体内的 CAT （简记为 CrpCAT）具有极其特殊的结构。Notch Persson 的实验表明，CrpCAT 的活性高于其它动物体内的 CAT，其具体实验步骤如下：\n\n步骤 1：取 3 支洁净的试管在适宜温度下保温，分别加入 \\(2 \\mathrm{mL}\\)​​ SOD 催化产物溶液。\n步骤 2：分别向 3 支试管中滴加 2 滴一定浓度的 \\(\\mathrm{FeCl_3}\\) 溶液（A 组）、__________（B 组）、__________（C 组）。\n步骤 3：一段时间后，精确测定各组反应速率，测得 \\(v(A) = 9.85 \\times 10^{-10} v(B) = 2.11 \\times 10^{-10} v(C)\\)​，从而证明了实验结论。\n\n该实验的 B 组与 C 组相较，可以说明 CrpCAT 的 ____（选择：A. 高效性；B. 专一性；C. 温和性；D. 以上选项均不能说明）\n引入 3：苦力怕 CrpCAT 的高活性使其可以耐受较高浓度的 TNT。用 TNT 处理苦力怕可诱导其突变为罕见的闪电苦力怕（Charged Creeper）变种。Jeb Bergensten 的研究揭示了闪电苦力怕的发电原理。在闪电苦力怕的发电器官中，电细胞细胞膜上的钠钾泵消耗细胞呼吸产生的 __________ （填物质名称）逆浓度梯度转运钠、钾离子建立起静息电位；而动作电位时，细胞后膜上大量电压门控钠离子通道以 ________ 的方式转运钠离子进入细胞，在前后膜之间形成 \\(\\mathrm{50 \\ mV}\\) 到 \\(\\mathrm{150 \\ mV}\\)​ 的电位差。\n实验：研究小组初步探究了利用闪电苦力怕发电器官进行生物发电的可行性。将完整的发电器官浸泡在营养液中，在其背侧和腹侧插入电极并连接电流表，整个实验器材置于密闭气缸中，测定气缸中 \\(\\mathrm{O_2}\\)​ 和 \\(\\mathrm{CO_2}\\)​ 含量的变化曲线如 Fig2 所示。据图推测闪电苦力怕无氧呼吸的有机产物为 ________，实验时间内有氧呼吸消耗葡萄糖 ______ \\(\\mathrm{mol}\\)​。该发电机输出了 \\(b \\ \\mathrm{kJ}\\)​ 电能，计算其发电效率为 ____________（\\(发电效率 = \\frac{输出电能}{输入的化学能} \\times 100 \\%\\)​，已知 \\(\\mathrm{1 \\ mol}\\)​ 葡萄糖折合能量 \\(a \\ \\mathrm{kJ}\\)​​，只考虑葡萄糖的呼吸分解）。该发电机的发电效率不高，其主要原因为 ________________________________________（从能量转化角度分析，答两点即可）\n参考文献：魏桐,周阳,杨治林,等. 典型炸药的毒性效应及其作用机制研究进展[J]. 含能材料,2019,27(7):558-568.\n其他参考：\n\n电鳗发电的原理是什么？ - 混乱博物馆的回答 - 知乎\n苦力怕 - Minecraft Wiki，最详细的我的世界百科"
  },
  {
    "objectID": "posts/20220224-creeper/index.html#problem",
    "href": "posts/20220224-creeper/index.html#problem",
    "title": "原创生物必修一大题 - Creepus Explodus",
    "section": "",
    "text": "【必修一大题】假定你是李华，你的外国交换生朋友 Steve 正在水本科毕业论文，请根据高中生物所学内容，帮他完善以下论文选段。\n闪电苦力怕的 TNT 诱导及其生物发电技术实践\nTNT-Induced Mutation of Charged Creepus Explodus and Its Bioelectricity Generating Technology\nSteve Mahjong, Alex Macrohard. [J]MineNature Volume 817, Issue 1926. 2021. PP 9960-9961\n摘要：苦力怕（Creeper，学名 Creepus Explodus，另译爬行者）是主世界中常见的友好生物。本文回顾了前人对三硝基甲苯诱导苦力怕突变的研究成果，提出了利用闪电苦力怕实现生物发电的构想，并初步完成了闪电苦力怕发电机的建造、试运行和效率分析工作，为后续同类型研究提供借鉴。\n \n（Fig 1：TNT 毒理）（Fig 2：气体含量曲线）\n引入 1：三硝基甲苯（TNT）具有相对较高的细胞毒性，其体外半数致死浓度 \\(\\mathrm{LC_{50}} \\approx 25 \\ \\mathrm{\\mu mol \\cdot L^{-1}}\\)​。氧化应激是被广泛认可的 TNT 中毒机制之一，其具体原理如 Fig1 所示。该理论认为，TNT 进入细胞后经过某些酶的催化，生成多种 ______（图中 \\(\\mathrm{ArNO_2^{\\frac{}{\\cdot}}}\\)​、\\(\\mathrm{O_2^{\\frac{}{\\cdot}}}\\)​）攻击和破坏细胞内各种执行正常功能的生物分子（如攻击 DNA 可能引起 ________），导致细胞衰老或损伤。为抵消 TNT 对生物体稳态的影响，生物体体内的超氧化物歧化酶（SOD）可催化有害物质歧化并最终由 __________（CAT）催化分解为无害物质。CAT 在动物 ____（填器官）中含量丰富。\n引入 2：苦力怕体内的 CAT （简记为 CrpCAT）具有极其特殊的结构。Notch Persson 的实验表明，CrpCAT 的活性高于其它动物体内的 CAT，其具体实验步骤如下：\n\n步骤 1：取 3 支洁净的试管在适宜温度下保温，分别加入 \\(2 \\mathrm{mL}\\)​​ SOD 催化产物溶液。\n步骤 2：分别向 3 支试管中滴加 2 滴一定浓度的 \\(\\mathrm{FeCl_3}\\) 溶液（A 组）、__________（B 组）、__________（C 组）。\n步骤 3：一段时间后，精确测定各组反应速率，测得 \\(v(A) = 9.85 \\times 10^{-10} v(B) = 2.11 \\times 10^{-10} v(C)\\)​，从而证明了实验结论。\n\n该实验的 B 组与 C 组相较，可以说明 CrpCAT 的 ____（选择：A. 高效性；B. 专一性；C. 温和性；D. 以上选项均不能说明）\n引入 3：苦力怕 CrpCAT 的高活性使其可以耐受较高浓度的 TNT。用 TNT 处理苦力怕可诱导其突变为罕见的闪电苦力怕（Charged Creeper）变种。Jeb Bergensten 的研究揭示了闪电苦力怕的发电原理。在闪电苦力怕的发电器官中，电细胞细胞膜上的钠钾泵消耗细胞呼吸产生的 __________ （填物质名称）逆浓度梯度转运钠、钾离子建立起静息电位；而动作电位时，细胞后膜上大量电压门控钠离子通道以 ________ 的方式转运钠离子进入细胞，在前后膜之间形成 \\(\\mathrm{50 \\ mV}\\) 到 \\(\\mathrm{150 \\ mV}\\)​ 的电位差。\n实验：研究小组初步探究了利用闪电苦力怕发电器官进行生物发电的可行性。将完整的发电器官浸泡在营养液中，在其背侧和腹侧插入电极并连接电流表，整个实验器材置于密闭气缸中，测定气缸中 \\(\\mathrm{O_2}\\)​ 和 \\(\\mathrm{CO_2}\\)​ 含量的变化曲线如 Fig2 所示。据图推测闪电苦力怕无氧呼吸的有机产物为 ________，实验时间内有氧呼吸消耗葡萄糖 ______ \\(\\mathrm{mol}\\)​。该发电机输出了 \\(b \\ \\mathrm{kJ}\\)​ 电能，计算其发电效率为 ____________（\\(发电效率 = \\frac{输出电能}{输入的化学能} \\times 100 \\%\\)​，已知 \\(\\mathrm{1 \\ mol}\\)​ 葡萄糖折合能量 \\(a \\ \\mathrm{kJ}\\)​​，只考虑葡萄糖的呼吸分解）。该发电机的发电效率不高，其主要原因为 ________________________________________（从能量转化角度分析，答两点即可）\n参考文献：魏桐,周阳,杨治林,等. 典型炸药的毒性效应及其作用机制研究进展[J]. 含能材料,2019,27(7):558-568.\n其他参考：\n\n电鳗发电的原理是什么？ - 混乱博物馆的回答 - 知乎\n苦力怕 - Minecraft Wiki，最详细的我的世界百科"
  },
  {
    "objectID": "posts/20220224-creeper/index.html#answer",
    "href": "posts/20220224-creeper/index.html#answer",
    "title": "原创生物必修一大题 - Creepus Explodus",
    "section": "Answer",
    "text": "Answer\n1) 自由基 基因突变 过氧化氢(H2O2) 肝脏\n2) 2滴一定浓度的CAT溶液 2滴等浓度的CrpCAT溶液 D\n3) 三磷酸腺苷 协助扩散\n4) 酒精 0.5 b/a*100% 大量能量以热能的形式散失、大量能量存留在无氧呼吸产生的酒精中、呼吸作用产生的能量还需用于其它各项生命活动"
  },
  {
    "objectID": "posts/20220224-creeper/index.html#solution",
    "href": "posts/20220224-creeper/index.html#solution",
    "title": "原创生物必修一大题 - Creepus Explodus",
    "section": "Solution",
    "text": "Solution\n2 问选择题：不能说明高效性。一方面，B 组与 C 组反应速率差异仅数倍，比起酶与无机催化剂的 \\(10^7\\)​ - \\(10^{13}\\)​ 倍差异太小；另一方面，“高效性”一般只用于描述酶与无机催化剂的催化能力差异。\n4 问，消耗 \\(\\mathrm{O_2 \\ 3 \\ mol}\\)，产生 \\(\\mathrm{CO_2 \\ 4 \\ mol}\\)，说明有氧呼吸与无氧呼吸均存在，且无氧呼吸生成酒精。根据有氧呼吸、酒精无氧呼吸方程式，有氧呼吸消耗葡萄糖 \\(\\mathrm{3 \\ mol \\times \\frac{1}{6} = 0.5 \\ mol}\\)，无氧呼吸消耗葡萄糖 \\(\\mathrm{\\left( 4 \\ mol - \\left( 0.5 \\ mol \\times 6 \\right) \\right) \\times \\frac{1}{2} = 0.5 \\ mol}\\)，共消耗葡萄糖 \\(\\mathrm{1 \\ mol}\\)，据此计算即可。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "sun123zxy's blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n原根、原根存在定理和模 m 剩余类环的乘法结构\n\n\n\n\n\n\n数学\n\n\n代数\n\n\n数论\n\n\n\n应用代数工具，对模 \\(m\\) 剩余类环 \\(\\mathbb Z / m \\mathbb Z\\) 的乘法结构做出流畅的刻画，作为推论导出原根存在定理．面向有朴素抽象代数基础的 OI/XCPC 算法竞赛选手和学习过本科抽象代数课程的同学．\n\n\n\n\n\n2024/09/22\n\n\nsun123zxy\n\n\n2024/10/26\n\n\n\n\n\n\n\n\n\n\n\n\n代数同构视角下的离散 Fourier 变换\n\n\n多项式环、求值插值与相似对角化\n\n\n\n数学\n\n\n代数\n\n\n讲稿\n\n\nslide\n\n\n\n\n\n\n\n\n\n2024/05/13\n\n\nsun123zxy\n\n\nInvalid Date\n\n\n\n\n\n\n\n\n\n\n\n\n矩阵代数的 Burnside 定理\n\n\n\n\n\n\n数学\n\n\n代数\n\n\n\n我们详细重述并证明 Simultaneous Triangularization (H. Radjavi and P. Rosenthal) 中的 Burnside 定理及其相关推论． \n\n\n\n\n\n2024/01/21\n\n\nsun123zxy\n\n\n2024/03/19\n\n\n\n\n\n\n\n\n\n\n\n\n一元多项式的 Delta 判别式\n\n\n\n\n\n\n数学\n\n\n代数\n\n\n组合\n\n\n讲稿\n\n\nslide\n\n\n\n\n\n\n\n\n\n2023/10/18\n\n\nsun123zxy\n\n\n2024/10/26\n\n\n\n\n\n\n\n\n\n\n\n\nA Convolution-Oriented FFT Tutorial\n\n\nfor OI/XCPC participants and algebra enthusiasts\n\n\n\n算法\n\n\n数学\n\n\n讲稿\n\n\nslide\n\n\n\n\n\n\n\n\n\n2023/08/01\n\n\nsun123zxy\n\n\n2023/09/28\n\n\n\n\n\n\n\n\n\n\n\n\n算法 & 数学碎碎念\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n\n现场赛公式模板库，亦可作为小而精的总结性学习材料参考．无需单独成文或暂不完善的内容会放在这里．\n\n\n\n\n\n2023/06/21\n\n\nsun123zxy\n\n\n2024/03/10\n\n\n\n\n\n\n\n\n\n\n\n\nCCPC 2023 湘潭邀请赛游记\n\n\n\n\n\n\n游记\n\n\n算法\n\n\n回忆\n\n\n\n\n\n\n\n\n\n2023/05/30\n\n\nsun123zxy\n\n\n2023/05/31\n\n\n\n\n\n\n\n\n\n\n\n\nHilbert 曲线与集合势理论\n\n\n\n\n\n\n数学\n\n\n拓扑\n\n\n讲稿\n\n\n\n\n\n\n\n\n\n2023/05/18\n\n\nsun123zxy\n\n\n2023/05/19\n\n\n\n\n\n\n\n\n\n\n\n\nWallis 公式、Stirling 公式与正态分布\n\n\n\n\n\n\n数学\n\n\n分析\n\n\n概率\n\n\n讲稿\n\n\n\n以及双阶乘、中心二项式系数、Catalan 数的渐进估计和 Poisson 分布．\n\n\n\n\n\n2023/04/23\n\n\nsun123zxy\n\n\n2023/08/27\n\n\n\n\n\n\n\n\n\n\n\n\n一些数论算法的时间复杂度分析\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n数论\n\n\n分析\n\n\n\nOI/XCPC 常见算法为主，渐进符号、约数函数、整除分块嵌套与杜教筛．\n\n\n\n\n\n2023/04/18\n\n\nsun123zxy\n\n\n2023/05/25\n\n\n\n\n\n\n\n\n\n\n\n\n国家博物馆兼东单良乡骑行一日游\n\n\n\n\n\n\n游记\n\n\n\n或许是第一篇正常的游记（\n\n\n\n\n\n2023/03/06\n\n\nsun123zxy\n\n\nInvalid Date\n\n\n\n\n\n\n\n\n\n\n\n\n聊聊红石音乐\n\n\n\n\n\n\n回忆\n\n\nMinecraft\n\n\n音乐\n\n\nPython\n\n\n\n封存的幻想。\n\n\n\n\n\n2023/02/17\n\n\nsun123zxy\n\n\nInvalid Date\n\n\n\n\n\n\n\n\n\n\n\n\nstr 学数学 题解\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n数论\n\n\n题解\n\n\n\n挺有意思的一道数学题。\n\n\n\n\n\n2023/02/13\n\n\nsun123zxy\n\n\nInvalid Date\n\n\n\n\n\n\n\n\n\n\n\n\n算法竞赛向 C++ Standard Library 使用速查\n\n\n\n\n\n\n算法\n\n\nC++\n\n\n\n\n\n\n\n\n\n2023/01/24\n\n\nsun123zxy\n\n\n2023/07/13\n\n\n\n\n\n\n\n\n\n\n\n\nJekyll 2 Quarto: Academic Writing’s not All About PDF\n\n\n博客搭建随想 Part II\n\n\n\n站点相关\n\n\nweb\n\n\nLaTeX\n\n\n回忆\n\n\n\nPDF，我所欲也；HTML，亦我所欲也。二者不可得兼……\n\n\n\n\n\n2022/12/26\n\n\nsun123zxy\n\n\n2023/04/17\n\n\n\n\n\n\n\n\n\n\n\n\n有限覆盖定理与实数理论\n\n\n\n\n\n\n数学\n\n\n分析\n\n\n题解\n\n\n讲稿\n\n\n\n《数学分析 I》第四次研讨课第三部分讲稿\n\n\n\n\n\n2022/12/13\n\n\nsun123zxy\n\n\n2023/03/22\n\n\n\n\n\n\n\n\n\n\n\n\nSunQuarTeX-cnart 测试文档\n\n\n这是副标题\n\n\n\nweb\n\n\nLaTeX\n\n\n站点相关\n\n\n\n使用 Quarto Markdown 语法，支持输出至 HTML、PDF/LaTeX、MS Word 等多种格式的中文学术写作工具，覆盖交叉引用、插图绘制、定理系统等多种功能．\n\n\n\n\n\n2022/12/07\n\n\nsun123zxy , 佚名\n\n\n2024/08/23\n\n\n\n\n\n\n\n\n\n\n\n\n关于泰勒展开拉格朗日余项中值点的渐进性\n\n\n\n\n\n\n数学\n\n\n分析\n\n\n题解\n\n\n\n中科大《数学分析教程》第三版问题 4.3.1\n\n\n\n\n\n2022/11/02\n\n\n2022/11/02\n\n\n\n\n\n\n\n\n\n\n\n\n关于 Python 的 import\n\n\n\n\n\n\nPython\n\n\n\n__init__.py, sys.path, python -m and more…\n\n\n\n\n\n2022/07/14\n\n\n2022/07/14\n\n\n\n\n\n\n\n\n\n\n\n\n从台体的体积公式谈起\n\n\n\n\n\n\n数学\n\n\n\n一些探究，一个证明，以及幂函数求导之类的玩意儿。\n\n\n\n\n\n2022/03/27\n\n\n2022/03/27\n\n\n\n\n\n\n\n\n\n\n\n\n原创生物必修一大题 - Creepus Explodus\n\n\n\n\n\n\n高考\n\n\n原创题目\n\n\n\n文化课整活计划第三弹（\n\n\n\n\n\n2022/02/24\n\n\n2022/02/24\n\n\n\n\n\n\n\n\n\n\n\n\nDockerCompose+VLESS+WS+TLS+Web 方式搭建 V2Ray 代理\n\n\n\n\n\n\nweb\n\n\n\n无懈可击的超强配置搭建教程。\n\n\n\n\n\n2022/02/04\n\n\n2022/06/01\n\n\n\n\n\n\n\n\n\n\n\n\n原创生物选修一大题 - 药水酿造\n\n\n\n\n\n\n高考\n\n\n原创题目\n\n\n\n文化课整活计划第二弹\n\n\n\n\n\n2021/10/23\n\n\n2021/10/23\n\n\n\n\n\n\n\n\n\n\n\n\nCnblogs 2 Jekyll：从寄人篱下到手撸全站\n\n\n博客搭建随想 Part I\n\n\n\n站点相关\n\n\nweb\n\n\n回忆\n\n\n\n某不务正业 OIer 摸鱼日记。\n\n\n\n\n\n2021/08/17\n\n\n2022/12/25\n\n\n\n\n\n\n\n\n\n\n\n\nJekyll 测试\n\n\n\n\n\nA post model.\n\n\n\n\n\n2021/08/17\n\n\n2021/08/17\n\n\n\n\n\n\n\n\n\n\n\n\n原创生物遗传大题 - 红白紫薇\n\n\n\n\n\n\n高考\n\n\n原创题目\n\n\n\n文化课整活计划第一弹\n\n\n\n\n\n2021/05/30\n\n\n2021/05/30\n\n\n\n\n\n\n\n\n\n\n\n\n从不定方程的非负整数解个数谈起\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n组合\n\n\n\n组合意义、Vandermonde 卷积、杨辉三角、生成函数、广义二项式定理、Burnside(Polya) 以及第一类斯特林数，你从未见过的全新解法。\n\n\n\n\n\n2021/05/01\n\n\n2023/03/10\n\n\n\n\n\n\n\n\n\n\n\n\n原创OI题目 白银之春 Problem and Solution\n\n\n\n\n\n\n算法\n\n\n原创题目\n\n\n题解\n\n\n\n\n\n\n\n\n\n2020/12/06\n\n\n2020/12/06\n\n\n\n\n\n\n\n\n\n\n\n\n终末之章——CSP-S2020&NOIP2020退役记\n\n\n\n\n\n\n算法\n\n\n游记\n\n\n回忆\n\n\n\n\n\n\n\n\n\n2020/12/06\n\n\n2021/08/14\n\n\n\n\n\n\n\n\n\n\n\n\n原创OI题目 GCD卷积 Problem and Solution\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n组合\n\n\n原创题目\n\n\n题解\n\n\n\n\n\n\n\n\n\n2020/12/06\n\n\n2020/12/06\n\n\n\n\n\n\n\n\n\n\n\n\n卡特兰数 题解\n\n\n\n\n\n\n算法\n\n\n组合\n\n\n题解\n\n\n\n\n\n\n\n\n\n2020/12/04\n\n\n2020/12/04\n\n\n\n\n\n\n\n\n\n\n\n\n树的解构 题解\n\n\n\n\n\n\n算法\n\n\n概率\n\n\n数学\n\n\n题解\n\n\n\n一道并不是特别难但没有切掉的期望题。\n\n\n\n\n\n2020/11/27\n\n\n2020/11/27\n\n\n\n\n\n\n\n\n\n\n\n\nCodeChef-LECOINS Little Elephant and Colored Coins 题解\n\n\n\n\n\n\n算法\n\n\n题解\n\n\n\n\n\n\n\n\n\n2020/11/18\n\n\n2020/11/18\n\n\n\n\n\n\n\n\n\n\n\n\nCodeChef-RNDRATIO Mysterious Ratio 题解\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n数论\n\n\n题解\n\n\n\n积性函数推式子纪念题。\n\n\n\n\n\n2020/11/16\n\n\n2020/11/16\n\n\n\n\n\n\n\n\n\n\n\n\nAbout\n\n\n\n\n\n\n站点相关\n\n\n\n\n\n\n\n\n\n2020/10/24\n\n\n2023/09/05\n\n\n\n\n\n\n\n\n\n\n\n\n树上差分的两种形式（相遇 or 行程的交集 题解）\n\n\n\n\n\n\n算法\n\n\n题解\n\n\n\n\n\n\n\n\n\n2020/10/24\n\n\n2020/10/24\n\n\n\n\n\n\n\n\n\n\n\n\n关于矩阵乘法结合律的证明\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n\n\n\n\n\n\n\n2020/06/06\n\n\n2021/08/13\n\n\n\n\n\n\n\n\n\n\n\n\n等价类计数：Burnside引理 & Polya定理\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n组合\n\n\n代数\n\n\n\n《同分异构体计数从入门到精通》（不是）\n\n\n\n\n\n2020/03/21\n\n\n2023/04/06\n\n\n\n\n\n\n\n\n\n\n\n\n约数个数函数的一个性质证明，以及其推广\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n数论\n\n\n\n关于 (d(AB) = {x|A} {y|B} [(x,y) = 1]) 的一系列推导。\n\n\n\n\n\n2020/02/20\n\n\n2020/03/08\n\n\n\n\n\n\n\n\n\n\n\n\n浅析一类要求相邻不同的环上染色问题\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n组合\n\n\n题解\n\n\n\n一类神烦的dp边界题。\n\n\n\n\n\n2020/02/04\n\n\n2020/02/04\n\n\n\n\n\n\n\n\n\n\n\n\n扩展欧几里得算法（ExGCD）\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n\n\n\n\n\n\n\n2019/12/21\n\n\n2019/12/21\n\n\n\n\n\n\n\n\n\n\n\n\n中国剩余定理（CRT）及其扩展（ExCRT）\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n数论\n\n\n\n\n\n\n\n\n\n2019/12/21\n\n\n2020/12/02\n\n\n\n\n\n\n\n\n\n\n\n\nbsoj5988 [Achen模拟赛]期望 题解\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n数论\n\n\n组合\n\n\n题解\n\n\n\n“套着期望皮的容斥题。”\n\n\n\n\n\n2019/12/18\n\n\n2019/12/18\n\n\n\n\n\n\n\n\n\n\n\n\n涂色游戏 题解\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n组合\n\n\n概率\n\n\n题解\n\n\n\n容斥、二项式反演、minmax容斥和树形dp，人类智慧神题。\n\n\n\n\n\n2019/12/09\n\n\n2019/12/09\n\n\n\n\n\n\n\n\n\n\n\n\nCSP-S2019游记\n\n\n\n\n\n\n算法\n\n\n游记\n\n\n回忆\n\n\n\n你们这个CSP啊，Exciting！\n\n\n\n\n\n2019/11/17\n\n\n2021/08/13\n\n\n\n\n\n\n\n\n\n\n\n\n[JZOJ A组]球 题解\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n组合\n\n\n概率\n\n\n题解\n\n\n\n\n\n\n\n\n\n2019/10/12\n\n\n2019/10/12\n\n\n\n\n\n\n\n\n\n\n\n\n由 [SDOI2012]Longge的问题 探讨欧拉函数和莫比乌斯函数的一些性质和关联\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n数论\n\n\n题解\n\n\n\n\n\n\n\n\n\n2019/09/22\n\n\n2019/11/04\n\n\n\n\n\n\n\n\n\n\n\n\n[NOIP模拟]文本编辑器 题解\n\n\n\n\n\n\n算法\n\n\n题解\n\n\n\n\n\n\n\n\n\n2019/08/28\n\n\n2019/08/28\n\n\n\n\n\n\n\n\n\n\n\n\n洛谷P5364 [SNOI2017]礼物 题解\n\n\n\n\n\n\n算法\n\n\n数学\n\n\n组合\n\n\n题解\n\n\n\n求 (A_1 = 1,A_n = _{i=1}^{n-1} A_i + n^k) 的通项公式。\n\n\n\n\n\n2019/07/01\n\n\n2020/05/16\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/20221110-taylor/index.html",
    "href": "posts/20221110-taylor/index.html",
    "title": "关于泰勒展开拉格朗日余项中值点的渐进性",
    "section": "",
    "text": "之前学拉格朗日中值定理的时候做到一道涉及到特定函数中值渐进性的题，感觉似乎有一般的结论，推广了一下就是这样了。\n感谢刘导拯救 \\(n=1\\) 都不会证的我，感谢王佬指出这是中科大《数学分析教程》第三版问题 4.3.1。\n\n设函数 \\(f(x)\\) 在区间 \\(I\\) 上有 \\(n+1\\) 阶导数，\\(x_0 \\in I\\)，\\(f^{(n+1)}(x_0) \\not = 0\\)；定义函数 \\(T_n(x)\\) 为 \\(f(x)\\) 在 \\(x=x_0\\) 处的 \\(n\\) 阶泰勒多项式：\n\\[\nT(x) = T_n(x_0+h) = \\sum_{k=0}^n \\frac{f^{(k)}(x_0)}{k!} h^k\n\\]\n求证： \\(f(x)\\) 在 \\(x=x_0\\) 处带拉格朗日余项的 \\(n-1\\) 阶泰勒展开\n\\[\nf(x) = f(x_0+h) = T_{n-1}(x_0+h) + \\frac{f^{(n)}(x_0+\\theta h)}{n!} h^n \\qquad \\theta \\in (0,1)\n\\]\n中的 \\(\\theta\\) 满足：\n\\[\n\\lim_{h \\to 0} \\theta = \\frac 1 {n+1}\n\\]\n\n非常漂亮的结论啊。\n理一下思路。关键点在于怎么构造出 \\(\\theta\\)，得想办法把它从 \\(f^{(n)}(x_0+\\theta h)\\) 这样的形式中拿出来。或许我们能想到构造\n\\[\n\\frac{f^{(n)}(x_0+\\theta h) - f^{(n)}(x_0)}{\\theta h} \\to f^{(n+1)}(x_0) \\qquad (h \\to 0)\n\\]\n这样 \\(\\theta\\) 就可以拿出来单独求极限了。\\(f^{(n)}(x_0+\\theta h)\\) 可以从 \\(f(x)\\) 的 \\(n-1\\) 阶泰勒展开的拉格朗日余项中得到，而 \\(f^{(n)}(x_0)\\) 和 \\(f^{(n+1)}(x_0)\\) 也可以从 \\(f(x)\\) 的 \\(n+1\\) 阶带皮亚诺余项的泰勒展开中拿到。于是，下面的证明就十分自然了。\n证明： 考虑 \\(f(x)\\) 的 \\(n-1\\) 阶带拉格朗日余项的泰勒展开\n\\[\nf(x_0 + h) = T_{n-1}(x_0 + h) + \\frac{f^{(n)}(x_0+\\theta h)}{n!} h^n\n\\]\n和 \\(f(x)\\) 的 \\(n+1\\) 阶带皮亚诺余项的泰勒展开\n\\[\nf(x_0 + h) = T_{n+1}(x_0 + h) + o(h^{n+1}) = T_{n-1}(x_0 + h) + \\frac{f^{(n)}(x_0)}{n!} h^n + \\frac{f^{(n+1)}(x_0)}{(n+1)!} h^{n+1} + o(h^{n+1})\n\\]\n两式相减得\n\\[\n\\frac{f^{(n)}(x_0+\\theta h)}{n!} h^n = \\frac{f^{(n)}(x_0)}{n!} h^n + \\frac{f^{(n+1)}(x_0)}{(n+1)!} h^{n+1} + o(h^{n+1})\n\\]\n移项整理得\n\\[\n\\theta \\cdot \\frac{f^{(n)}(x_0+\\theta h)-f^{(n)}(x_0)}{\\theta h} = \\frac{f^{(n+1)}(x_0)}{n+1} + n! \\cdot \\frac {o(h^{n+1})}{h^{n+1}}\n\\]\n两侧同时取 \\(h \\to 0\\) 即得\n\\[\n\\lim_{h \\to 0} \\theta \\cdot f^{(n+1)}(x_0) = \\frac{f^{(n+1)}(x_0)}{n+1}\n\\]\n于是由 \\(f^{(n+1)}(x_0) \\not = 0\\)，我们有\n\\[\n\\lim_{h \\to 0} \\theta = \\frac{1}{n+1}\n\\]\n得证。\n\n备考：\nAzpeitia A G. On the Lagrange remainder of the Taylor formula[J]. The American Mathematical Monthly, 1982, 89(5): 311-312.\nAbel U. On the Lagrange remainder of the Taylor formula[J]. The American mathematical monthly, 2003, 110(7): 627-633.\n这两篇论文似乎对这种渐进性有更深入的讨论。"
  },
  {
    "objectID": "posts/20240121-burnside/index.html",
    "href": "posts/20240121-burnside/index.html",
    "title": "矩阵代数的 Burnside 定理",
    "section": "",
    "text": "我们详细重述并证明 [1, Sec. 1.2] 中的 Burnside 定理及其相关推论．\n下面设 \\(V\\) 是复数域 \\(\\mathbb C\\) 上的有限维线性空间，\\(\\mathcal B(V)\\) 是 \\(V\\) 上的线性变换代数；\\(I\\) 是 \\(\\mathcal B(V)\\) 的单位元．称线性变换族 \\(\\mathcal C \\subset B(V)\\) 可约，当且仅当其存在非平凡不变子空间——即存在非零且不是全空间的子空间 \\(M \\subset V\\)，使得对任意线性变换 \\(A \\in \\mathcal C\\)，都有 \\(AM := \\{ Ax : x \\in M \\} \\subset M\\)．\nBurnside 定理证明较长．为使逻辑顺畅，先做一些准备工作．\n\n\n\n\n\n\n\nLemma 1 设 \\(\\mathcal A\\) 是 \\(\\mathcal B(V)\\) 上的乘法半群，若 \\(\\mathcal A\\) 不可约，则对任意非零的 \\(x \\in V\\)，都有 \\(\\mathcal A x := \\{ Ax : A \\in \\mathcal A \\} = V\\)（此时称 \\(x\\) 是 \\(\\mathcal A\\) 的循环向量）．\n\n\n\n\n\nProof. 首先 \\(\\mathcal A \\neq \\{ 0 \\}\\)，因为任何 \\(V\\) 的子空间都是后者的不变子空间．\n\n注意到 \\(\\operatorname{Ker}\\mathcal A := \\bigcap_{A \\in \\mathcal A} \\operatorname{Ker}A\\) 是 \\(\\mathcal A\\) 的一个不变子空间，而 \\(\\mathcal A\\) 不可约，故 \\(\\operatorname{Ker}\\mathcal A = \\{ 0 \\}\\) 或 \\(V\\)．因为 \\(\\mathcal A \\neq \\{0\\}\\)，后者不可能发生，故 \\(\\operatorname{Ker}\\mathcal A = \\{ 0 \\}\\)．\n注意到 \\(\\mathcal A x := \\{ A x : A \\in \\mathcal A \\}\\) 是 \\(\\mathcal A\\) 的一个不变子空间，而 \\(\\mathcal A\\) 不可约，故 \\(\\mathcal A x = \\{ 0 \\}\\) 或 \\(V\\)．由 \\(x \\neq 0\\) 和 \\(\\operatorname{Ker}\\mathcal A = \\{ 0 \\}\\)，前者不可能发生，故 \\(\\mathcal A x = V\\)．\n\n\n\nRemark. 事实上 \\(\\mathcal B(V)\\) 上半群的可约性等价于其线性生成的代数的可约性，见 [1], Definition 2.1.1．\n\n\n\n\n\n\n\n\nCorollary 1 设 \\(V^*\\) 是 \\(V\\) 的对偶空间．设 \\(\\mathcal A\\) 是 \\(\\mathcal B(V)\\) 上的乘法半群，\\(\\mathcal A^* := \\{A^* : A \\in \\mathcal A \\}\\) 是 \\(\\mathcal A\\) 的对偶线性变换构成的集合（显然它也是个半群）．若 \\(\\mathcal A\\) 不可约，则对任意非零的线性函数 \\(\\varphi \\in V^*\\)，都有 \\(\\mathcal A^* \\varphi := \\{ A^* \\varphi : A^* \\in \\mathcal A^* \\} = \\{  \\varphi A : A \\in \\mathcal A \\} = V^*\\)．\n\n\n\n\n\nProof. 定义 \\(\\mathcal A^* \\varphi\\) 的 annihilator \\((\\mathcal A^* \\varphi)^0 := \\{ x^{**} \\in V^{**} : (\\mathcal A^* \\varphi)(x) = 0 \\}\\)．由 \\(\\dim (A^* \\varphi)^0 = \\dim V^* - \\dim (A^* \\varphi)\\) 见 [2, Sec. 3F]， \\[\n\\begin{aligned}\n\\mathcal A^* \\varphi = V^*\n&\\iff \\dim (\\mathcal A^* \\varphi) = \\dim V^* \\\\\n&\\iff \\dim (\\mathcal A^* \\varphi)^0 = 0 \\\\\n&\\iff (\\mathcal A^* \\varphi)^0 = \\{0\\}\n\\end{aligned}\n\\] 由 annihilator 的定义和 Lemma 1， \\[\n\\begin{aligned}\n(\\mathcal A^* \\varphi)^0 = \\{0\\}\n&\\iff (\\mathcal A^* \\varphi) x \\neq \\{0\\},\\quad \\forall x \\neq 0 \\\\\n&\\iff \\varphi \\mathcal A x  \\neq \\{0\\},\\quad \\forall x \\neq 0 \\\\\n&\\iff \\varphi V \\neq \\{0\\} \\\\\n&\\iff \\varphi \\neq 0\n\\end{aligned}\n\\] 故最终我们得到 \\(\\mathcal A^* \\varphi = V^* \\iff \\varphi \\neq 0\\)．\n\n若下面的猜想成立，则上述推论将具有更简单的推导．\n\n\n\n\n\n\n\nConjecture 1 若 \\(\\mathcal A\\) 不可约，则 \\(\\mathcal A^*\\) 也不可约．\n\n\n\n\n我们暂未找到证明或证伪上述猜想的方法．\n下面来证明 Burnside 定理．\n\n\n\n\n\n\n\nTheorem 1 (Burnside 定理) \\(\\mathcal B(V)\\) 的不可约子代数有且只有 \\(\\mathcal B(V)\\)．\n\n\n\n\n首先说明 \\(\\mathcal B(V)\\) 的不可约性．因为 \\(\\mathcal B(V) M = V\\) 对任意非零不变子空间 \\(M\\) 成立，故 \\(\\mathcal B(V)\\) 不可约．下面设 \\(\\mathcal A\\) 是一任意给定的 \\(\\mathcal B(V)\\) 的一个不可约子代数．显然 \\(\\mathcal A \\neq \\{ 0 \\}\\)，原因在 Lemma 1 中已述．我们的证明分三步进行：\n\n证明 \\(\\mathcal A\\) 中存在一个秩为 \\(1\\) 的线性变换 \\(T_0\\)．\n证明所有 \\(\\mathcal B(V)\\) 中秩为 \\(1\\) 的线性变换都在 \\(\\mathcal A\\) 中．\n证明任何 \\(\\mathcal B(V)\\) 中的线性变换都可被分解为若干个秩不超过 \\(1\\) 的线性变换的和，从而（利用代数对加法的封闭性）\\(\\mathcal A = \\mathcal B(V)\\)．\n\n\nProof (第一部分). 由 \\(\\mathcal A \\neq \\{ 0 \\}\\)，可以取 \\(T_0\\) 是 \\(\\mathcal A\\) 中的一个秩最小的非零线性变换，\\(\\operatorname{rank}T_0 \\geq 1\\)．考虑反证，假设 \\(\\operatorname{rank}T_0 \\geq 2\\)，只要构造出一个非零线性变换 \\(S_* \\in \\mathcal A\\) 使得 \\(\\operatorname{Im}S_* \\subsetneq \\operatorname{Im}T_0\\)，就能推出矛盾．\n由 \\(\\operatorname{rank}T_0 \\geq 2\\)，可设 \\(\\operatorname{Im}T_0\\) 中存在两个线性无关的非零向量 \\(\\{ T_0 x_1,T_0 x_2 \\}\\)（因此 \\(x_1\\) 与 \\(x_2\\) 也线性无关）．由 Lemma 1，存在线性变换 \\(A_0 \\in \\mathcal A\\) 使得 \\(A_0 T_0 x_1 = x_2\\)，于是 \\(\\{ T_0 x_1,T_0 x_2 \\} = \\{ T_0 x_1, T_0 A T_0 x_1 \\}\\) 线性无关．这意味着 \\((\\lambda T_0 - T_0 A_0 T_0)x_1 \\neq 0\\) 对任意 \\(\\lambda \\in \\mathbb C\\) 成立，即线性变换 \\(S_\\lambda := \\lambda T_0 - T_0 A_0 T_0 \\in \\mathcal A\\) 非零．下面尝试从这些 \\(S_\\lambda\\) 中找到我们想要的 \\(S_*\\)．\n\n注意到 \\(S_\\lambda =  T_0(\\lambda I - A_0 T_0)\\)，故 \\(\\operatorname{Im}S_\\lambda \\subset \\operatorname{Im}T_0\\)．\n注意到 \\(S_\\lambda =  (\\lambda I - T_0 A_0) T_0\\)，而 \\(\\operatorname{Im}T_0\\) 是 \\(T_0 A_0\\) 的一个不变子空间．故可以取 \\(T_0 A_0\\) 在 \\(\\operatorname{Im}T_0\\) 上的限制 \\(T_0 A_0 |_{\\operatorname{Im}T_0}\\)．设 \\(T_0 A_0 |_{\\operatorname{Im}T_0}\\) 有一特征值 \\(\\lambda_0\\)（由于 \\(\\operatorname{Im}T_0\\) 是复数域上有限维线性空间），这样 \\(\\lambda_0 I - T_0 A_0 |_{\\operatorname{Im}T_0}\\) 就不是单射，因此也不是满射（由于 \\(\\operatorname{Im}T_0\\) 是有限维线性空间），即 \\(S_{\\lambda_0} = (\\lambda_0 I - T_0 A_0) T_0\\) 不能映满 \\(\\operatorname{Im}T_0\\)．\n\n综上 \\(\\operatorname{Im}S_{\\lambda_0} \\subsetneq \\operatorname{Im}T_0\\) 且 \\(0 \\neq S_{\\lambda_0} \\in \\mathcal A\\)，故 \\(S_{\\lambda_0}\\) 就是我们想要的 \\(S_*\\)．\n\n\nProof (第二部分). 对任意给定的某一秩为 \\(1\\) 的线性变换 \\(T \\in \\mathcal B(V)\\)，任取非零的 \\(y \\in \\operatorname{Im}T\\)，存在线性函数 \\(\\varphi \\in V^*\\) 使得 \\(T x = \\varphi(x) y,\\, \\forall x \\in V\\)．已经知道 \\(\\mathcal A\\) 中存在一个秩为 \\(1\\) 的线性变换 \\(T_0\\)，则任取非零的 \\(y_0 \\in \\operatorname{Im}T_0\\)，存在线性函数 \\(\\varphi_0 \\in V^*\\) 使得 \\(T_0 x = \\varphi_0(x) y_0,\\, \\forall x \\in V\\)．\n\n由 Lemma 1，存在 \\(A \\in \\mathcal A\\) 使得 \\(A y_0 = y\\)．\n由 Corollary 1，存在 \\(B \\in \\mathcal A\\) 使得 \\(\\varphi_0 B = \\varphi\\)．\n\n综上， \\[\nT x = \\varphi(x) y = \\varphi_0(Bx) A y_0 = A(\\varphi_0(Bx) y_0) = A T_0 B x,\\quad \\forall x \\in V\n\\] 故 \\(T = A T_0 B \\in \\mathcal A\\)．\n\n\nProof (第三部分). 设 \\(A \\in \\mathcal B(V)\\) 是任一给定的线性变换，任取 \\(V\\) 中的一组基 \\(b_1,\\dots,b_n\\)，设其对偶基为 \\(\\varphi_1,\\dots,\\varphi_n\\)．定义关于基 \\(b_1,\\dots,b_n\\) 的 \\(n\\) 个投影变换 \\(P_k: x \\mapsto \\varphi_k(x) b_k\\)，由对偶基性质，显然有 \\(I = \\sum_{k=1}^n P_k\\)，于是 \\[\nA = A I = A \\sum_{k=1}^n P_k = \\sum_{k=1}^n A P_k\n\\] 其中每一个 \\(A P_k\\) 都是秩不超过 \\(1\\) 的线性变换．\n\n至此，Theorem 1 得到完整证明．\nBurnside 定理可以为下面的定理提供一个较为简单的证明．\n\n\n\n\n\n\n\nTheorem 2 \\(\\mathcal B(V)\\) 是单代数，即 \\(\\{ 0 \\}\\) 和 \\(\\mathcal B(V)\\) 是代数 \\(\\mathcal B(V)\\) 上唯二的双边理想．\n\n\n\n\n\nProof. 显然 \\(\\{ 0 \\}\\) 和 \\(\\{ \\mathcal B(V) \\}\\) 都是双边理想．下面任取一 \\(\\mathcal B(V)\\) 上的双边理想 \\(\\mathcal I \\neq \\{ 0 \\}\\)，我们证明它不可约．任取 \\(\\mathcal I\\) 的一个非零不变子空间 \\(M\\)，由 \\(M,\\, \\mathcal I\\) 的非零性和 \\(\\mathcal I V\\) 的非零性， \\[\nM \\supset \\mathcal I M \\supset \\mathcal B(V) \\mathcal I \\mathcal B(V) M = \\mathcal B(V) \\mathcal I V = \\mathcal B(V) (\\mathcal I V) = V\n\\] 故只能有 \\(M = V\\)，因此 \\(\\mathcal I\\) 确不可约．现在 \\(\\mathcal I\\) 是 \\(\\mathcal B(V)\\) 的不可约理想，理想一定是子代数，根据 Theorem 1 就有 \\(\\mathcal I = \\mathcal B(V)\\)．\n\n下面的定理为 \\(\\mathcal B(V)\\) 上的全体代数自同构提供了表示方法．\n\n\n\n\n\n\n\nTheorem 3 \\(\\mathcal B(V)\\) 上的全体代数自同构均为内自同构．即，任意 \\(\\mathcal B(V)\\) 上的自同构 \\(\\varphi: \\mathcal B(V) \\to \\mathcal B(V)\\) 都可写为 \\(A \\mapsto S A S^{-1}\\) 的形式，其中 \\(S \\in \\mathcal B(V)\\) 为与 \\(\\varphi\\) 相关的某一可逆线性变换．\n\n\n\n\n将矩阵表示和线性空间的语言相结合，可以为该定理提供思路更清晰的证明．\n\nProof. 取定 \\(V\\) 上的一组基 \\(x_1,\\dots,x_n\\)，定义 \\[\nE_{i,j}(x_1,\\dots,x_n) := (x_1,\\dots,x_n) \\hat E_{i,j} \\pod{i=1,2,\\dots,n;\\; j=1,2,\\dots,n}\n\\] 其中全体 \\(\\hat E_{i,j} \\in \\mathrm M_n(\\mathbb C)\\) 代表 \\(n\\) 阶矩阵空间的一组自然基．于是全体 \\(E_{i,j}\\) 自然也是 \\(\\mathcal B(V)\\) 的一组基．现在只需研究自同构 \\(\\varphi\\) 将 \\(E_{i,j}\\) 映至何处．为显式地将 \\(S\\) 确定出来，不妨先考虑 \\(\\varphi(E_{i,i})\\) 的性质．\n首先指出，\\(\\varphi(E_{i,i})\\) 仍然是秩为 \\(1\\) 的投影变换，因为：\n\n\\(E_{i,i}\\) 是投影变换，根据其幂等性和代数自同构保持乘法，\\(\\varphi(E_{i,i})\\) 也是投影变换．\n\\(E_{i,i} \\mathcal B(V) E_{i,i}\\) 是 \\(\\mathcal B(V)\\) 的 \\(1\\) 维子空间（从矩阵表示角度考虑），因此 \\(\\varphi(E_{i,i} \\mathcal B(V) E_{i,i}) = \\varphi(E_{i,i}) \\mathcal B(V) \\varphi(E_{i,i})\\) 也是 \\(\\mathcal B(V)\\) 的 \\(1\\) 维子空间．考虑到 \\(\\varphi(E_{i,i})\\) 还是投影变换，故其秩只能为 \\(1\\)（同样从矩阵表示角度考虑）．\n\n现在设 \\(\\operatorname{Im}\\varphi(E_{i,i}) = \\operatorname{span}\\{y_i\\}\\)．因为 \\[\n\\begin{aligned}\n\\sum_{i=1}^n \\operatorname{span}\\{y_i\\}\n&= \\sum_{i=1}^n \\varphi(E_{i,i}) V \\\\\n&\\supset \\left( \\sum_{i=1}^n \\varphi(E_{i,i}) \\right) V \\\\\n&= \\varphi \\left(\\sum_{i=1}^n E_{i,i} \\right) V \\\\\n&= \\varphi(I) V = I V = V\n\\end{aligned}\n\\] 故 \\(y_1,\\dots,y_n\\) 仍是 \\(V\\) 的一组基．定义可逆线性变换 \\(S(x_1,\\dots,x_n) := (y_1,\\dots,y_n)\\)．至此，断言 \\(\\varphi\\) 就是 \\(A \\mapsto S A S^{-1}\\)，为此下面证明 \\(\\varphi(E_{i,j}) = S E_{i,j} S^{-1}\\)．\n仍然先看 \\(\\varphi(E_{i,i})\\)．已经知道 \\(\\varphi(E_{i,i})\\) 是秩为 \\(1\\) 的投影变换，故 \\[\n\\begin{aligned}\n&\\phantom{\\implies .} \\varphi(E_{i,i}) y_i = y_i \\\\\n&\\implies \\varphi(E_{i,i}) S x_i = S x_i \\\\\n&\\implies S^{-1} \\varphi(E_{i,i}) S x_i = x_i\n\\end{aligned}\n\\] 容易验证 \\(S^{-1} \\varphi(E_{i,i}) S\\) 幂等且秩为 \\(1\\)，因此只能有 \\(S^{-1} \\varphi(E_{i,i}) S = E_{i,i}\\)，即 \\(\\varphi(E_{i,i}) = S E_{i,i} S^{-1}\\)．\n现在看 \\(\\varphi(E_{i,j})\\)，为此考察 \\(S^{-1} \\varphi(E_{i,j}) S\\) 将 \\(x_1, \\dots, x_n\\) 映至何处．事实上 \\[\n\\begin{aligned}\n&\\phantom{\\implies .} \\varphi(E_{i,j}) \\varphi(E_{j,j}) = \\varphi(E_{i,j} E_{j,j}) = \\varphi(E_{i,j}) \\\\\n&\\implies \\varphi(E_{i,j}) S E_{j,j} S^{-1} = S E_{i,j} S^{-1}\\\\\n&\\implies S^{-1} \\varphi(E_{i,j}) S E_{j,j} = E_{i,j}\\\\\n&\\implies S^{-1} \\varphi(E_{i,j}) S x_j = x_i\n\\end{aligned}\n\\] 且对任何 \\(k \\neq j\\)， \\[\n\\begin{aligned}\n(S^{-1} \\varphi(E_{i,j}) S) x_k\n&= S^{-1} \\varphi(E_{i,j}) y_k \\\\\n&= S^{-1} \\varphi(E_{i,j} E_{j,j}) y_k \\\\\n&= S^{-1} \\varphi(E_{i,j}) (\\varphi(E_{j,j}) y_k) \\\\\n&= 0\n\\end{aligned}\n\\] 故可以断定 \\(S^{-1} \\varphi(E_{i,j}) S = E_{i,j}\\)，即 \\(\\varphi(E_{i,j}) = S^{-1} E_{i,j} S\\)．\n\n\nRemark. 研究 \\(\\mathcal B(V)\\) 上的自同态时，可能在应用线性变换关于其作用域 \\(V\\) 的性质时遇到困难．这时需要将其合理转化为 \\(\\mathcal B(V)\\) 上的代数性质，如考虑投影变换的幂等性，将投影变换秩为 \\(1\\) 转化为 \\(\\mathcal B(V)\\) 上的 \\(1\\) 维子空间等．这些技巧在证明中多次使用．\n\n\n\n\n\nReferences\n\n[1] H. Radjavi and P. Rosenthal, Simultaneous Triangularization. in Universitext. New York, NY: Springer, 2000. doi: 10.1007/978-1-4612-1200-3.\n\n\n[2] S. Axler, Linear Algebra Done Right. in Undergraduate Texts in Mathematics. Cham: Springer International Publishing, 2015. doi: 10.1007/978-3-319-11080-6."
  },
  {
    "objectID": "posts/20201206-spring/index.html",
    "href": "posts/20201206-spring/index.html",
    "title": "原创OI题目 白银之春 Problem and Solution",
    "section": "",
    "text": "比赛用题面、题解、标程和数据生成器都挂在 git@github.com:sun123zxy/spring.git 上。"
  },
  {
    "objectID": "posts/20201206-spring/index.html#problem",
    "href": "posts/20201206-spring/index.html#problem",
    "title": "原创OI题目 白银之春 Problem and Solution",
    "section": "Problem",
    "text": "Problem\n\n白银之春 (spring.cpp/.in/.out) (2s,512MB)\nBackground\n妖梦正在收集春度！\nDescription\n幻想乡由 \\(n\\) 个地点和 \\(m\\) 条单向小路组成，第 \\(i\\) 个地点蕴含着 \\(s_i\\) 的春度。妖梦从位于 \\(1\\) 号节点的白玉楼出发，沿图上路径收集沿路的春度，总春度为收集到的所有春度之和。\n半人半灵的妖梦具有一种名叫“人妖槽”的属性，该属性有两种状态——“人类逢魔”与“妖怪逢魔”，出发时状态为“人类逢魔”。某些小路上可能被放置了“森罗结界”。在经过被放置结界的小路时，妖梦的人妖槽状态将会发生变化——若经过这条小路前人妖槽状态为“人类逢魔”，则经过后将变为“妖怪逢魔”；反之，若经过前状态为“妖怪逢魔”，则经过后将变为“人类逢魔”。当且仅当人妖槽状态为“妖怪逢魔”时，妖梦才可以收集到当前所在地点所蕴含的春度。\n每个点的春度只能被收集一次。妖梦可以在图上任意游走，并可以选择在任意一个地点停止收集。\n妖梦希望收集到的总春度最大，但她并没有学过OI，请你帮忙算出她最多能收集到多少春度。\n因为并非所有人都具有结界内的常识，妖梦也提供了一份题意简述 ：\n\n给定一个带点权普通有向图和一只具有 \\(0/1\\) 状态的妖梦，从 \\(1\\) 号节点出发，初始状态为 \\(0\\) 。边有 \\(0/1\\) 边权，经过边时状态要异或上边权。当前状态为 \\(1\\) 时可取得所在点权，点权只能被取得一次。问在图上随意游走可获得的最大点权和。\n\nInput\n第一行四个整数 \\(n\\) ， \\(m\\) ，表示图由 \\(n\\) 个点， \\(m\\) 条边构成。\n接下来一行有 \\(n\\) 个整数 \\(s_i\\) ，表示\\(i\\)号节点蕴含 \\(s_i\\) 的春度。\n接下来 \\(m\\) 行每行 \\(3\\) 个整数 \\(u_i\\) ， \\(v_i\\) ， \\(w_i\\) ，表示有一条从 \\(u_i\\) 到 \\(v_i\\) 的有向边，若 \\(w_i = 1\\) ，则表示该小路上被放置了森罗结界，若 \\(w_i = 0\\) ，则表示未被放置。\nOutput\n输出一行一个整数，表示妖梦能收集到的最大总春度。\nSample 1\nSample 1 Input\n5 6\n99 82 44 35 3\n1 2 1\n2 3 0\n3 4 1\n4 5 0\n2 4 1\n3 5 1\nSample 1 Output\n126\nSample 1 Explanation\n路径为 \\(1\\) -&gt; \\(2\\) -&gt; \\(3\\) ，可获得 \\(0 \\times 99 + 1 \\times 82 + 1 \\times 44=126\\) 点春度。\nSample 2\nSample 2 Input\n9 10\n9 9 8 2 4 4 3 5 3\n1 2 0\n2 3 1\n3 2 0\n3 4 0\n4 5 1\n5 6 0\n6 4 1\n2 5 0\n7 8 1\n9 8 1\nSample 2 Output\n25\nSample 2 Explanation\n路径为 \\(1\\) -&gt; \\(2\\) -&gt; \\(3\\) -&gt; \\(2\\) -&gt; \\(5\\) -&gt; \\(6\\) ，可以获得 \\(0 \\times 9 + 0 \\times 9 + 1 \\times 8 + 1 \\times 9 + 1 \\times 4 + 1 \\times 4= 25\\) 点春度。\nSample 3\n见 sample 目录下 spring3.in/.ans 。\n该样例是一个无环图。\nSample 4\n见 sample 目录下 spring4.in/.ans 。\nConstraints\n对于30%的数据，保证图中无环。\n对于另外20%的数据，保证图随机生成。\n对于100%的数据， \\(2 \\le N \\le 5 *  10^5\\) ， \\(1 \\le M \\le 10^6\\) ， \\(0 \\le s_i \\le 10^9\\) ， \\(1 \\le u_i,v_i \\le N\\) ， \\(w_i \\in \\{ 0,1 \\}\\) 。\nHints\n由于幻想乡不受常识束缚，不保证不出现重边和自环，不保证图连通。\n输入量较大，请使用较为快速的读入方式。\n保证时限在std用时的2倍左右。std没有卡常，请放心食用。\nSource\nsun123zxy"
  },
  {
    "objectID": "posts/20201206-spring/index.html#fun-facts",
    "href": "posts/20201206-spring/index.html#fun-facts",
    "title": "原创OI题目 白银之春 Problem and Solution",
    "section": "Fun Facts",
    "text": "Fun Facts\n\n森罗结界 - 东方妖妖梦\n人妖槽 - 东方永夜抄\n题目名neta的是妖妖梦一面的卷首语。"
  },
  {
    "objectID": "posts/20201206-spring/index.html#solution",
    "href": "posts/20201206-spring/index.html#solution",
    "title": "原创OI题目 白银之春 Problem and Solution",
    "section": "Solution",
    "text": "Solution\n\n无环图\nDAG上dp就好了。设状态 \\(f[u][0/1]\\) 为到达点 \\(u\\) 时状态为 \\(0/1\\) 可收集到的最大春度，若 \\(f[u][t]\\) 可达，有 \\[\nf[u][t] = t \\times \\mathrm{val}[u] + \\max_{(v,w) \\in \\mathrm{pre}_u} f[v][t \\otimes w]\n\\] 其中 \\(\\mathrm{val}[u]\\) 是点 \\(u\\) 的权值， \\((v,w) \\in \\mathrm{pre}_u\\) 表示 \\(u\\) 在DAG上的前驱边， \\(\\otimes\\) 代表异或。\n答案即 \\(\\max_{u \\in G} \\max(f[u][0],f[u][1])\\) 。\n\n\n普通图\n普通图有环，环上的状态转移方程相互依赖，无法dp。\n根据部分分的提示，考虑缩点。\n不妨先看所有强连通分量都只是简单环的情况。\n\n环套DAG\n为了方便描述，我们定义如下两种描述：\n\n奇环：环上所有边权异或和为 \\(1\\) 的环。\n偶环：环上所有边权异或和为 \\(0\\) 的环。\n\n容易发现奇环上可以通过绕一圈的方式回到原点，使状态发生改变。也就是说，不论从进出位置和初始状态如何，一个奇环总可以输出任意的 \\(0\\) 或 \\(1\\) 。而如果在奇环上绕两圈，就可以取得环上所有点的春度。所以直接缩点处理即可。\n那么偶环如何处理呢？\n首先，若进入偶环的的位置（入点）确定，无论怎样在偶环上绕圈，到达环上某点（出点）时的状态总是唯一确定的。\n进一步的，偶环上的点可根据到达该点时的状态被分为两组。组与组之间在环上交错排列，所有边权为 \\(1\\) 的边都是都是一个间隔。若入点和出点在同一组内，则状态不会发生变化；反之则状态改变。这启发我们将偶环缩成两个点来处理，每一个点代表一个组。\n考虑春度的获取。如果进入时状态为 \\(0\\) ，那么和入点在同一组内的点上的春度都无法取得（因为经过该点时状态始终为 \\(0\\) ），而在不同组的点上的春度能够取得（因为经过该点时状态始终为 \\(1\\) ）；反之，若进入时状态为 \\(1\\) ，那么和入点在同一组的点上的春度可以取得，在不同组的不能取得。\n缩点后做一些讨论就可以了。\n\n\n强连通分量\n在环上我们已经发现——奇环可以特殊处理，而偶环内的点可以被分成两组。强连通分量是否有与其相似的性质呢？\n\n奇强连通分量\n强连通分量无非是许多个环叠起来的连通块。如果一个强连通分量包含一个或多个奇环（称之为“奇强连通分量”），那么该强连通分量同样有奇环的性质——每个点都可以通过在奇环上绕圈获得 \\(0/1\\) 两种状态，块上所有点的春度都能取得。\n实测发现随机图中出现偶强连通分量的概率极小，因此只处理奇强连通分量的算法可以通过随机图数据。\n\n\n偶强连通分量\n剩下的问题已经很明确了——处理所含环全都是偶环的强连通分量（称之为“偶强连通分量”）。\n可以发现这一结论：无论如何在偶强连通分量中游走，只要入点和进入时的状态确定，那么每个点的状态就唯一确定。于是偶强连通分量中的点也可以被分成两组，好比环套DAG中的偶环。\n易用反证法证明该性质：在一偶强连通分量中，假设点 \\(u\\) 到点 \\(v\\) 同时存在偶路径 \\(P\\) 和奇路径 \\(Q\\) 。那么奇路径 \\(Q\\) 必然与某条从 \\(v\\) 到 \\(u\\) 的奇路径 \\(R\\) 共同组成了一个偶环（偶强连通分量中只有偶环且各点强连通）。则偶路径 \\(P\\) 和奇路径 \\(R\\) 构成奇环，与假设矛盾，故性质成立。\n春度的获取也与偶环相同。\n判断一个强连通分量是奇是偶，只需二分图染色，取环上任意一个点作为起点DFS，如果能以不同的状态到达某点，那该分量就是奇的，反之则是偶的。正确性比较显然，证明在此略去。\n\n\n\n\n实现\n实现细节较多，建议缩点后重新建图。\n可以用4个节点分别代理两个分组各自的入边和出边，算出到达该组状态为 \\(0/1\\) 时连通块内两个组的点权对答案的贡献。为了方便，实现时可以以边数x2的代价把节点数压缩到2个。"
  },
  {
    "objectID": "posts/20201206-spring/index.html#code",
    "href": "posts/20201206-spring/index.html#code",
    "title": "原创OI题目 白银之春 Problem and Solution",
    "section": "Code",
    "text": "Code\n/*\n白银之春 (spring) std\nby sun123zxy\n\nPS: If you got a runtime error, \"-Wl,--stack=123456789\"\n*/\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nll Rd(){\n    ll ans=0;bool fh=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9'){if(c=='-') fh=1; c=getchar();}\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    if(fh) ans=-ans;\n    return ans;\n}\n\nconst ll INF=1E18;\n\nconst ll PTN=1E6+5,EDN=2E6+5;\nll N;\nstruct Edge{ll u,v;bool w;ll nxt;};\nstruct Graph{\n    Edge edge[EDN];\n    ll graM,last[PTN];\n    void GraphInit(){graM=0;for(ll i=0;i&lt;PTN;i++) last[i]=0;}\n    void AddBscEdge(ll u,ll v,bool w){\n        edge[++graM]=(Edge){u,v,w,last[u]};\n        last[u]=graM;\n    }\n    void AddUnEdge(ll u,ll v,bool w){\n        AddBscEdge(v,u,w); \n    }\n    ll ptW[PTN][2]; //value Youmu can get when reaching the vertex with state 0/1\n}G1,G2;\nll Id(ll cId,bool col){\n    return 2*cId-col;\n}\n\nll bel[PTN],cN,rps[PTN]; //belong, number of components, representative vertax of the component\nll dfn[PTN],low[PTN],dN;\nll stk[PTN],tp;bool isI[PTN];\nvoid Tarjan(ll u){\n    dfn[u]=low[u]=++dN;\n    stk[++tp]=u;isI[u]=1;\n    for(ll i=G1.last[u];i!=0;i=G1.edge[i].nxt){\n        ll v=G1.edge[i].v;\n        if(isI[v]){\n            low[u]=min(low[u],dfn[v]);\n        }else if(!dfn[v]){\n            Tarjan(v);\n            low[u]=min(low[u],low[v]);\n        }\n    }\n    if(dfn[u]==low[u]){\n        rps[++cN]=u;ll t;\n        do{\n            t=stk[tp--];\n            isI[t]=0;bel[t]=cN;\n        }while(t!=u);\n    }\n}\nbool cTyp[PTN]; //component type (0: even; 1: odd)\nll col[PTN];\nvoid ColDFS(ll u,bool color,ll curC){\n    col[u]=color;\n    G2.ptW[Id(curC,color)][1]+=G1.ptW[u][1]; //calculate values for each group (even component)\n    for(ll i=G1.last[u];i!=0;i=G1.edge[i].nxt){\n        ll v=G1.edge[i].v;bool w=G1.edge[i].w;\n        if(bel[v]!=curC) continue;\n        if(col[v]==-1) ColDFS(v,color^w,curC);\n        else if((color^w)!=col[v]) cTyp[curC]=1; //odd component\n    }\n}\nvoid BuildG2(){\n    for(ll i=1;i&lt;=G1.graM;i++){\n        ll u=G1.edge[i].u,v=G1.edge[i].v;bool w=G1.edge[i].w;\n        ll cU=bel[u],cV=bel[v];\n        if(!cU||!cV) continue; //edges Youmu can never reach\n        if(cU==cV) continue;   //edges inside the component\n        ll myV=Id(cV,col[v]*(cTyp[cV]^1));\n        if(cTyp[cU]==1){\n            G2.AddUnEdge(Id(cU,0),myV,w);\n            G2.AddUnEdge(Id(cU,0),myV,w^1);\n        }else{\n            G2.AddUnEdge(Id(cU,col[u]),myV,w);     //from this group\n            G2.AddUnEdge(Id(cU,col[u]^1),myV,w^1); //from the other group\n        }\n    }\n}\nll f[PTN][2];\nll F(ll u,bool typ){\n    if(f[u][typ]!=-1) return f[u][typ];\n    f[u][typ]=-INF; \n    for(ll i=G2.last[u];i!=0;i=G2.edge[i].nxt){\n        ll v=G2.edge[i].v;bool w=G2.edge[i].w;\n        f[u][typ]=max(f[u][typ],G2.ptW[u][typ]+F(v,typ^w));\n    }\n    return f[u][typ];\n}\nll ST=1;\nvoid Solve(){\n    cN=0;dN=0;tp=0;for(ll i=1;i&lt;=N;i++) dfn[i]=low[i]=0,bel[i]=0,isI[i]=0;\n    Tarjan(ST); //Only need to get components Youmu can reach\n    G2.GraphInit();\n    for(ll i=1;i&lt;=N;i++) col[i]=-1;\n    for(ll i=1;i&lt;=cN;i++) cTyp[i]=0,ColDFS(rps[i],0,i);\n    for(ll i=1;i&lt;=cN;i++){\n        if(cTyp[i]==1){ //odd component\n            G2.ptW[Id(i,0)][0]=G2.ptW[Id(i,0)][1]+=G2.ptW[Id(i,1)][1]; //an odd component enjoys all the values\n            G2.ptW[Id(i,1)][0]=G2.ptW[Id(i,1)][1]=0; //abandon Id(i,1)\n        }else{ //even component\n            G2.ptW[Id(i,0)][0]=G2.ptW[Id(i,1)][1];\n            G2.ptW[Id(i,1)][0]=G2.ptW[Id(i,0)][1];\n        }\n    }\n    BuildG2();\n    \n    for(ll i=1;i&lt;=2*N;i++) f[i][0]=f[i][1]=-1;\n    ll myST=Id(bel[ST],col[ST]*(cTyp[bel[ST]]^1));\n    f[myST][0]=G2.ptW[myST][0];\n    ll ans=-INF;\n    for(ll i=1;i&lt;=2*N;i++)\n        ans=max(ans,max(F(i,0),F(i,1)));\n    printf(\"%lld\",ans);\n}\nint main(){\n    freopen(\"spring.in\",\"r\",stdin);\n    freopen(\"spring_std.out\",\"w\",stdout);\n    G1.GraphInit();\n    N=Rd();ll m=Rd();\n    for(ll u=1;u&lt;=N;u++) G1.ptW[u][1]=Rd();\n    while(m--){\n        ll u=Rd(),v=Rd();bool w=Rd();\n        G1.AddBscEdge(u,v,w); \n    }\n    Solve();\n    return 0;\n}"
  },
  {
    "objectID": "posts/20201206-spring/index.html#omake",
    "href": "posts/20201206-spring/index.html#omake",
    "title": "原创OI题目 白银之春 Problem and Solution",
    "section": "Omake",
    "text": "Omake\n第一次出题，有纰漏请多多包涵。\n快要交题时才发现一年前写的std出锅了，匆匆忙忙的重写了一个，不知道有没有新造出什么bug。数据也造得比较匆忙，如果爆炸了请随便辱骂出题人或者去他博客上告诉他（\n可以说这道题把二分图拓展到了强连通有向图上，不知道有没有什么更有趣的性质可以发掘。\n后来做到几道性质相似的题目，这里列出来供参考： 垃圾撞题出题人\n\nCF1444C - Codeforces Round #680 - Team-Building (official solution)\nLOJ508 - LibreOJ NOI Round #1 - 失控的未来交通工具 (official solution)\n\n思考背景怎样与题目契合也是个挺有趣的过程。\n感谢听我乱扯idea的 TbYangZ 和 Waper ，以及尝试叉掉std的两位勇士 p9t6g 和 changruinian2020 。 虽然都失败了\n就这些吧。\n\n——sun123zxy\n\n\nOct. 2019 初稿完成\n\n\nNov. 2020 最后更新\n\nNext Phantasm…"
  },
  {
    "objectID": "posts/20191221-exgcd/index.html",
    "href": "posts/20191221-exgcd/index.html",
    "title": "扩展欧几里得算法（ExGCD）",
    "section": "",
    "text": "ExGCD用于求解不定方程\n\\[\nax + by = c\n\\]\n的一组特解。常用于求解同余方程，比如求模非质数意义下的逆元。"
  },
  {
    "objectID": "posts/20191221-exgcd/index.html#瞎扯",
    "href": "posts/20191221-exgcd/index.html#瞎扯",
    "title": "扩展欧几里得算法（ExGCD）",
    "section": "",
    "text": "ExGCD用于求解不定方程\n\\[\nax + by = c\n\\]\n的一组特解。常用于求解同余方程，比如求模非质数意义下的逆元。"
  },
  {
    "objectID": "posts/20191221-exgcd/index.html#推导",
    "href": "posts/20191221-exgcd/index.html#推导",
    "title": "扩展欧几里得算法（ExGCD）",
    "section": "推导",
    "text": "推导\n\n主体\n首先，不定方程有解的充分必要条件由裴蜀定理给出\n\\[\n\\gcd(a,b) | c\n\\]\n于是，我们只需关注\n\\[\nax + by = \\gcd(a,b)\n\\]\n的解。（原方程的解只需分别对\\(x\\)，\\(y\\)乘上\\(\\frac{c}{gcd(a,b)}\\)即可求出）\n（下文中%代指取模操作）\n考虑递归的求解。假设我们已经知道了不定方程\n\\[\nb x + (a \\% b) y = \\gcd(b, a\\% b)\n\\]\n的解\\(x_1\\)，\\(y_1\\)，即\n\\[\nb x_1 + (a \\% b) y_1 = \\gcd(b, a\\% b)\n\\]\n现在尝试利用此式构造出原方程的解\\(x\\)，\\(y\\)。\n由 \\(\\gcd(a,b) = \\gcd(b,a\\%b)\\) 以及 \\(a \\% b = a- \\lfloor \\frac{a}{b} \\rfloor b\\)\n原式化为\n\\[\nb x_1 + (a- \\lfloor \\frac{a}{b} \\rfloor b) y_1 = \\gcd(a,b)\n\\]\n拆开括号\n\\[\nb x_1 + a y_1 - \\lfloor \\frac a b \\rfloor b y_1 = \\gcd(a,b)\n\\]\n我们的目标是构造出系数为\\(a\\)，\\(b\\)的原方程，故整理得\n\\[\na y_1 + b(x_1 - \\lfloor \\frac a b \\rfloor y_1) = \\gcd(a,b)\n\\]\n成功构造。故\n\\[\n\\begin{aligned}\nx &= y_1 \\\\\ny &= x_1 - \\lfloor \\frac a b \\rfloor y_1\n\\end{aligned}\n\\]\n该递归的边界条件同欧几里得算法，当\\(b=0\\)时，方程为\n\\[\na x = \\gcd(a,0) = a\n\\]\n\\(x=1\\)，\\(y = 0\\)即该方程的一组特解。\n\n\n构造最小\\(x\\)的特解\nExgcd常用于逆元求解。这时需要找到一组解，使得\\(x\\)最小（正整数范围内）。可以这样构造。\n我们知道，不定方程的通解形式为\n\\[\n\\left\\{\n\\begin{aligned}\nx &= x_0 + kt\\\\\ny &= y_0 - ku\n\\end{aligned}\n\\right.\n\\]\n其中，\\(t=\\frac b {\\gcd(a,b)}, u=\\frac a {\\gcd(a,b)}\\)\nupd：友情提示一下大家通常了解到的通解形式里面的\\(t=b, u=a\\)，但是实际上该通解形式仅在\\(\\gcd(a,b)=1\\)时正确（不过如果你没有意识到这一点也没啥问题，因为仍然能求出MOD内的逆元，，，）\n所以，以\\(x\\)为例，最小的正整数\\(x= (x_0 \\% t +t) \\% t\\)，然后将其带入不定方程解出\\(y=\\frac {c-a*x} {b}\\)即可。"
  },
  {
    "objectID": "posts/20191221-exgcd/index.html#code",
    "href": "posts/20191221-exgcd/index.html#code",
    "title": "扩展欧几里得算法（ExGCD）",
    "section": "Code",
    "text": "Code\nnamespace ExGcd{\n    ll x,y;\n    ll ExGcd(ll a,ll b){\n        ll ans;\n        if(b==0){\n            x=1;y=0;ans=a;\n        }else{\n            ans=ExGcd(b,a%b);\n            ll x1=x,y1=y;\n            x=y1;y=x1-a/b*y1;\n        }\n        return ans;\n    }\n    bool SolveEqu(ll a,ll b,ll c){\n        ll d=ExGcd(a,b);\n        if(c%d!=0) return 0;\n        x*=c/d;y*=c/d;\n        //Minimize x\n        ll t=b/d;\n        x=(x%t+t)%t;\n        y=(c-a*x)/b;\n        return 1;\n    }\n}\n//以下为求逆元\nll Inv(ll a,ll m){\n    ExGcd::SolveEqu(a,m,1);\n    return ExGcd::x;\n}\n板题：洛谷P1082 同余方程，随便改改上面的程序即可。"
  },
  {
    "objectID": "posts/20200204-circle/index.html",
    "href": "posts/20200204-circle/index.html",
    "title": "浅析一类要求相邻不同的环上染色问题",
    "section": "",
    "text": "我们先来解决最经典的圆环染色问题。\n\n一个环上有\\(n\\)个点，每个点染为\\(m\\)种颜色之一，要求相邻两点颜色不同。求可行的方案数。\n\n这里有一道题的部分分是这个问题：uoj#241. 【UR #16】破坏发射台\n\n\n\n《彩色圆环(circle)》命题报告,吴佳俊\n\n\n那么，设\\(f[i][0/1]\\)表示当前正在决定第\\(i\\)位的颜色，且要求该颜色是否（\\(0/1\\)）与第\\(1\\)位颜色相同。\n对于\\(f[i][1]\\)没啥好决定的，第\\(i\\)位必须与第\\(1\\)位相同，所以系数是\\(1\\)。\n对于\\(f[i][0]\\)分两种情况，一种前接\\(f[i-1][1]\\)，这时第\\(i-1\\)位颜色与第\\(1\\)位颜色相同，有\\((m-1)\\)种颜色供第\\(i\\)位选择。一种是前接\\(f[i-1][0]\\)，第\\(i-1\\)位与第\\(i\\)位不同了，第\\(i\\)位不能与其中任一相同，只有\\((m-2)\\)种可以选。 \\[\n\\begin{aligned}\nf[i][0] &= (m-2) f[i-1][0] + (m-1) f[i-1][1] \\\\\nf[i][1] &= f[i-1][0]\n\\end{aligned}\n\\]\n初始状态很重要，保险的定义应该从\\(2\\)开始，但是根据意义从\\(1\\)开始也无妨。\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=998244353;\n\nconst ll MXN=1E7+5;\nll f[MXN][2];\nint main(){\n    ll N,M;scanf(\"%lld%lld\",&N,&M);\n    f[1][0]=0,f[1][1]=M;\n    for(ll i=2;i&lt;=N;i++){\n        f[i][0]=((M-1)*f[i-1][1]+(M-2)*f[i-1][0])%MOD;\n        f[i][1]=f[i-1][0]%MOD;\n    }\n    cout&lt;&lt;f[N][0];\n    return 0;\n}\n上面这个dp其实还可以更优，用矩阵快速幂可以优化，也可以用特征根等方式推出通项公式\\((m-1)^n+(m-1)(-1)^n\\)。\n下面介绍几种变种，本质其实是一样的，可以根据题目灵活选择。\n可以考虑钦定第\\(1\\)位的颜色，把枚举第\\(1\\)位颜色放在求答案部分。\n可以考虑假设出一个第\\(0\\)位的颜色，这样环的要求变为第\\(0\\)为与末位相同，即答案变为\\(f[n][1]\\)。好处在于可以将初始状态提前到第\\(0\\)位设置。\n还有另一种dp的方式是钦定当前位的颜色，考虑前一位可以选那些颜色。状态转移方程是： \\[\n\\begin{aligned}\nf[i][0] &= f[i-1][1] + (m-2) * f[i-1][0] \\\\\nf[i][1] &= (m-1) * f[i-1][0]\n\\end{aligned}\n\\]\n既然是钦定，答案就需要另外乘\\(M\\)来枚举颜色。\n总之，都是拆环为链，压缩无用状态，用一个\\(0/1\\)位保留环的限制。\n我们从中获取了一种处理这类环上dp的思路，即增设0/1位来维护首尾信息\n利用该模型，可以解决许多变种问题。"
  },
  {
    "objectID": "posts/20200204-circle/index.html#经典",
    "href": "posts/20200204-circle/index.html#经典",
    "title": "浅析一类要求相邻不同的环上染色问题",
    "section": "",
    "text": "我们先来解决最经典的圆环染色问题。\n\n一个环上有\\(n\\)个点，每个点染为\\(m\\)种颜色之一，要求相邻两点颜色不同。求可行的方案数。\n\n这里有一道题的部分分是这个问题：uoj#241. 【UR #16】破坏发射台\n\n\n\n《彩色圆环(circle)》命题报告,吴佳俊\n\n\n那么，设\\(f[i][0/1]\\)表示当前正在决定第\\(i\\)位的颜色，且要求该颜色是否（\\(0/1\\)）与第\\(1\\)位颜色相同。\n对于\\(f[i][1]\\)没啥好决定的，第\\(i\\)位必须与第\\(1\\)位相同，所以系数是\\(1\\)。\n对于\\(f[i][0]\\)分两种情况，一种前接\\(f[i-1][1]\\)，这时第\\(i-1\\)位颜色与第\\(1\\)位颜色相同，有\\((m-1)\\)种颜色供第\\(i\\)位选择。一种是前接\\(f[i-1][0]\\)，第\\(i-1\\)位与第\\(i\\)位不同了，第\\(i\\)位不能与其中任一相同，只有\\((m-2)\\)种可以选。 \\[\n\\begin{aligned}\nf[i][0] &= (m-2) f[i-1][0] + (m-1) f[i-1][1] \\\\\nf[i][1] &= f[i-1][0]\n\\end{aligned}\n\\]\n初始状态很重要，保险的定义应该从\\(2\\)开始，但是根据意义从\\(1\\)开始也无妨。\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=998244353;\n\nconst ll MXN=1E7+5;\nll f[MXN][2];\nint main(){\n    ll N,M;scanf(\"%lld%lld\",&N,&M);\n    f[1][0]=0,f[1][1]=M;\n    for(ll i=2;i&lt;=N;i++){\n        f[i][0]=((M-1)*f[i-1][1]+(M-2)*f[i-1][0])%MOD;\n        f[i][1]=f[i-1][0]%MOD;\n    }\n    cout&lt;&lt;f[N][0];\n    return 0;\n}\n上面这个dp其实还可以更优，用矩阵快速幂可以优化，也可以用特征根等方式推出通项公式\\((m-1)^n+(m-1)(-1)^n\\)。\n下面介绍几种变种，本质其实是一样的，可以根据题目灵活选择。\n可以考虑钦定第\\(1\\)位的颜色，把枚举第\\(1\\)位颜色放在求答案部分。\n可以考虑假设出一个第\\(0\\)位的颜色，这样环的要求变为第\\(0\\)为与末位相同，即答案变为\\(f[n][1]\\)。好处在于可以将初始状态提前到第\\(0\\)位设置。\n还有另一种dp的方式是钦定当前位的颜色，考虑前一位可以选那些颜色。状态转移方程是： \\[\n\\begin{aligned}\nf[i][0] &= f[i-1][1] + (m-2) * f[i-1][0] \\\\\nf[i][1] &= (m-1) * f[i-1][0]\n\\end{aligned}\n\\]\n既然是钦定，答案就需要另外乘\\(M\\)来枚举颜色。\n总之，都是拆环为链，压缩无用状态，用一个\\(0/1\\)位保留环的限制。\n我们从中获取了一种处理这类环上dp的思路，即增设0/1位来维护首尾信息\n利用该模型，可以解决许多变种问题。"
  },
  {
    "objectID": "posts/20200204-circle/index.html#破坏发射台",
    "href": "posts/20200204-circle/index.html#破坏发射台",
    "title": "浅析一类要求相邻不同的环上染色问题",
    "section": "破坏发射台",
    "text": "破坏发射台\nuoj#241. 【UR #16】破坏发射台\n\n一句话题意：长度为 \\(n\\) 的环，每个点染色，有 \\(m\\) 种颜色，要求相邻相对不能同色，求方案数对 \\(998244353\\) 取模的结果。（定义两个点相对为去掉这两个点后环能被分成相同大小的两段）\n\\(n,m \\le 10^9\\)\n\n官方题解 UOJ Round #16\n对于长度为奇数的环，就是经典问题，矩阵快速幂或者直接通项公式即可。\n对于长度为偶数的环，就有点复杂了。因为要考虑相对点之间的相互影响，不妨将它们捆在一块，装在一个状态里考虑。然后，我们需要处理环的上半部分和下半部分的相互接触问题，类比处理经典问题的思路，\n\n我们设第一格的颜色为 \\(A\\)，设第 \\(n/2+1\\) 格的颜色为 B，然后设个二元三进制状态表示第 i 格和第 \\(n/2+i\\) 格的颜色是否为颜色 A 或颜色 B（\\(1≤i≤n/2\\)）。\n设 \\(F[i][0..8]\\) 表示推到第 \\(i\\) 格的所有二元三进制状态的合法方案数，然后递推一波即可。\n\n——UOJ Round #16 题解\n\n\n这个讨论有点变态，，，代码就咕了（"
  },
  {
    "objectID": "posts/20200204-circle/index.html#彩色圆环",
    "href": "posts/20200204-circle/index.html#彩色圆环",
    "title": "浅析一类要求相邻不同的环上染色问题",
    "section": "彩色圆环",
    "text": "彩色圆环\n清橙A1202 bzoj2201 bsoj4074\n\n试题来源\n2010中国国家集训队命题答辩\n问题描述\n小A喜欢收集宝物。一天他得到了一个圆环，圆环上有N颗彩色宝石，闪闪发光。小A很爱惜这个圆环，天天把它带在身边。\n一天，小A突然发现圆环上宝石的颜色是会变化的。他十分惊讶，仔细观察这个圆环后发现，圆环上宝石的颜色每天变化一次，而且每颗宝石的颜色都等概率地为特定的M种颜色之一。小A发现了这个秘密后，对圆环更是爱不释手，时时刻刻都在研究。\n又经过了一段时间，小A发现因为圆环上宝石的颜色不断变化，圆环有时会显得比其他时候更美丽。为了方便比较，小A这样定义圆环的“美观程度”：\n设圆环上相同颜色的宝石构成的连续段长度分别为a1, a2, …, an；\n定义圆环的“美观程度” \\(R = \\prod_{i=1}^{n} a_i\\)​ 。以图一给出的圆环为例，有a1 = 3, a2 = 2, a3 = 1，故R = 6。\n现在小A想知道，在上述前提下，圆环的“美观程度”的期望值E(R)是多少。因为如果知道了E(R)，他就可以判断每天变化出的新圆环是否比一般情况更美丽。\n说明：“美观程度”的期望值即为对每种可能的圆环状态的“美观程度”与其出现概率的乘积进行求和所得的值。\n输入格式\n输入仅有一行，该行给出依次两个正整数N, M，分别表示宝石的个数和宝石在变化时可能变成的颜色种类数。\n输出格式\n输出应仅有一行，该行给出一个实数E(R)，表示圆环的“美观程度”的期望值。\n样例输入\n3 2\n样例输出\n2.25\n样例输入\n200 1\n样例输出\n200\n数据规模和约定\n20%的数据满足1 ≤ N, M ≤ 8；\n50%的数据满足1 ≤ N, M ≤ 25；\n100%的数据满足1 ≤ N ≤ 200, 1 ≤ M ≤10^9。\n\n先来看链的情况\n设\\(f[i]\\)表示考虑到第\\(i\\)位时的期望美观度，按划分颜色块的思路dp，显然有 \\[\nf[i]=\\sum_{0 \\le j &lt; i} f[j]*(i-j)*P[i-j]*(M-1)\n\\]\n其中\\(P[i]\\)表示连续选\\(i\\)个相同一种颜色的概率 \\[\nP[i] = M^{-i}\\\\\n\\]\n\\((M-1)\\)代表当前颜色块的颜色要与前块不同\n那么现在用圆环染色的思路来试着写环的dp式\n正如解决原始版本的方式，我们拆环为链，并假设已经钦定了第\\(0\\)位的颜色。我们设\\(f[i][0/1]\\)表示考虑前\\(i\\)位，且要求第\\(i\\)位（所属块）颜色是否（\\(0/1\\)）与第\\(0\\)位颜色相同，这时的期望美观度。可得转移方程： \\[\nf[i][0] = \\sum_{0 \\le j &lt; i} f[j][0]*(i-j)*P[i-j]*(m-2) + f[j][1]*(i-j)*P[i-j]*(m-1)\\\\\nf[i][1] = \\sum_{0 \\le j &lt; i} f[j][0]*(i-j)*P[i-j]\n\\]\n考虑如何求答案。由于无法直接获取首尾相接颜色块长度，考虑将它单独拎出来计算。枚举首尾相接颜色块两端加起来的总长度\\(x\\)，则总共有\\(x\\)种分割首尾的方案，每种方案有\\(M\\)个颜色可以选择（因为钦定），每个方案贡献为\\(x\\)，剩下的部分就可以用\\(f\\)来表示了。（想想钦定第\\(0\\)位而不是第\\(1\\)位的目的）\n\\(x=N\\)时要特判，于是答案如下 \\[\nAns = P[N]*N*M + \\sum_{1 \\le x &lt; N} x*x*P[x]*M*f[n-x][0]\n\\]\n\\(O(n^2)\\)的代码\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\nusing namespace std;\ntypedef long double ldb;\ntypedef long long ll;\n\nconst ll MXN=1005;\nll N,M;\nldb f[MXN][2];\nldb P[MXN];\nint main(){\n    cin&gt;&gt;N&gt;&gt;M;\n    P[0]=1;for(ll i=1;i&lt;=N;i++) P[i]=P[i-1]/M;\n    f[0][0]=0;f[0][1]=1;//f[0]时只有第0位，一定相同，故f[0][0]不合法置0，f[0][1]置单位元\n    for(ll i=1;i&lt;=N;i++){\n        f[i][0]=f[i][1]=0;\n        for(ll j=0;j&lt;i;j++){//可以从0转移，给了只有一个块转移的机会\n            f[i][0]+=f[j][0]*(i-j)*P[i-j]*(M-2)\n                    +f[j][1]*(i-j)*P[i-j]*(M-1);\n            f[i][1]+=f[j][0]*(i-j)*P[i-j];\n        }\n    }\n    ldb ans=N*P[N]*M;\n    for(ll x=1;x&lt;N;x++)\n        ans+=x*x*P[x]*M*f[N-x][0];//一个x是贡献，一个x是分割开头和结尾的方式数，f[N-x][0]则充当了中间部分 \n    printf(\"%.5Lf\",ans);\n    return 0;\n}\n我们发现推出的dp方程有一部分是与\\(j\\)无关的。将它们提出来，维护剩下的只与\\(j\\)有关的前缀和，复杂度即可降至\\(O(N)\\)\n前缀和优化后\\(O(n)\\)\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\nusing namespace std;\ntypedef long double ldb;\ntypedef long long ll;\n\nconst ll MXN=1000005;\nll N,M;\nldb f[MXN][2];\nldb powM[MXN];//M^i\nint main(){\n    cin&gt;&gt;N&gt;&gt;M;\n    powM[0]=1;for(ll i=1;i&lt;=N;i++) powM[i]=powM[i-1]*M;\n    \n    f[0][0]=0;f[0][1]=1;\n    ldb s_01=0,s_0j=0;\n    ldb s_11=1,s_1j=0;\n    for(ll i=1;i&lt;=N;i++){\n        f[i][0] = s_01*(M-2)*i/powM[i] + s_0j*(M-2)/powM[i]\n                + s_11*(M-1)*i/powM[i] + s_1j*(M-1)/powM[i];\n        f[i][1] = s_01      *i/powM[i] + s_0j      /powM[i];\n        \n        s_01 += f[i][0]*powM[i];\n        s_0j += f[i][0]*powM[i]*i;\n        s_11 += f[i][1]*powM[i];\n        s_1j += f[i][1]*powM[i]*i;\n    }\n    ldb ans=N/powM[N]*M;\n    for(ll x=1;x&lt;N;x++)\n        ans+=x*x/powM[x]*M*f[N-x][0];\n    printf(\"%.5Lf\",ans);\n    return 0;\n}\n实际上是会炸精度的，懒得管了:p"
  },
  {
    "objectID": "posts/20210817-aboutblog/index.html",
    "href": "posts/20210817-aboutblog/index.html",
    "title": "Cnblogs 2 Jekyll：从寄人篱下到手撸全站",
    "section": "",
    "text": "很早就在考虑自建博客的事情了。\n大概是 18 年吧，根据 OIer 传统，打算开个博客存点模板和学习笔记。博客园广告少，dalao 多，还能自定义 css/js 美化博客，比隔壁 CSDN 不知道高到哪里去了，虽然不是很懂前端，但一看就来劲了，开始折腾。于是一个暑假 OI 没啥进步，倒是写了一车 css/js 修改自带皮肤，整出来一套多主题切换系统。之后又经过了数次大改重构，适配了 markdown 编辑器，功能日趋完善。\n然而改版越来越多，代码越来越乱，寄人篱下也总有这样那样的不方便之处。想来想去，改别人的东西总是有极限的，与其无数次推倒重构，还不如自己去搭个新的。\n这么想着又咕了几个月（笑）\n直到 20 年晚些时候才开始认真思考这个问题。一开始也是打算在 Hexo 或 Jekyll 上直接套个主题改改就好，毕竟是相当省事。只是某天在机房摸鱼学了波 Jekyll 后，突然一想——折腾博客也两三年了，懂的前端也不少了，又打算自己搭博客，要不干脆从零手撸个出来？\n于是又摸了大半年，差不多可以用了。\n以前用 markdown 写的文章都搬过来了，其他的回头再说吧。好像也没啥保留价值\n那么，之后就在这边安家了。博客园那边应该还会同步发布，但后续的更新和修改就不能保证了。\n还有，话说正式启用博客的时间正好是 8 月 17 日，这个时间…\n是妖妖梦、风神录正式版发售时间\n给国家省点子弹吧（"
  },
  {
    "objectID": "posts/20210817-aboutblog/index.html#旅程开始",
    "href": "posts/20210817-aboutblog/index.html#旅程开始",
    "title": "Cnblogs 2 Jekyll：从寄人篱下到手撸全站",
    "section": "",
    "text": "很早就在考虑自建博客的事情了。\n大概是 18 年吧，根据 OIer 传统，打算开个博客存点模板和学习笔记。博客园广告少，dalao 多，还能自定义 css/js 美化博客，比隔壁 CSDN 不知道高到哪里去了，虽然不是很懂前端，但一看就来劲了，开始折腾。于是一个暑假 OI 没啥进步，倒是写了一车 css/js 修改自带皮肤，整出来一套多主题切换系统。之后又经过了数次大改重构，适配了 markdown 编辑器，功能日趋完善。\n然而改版越来越多，代码越来越乱，寄人篱下也总有这样那样的不方便之处。想来想去，改别人的东西总是有极限的，与其无数次推倒重构，还不如自己去搭个新的。\n这么想着又咕了几个月（笑）\n直到 20 年晚些时候才开始认真思考这个问题。一开始也是打算在 Hexo 或 Jekyll 上直接套个主题改改就好，毕竟是相当省事。只是某天在机房摸鱼学了波 Jekyll 后，突然一想——折腾博客也两三年了，懂的前端也不少了，又打算自己搭博客，要不干脆从零手撸个出来？\n于是又摸了大半年，差不多可以用了。\n以前用 markdown 写的文章都搬过来了，其他的回头再说吧。好像也没啥保留价值\n那么，之后就在这边安家了。博客园那边应该还会同步发布，但后续的更新和修改就不能保证了。\n还有，话说正式启用博客的时间正好是 8 月 17 日，这个时间…\n是妖妖梦、风神录正式版发售时间\n给国家省点子弹吧（"
  },
  {
    "objectID": "posts/20210817-aboutblog/index.html#杂谈",
    "href": "posts/20210817-aboutblog/index.html#杂谈",
    "title": "Cnblogs 2 Jekyll：从寄人篱下到手撸全站",
    "section": "杂谈",
    "text": "杂谈\n聊聊搭建过程中的一点心得。\n博客源码\n\n技术 & 功能\n\n基于 Jekyll 和 jekyll-pandoc 插件，配合自制小工具 InlineMathSpaceKiller 的静态 markdown 博客。\n全站 js 和主题切换动画效果使用 JQuery。\n支持锚点跳转的目录系统。\n数学公式使用 KaTeX 渲染。\n代码高亮使用 highlight.js 分析代码结构，配合魔改后的样式表实现。\n评论系统使用 Giscus，基于 Github Discussions 的静态博客评论系统。\n\n\n\n环境配置\n看仓库的 README.md 吧，Jekyll 的官方文档也可以（其实是我有点忘了 :p）\n\n\n数学公式、jekyll-pandoc 和 InlineMathSpaceKiller\n用插件干啥啊好好用原生 Jekyll Github 自动帮你编译它不香吗\n本地我用 Typora 编写 markdown（最近 Typora 转付费了，现在用 MarkText），希望能在上传过程中尽可能少地改动源文件，这包括内嵌的 \\(\\LaTeX\\) 数学公式。但 Jekyll 自带的 markdown 解析器老是不好使，比如公式里的 | 被解析成表格了之类各种怪七怪八的问题…\n于是想到了文档转换界的瑞士军刀——\n\nIf you need to convert files from one markup format into another, pandoc is your swiss-army knife.\n\nGoogle 了一圈找到了 jekyll-pandoc，可以改用 Pandoc 的文档解析来渲染 Markdown。\n\njekyll-pandoc 的具体参数配置\n安装流程照着 README 里给的方法走就好了。这里主要谈一谈参数的配置。\njekyll-pandoc 文档里对 _config.yml 里面的参数设置给出了一个例子（已经过时了）——\n\nAdditional pandoc options can be provided in the Jekyll _config.yml:\npandoc:\n extensions:\n   - normalize\n   - smart\n   - mathjax\n   - csl: _styles/apa.csl\n   - bibliography: bibliography/references.bib\n\n这些参数等价于 Pandoc 的命令行参数，即上述代码等价于文件渲染时执行\npandoc target.md -o target.html --normalize --smart --mathjax --csl=_styles/apa.csl --bibliography=bibliography/references.bib\n所以根据需求照着配就可以了。目前我用的配置是\nplugins:\n   - jekyll-pandoc\nmarkdown: Pandoc\npandoc:\n  extensions:\n    - mathjax\n    - no-highlight\n    - from: markdown-smart # disable smart quotes\n\n开启 --mathjax 可以自动把 $ 和 $$ 换成 \\(、\\) 和 \\[、\\]，可以直接被 KaTeX 提供的 auto-render.min.js 识别。\n--no-highlight 打算用 highlight.js 来做高亮，所以这里就不需要了。\nPandoc 在转换 Markdown 时默认开启智能标点功能（参见 Pandoc 文档 - Extensions - Typography），会把 \"\"、'' 自动替换成 “”、‘’，所以用 -smart 关闭这个插件。\n\n\n\nSpaceKiller\n还有一个小问题——Typora （MarkText 好像有这个问题）允许存在形如 $ \\gcd(a,b) $ 这样 $ 旁边紧跟着空格的行内公式，但 Pandoc 解析不了。后来翻到这个 issue，官方似乎不打算修复这个问题，就写了个预处理工具删空格，新文章上传前 spacekiller 一下就可以了。\n\n\n\n文章存储结构\n没有使用 Jekyll 自带的 posts。\n我不喜欢这种图文分离的组织格式。文本和图片本来就同属一篇文章，强行把图片拆开放到 /assets/images/.../ 里面既不合逻辑，又丧失了可移植性，匪夷所思。\n最后使用了打开 output 选项的 collection 来实现，每篇文章都有一个独立的文件夹，包含 index.md （文本）和所需图片、文件等所有内容。index.md 里面直接使用相对引用插入图片，和无博客状态下写作体验完全一致。\n\n\n页面设计\n白模写好后就开肝 css，一开始完全参考之前魔改的博客园 iMetro 主题整出来个高仿，后来有了一些更好的想法，比如把侧边栏做成 panel 样式之类的，就成现在这个样子了。\n\n\n图片预加载与缓存\n国内访问 github.io 很不稳定，背景图片加载特别慢，这几天在想怎么优化这个问题。\n最终的方案是在切换主题时等背景图片加载完毕后再向页面引入主题 css 文件。这样在图片加载过程中，页面显示的 css 尚处于无主题的默认状态，避免了背景白屏的现象出现。\n于是去学了波预加载技术，最开始用 Ajax 来做，结果写完发现 Firefox 和 Chrome 都好像没看到 Ajax 的缓存一样，又在加载主题 css 时重新请求了一次图片…\n无奈，改用 new Image() 来预加载。这回 Firefox 好使了，但 Chrome 还是很顽固。想了想，这玩意居然与浏览器有关，是不是因为不同浏览器默认缓存过期时间不一样导致的呢？于是去看了响应头，终于发现原来是测试时 jekyll serve 出来的服务器根本没有设置响应的 Expires，然后某些浏览器就默认重新加载了…\n那刚刚 Ajax 怕不是也是这个原因…\n看了一下 github.io 的响应头，有 10min 的 Expires，应该部署上去就没问题了。\n其实就是个 HTTP Cache 的问题吧，看来理解还不够深刻…\nPS：Chrome 或 Firefox DevTool 的节流（throttling）功能可以方便的模拟真实网络的限速和延迟，本地测试时非常方便。\n\n\n背景的视差（Parallax）效果\n这个效果很早就做出来了，但现在才开始深入了解。\n用 js 监听 scroll 事件动态更新背景图片的 background-position，以前只有 Firefox 可以实现平滑的滚动，而 Chrome 则会在滚动时白屏——这个问题在最近的版本才消失——总之，当时偷懒，把 Chrome 的这个效果给关了。所以根本没人发现有这个效果对吧\n监听 scroll 确实不是个好方法。Firefox 的 Console 在该效果启用时会弹出警告，文档里说会与异步平移有冲突：\n\nScroll-linked effects — Firefox Source Docs documentation\nAsynchronous scrolling in Firefox - staktrace.com\n\n——异步平移冲突的情况我没碰到，但不论是 Firefox 和 Chrome 偶尔都会白屏倒是真的。第二篇文章里提到一种纯 CSS 实现 Parallax 的方法，网上也有人说可以用 CSS 3D。\n以后再研究吧…\n\n\n评论系统\n静态博客的评论要托管，之前感觉有点麻烦就没搞。后来想用基于 Github Issue 的现成轮子来做，但是不论是 Gitalk 还是 Gitment 都得把 OAuth 的 Client Secret 写在前端，太不安全；后来发现有个叫 Utterances 的基于 Github Apps 的小众项目好像还行，然后就咕咕咕了半年（\n再后来就发现了 Giscus，同样是基于 Github Apps，但和 Utterances 的不同之处在于其使用 Discussions 而不是 Issues 来存储数据。个人认为 Discussions 的设计更适合拿来做评论，总之就花了一个晚上实装了。\n但是适配动态切换的主题成了大麻烦。后来找到 Issue #336 发现可以向 iframe 里 postMessage 改变参数。但需要注意的是 postMessage 之前需先保证 iframe 加载完毕，试图用onload 事件，但测试发现开新界面时还是有概率失败。然后又 Google 了一波发现正确的做法似乎是 iframe 自己发消息表明可以接受 postMessage，于是就修好了。"
  },
  {
    "objectID": "posts/20210817-aboutblog/index.html#画廊",
    "href": "posts/20210817-aboutblog/index.html#画廊",
    "title": "Cnblogs 2 Jekyll：从寄人篱下到手撸全站",
    "section": "画廊",
    "text": "画廊\n（最早的版本没截图找不到了）\n\n\n\n博客园 - 第二次重构 - 基于 iMetro 皮肤的 mc01 和 youmu 主题 (2019)\n\n\n\n\n\n博客园 - 第三次重构，本次重构后支持多皮肤 - 基于 simplememory 皮肤的 yay 主题和基于 iMetro 皮肤的 mc02 主题 (2020)\n\n\n\n\n\n白模阶段 (2020/12)\n\n\n\n\n\n我高仿我自己.jpg (2021/02)\n\n\n\n\n\n现在的样子 (2021/08, shooted in 2021/12)\n\n\n\n\n\n最终的样子（2022/12/15）"
  },
  {
    "objectID": "posts/20210817-aboutblog/index.html#尾声",
    "href": "posts/20210817-aboutblog/index.html#尾声",
    "title": "Cnblogs 2 Jekyll：从寄人篱下到手撸全站",
    "section": "尾声",
    "text": "尾声\n当年的 sun123zxy 还真是对多主题系统有着莫名的执念。最开始的他只是想给博客换个背景，现在似乎已经走的很远了。\n博客上线后的 sun123zxy 迎来了充实的高三生活，学业紧张的他却从没有忘记劳逸结合，不停的做着小修小补，甚至在高考倒计时两只手就能数过来的时候他还在……\ncommit 7a2791ebdcc91415982add697a5b40c62044dabc\nAuthor: sun123zxy &lt;304244450@qq.com&gt;\nDate:   Wed Jun 1 16:23:16 2022 +0800\n\n    update article\n\ncommit edc1e5a0c76f91f0e2ee8bd952550b10f53b3b3f\nAuthor: sun123zxy &lt;304244450@qq.com&gt;\nDate:   Wed Jun 1 12:09:19 2022 +0800\n\n    optimize punctuation, update article\n总之，到此为止，这位不务正业的 OIer 以自己满意的方式结束了高中生活。等待他和他博客的未来，又是怎样的呢？\n博客搭建随想 Part II - Academic Writing’s not All About PDF"
  },
  {
    "objectID": "posts/20231018-discriminant/index.html",
    "href": "posts/20231018-discriminant/index.html",
    "title": "一元多项式的 Delta 判别式",
    "section": "",
    "text": "设非负整数数列 \\(\\boldsymbol\\lambda := (\\lambda_1, \\lambda_2, \\dots)\\) 只有有限项非零且（不严格）单调递减．定义长度 \\(\\mathcal L(\\boldsymbol\\lambda)\\) 为其非零项元素个数；定义 \\(\\mathcal S(\\boldsymbol\\lambda)\\) 为其非零项元素之和．此时称 \\(\\boldsymbol\\lambda\\) 是整数 \\(\\mathcal S(\\boldsymbol\\lambda)\\) 的一个长度为 \\(\\mathcal L(\\boldsymbol\\lambda)\\) 的分拆．\n由于分拆只有有限项非零，对大于等于 \\(\\mathcal L(\\boldsymbol\\lambda)\\) 的非负整数 \\(k\\)，我们也常省略从第 \\(k+1\\) 项开始的全为 \\(0\\) 的项，将 \\(\\boldsymbol\\lambda\\) 直接记为长度为 \\(k\\) 的非负整数数组 \\((\\lambda_1, \\lambda_2, \\dots, \\lambda_k)\\)．\nFerrers diagram 和 Young diagram 是图示分拆的常见方法．\n通过沿主对角线翻转分拆的 Ferrers diagram 或 Young diagram，可以定义分拆的转置．分拆 \\(\\lambda\\) 的转置记为 \\(\\lambda^\\mathrm{T}\\)．转置后分拆的长度变为原分拆的首项，而首项变为原分拆的长度．\n\n\n\n\n\n\n设 \\(n\\) 是正整数，\\(K\\) 是一个域．记 \\(\\boldsymbol x := (x_1,\\dots,x_n)\\)．设 \\(\\boldsymbol\\lambda := (\\lambda_1, \\lambda_2, \\dots \\lambda_n)\\) 是长度不超过 \\(n\\) 的一个分拆．\n定义 \\(n\\) 元多项式环 \\(K[\\boldsymbol x]\\) 上的关于分拆 \\(\\boldsymbol\\lambda\\) 的单项对称多项式（monomial symmetric polynomial）\\(m_{\\boldsymbol\\lambda}(\\boldsymbol x)\\) 为各项系数为 \\(1\\) 的含有单项式 \\(\\boldsymbol x^{\\boldsymbol\\lambda} := x_1^{\\lambda_1} x_2^{\\lambda_2} \\dots x_n^{\\lambda_n}\\) 的项数最少的对称多项式．\n\n\\(m_{(2,1,0)}(x_1,x_2,x_3) = x_1^2 x_2 + x_1^2 x_3 + x_1 x_2^2 + x_1 x_3^2 + x_2^2 x_3 + x_2 x_3^2\\)\n\\(m_{(2,2,1)}(x_1,x_2,x_3) = x_1^2 x_2^2 x_3 + x_1^2 x_2 x_3^2 + x_1 x_2^2 x_3^2\\)\n\n易见 \\(m_{\\boldsymbol\\lambda}(\\boldsymbol x)\\) 是次数为 \\(\\mathcal S(\\boldsymbol\\lambda)\\) 的齐次（homogeneous）多项式．全体单项对称多项式构成 \\(n\\) 元对称多项式环 \\(\\Lambda_n \\subset K[\\boldsymbol x]\\) 作为 \\(K\\) 上线性空间的一组基底．\n\n\n\n\n\n\n\n\n\n\n习题 1 对一给定的长度不超过 \\(n\\) 的分拆 \\(\\boldsymbol\\lambda := (\\lambda_1, \\lambda_2, \\dots \\lambda_n)\\)，\\(n\\) 元单项对称多项式 \\(m_\\lambda(\\boldsymbol x)\\) 共有多少项？\n\n\n\n\n在计数时根据分拆中重复项的分布情况进行消序．\n\n\n\n\n\n\n\n习题 2 \\(n\\) 元 \\(d\\) 次单项对称多项式共有多少种可能的构型？设 \\(\\Lambda_n^{(d)} \\subset \\Lambda_n\\) 由全体至多 \\(d\\) 次的 \\(n\\) 元对称多项式构成，其作为 \\(K\\) 上线性空间的维数是多少？\n\n\n\n\n该问题等价于求满足 \\(\\mathcal S(\\boldsymbol\\lambda) = d\\)，\\(\\mathcal L(\\boldsymbol\\lambda) \\leq n\\) 的所有可能分拆 \\(\\boldsymbol\\lambda\\) 的数量，也即“将 \\(d\\) 个无标号球放入 \\(n\\) 个可空置的无标号盒”的可行方案数．\n\n\n\n\n\n\n\\(n\\) 元多项式环 \\(K[\\boldsymbol x]\\) 上的 \\(n\\) 个基本对称多项式（elementary symmetric polynomial）定义为 \\[\ne_k(x_1,\\dots,x_n) := \\sum_{1 \\leq i_1 &lt; i_2 \\dots &lt; i_k \\leq n} x_{i_1} x_{i_2} \\dots x_{i_k}, \\quad k = 1,2,\\dots, n\n\\] 使用单项对称多项式的记号，也可记为 \\[\ne_k(\\boldsymbol x) := m_{\\boldsymbol\\lambda_k} (\\boldsymbol x)\n\\] 其中分拆 \\(\\boldsymbol\\lambda_k := (1,\\dots,1,0,\\dots)\\) 的前 \\(k\\) 项为 \\(1\\)，其余项皆为 \\(0\\)．\n方便起见，定义 \\(\\boldsymbol e_0 = 1\\)，定义 \\(k&gt;n\\) 和 \\(k&lt;0\\) 的 \\(e_k = 0\\)．设分拆 \\(\\boldsymbol\\lambda := (\\lambda_1,\\lambda_2,\\dots)\\) 满足 \\(\\lambda_i \\leq n, \\quad \\forall i \\in \\mathbb N_+\\)．我们记 \\(e_{\\boldsymbol\\lambda}(\\boldsymbol x) := e_{\\lambda_1}(\\boldsymbol x) e_{\\lambda_2}(\\boldsymbol x) \\dots e_{\\lambda_{\\mathcal L(\\boldsymbol\\lambda)}}(\\boldsymbol x)\\)．\n\n\n\n基本对称多项式有生成函数 \\[\nE(s) := \\sum_{k \\in \\mathbb Z} e_k s^k = \\prod_{i=1}^m (1 + x_i s)\n\\]\n\n\n\n\n\n\n\n\n\n\n定理 1 (对称多项式基本定理) 设 \\(f(\\boldsymbol x)\\) 是域 \\(K\\) 上的 \\(n\\) 元对称多项式，则存在唯一的 \\(g(\\boldsymbol x) \\in K[\\boldsymbol x]\\)，使得 \\[\nf(\\boldsymbol x) = g(e_1(\\boldsymbol x),\\dots,e_n(\\boldsymbol x))\n\\]\n\n\n\n\n该定理对交换环上的对称多项式仍然成立．这意味着若 \\(f\\) 是整系数对称多项式，则 \\(g\\) 也是整系数多项式．\n在定理的存在性证明中，为消去首项对应的单项对称多项式 \\(m_{\\boldsymbol\\lambda}(\\boldsymbol x)\\)，我们构造的若干个基本对称多项式的乘积恰为 \\(\\boldsymbol e_{\\boldsymbol\\lambda^\\mathrm{T}}\\)．\n考察全体满足 \\(\\lambda_i \\leq n, \\quad \\forall i \\in \\mathbb N_+\\) 的分拆 \\(\\boldsymbol\\lambda\\) 对应的 \\(e_{\\boldsymbol\\lambda}(\\boldsymbol x)\\)，它们构成了 \\(n\\) 元对称多项式环 \\(\\Lambda_n\\) 作为 \\(K\\) 上线性空间的另一组基底．\n\n\n\n\n\n\n\\(n\\) 元多项式环 \\(K[\\boldsymbol x]\\) 上的幂和对称多项式（power sum symmetric polynomial）定义为 \\[\np_k(x_1,\\dots,x_n) := x_1^k + x_2^k + \\dots + x_n^k,\\quad k \\in \\mathbb N_{\\geq 0}\n\\] 使用单项对称多项式的记号，也可记为 \\[\np_k(\\boldsymbol x) := m_{(k,0,0,\\dots)}\n\\] 特别的，\\(p_0(\\boldsymbol x) = n\\)．方便起见，定义 \\(k &lt; 0\\) 的 \\(p_k = 0\\)．\n\n\n\n\n\n\n\n定理 2 设 \\(\\mathbb Q \\subset K \\subset \\mathbb C\\) 是数域，设 \\(f(\\boldsymbol x)\\) 是域 \\(K\\) 上的 \\(n\\) 元对称多项式，则存在唯一的 \\(g(\\boldsymbol x) \\in K[\\boldsymbol x]\\)，使得 \\(f(\\boldsymbol x) = g(p_1(\\boldsymbol x),\\dots,p_n(\\boldsymbol x))\\)．\n\n\n\n\n一般地，结论对特征为 \\(0\\) 的域 \\(K\\) 也成立．\n\n\n\n幂和对称多项式有生成函数 \\[\nP(s) := \\sum_{k \\in \\mathbb Z} p_k s^k = \\sum_{k=0}^{+\\infty} s^k \\sum_{i=1}^m x_i^k = \\sum_{i=1}^m \\sum_{k=0}^{+\\infty} (x_i s)^k = \\sum_{i=1}^m \\frac{1}{1-x_i s}\n\\]\n\n\n\n以下定理递推地给出了幂和对称多项式 \\(p_1,\\dots,p_n\\) 与基本对称多项式 \\(e_1,\\dots,e_n\\) 间的关系．定理 2 的存在性部分可由这一定理给出．\n\n\n\n\n\n\n\n定理 3 (Newton’s Identities) \\[\n\\begin{aligned}\np_k &= \\sum_{i=1}^{k-1} (-1)^{i-1} e_i p_{k-i} + (-1)^{k-1} k e_k & k &= 1,2,\\dots,n \\\\\np_k &= \\sum_{i=1}^n (-1)^{i-1} e_i p_{k-i} & k&&gt;n \\\\\nk e_k &= \\sum_{i=1}^k (-1)^{i-1} p_{i} e_{k-i} & k &= 1,2,\\dots,n \\\\\n0 &= \\sum_{i=1}^n (-1)^{i-1} p_{i} e_{k-i} & k &&gt; n\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n\\[\n\\sum_{\\substack{i+j=k}} (-1)^i e_i p_j = 0,\\quad k \\in \\mathbb N_{\\geq 0}\n\\] 但在求和中“认为” \\(p_0 = k\\)．\n\n\n\n\\[\n\\frac{s E'(s)}{E(s)} =  s \\frac{\\operatorname{d}\\!}{\\operatorname{d}\\!s} \\left( \\ln E(s) \\right) = \\sum_{i=1}^m \\frac{x_i s}{1+x_i s} = m - \\sum_{i=1}^m \\frac{1}{1+x_i s} = m - P(-s)\n\\] 即 \\[\n\\sum_{k=0}^\\infty k e_k s^k  = s E'(s) = E(s) (m - P(-s)) = E(s) \\sum_{k=1}^\\infty (-1)^{k-1} p_k\n\\] 对比各项即得 Newton 公式．\n\n\n\n\n\n\n完全齐次对称多项式（Complete homogeneous symmetric polynomials）、Schur 多项式……\n本节主要参考 [1]–[4]．"
  },
  {
    "objectID": "posts/20231018-discriminant/index.html#整数分拆",
    "href": "posts/20231018-discriminant/index.html#整数分拆",
    "title": "一元多项式的 Delta 判别式",
    "section": "",
    "text": "设非负整数数列 \\(\\boldsymbol\\lambda := (\\lambda_1, \\lambda_2, \\dots)\\) 只有有限项非零且（不严格）单调递减．定义长度 \\(\\mathcal L(\\boldsymbol\\lambda)\\) 为其非零项元素个数；定义 \\(\\mathcal S(\\boldsymbol\\lambda)\\) 为其非零项元素之和．此时称 \\(\\boldsymbol\\lambda\\) 是整数 \\(\\mathcal S(\\boldsymbol\\lambda)\\) 的一个长度为 \\(\\mathcal L(\\boldsymbol\\lambda)\\) 的分拆．\n由于分拆只有有限项非零，对大于等于 \\(\\mathcal L(\\boldsymbol\\lambda)\\) 的非负整数 \\(k\\)，我们也常省略从第 \\(k+1\\) 项开始的全为 \\(0\\) 的项，将 \\(\\boldsymbol\\lambda\\) 直接记为长度为 \\(k\\) 的非负整数数组 \\((\\lambda_1, \\lambda_2, \\dots, \\lambda_k)\\)．\nFerrers diagram 和 Young diagram 是图示分拆的常见方法．\n通过沿主对角线翻转分拆的 Ferrers diagram 或 Young diagram，可以定义分拆的转置．分拆 \\(\\lambda\\) 的转置记为 \\(\\lambda^\\mathrm{T}\\)．转置后分拆的长度变为原分拆的首项，而首项变为原分拆的长度．"
  },
  {
    "objectID": "posts/20231018-discriminant/index.html#单项对称多项式",
    "href": "posts/20231018-discriminant/index.html#单项对称多项式",
    "title": "一元多项式的 Delta 判别式",
    "section": "",
    "text": "设 \\(n\\) 是正整数，\\(K\\) 是一个域．记 \\(\\boldsymbol x := (x_1,\\dots,x_n)\\)．设 \\(\\boldsymbol\\lambda := (\\lambda_1, \\lambda_2, \\dots \\lambda_n)\\) 是长度不超过 \\(n\\) 的一个分拆．\n定义 \\(n\\) 元多项式环 \\(K[\\boldsymbol x]\\) 上的关于分拆 \\(\\boldsymbol\\lambda\\) 的单项对称多项式（monomial symmetric polynomial）\\(m_{\\boldsymbol\\lambda}(\\boldsymbol x)\\) 为各项系数为 \\(1\\) 的含有单项式 \\(\\boldsymbol x^{\\boldsymbol\\lambda} := x_1^{\\lambda_1} x_2^{\\lambda_2} \\dots x_n^{\\lambda_n}\\) 的项数最少的对称多项式．\n\n\\(m_{(2,1,0)}(x_1,x_2,x_3) = x_1^2 x_2 + x_1^2 x_3 + x_1 x_2^2 + x_1 x_3^2 + x_2^2 x_3 + x_2 x_3^2\\)\n\\(m_{(2,2,1)}(x_1,x_2,x_3) = x_1^2 x_2^2 x_3 + x_1^2 x_2 x_3^2 + x_1 x_2^2 x_3^2\\)\n\n易见 \\(m_{\\boldsymbol\\lambda}(\\boldsymbol x)\\) 是次数为 \\(\\mathcal S(\\boldsymbol\\lambda)\\) 的齐次（homogeneous）多项式．全体单项对称多项式构成 \\(n\\) 元对称多项式环 \\(\\Lambda_n \\subset K[\\boldsymbol x]\\) 作为 \\(K\\) 上线性空间的一组基底．\n\n\n\n\n\n\n\n\n\n\n习题 1 对一给定的长度不超过 \\(n\\) 的分拆 \\(\\boldsymbol\\lambda := (\\lambda_1, \\lambda_2, \\dots \\lambda_n)\\)，\\(n\\) 元单项对称多项式 \\(m_\\lambda(\\boldsymbol x)\\) 共有多少项？\n\n\n\n\n在计数时根据分拆中重复项的分布情况进行消序．\n\n\n\n\n\n\n\n习题 2 \\(n\\) 元 \\(d\\) 次单项对称多项式共有多少种可能的构型？设 \\(\\Lambda_n^{(d)} \\subset \\Lambda_n\\) 由全体至多 \\(d\\) 次的 \\(n\\) 元对称多项式构成，其作为 \\(K\\) 上线性空间的维数是多少？\n\n\n\n\n该问题等价于求满足 \\(\\mathcal S(\\boldsymbol\\lambda) = d\\)，\\(\\mathcal L(\\boldsymbol\\lambda) \\leq n\\) 的所有可能分拆 \\(\\boldsymbol\\lambda\\) 的数量，也即“将 \\(d\\) 个无标号球放入 \\(n\\) 个可空置的无标号盒”的可行方案数．"
  },
  {
    "objectID": "posts/20231018-discriminant/index.html#基本对称多项式",
    "href": "posts/20231018-discriminant/index.html#基本对称多项式",
    "title": "一元多项式的 Delta 判别式",
    "section": "",
    "text": "\\(n\\) 元多项式环 \\(K[\\boldsymbol x]\\) 上的 \\(n\\) 个基本对称多项式（elementary symmetric polynomial）定义为 \\[\ne_k(x_1,\\dots,x_n) := \\sum_{1 \\leq i_1 &lt; i_2 \\dots &lt; i_k \\leq n} x_{i_1} x_{i_2} \\dots x_{i_k}, \\quad k = 1,2,\\dots, n\n\\] 使用单项对称多项式的记号，也可记为 \\[\ne_k(\\boldsymbol x) := m_{\\boldsymbol\\lambda_k} (\\boldsymbol x)\n\\] 其中分拆 \\(\\boldsymbol\\lambda_k := (1,\\dots,1,0,\\dots)\\) 的前 \\(k\\) 项为 \\(1\\)，其余项皆为 \\(0\\)．\n方便起见，定义 \\(\\boldsymbol e_0 = 1\\)，定义 \\(k&gt;n\\) 和 \\(k&lt;0\\) 的 \\(e_k = 0\\)．设分拆 \\(\\boldsymbol\\lambda := (\\lambda_1,\\lambda_2,\\dots)\\) 满足 \\(\\lambda_i \\leq n, \\quad \\forall i \\in \\mathbb N_+\\)．我们记 \\(e_{\\boldsymbol\\lambda}(\\boldsymbol x) := e_{\\lambda_1}(\\boldsymbol x) e_{\\lambda_2}(\\boldsymbol x) \\dots e_{\\lambda_{\\mathcal L(\\boldsymbol\\lambda)}}(\\boldsymbol x)\\)．\n\n\n\n基本对称多项式有生成函数 \\[\nE(s) := \\sum_{k \\in \\mathbb Z} e_k s^k = \\prod_{i=1}^m (1 + x_i s)\n\\]\n\n\n\n\n\n\n\n\n\n\n定理 1 (对称多项式基本定理) 设 \\(f(\\boldsymbol x)\\) 是域 \\(K\\) 上的 \\(n\\) 元对称多项式，则存在唯一的 \\(g(\\boldsymbol x) \\in K[\\boldsymbol x]\\)，使得 \\[\nf(\\boldsymbol x) = g(e_1(\\boldsymbol x),\\dots,e_n(\\boldsymbol x))\n\\]\n\n\n\n\n该定理对交换环上的对称多项式仍然成立．这意味着若 \\(f\\) 是整系数对称多项式，则 \\(g\\) 也是整系数多项式．\n在定理的存在性证明中，为消去首项对应的单项对称多项式 \\(m_{\\boldsymbol\\lambda}(\\boldsymbol x)\\)，我们构造的若干个基本对称多项式的乘积恰为 \\(\\boldsymbol e_{\\boldsymbol\\lambda^\\mathrm{T}}\\)．\n考察全体满足 \\(\\lambda_i \\leq n, \\quad \\forall i \\in \\mathbb N_+\\) 的分拆 \\(\\boldsymbol\\lambda\\) 对应的 \\(e_{\\boldsymbol\\lambda}(\\boldsymbol x)\\)，它们构成了 \\(n\\) 元对称多项式环 \\(\\Lambda_n\\) 作为 \\(K\\) 上线性空间的另一组基底．"
  },
  {
    "objectID": "posts/20231018-discriminant/index.html#幂和对称多项式",
    "href": "posts/20231018-discriminant/index.html#幂和对称多项式",
    "title": "一元多项式的 Delta 判别式",
    "section": "",
    "text": "\\(n\\) 元多项式环 \\(K[\\boldsymbol x]\\) 上的幂和对称多项式（power sum symmetric polynomial）定义为 \\[\np_k(x_1,\\dots,x_n) := x_1^k + x_2^k + \\dots + x_n^k,\\quad k \\in \\mathbb N_{\\geq 0}\n\\] 使用单项对称多项式的记号，也可记为 \\[\np_k(\\boldsymbol x) := m_{(k,0,0,\\dots)}\n\\] 特别的，\\(p_0(\\boldsymbol x) = n\\)．方便起见，定义 \\(k &lt; 0\\) 的 \\(p_k = 0\\)．\n\n\n\n\n\n\n\n定理 2 设 \\(\\mathbb Q \\subset K \\subset \\mathbb C\\) 是数域，设 \\(f(\\boldsymbol x)\\) 是域 \\(K\\) 上的 \\(n\\) 元对称多项式，则存在唯一的 \\(g(\\boldsymbol x) \\in K[\\boldsymbol x]\\)，使得 \\(f(\\boldsymbol x) = g(p_1(\\boldsymbol x),\\dots,p_n(\\boldsymbol x))\\)．\n\n\n\n\n一般地，结论对特征为 \\(0\\) 的域 \\(K\\) 也成立．\n\n\n\n幂和对称多项式有生成函数 \\[\nP(s) := \\sum_{k \\in \\mathbb Z} p_k s^k = \\sum_{k=0}^{+\\infty} s^k \\sum_{i=1}^m x_i^k = \\sum_{i=1}^m \\sum_{k=0}^{+\\infty} (x_i s)^k = \\sum_{i=1}^m \\frac{1}{1-x_i s}\n\\]\n\n\n\n以下定理递推地给出了幂和对称多项式 \\(p_1,\\dots,p_n\\) 与基本对称多项式 \\(e_1,\\dots,e_n\\) 间的关系．定理 2 的存在性部分可由这一定理给出．\n\n\n\n\n\n\n\n定理 3 (Newton’s Identities) \\[\n\\begin{aligned}\np_k &= \\sum_{i=1}^{k-1} (-1)^{i-1} e_i p_{k-i} + (-1)^{k-1} k e_k & k &= 1,2,\\dots,n \\\\\np_k &= \\sum_{i=1}^n (-1)^{i-1} e_i p_{k-i} & k&&gt;n \\\\\nk e_k &= \\sum_{i=1}^k (-1)^{i-1} p_{i} e_{k-i} & k &= 1,2,\\dots,n \\\\\n0 &= \\sum_{i=1}^n (-1)^{i-1} p_{i} e_{k-i} & k &&gt; n\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n\\[\n\\sum_{\\substack{i+j=k}} (-1)^i e_i p_j = 0,\\quad k \\in \\mathbb N_{\\geq 0}\n\\] 但在求和中“认为” \\(p_0 = k\\)．\n\n\n\n\\[\n\\frac{s E'(s)}{E(s)} =  s \\frac{\\operatorname{d}\\!}{\\operatorname{d}\\!s} \\left( \\ln E(s) \\right) = \\sum_{i=1}^m \\frac{x_i s}{1+x_i s} = m - \\sum_{i=1}^m \\frac{1}{1+x_i s} = m - P(-s)\n\\] 即 \\[\n\\sum_{k=0}^\\infty k e_k s^k  = s E'(s) = E(s) (m - P(-s)) = E(s) \\sum_{k=1}^\\infty (-1)^{k-1} p_k\n\\] 对比各项即得 Newton 公式．"
  },
  {
    "objectID": "posts/20231018-discriminant/index.html#其它基底",
    "href": "posts/20231018-discriminant/index.html#其它基底",
    "title": "一元多项式的 Delta 判别式",
    "section": "",
    "text": "完全齐次对称多项式（Complete homogeneous symmetric polynomials）、Schur 多项式……\n本节主要参考 [1]–[4]．"
  },
  {
    "objectID": "posts/20210530-reimu/index.html",
    "href": "posts/20210530-reimu/index.html",
    "title": "原创生物遗传大题 - 红白紫薇",
    "section": "",
    "text": "近日，由国家花卉工程技术研究中心与北京林业大学紫薇课题组培育的紫薇新品种“灵梦”通过现场审定。“灵梦”由 Dallas Red 与 Velma’s Royal Delight 两个紫薇品种的杂交后代选育得到，为直立株型，开复色花，红色为底、白色镶边。 现某研究小组对“紫薇”【注】的花色遗传展开研究。\n\n研究小组选取红色纯合“紫薇”与白色纯合“紫薇”作为亲本杂交，\\(F_1\\) 全为粉红色“紫薇”。令 \\(F_1\\) 自交，\\(F_2\\) 各表现型比例如表所示。\n\n\n\n红色\n粉红色\n红底白边\n粉红底白边\n白色\n\n\n\n\n3\n6\n1\n2\n4\n\n\n\n已知“紫薇”的花色由两对独立遗传的等位基因（\\(\\mathrm{A}\\) 与 \\(\\mathrm{a}\\)、\\(\\mathrm{B}\\) 与 \\(\\mathrm{b}\\)）控制，其中 \\(\\mathrm{A}\\) 与 \\(\\mathrm{a}\\) 控制“紫薇”的底色。\n\n“紫薇”花色遗传满足 ________ 定律， ______________ （填细胞周期阶段）体现了这一定律（不考虑交叉互换）。\n已知一种白色“紫薇”基因型为 \\(\\mathrm{aabb}\\)，现将该“紫薇”与 \\(F_2\\)​ 粉红底白边“紫薇”杂交，子代表现型有 ____ 种。\n实验中亲本基因型分别为 ______________ ；\\(F_2\\) 所有表现型中性状可以稳定遗传的有 ______________ ；\\(F_2\\) 白色“紫薇”中纯合子与杂合子的比例为 ______ 。\n研究小组尝试让 \\(F_2\\) 所有粉红色“紫薇”自由交配，得到类似“灵梦”的红底白边“紫薇”。推测红底白边“紫薇”在子代中的占比为 ____ 。\n\n【注】紫薇的遗传多样性非常丰富，题目中“紫薇”的花色遗传方式纯属虚构，还请周知。"
  },
  {
    "objectID": "posts/20210530-reimu/index.html#problem",
    "href": "posts/20210530-reimu/index.html#problem",
    "title": "原创生物遗传大题 - 红白紫薇",
    "section": "",
    "text": "近日，由国家花卉工程技术研究中心与北京林业大学紫薇课题组培育的紫薇新品种“灵梦”通过现场审定。“灵梦”由 Dallas Red 与 Velma’s Royal Delight 两个紫薇品种的杂交后代选育得到，为直立株型，开复色花，红色为底、白色镶边。 现某研究小组对“紫薇”【注】的花色遗传展开研究。\n\n研究小组选取红色纯合“紫薇”与白色纯合“紫薇”作为亲本杂交，\\(F_1\\) 全为粉红色“紫薇”。令 \\(F_1\\) 自交，\\(F_2\\) 各表现型比例如表所示。\n\n\n\n红色\n粉红色\n红底白边\n粉红底白边\n白色\n\n\n\n\n3\n6\n1\n2\n4\n\n\n\n已知“紫薇”的花色由两对独立遗传的等位基因（\\(\\mathrm{A}\\) 与 \\(\\mathrm{a}\\)、\\(\\mathrm{B}\\) 与 \\(\\mathrm{b}\\)）控制，其中 \\(\\mathrm{A}\\) 与 \\(\\mathrm{a}\\) 控制“紫薇”的底色。\n\n“紫薇”花色遗传满足 ________ 定律， ______________ （填细胞周期阶段）体现了这一定律（不考虑交叉互换）。\n已知一种白色“紫薇”基因型为 \\(\\mathrm{aabb}\\)，现将该“紫薇”与 \\(F_2\\)​ 粉红底白边“紫薇”杂交，子代表现型有 ____ 种。\n实验中亲本基因型分别为 ______________ ；\\(F_2\\) 所有表现型中性状可以稳定遗传的有 ______________ ；\\(F_2\\) 白色“紫薇”中纯合子与杂合子的比例为 ______ 。\n研究小组尝试让 \\(F_2\\) 所有粉红色“紫薇”自由交配，得到类似“灵梦”的红底白边“紫薇”。推测红底白边“紫薇”在子代中的占比为 ____ 。\n\n【注】紫薇的遗传多样性非常丰富，题目中“紫薇”的花色遗传方式纯属虚构，还请周知。"
  },
  {
    "objectID": "posts/20210530-reimu/index.html#answer",
    "href": "posts/20210530-reimu/index.html#answer",
    "title": "原创生物遗传大题 - 红白紫薇",
    "section": "Answer",
    "text": "Answer\n(1) 自由组合 第一次减数分裂后期\n(2) 2\n(3) AABB和aabb 红底白边“紫薇”和白色“紫薇” 1:1\n(4) 1/36"
  },
  {
    "objectID": "posts/20210530-reimu/index.html#solution",
    "href": "posts/20210530-reimu/index.html#solution",
    "title": "原创生物遗传大题 - 红白紫薇",
    "section": "Solution",
    "text": "Solution\n\n问送分。\n由 红色纯合“紫薇”与白色纯合“紫薇”作为亲本杂交， F_1 全为粉红色“紫薇”，又由 A 与 a 控制“紫薇”的底色，可以判断 \\(\\mathrm{Aa}\\) 表现为粉红色，而 \\(\\mathrm{AA}\\) 或 \\(\\mathrm{aa}\\) 表现为红色或白色。\n观察 \\(F_2\\)​ 表现型比例，初步发现其具有典型 \\(\\mathrm{AaBb}\\) 性状分离的特征，于是可以断定 \\(F_1\\)​ 粉红色“紫薇”的基因型为 \\(\\mathrm{AaBb}\\)。\n现尝试解释比例。因为 \\(\\mathrm{A}\\)​​​ 与 \\(\\mathrm{a}\\)​​​ 控制的花色性状与是否杂合有关，故容易想到按“\\(\\mathrm{A}\\)​​​ 与 \\(\\mathrm{a}\\)​​ 是否杂合”的标准拆分 \\(9:3:3:1\\)​，得到 \\((3+6):(1+2):3:1\\)​，几乎拿到 \\(F_2\\)​ 的性状比。推测 \\(F_2\\)​​​​​​ 白色“紫薇”比例 \\(4 = 3+1 = \\mathrm{aaB?} + \\mathrm{aabb}\\)，而根据 2 问题干 已知一种白色“紫薇”基因型为 aabb 也确认了该推测。进一步对照表格即可得到题眼：\n\n\\(\\mathrm{AA}\\) 表现为红色，\\(\\mathrm{Aa}\\) 表现为粉红色，\\(\\mathrm{aa}\\) 表现为白色；\n\\(\\mathrm{B?}\\) 表现为纯色，\\(\\mathrm{bb}\\) 表现为有白边；\n无法区分白色和“白底白边”。\n\n问，粉红底白边“紫薇”的基因型为 \\(\\mathrm{Aabb}\\)，与 \\(\\mathrm{aabb}\\) 测交得到粉红底白边 \\((\\mathrm{Aabb})\\)、白色 \\((\\mathrm{aabb})\\) 两种后代。\n问，亲本基因型分别为 \\(\\mathrm{AABB}\\)​ 和 \\(\\mathrm{aabb}\\)​； \\(F_2\\)​ 红色 \\((\\mathrm{AABB}\\)​, \\(\\mathrm{AABb})\\)​、粉红色 \\((\\mathrm{AaBB}, \\mathrm{AaBb})\\)​、粉红底白边 \\(\\mathrm{(Aabb)}\\)​ 均可能发生性状分离，而红底白边 \\(\\mathrm{(AAbb)}\\)​ 和白色 \\(\\mathrm{(aaBB, aaBb, aabb)}\\)​ 可以稳定遗传；根据性状分离比，\\(F_2\\)​ 白色“紫薇”的基因型构成为 \\(\\mathrm{aaBB}:\\mathrm{aaBb}:\\mathrm{aabb}=1:2:1\\)​，易得纯杂比为 \\(1:1\\)​。\n问，\\(F_2\\)​​​ 粉红色“紫薇” \\(( \\frac{1}{3} \\mathrm{AaBB}, \\frac{2}{3} \\mathrm{AaBb})\\)​​ 自由交配，要求得到红底白边“紫薇” \\((\\mathrm{AAbb})\\)​​。单独考虑每对基因。对 \\(\\mathrm{A}\\)​​ 与 \\(\\mathrm{a}\\)​​，根据性状分离比，红底概率为 \\(\\frac{1}{4}\\)​​ 。对 \\(\\mathrm{B}\\)​​ 与 \\(\\mathrm{b}\\)​​，使用配子法，得 \\(( \\frac{2}{3} \\mathrm{B}, \\frac{1}{3} \\mathrm{b})\\)，于是白边概率为 \\(\\frac{1}{3} \\times \\frac{1}{3} = \\frac{1}{9}\\) ，综上得到红底白边“紫薇”的概率为 \\(\\frac{1}{4} \\times \\frac{1}{9} = \\frac{1}{36}\\)​ 。"
  },
  {
    "objectID": "posts/20191218-mex/index.html",
    "href": "posts/20191218-mex/index.html",
    "title": "bsoj5988 [Achen模拟赛]期望 题解",
    "section": "",
    "text": "bsoj5988\n\n【题目背景】\n　　NOI2018 已经过去了许久，2019 届的 BSOIer 们退役的退役，颓废的颓废，计数能力大不如前。曾经的数数之王 xxyj 坦言：“我现在算期望都靠枚举”，嘴边还挂着什么“分布列”，什么“样本数据”，然后又继续投身于文化课学习中了。 为了让 OI 的火炬传递下去，苣蒻 AChen 决定将 xxyj 退役前随口提到的期望问题交给你来解决。\n【题目描述】\n　　现有 m + 1 个白色的小球排成一列并从一开始编号。每次操作从前 m 个小球中随机选择一个涂黑。现在执行了 n 次操作，则编号最小的白球编号的期望是多少？\n【输入】\n　　从文件 mex.in 中读入数据。\n　　输入共一行两个整数 n,m。表示操作次数和白色小球的个数\n【输出】\n　　输出到文件 mex.out 中。\n　　若最小的白球编号的期望为 E，则输出一行表示：\\(((m^n)* E) \\mod (10^9 + 7)\\)\n　　可以看出上式一定是个整数。\n【样例输入】\n1 1\n【样例输出】\n2\n【提示】\n\\(n \\le 10^9, m \\le 10^6\\)\n【来源】\nAchen\n\n%%%AChen队爷%%%\n考察对容斥的基础理解，挺不错的一题\n易列答案式\n\\[\n\\sum_{i=1}^{m+1} P(mex = i) i\n\\]\n对这种期望，常使用套路化法 \\[\n\\sum_{i=0}^m P(mex&gt;i)\n\\]\n和式里面相当于要求已钦定\\(i\\)个确定的球，求随机选\\(n\\)次将这\\(i\\)个球全部染黑的概率。\n考虑容斥。先随便选，然后减去一个球未染的，然后加上两个球未染的，… \\[\n\\sum_{i=0}^{m} \\sum_{k=0}^{i} (-1)^k C_i^k (\\frac{m-k}{m})^n\n\\]\n是一个类似二项式反演但又不是的容斥\n更换枚举 \\[\n\\sum_{k=0}^{m} (-1)^k (\\frac{m-k}{m})^n \\sum_{i=k}^{m} C_i^k\n\\] 又由组合数的性质 \\[\n\\sum_{i=k}^{n} C_i^k = C_{n+1}^{k+1}\n\\] （容易通过杨辉三角和组合数的递推式证明）\n得 \\[\n\\sum_{k=0}^{m} (-1)^k (\\frac{m-k}{m})^n C_{m+1}^{k+1}\n\\] 直接计算即可。\n数据量如果更大的话，可以线筛出所有\\(n\\)次幂以省掉快速幂的\\(\\log\\)。偷懒不写了（\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1E9+7;\n\nll QPow(ll x,ll up){\n    x%=MOD;\n    ll ans=1;\n    while(up)\n        if(up%2==0) x=x*x%MOD,up=up/2;\n        else ans=ans*x%MOD,up--;\n    return ans;\n}\nll Inv(ll x){\n    return QPow(x,MOD-2);\n}\n\nconst ll MXN=1E6+5;\nll fac[MXN],facInv[MXN];\nvoid FacInit(ll n){\n    fac[0]=1;for(ll i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%MOD;\n    facInv[n]=Inv(fac[n]);for(ll i=n-1;i&gt;=1;i--) facInv[i]=facInv[i+1]*(i+1)%MOD;\n    facInv[0]=1;\n}\nll C(ll n,ll m){\n    if(n&lt;m) return 0;\n    return fac[n]*facInv[m]%MOD*facInv[n-m]%MOD;\n}\n\nll N,M;\nint main(){\n    scanf(\"%lld%lld\",&N,&M);\n    FacInit(M+1);\n    ll Ans=0;\n    for(ll k=0;k&lt;=M;k++){\n        ll p=1;if(k%2==1) p=(-1+MOD)%MOD;\n        Ans+=p*QPow(M-k,N)%MOD*C(M+1,k+1)%MOD;\n        Ans%=MOD;\n    }\n    printf(\"%lld\",Ans);\n    return 0;\n}"
  },
  {
    "objectID": "posts/20220204-vmagic/index.html",
    "href": "posts/20220204-vmagic/index.html",
    "title": "DockerCompose+VLESS+WS+TLS+Web 方式搭建 V2Ray 代理",
    "section": "",
    "text": "全文参考："
  },
  {
    "objectID": "posts/20220204-vmagic/index.html#原理",
    "href": "posts/20220204-vmagic/index.html#原理",
    "title": "DockerCompose+VLESS+WS+TLS+Web 方式搭建 V2Ray 代理",
    "section": "原理",
    "text": "原理\nVLESS 作为内部传输协议，使用 HTTP 的扩展 WebSocket 作为传输载体，外层使用 TLS 加密传输。服务器端用 Nginx 搭建正常 HTTPS 网站，收到向特定路径发送的 WebSocket 流量时充当反向代理转发至 Docker 容器内的 V2Ray 处理。\n从外部看，服务器是货真价实的 HTTPS 服务器，客户端发出的请求也是货真价实的 HTTPS 流量；直接用浏览器访问入口路径将返回 400 Bad Request（由 V2Ray 返回）或 404 Not Found（可在 Nginx 中预检测 WebSocket 请求，增强隐蔽性）；安全性、抗干扰能力则完全由 TLS 保障，几乎无懈可击。\n更强的技术还有 Xray 中使用的 XTLS，无缝拼接了内外两层 TLS 使得性能进一步提高。不过因为和 V2Ray 主社区分离了，还是决定先用 VLESS+WS+TLS+Web 配置。\n\nV2Ray V2Fly Xray 的历史\n\n结构上，使用 Docker 和 Docker Compose 容器化安装方便管理；而装在外层的 Nginx 可以作为所有网页服务的入口点，方便以后增加其它服务。"
  },
  {
    "objectID": "posts/20220204-vmagic/index.html#流程",
    "href": "posts/20220204-vmagic/index.html#流程",
    "title": "DockerCompose+VLESS+WS+TLS+Web 方式搭建 V2Ray 代理",
    "section": "流程",
    "text": "流程\n以下所有操作在 Ubuntu 20.04 的 root 用户下进行。代码中部分需要自己填写的敏感信息会用如 {[VARIABLE]} 的记号标明，请自行替换。\n\n准备工作\n\n安装 cURL\napt install curl\n\n\n安装 Docker\ncurl -fsSL https://get.docker.com/ | sh # 获取脚本并交给 sh (shell) 执行\nsystemctl start docker\n\n\n安装 Docker Compose\ncurl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n# docker-compose --version\n\n\n安装并运行 Nginx\napt install nginx\nsystemctl start nginx\n此时通过浏览器访问服务器就能看到 Nginx 默认的欢迎界面了。\n\n\n调试技巧\nNginx 的日志存储在 /var/log/nginx 目录下；V2Ray 的日志在 Docker 容器里，之后我们将把它映射到宿主机上方便操作和存储。\n一些常用的调试命令：\nsystemctl start nginx\nsystemctl status nginx\nsystemctl stop nginx\n\ndocker-compose up -d # Create and start containers（-d 表示后台运行）\ndocker-compose down  # Stop and remove containers, networks, images, and volumes\ndocker-compose start # Start services\ndocker-compose stop  # Stop services\n\ndocker ps # 查看各容器运行状态\ndocker log {[CONTAINER_ID]} # 查看某容器运行日志\n\n\n\n安装 Certbot 并以 Webroot 方式获取 Let’s Encrypt 证书\n\nCertbot 官方教程：User Guide — Certbot 1.22.0 documentation\nCertbot 原理：HTTPS-使用Certbot自动配置Let’s Encrypt证书 - 简书\n\nLet’s Encrypt 是一个免费、自动化和开放的证书颁发机构，为网站提供免费的 SSL/TLS 证书。要从 Let’s Encrypt 获取某个域名的证书，需要证明拥有对该域名的控制权，而 Certbot 就是官方提供的自动化认证工具。\nWebroot 是 Certbot 提供的一种认证方式，如果服务器上有网站运行且有能力修改其配置，就可以用该方式进行认证。使用这种方式获取证书时无需暂停网页服务端的运行。\n\nThe webroot plugin works by creating a temporary file for each of your requested domains in ${webroot-path}/.well-known/acme-challenge. Then the Let’s Encrypt validation server makes HTTP requests to validate that the DNS for each requested domain resolves to the server running certbot.\n\n首先安装 Certbot：\napt install certbot python3-certbot\n因为之前安装的 Nginx 已经在 /var/www/html 下生成默认的欢迎页网站，故可直接利用该目录进行 Webroot 认证：\ncertbot certonly --webroot -w /var/www/html -d {[YOUR_DOMAIN]}\n认证过程中 Certbot 的回显信息：\nSaving debug log to /var/log/letsencrypt/letsencrypt.log\nPlugins selected: Authenticator webroot, Installer None\nObtaining a new certificate\nPerforming the following challenges:\nhttp-01 challenge for {[YOUR_DOMAIN]}\nUsing the webroot path /var/www/html for all unmatched domains.\nWaiting for verification...\nCleaning up challenges\n\nIMPORTANT NOTES:\n - Congratulations! Your certificate and chain have been saved at:\n   /etc/letsencrypt/live/{[YOUR_DOMAIN]}/fullchain.pem\n   Your key file has been saved at:\n   /etc/letsencrypt/live/{[YOUR_DOMAIN]}/privkey.pem\n   Your cert will expire on {[EXPIRE-DATE]}. To obtain a new or tweaked\n   version of this certificate in the future, simply run certbot\n   again. To non-interactively renew *all* of your certificates, run\n   \"certbot renew\"\n - If you like Certbot, please consider supporting our work by:\n\n   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate\n   Donating to EFF:                    https://eff.org/donate-le\n\n\n使用 Docker Compose 安装并配置 V2Ray\n上传 docker-compose.json 至适当位置（建议妥善储存该文件，以便后续管理使用）：\nversion: \"3.4\"\nservices:\n  v2ray:\n    image: v2fly/v2fly-core\n    container_name: v2ray\n    restart: always # 自动重启容器\n    ports: \n      - {[YOUR_PORT_OUTER]}:{[YOUR_PORT_INNER]} # 端口映射，注意外左内右\n    command: v2ray -config=/etc/v2ray/config.json # 需要指定配置文件位置\n    volumes:\n      - /etc/v2ray:/etc/v2ray # 左边宿主目录，右边容器目录\n      - /var/log/v2ray:/var/log/v2ray\n利用 volume 技术，容器中 V2Ray 的配置文件被映射到宿主机的 /etc/v2ray 目录下，而日志信息被映射到 /var/log/v2ray 目录下。\n故运行容器之前，我们在 /etc/v2ray 下放置 config.json 作为容器内 V2Ray 的配置文件：\n{\n    \"log\": {\n        \"loglevel\": \"warning\",\n        \"access\": \"/var/log/v2ray/access.log\",\n        \"error\": \"/var/log/v2ray/error.log\"\n    },\n    \"inbounds\": [\n        {\n            \"port\": \"{[YOUR_PORT_INNER]}\", // 容器内的监听端口\n            \"listen\":\"0.0.0.0\", // Caution!\n            \"protocol\": \"vless\",\n            \"settings\": {\n                \"decryption\": \"none\",\n                \"clients\": [\n                    {\n                        \"id\": \"{[YOUR_UUID]}\",\n                        \"email\": \"{[YOUR_EMAIL]}\" // 作标识用，可以随便填\n                    }\n                ]\n            },\n            \"streamSettings\": {\n                \"network\": \"ws\",\n                \"wsSettings\": {\n                    \"path\": \"{[YOUR_PATH]}\" // 希望设定的 V2Ray 入口路径，如 \"/ray\"\n                }\n            }\n        }\n    ],\n    \"outbounds\": [\n        {\n            \"protocol\": \"freedom\",\n            \"settings\": {}\n        }\n    ]\n}\n\n有一个小坑点（见 Issue #2221）：与白话文指南不同，如果用 Docker 搭建 V2Ray，容器外的 Nginx 需要向容器内的 V2Ray 发送数据，因此容器内的 V2Ray 必须监听本机 IP 0.0.0.0 而不是本地回环 IP 127.0.0.1。\n常见的症状是客户端报 502 Bad Gateway &gt; websocket: bad handshake ，Nginx 报 upstream prematurely closed connection，而容器内 V2Ray 没有报警日志。\n\n最后，在之前放置 docker-compose.yml 的目录下执行：\ndocker-compose up -d\n\n\n设置 Nginx 反向代理\n\nNginx - Configuring HTTPS servers\nNginx - Module ngx_http_ssl_module\n\n通常修改 Nginx 配置可以通过直接修改 /etc/nginx/nginx.conf 或在 /etc/nginx/conf.d/ 目录下新建配置文件的方式进行，但根据推荐的目录结构（参见 Nginx/DirectoryStructure - Debian Wiki），这里选择在 /etc/nginx/sites-available/ 放置配置文件后在 /etc/nginx/sites-enabled/my-enabled.conf 中动态引用。\n故首先在 /etc/nginx/sites-available/ 下新建 {[YOUR_DOMAIN]}.conf（文件名可自行调整）：\nserver {\n  listen 443 ssl;\n  listen [::]:443 ssl;\n\n  ssl_certificate       /etc/letsencrypt/live/{[YOUR_DOMAIN]}/fullchain.pem;\n  ssl_certificate_key   /etc/letsencrypt/live/{[YOUR_DOMAIN]}/privkey.pem;\n  # 利用缓存重用 session 提高性能\n  ssl_session_timeout 1d;\n  ssl_session_cache shared:MozSSL:10m;\n  ssl_session_tickets off;\n\n  ssl_protocols         TLSv1.2 TLSv1.3;\n  # 设置加密方式，默认的已经不安全了\n  ssl_ciphers           ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;\n  ssl_prefer_server_ciphers off; # (?) Specifies that server ciphers should be preferred over client ciphers when using the SSLv3 and TLS protocols.\n\n  server_name           {[YOUR_DOMAIN]};\n  location {[YOUR_PATH]} { # 与 V2Ray 配置中的 path 保持一致\n    if ($http_upgrade != \"websocket\") { # WebSocket 协商失败时返回 404\n        return 404;\n    }\n    proxy_redirect off;\n    proxy_pass http://127.0.0.1:{[YOUR_PORT_OUTER]}; # 设置反向代理转发至 V2Ray\n    proxy_http_version 1.1;\n    # 一些 WebSocket 需要的配置\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header Host $host;\n    # Show real IP in v2ray access.log\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  }\n}\n# modified from (2022/01/30) https://guide.v2fly.org/advanced/wss_and_web.html#nginx-%E9%85%8D%E7%BD%AE\n然后在 /etc/nginx/sites-enabled/ 目录下，保持原有的 default 文件，并利用\nln -s /etc/nginx/sites-available/{[YOUR_DOMAIN]}.conf\n创建软链接至刚才保存的配置文件．最后重新加载配置文件：\nnginx -s reload\n\n\n客户端\n用的图形化界面还没研究配置文件，不过 outbounds 部分大致应如下所示：\n\"outbounds\": [\n    {\n        \"protocol\": \"vless\",\n        \"settings\": {\n            \"vnext\": [\n                {\n                    \"address\": \"{[YOUR_DOMAIN]}\",\n                    \"port\": 443,\n                    \"users\": [\n                        {\"id\": \"{[YOUR_UUID]}\", \"email\": \"{[YOUR_EMAIL]}\"}\n                    ]\n                }\n            ]\n        },\n        \"streamSettings\": {\n            \"network\": \"ws\",\n            \"security\": \"tls\",\n            \"wsSettings\": {\n                \"path\": \"{[YOUR_PATH]}\"\n            }\n        }\n    }\n]"
  },
  {
    "objectID": "posts/20230124-stl/index.html",
    "href": "posts/20230124-stl/index.html",
    "title": "算法竞赛向 C++ Standard Library 使用速查",
    "section": "",
    "text": "本文旨在对算法竞赛所需 C++ Standard Library 做一个全面而相对严谨的总结。\n全文主要参考以下文档：\n如有能力，阅读原文可获得更深入的了解。"
  },
  {
    "objectID": "posts/20230124-stl/index.html#stl-算法",
    "href": "posts/20230124-stl/index.html#stl-算法",
    "title": "算法竞赛向 C++ Standard Library 使用速查",
    "section": "1 STL 算法",
    "text": "1 STL 算法\n均在 #include&lt;algorithm&gt; 定义。\n\nstd::sort(first,last,cmp)\n排序为不降序列。\n接受随机访问迭代器。可自定义比较函数。\n平均时间复杂度 \\(O(n \\log n)\\)，C++11 后严格 \\(O(n \\log n)\\)。\nstd::stable_sort(first,last,cmp)\n排序为不降序列，且保持相等元素的顺序。\nstd::lower_bound(first,last,val,cmp)\n返回指向首个不小于 val 的元素的迭代器，如无，返回 last。\n要求小于 val 的值和大于等于 val 的值分居区间两侧。\n可自定义比较函数。若迭代器支持随机访问，对数时间复杂度，否则为线性。\nstd::upper_bound(first,last,val,cmp)\n返回指向首个大于 val 的元素的迭代器，如无，返回 last。\nstd::unique(first,last,cmp)\n保留区间中所有连续等值区间的首个元素组成新序列，返回处理后序列的尾迭代器。\n接受前向迭代器，可自定义判断相等的函数。\n线性时间复杂度。"
  },
  {
    "objectID": "posts/20230124-stl/index.html#基本或特殊容器",
    "href": "posts/20230124-stl/index.html#基本或特殊容器",
    "title": "算法竞赛向 C++ Standard Library 使用速查",
    "section": "2 基本或特殊容器",
    "text": "2 基本或特殊容器\n注：C++11 新引入的容器，大部分头文件名与容器名一致。\n\npair #include&lt;utility&gt; ：元素对。\ntuple (C++11) ：元组。\nbitset #include&lt;bitset&gt; ：定长压缩 01 串，可在 \\(O(\\frac N K)\\) 的时空复杂度内完成常见运算，\\(K\\) 对应操作系统位数。\nstring #include&lt;string&gt; ：字符串。\n\n\n2.1 pair\n\noperator= ：重载了赋值运算符用于拷贝。\nfirst / second ：访问第一项或第二项。\nstd::make_pair(a,b) ：新建元素对，自动检测类型。\noperator&lt;=&gt; ：重载了各种比较运算符，按第一关键字、第二关键字顺序比较。\n\n\n\n2.2 tuple\n\noperator= ：重载了赋值运算符用于拷贝。\nstd::get&lt;i&gt;(tp) ：获取元组的第 i 项。\nstd::get&lt;T&gt;(tp) ：获取元组中类型为 T 的项。\nstd::tie(a,b,...) ：构造一个变量引用构成的元组．用于在赋值时将等号右侧的元组解包到左侧的 a,b,... 等变量中。\nstd::make_tuple(a,b,c,...)：新建元组，自动检测类型。\noperator&lt;=&gt; ：重载比较运算符，同样是顺序关键字比较。\n\n\n\n\n\n\n\n下面是一个应用 C++11 新引入的元组和列表初始化的 ExGCD 实现。\ntypedef tuple&lt;ll,ll,ll&gt; Tuple;\nTuple exgcd(ll a,ll b){\n    if(b==0) return {1,0,a};\n    ll x1,y1,d; tie(x1,y1,d)=exgcd(b,a%b);\n    return {y1,x1-(a/b)*y1,d};\n}\n\n\n\n\n\n2.3 string\n与 vector 类似。其余重要特性如下：\n\nc_str() ：生成一个 C 风格字符串（尾部置 0）并返回其头部指针。\nlength() ：size() 的同义函数。\nappend(str) ：后方追加字符串，返回 *this。\nappend(first, last) ：区间插入版本。\noperator+ ：连接两个字符串。\ncompare(str) ：字典序比较。返回一个 int，用 &lt;0 / ==0 / &gt;0 判断该字符串小于 / 等于 / 大于参数字符串。\noperator&lt;=&gt; ：字典序比较的运算符重载。\nsubstr(pos=0, count)：返回 [pos, min(pos+count, size())) 的子串。时间复杂度与 count 成线性。\npop_back() (C++11)\nfind(str) / rfind(str) / find_first_of(c) / find_first_not_of(c) / find_last_of(c) / find_last_not_of(c)：找字符串或字符，返回位置。若无，返回 npos=-1。无时间复杂度保证，不建议使用。\n\n\n\n2.4 bitset\nbitset&lt;N&gt; bs(val / str)：声明一个长度为 N 的 bitset 并设定初值。\n\n& / ! / ^ / ~ / &gt;&gt; / &lt;&lt; ：支持 AND / OR / XOR / NOT / 右移 / 左移等位运算系列。\noperator== ：判断两个 bitset 是否相同。\ntest(idx) / operator[idx] ：前者会做越界检查，抛出异常。\nsize()\ncount() ：返回 1 的个数。\nall() (C++11) ：检查是否全为 1。\nany() / none() ：检查是否存在 1 / 没有 1。\nset() / reset() ：所有位赋 1 / 0。\nflip() ：翻转 0 / 1。"
  },
  {
    "objectID": "posts/20230124-stl/index.html#stl-容器概览",
    "href": "posts/20230124-stl/index.html#stl-容器概览",
    "title": "算法竞赛向 C++ Standard Library 使用速查",
    "section": "3 STL 容器概览",
    "text": "3 STL 容器概览\n以下部分均为 STL 容器相关内容。\n\n3.1 迭代器\n声明：形如 vector&lt;int&gt;::iterator iter = xxx.begin()。C++11 后可用 auto 代替类型声明。\n*iter 取值，iter++ 后继。\n双向迭代器可 iter--，随机访问迭代器支持加减、比较运算。\n\nbegin(), end() ：返回迭代器。end() 常作为 NULL 使用。\ncbegin(), cend() (C++11) ：部分容器支持，返回只读迭代器。\nrbegin(), rend() ：部分容器支持，返回反向迭代器。\ncrbegin(), crend() ：部分容器支持，返回只读反向迭代器。\n\n\n\n3.2 公共性质\n\n[first, last) 式迭代器构造，拷贝构造等。\noperator= ：重载了赋值运算符用于拷贝。\nempty() ：返回容器是否为空，即 v.begin() == v.end()。\nsize() ：返回容器内元素个数。\nclear() ：清空容器。"
  },
  {
    "objectID": "posts/20230124-stl/index.html#序列式容器或容器适配器",
    "href": "posts/20230124-stl/index.html#序列式容器或容器适配器",
    "title": "算法竞赛向 C++ Standard Library 使用速查",
    "section": "4 序列式容器或容器适配器",
    "text": "4 序列式容器或容器适配器\n序列式容器：\n\narray (C++11) ：定长顺序表，常数随机访问。\nvector #include&lt;vector&gt;：顺序表，常数后段插入，常数随机访问。\ndeque #include&lt;deque&gt; ：顺序表，常数双端插入，常数随机访问。\nlist #include&lt;list&gt; ：链表，常数插入删除，双向迭代器。\n\nforward_list (C++11) ：单向版本。\n\n\n容器适配器（均不支持迭代器）：\n\nqueue #include&lt;queue&gt;：队列（FIFO）。适配双向变长序列式容器，即 deque（默认）或 list。\nstack #include&lt;stack&gt;：栈（LIFO）。适配变长序列式容器，即 deque（默认）、vector或 list。\npriority_queue #include&lt;queue&gt;：大根堆。适配随机访问变长序列式容器，即 vector（默认）或 deque。\n\n\n4.1 vector\nConstruct:\n\nvector&lt;T&gt;(count,value) ：初始化时放 count 个 value 的拷贝在里面。\n\nAccess:\n\ncrbegin()\nat(idx) / operator[idx] ：前者会做越界检查，抛出异常。\nfront(), back() ：返回首尾元素引用。\n\nModify:\n\npush_back(x) / pop_back() ：均摊常数复杂度。\ninsert(iter, val) ：于迭代器 iter 前插入，返回指向被插入元素的迭代器。 insert(iter, first, last) ：左闭右开区间插入，返回指向首个被插入元素的迭代器。 注意，此操作非常数时间复杂度。\nerase(iter) ：于迭代器 iter 处删除，返回指向被删除元素的后一个元素的迭代器。 erase(first, last) ：左闭右开区间删除，返回指向被删除元素的后一个元素的迭代器。 注意，此操作非常数时间复杂度。\n\nSize:\n\nresize(n) ：改变长度，可指定补充元素默认值。\nshrink_to_fit() ：调整为恰好长度。\n\n\n\n\n\n\n\nvector&lt;bool&gt; 被特殊定义，使用方式较为复杂，不建议使用。\n\n\n\n\n\n4.2 deque\n\npush_front(x), pop_front()\n\n其余与 vector 类似。\n\nstack\n\ntop()\npush(x)\npop()\n\n\n\nqueue\n\nfront()\npush(x)\npop()\n\n\n\npriority_queue\n\nstd::priority_queue&lt;TypeName&gt; ：Compare 默认使用 std::less&lt;T&gt;，即以 operator &lt; 作为大根堆的比较依据。\nstd::priority_queue&lt;TypeName, Container, Compare&gt; ：亦可自行指定底层容器和比较函数对象。\n\n例如，传入 std::greater&lt;T&gt; 将使用 &gt; 作为比较符号，进而构造出小根堆。\n\n\n\n\n\n\n自定义比较函数对象，可仿照以下代码：\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\ntypedef long long ll;\nstruct Vec{\n    ll x,y;\n    Vec(){}\n    Vec(ll x,ll y){\n        this-&gt;x=x;this-&gt;y=y;\n    }\n};\nstruct vecCompare{\n    bool operator () (const Vec& a,const Vec& b) const {\n        return a.x&lt;b.x||(a.x==b.x&&a.y&lt;b.y);\n    }\n};\nint main(){\n    std::priority_queue&lt; Vec, std::vector&lt;Vec&gt;, vecCompare &gt; H;\n    H.push(Vec(1,2));\n    H.push(Vec(2,1));\n    Vec t=H.top();\n    std::cout&lt;&lt;t.x&lt;&lt;\",\"&lt;&lt;t.y;\n}\n\n\n\n用法基本同 queue，但 push() / pop() 为对数时间复杂度。\n\n\n\n4.3 list\n\n无随机访问接口。\ninsert(iter, val) / erase(iter) ：插入与删除变为常数时间复杂度，参见 vector。\nsort(cmp) ：为链表特殊设计的 \\(O(n \\log n)\\) 稳定排序算法。\n\n其余与 deque 类似。"
  },
  {
    "objectID": "posts/20230124-stl/index.html#关联式容器",
    "href": "posts/20230124-stl/index.html#关联式容器",
    "title": "算法竞赛向 C++ Standard Library 使用速查",
    "section": "5 关联式容器",
    "text": "5 关联式容器\n不支持随机访问，双向迭代器，大部分操作为对数时间复杂度，红黑树实现。\n\nset / multiset #include&lt;set&gt;：元素有序。后者支持同值多元素。\nmap / multimap #include&lt;map&gt;：键有序。后者支持同键值多元素。\n\n\n5.1 set / multiset\n\nset&lt;Key&gt;：默认使用 operator &lt; 比较（升序）。\nset&lt;Key, Compare&gt;：也可使用类似 priority_queue 的方法自定义比较函数对象 Compare。\n\nAccess：\n\ncrbegin()\ncount(x) ：返回值为 x 的元素数量。\nlower_bound(x) / upper_bound(x) ：为 set 特殊定制的对数时间复杂度 lower_bound 和 upper_bound。\n\n\n\n\n\n\n\n没有 nth_element()，对数时间复杂度查询第 k 大需自行手写平衡树或使用 pbds 库。\n\n\n\nModify:\n\ninsert(x) ：插入元素 x。返回 pair&lt;iterator, bool&gt;，表示插入元素的迭代器与插入是否成功。 对于 multiset，由于插入不会失败，insert 只返回迭代器。\nerase(x) ：删除所有值为 x 的元素，返回删除元素的个数。 erase(iter) ：删除迭代器指向的元素，(C++11) 返回指向被删除元素的后一个元素的迭代器。 erase(first, last)：左闭右开区间删除，(C++11) 返回指向被删除元素的后一个元素的迭代器。\n\n\n\n\n\n\n\n删除单个值为 x 的元素，可按如下方法进行：\nauto it = s.find(x);\ns.erase(it);\n\n\n\n\n\n5.2 map / multimap\nmap&lt;Key, T, Compare&gt;：可自定义比较方式。\n\n对迭代器解引用得到 pair&lt;Key, T&gt;。\ninsert(pair&lt;Key, T&gt;)\nat[key] / operator[key]：前者会做越界检查，抛出异常。\n\n其余与 set 类似。"
  },
  {
    "objectID": "posts/20230124-stl/index.html#无序关联式容器-c11",
    "href": "posts/20230124-stl/index.html#无序关联式容器-c11",
    "title": "算法竞赛向 C++ Standard Library 使用速查",
    "section": "6 无序关联式容器 (C++11)",
    "text": "6 无序关联式容器 (C++11)\n单向迭代器，平均常数时间复杂度，Hash 实现。\n若不支持 c++11，使用时需引入 TR1 扩展。例如，使用 unordered_map 需引入 #include&lt;tr1/unordered_map&gt; 头文件，使用时需写为 std::tr1::unordered_map。\n\nunordered_set / unordered_multiset #include&lt;unordered_set&gt;：元素无序。\nunorderep_map / unordered_multimap #include&lt;unordered_map&gt;：键无序。\n\n只有单向迭代器，其余特性与有序版本类似。\n此外，还可自行指定相等判定方式和 Hash 函数。\n\nunordered_set&lt;Key, Hash, KeyEqual&gt;\nunordered_map&lt;Key, T, Hash, KeyEqual&gt;\n\n\n\n\n\n\n\nHash 函数的自定义方法也与 priority_queue 中的方法类似：\n#include&lt;iostream&gt;\n#include&lt;unordered_set&gt;\ntypedef long long ll;\nstruct Vec{\n  ll x,y;\n    Vec(){}\n    Vec(ll x,ll y){\n        this-&gt;x=x;this-&gt;y=y;\n    }\n};\nbool operator == (const Vec& a,const Vec& b){\n    return a.x==b.x&&a.y==b.y;\n}\nstruct vecHash{\n    size_t operator () (const Vec& v) const {\n        return (v.x*ll(1E9)+v.y)%107897;\n    }\n};\nint main(){\n    std::unordered_set&lt;Vec,vecHash&gt; S;\n    S.insert(Vec(1,2));\n    S.insert(Vec(2,3));\n    std::cout&lt;&lt;S.count(Vec(1,2));\n}"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html",
    "href": "posts/20221226-quarto-fantasia/index.html",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "",
    "text": "上回说到，sun123zxy 同学完成了手撸 Jekyll 的伟大壮举，然后悠哉游哉地度过了他的高三生活。现在，静态博客的大厦已经基本落成，剩下的只是一些装修工作。然而，几朵不大不小的乌云却总让他感到不安。\nsun123zxy 曾写过一篇相对严谨的学习笔记等价类计数：Burnside引理 & Polya定理，还有一篇关于行列式与生成树计数的笔记尚未发布。这些笔记里包含大量章节标号、定理与交叉引用。关于交叉引用，原生 Markdown 只支持在链接处以 section 的标题作为标签完成引用，显然对中文文档不大友好。不少人选择使用内嵌 HTML 解决问题，但死脑筋的 sun123zxy 认为这种方式背离了 Markdown 简化格式的初衷。后来他发现，PHP Markdown Extra 格式的 Special Attributes 能解决部分交叉引用的问题，更惊喜的是 Pandoc 竟然兼容这种语法（当时 sun123zxy 对 Pandoc 还没有做深入了解，只局限于使用 jekyll-pandoc 渲染而已）。至于处理章节标号，只需对已经写好的目录系统脚本做一点改动即可，而且当时 sun123zxy 也并没有那么多篇严谨的学术向写作。总之，问题暂时得到解决。\n另一朵乌云来自 LaTeX。众所周知，Markdown 的内嵌数学公式是 LaTeX Math Mode 的某个子集。sun123zxy 发现，自己在 LaTeX 上的不求甚解开始给他带来各种麻烦。比如，他无法解释为什么只有 aligned 环境能被正确渲染，而不少教程中提到的 align* 和支持标号的 align 却总是报错；再比如，由于使用了重视速度的 KaTeX 而不是更加完备的 MathJax 作为渲染引擎，他发现自己无法使用诸如 \\newcommand、\\DeclareMathOperator 的宏定义。而且，一些教程中提到的 physics 等需要自行导入的“宏包”也让他摸不着头脑。\n最重要的是，sun123zxy 开启了他的大学生活，论文写作的需求使他产生了系统学习 LaTeX 的想法。他在网协大牛那里听说了 Overleaf，并在间歇性热情驱使下疯狂啃食文档，最终写出了自己的文档类，覆盖常见中文社科、科技向论文写作需求。验之以文，效果拔群。学习过程中，sun123zxy 习得众多排版常识，掌握了各种 font family 的区别、衬线字体的使用情景、英文 dash 的分辨方式等技巧，姿势水平得到质的飞跃。\nsun123zxy 发现自己有点沉迷 LaTeX 了。他在写集合论大作业时学习了 amsthm 宏包，现已完全抵挡不住“定理 2.3”、“推论 4.1.1”、“例题 3.2”、“图 3”、“表 1”自动标号和交叉引用的诱惑。曾经博客使用的加强版 Markdown 在完备的 LaTeX 面前不值一提。他突然感觉有点害怕，毕竟 PDF 格式的网络发布效果并不理想。他需要找到一种能兼取两种格式长处的解决方案，否则他的博客将成为历史的眼泪。\n然而在这里他遇到了瓶颈。尽管已经有一系列形如 LaTeX2HTML 的项目存在，但因为 TeX/LaTeX 是为 PDF 等页面固定的展现方式而设计，在转换成尺寸动态变化的网页（HTML）时必然面临信息损失。Markdown or LaTeX? - Yihui Xie | 谢益辉 这篇文章详细的讨论了 Markdown 和 LaTeX 间不可调和的冲突。更好的思路是，利用轻巧且可读性优秀的 Markdown 作为写作语言直接输出 HTML，需要 PDF 时再使用其它程序处理得到 LaTeX 代码。markdown 宏包就解决了这样的问题。\n\n「你喜爱的 Markdown 写作，现更以 LaTeX 呈现。」\n——以 Markdown 撰写文稿，以 LaTeX 排版 | 始终\n\nmarkdown 宏包提供的 hybrid 功能还提供了将 LaTeX 命令混入 Markdown 的功能，完美覆盖了上述使用情景。然而，Markdown 自身在学术写作方面的固有缺陷——难以交叉引用、无法自动编号、没有定理系统——仍然让 HTML 输出举步维艰。问题在这里似乎陷入了死结：既想要 Markdown 的可读性和 HTML 输出，又想要 LaTeX 的定理系统和 PDF 输出——这可能吗？\nsun123zxy 询问了不少同时掌握 Markdown 和 LaTeX 的大佬，他们都没有研究过这样的问题。唯一的希望是：找到一种合适的方式扩展 Markdown 的语法。sun123zxy 想起了 Pandoc——文档转换界的瑞士军刀。事实证明 Pandoc 确实对得起这个称呼。他离解决方案已经非常近了：Pandoc’s Markdown 已经非常强大，强大到可以随意内嵌 LaTeX 代码（当然只对 LaTeX 输出有效），交叉引用几乎任何内容，甚至可以用 Markdown 风格的 fenced syntax 控制 HTML 中的 div、span 及其参数！再加上 pandoc-xnos 插件提供的自动标号功能，问题几乎得到全部解决——而现在看来，定理系统也可以通过编写 Pandoc filter 实现。\n当然，sun123zxy 是个懒人，在能搜到解决方案的情况下，他不会干重复造轮子的傻事。某日，sun123zxy 又开始他了的头脑风暴。通过 Google 新的关键字 markdown、cross-reference、academic writing，他发现了 R Markdown，进而发现了 Quarto。\n\nQuarto is an open-source scientific and technical publishing system built on Pandoc.\n\nCreate dynamic content with Python, R, Julia, and Observable.\nAuthor documents as plain text markdown or Jupyter notebooks.\nPublish high-quality articles, reports, presentations, websites, blogs, and books in HTML, PDF, MS Word, ePub, and more.\nAuthor with scientific markdown, including equations, citations, crossrefs, figure panels, callouts, advanced layout, and more.\n\n——几乎让我一下子跳起来的 Overview\n\nQuarto 是构建在 Pandoc 上的文档发布系统，对 Pandoc’s Markdown 做了进一步扩展以适应学术写作，其中就包含了 pandoc-xnos 的语法和——用 Pandoc’s Markdown 的 fenced syntax 实现的定理系统！此外，Quarto 甚至还支持 Jupyter Notebook 的动态计算，附上 Matplotlib 代码就可动态生成统计图表——而且同样也可以被交叉引用！更让人欣喜的是，除了直接输出 HTML 和 PDF/LaTeX，Quarto 还提供了类似 Jekyll 的生成静态网站的功能！\n于是，长达数月的探索终于落下帷幕，语法学习、环境配置与博客迁移被提上日程。又是近一个月的辛勤劳动，sun123zxy 终于完成了写作流程的构建和博客的搭建工作。盯着桌前已经冷透了的保温杯，他陷入了沉思……"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html#旅程继续",
    "href": "posts/20221226-quarto-fantasia/index.html#旅程继续",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "",
    "text": "上回说到，sun123zxy 同学完成了手撸 Jekyll 的伟大壮举，然后悠哉游哉地度过了他的高三生活。现在，静态博客的大厦已经基本落成，剩下的只是一些装修工作。然而，几朵不大不小的乌云却总让他感到不安。\nsun123zxy 曾写过一篇相对严谨的学习笔记等价类计数：Burnside引理 & Polya定理，还有一篇关于行列式与生成树计数的笔记尚未发布。这些笔记里包含大量章节标号、定理与交叉引用。关于交叉引用，原生 Markdown 只支持在链接处以 section 的标题作为标签完成引用，显然对中文文档不大友好。不少人选择使用内嵌 HTML 解决问题，但死脑筋的 sun123zxy 认为这种方式背离了 Markdown 简化格式的初衷。后来他发现，PHP Markdown Extra 格式的 Special Attributes 能解决部分交叉引用的问题，更惊喜的是 Pandoc 竟然兼容这种语法（当时 sun123zxy 对 Pandoc 还没有做深入了解，只局限于使用 jekyll-pandoc 渲染而已）。至于处理章节标号，只需对已经写好的目录系统脚本做一点改动即可，而且当时 sun123zxy 也并没有那么多篇严谨的学术向写作。总之，问题暂时得到解决。\n另一朵乌云来自 LaTeX。众所周知，Markdown 的内嵌数学公式是 LaTeX Math Mode 的某个子集。sun123zxy 发现，自己在 LaTeX 上的不求甚解开始给他带来各种麻烦。比如，他无法解释为什么只有 aligned 环境能被正确渲染，而不少教程中提到的 align* 和支持标号的 align 却总是报错；再比如，由于使用了重视速度的 KaTeX 而不是更加完备的 MathJax 作为渲染引擎，他发现自己无法使用诸如 \\newcommand、\\DeclareMathOperator 的宏定义。而且，一些教程中提到的 physics 等需要自行导入的“宏包”也让他摸不着头脑。\n最重要的是，sun123zxy 开启了他的大学生活，论文写作的需求使他产生了系统学习 LaTeX 的想法。他在网协大牛那里听说了 Overleaf，并在间歇性热情驱使下疯狂啃食文档，最终写出了自己的文档类，覆盖常见中文社科、科技向论文写作需求。验之以文，效果拔群。学习过程中，sun123zxy 习得众多排版常识，掌握了各种 font family 的区别、衬线字体的使用情景、英文 dash 的分辨方式等技巧，姿势水平得到质的飞跃。\nsun123zxy 发现自己有点沉迷 LaTeX 了。他在写集合论大作业时学习了 amsthm 宏包，现已完全抵挡不住“定理 2.3”、“推论 4.1.1”、“例题 3.2”、“图 3”、“表 1”自动标号和交叉引用的诱惑。曾经博客使用的加强版 Markdown 在完备的 LaTeX 面前不值一提。他突然感觉有点害怕，毕竟 PDF 格式的网络发布效果并不理想。他需要找到一种能兼取两种格式长处的解决方案，否则他的博客将成为历史的眼泪。\n然而在这里他遇到了瓶颈。尽管已经有一系列形如 LaTeX2HTML 的项目存在，但因为 TeX/LaTeX 是为 PDF 等页面固定的展现方式而设计，在转换成尺寸动态变化的网页（HTML）时必然面临信息损失。Markdown or LaTeX? - Yihui Xie | 谢益辉 这篇文章详细的讨论了 Markdown 和 LaTeX 间不可调和的冲突。更好的思路是，利用轻巧且可读性优秀的 Markdown 作为写作语言直接输出 HTML，需要 PDF 时再使用其它程序处理得到 LaTeX 代码。markdown 宏包就解决了这样的问题。\n\n「你喜爱的 Markdown 写作，现更以 LaTeX 呈现。」\n——以 Markdown 撰写文稿，以 LaTeX 排版 | 始终\n\nmarkdown 宏包提供的 hybrid 功能还提供了将 LaTeX 命令混入 Markdown 的功能，完美覆盖了上述使用情景。然而，Markdown 自身在学术写作方面的固有缺陷——难以交叉引用、无法自动编号、没有定理系统——仍然让 HTML 输出举步维艰。问题在这里似乎陷入了死结：既想要 Markdown 的可读性和 HTML 输出，又想要 LaTeX 的定理系统和 PDF 输出——这可能吗？\nsun123zxy 询问了不少同时掌握 Markdown 和 LaTeX 的大佬，他们都没有研究过这样的问题。唯一的希望是：找到一种合适的方式扩展 Markdown 的语法。sun123zxy 想起了 Pandoc——文档转换界的瑞士军刀。事实证明 Pandoc 确实对得起这个称呼。他离解决方案已经非常近了：Pandoc’s Markdown 已经非常强大，强大到可以随意内嵌 LaTeX 代码（当然只对 LaTeX 输出有效），交叉引用几乎任何内容，甚至可以用 Markdown 风格的 fenced syntax 控制 HTML 中的 div、span 及其参数！再加上 pandoc-xnos 插件提供的自动标号功能，问题几乎得到全部解决——而现在看来，定理系统也可以通过编写 Pandoc filter 实现。\n当然，sun123zxy 是个懒人，在能搜到解决方案的情况下，他不会干重复造轮子的傻事。某日，sun123zxy 又开始他了的头脑风暴。通过 Google 新的关键字 markdown、cross-reference、academic writing，他发现了 R Markdown，进而发现了 Quarto。\n\nQuarto is an open-source scientific and technical publishing system built on Pandoc.\n\nCreate dynamic content with Python, R, Julia, and Observable.\nAuthor documents as plain text markdown or Jupyter notebooks.\nPublish high-quality articles, reports, presentations, websites, blogs, and books in HTML, PDF, MS Word, ePub, and more.\nAuthor with scientific markdown, including equations, citations, crossrefs, figure panels, callouts, advanced layout, and more.\n\n——几乎让我一下子跳起来的 Overview\n\nQuarto 是构建在 Pandoc 上的文档发布系统，对 Pandoc’s Markdown 做了进一步扩展以适应学术写作，其中就包含了 pandoc-xnos 的语法和——用 Pandoc’s Markdown 的 fenced syntax 实现的定理系统！此外，Quarto 甚至还支持 Jupyter Notebook 的动态计算，附上 Matplotlib 代码就可动态生成统计图表——而且同样也可以被交叉引用！更让人欣喜的是，除了直接输出 HTML 和 PDF/LaTeX，Quarto 还提供了类似 Jekyll 的生成静态网站的功能！\n于是，长达数月的探索终于落下帷幕，语法学习、环境配置与博客迁移被提上日程。又是近一个月的辛勤劳动，sun123zxy 终于完成了写作流程的构建和博客的搭建工作。盯着桌前已经冷透了的保温杯，他陷入了沉思……"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html#主要成果",
    "href": "posts/20221226-quarto-fantasia/index.html#主要成果",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "主要成果",
    "text": "主要成果\n\n基于 Quarto 的 SunQuarTeX 多格式中文学术写作出版流程，内含适用于常见中文论文写作的 LaTeX 文档类及其示例文档。\nQuarto 驱动的适应学术写作要求的新版博客（sun123zxy/blog-quarto-code）。\n\n上一个 Jekyll 博客，一砖一瓦都是自己搭出来的，有感情了（笑）。所以也没下线，放在 blog-jekyll.sun123zxy.top 上了。如果你也和我一样怀旧，可以去看看~\n那么，依照惯例，聊聊学习与折腾中的一点心得体会。"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html#关于-latex",
    "href": "posts/20221226-quarto-fantasia/index.html#关于-latex",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "关于 LaTeX",
    "text": "关于 LaTeX\n很多人说 LaTeX 不好学——的确。即使是 OIer 群体，对 LaTeX 的认知也大多停留在数学公式水平。然而比起客观的困难，更应该问的问题是——Why LaTeX? 不同人的答案或许有所不同，但应有以下几点：\n\n有学术写作或打印文档的需求（否则可直接使用 Markdown/HTML）\n认同内容与样式分离的设计思想，希望对文档排版有清晰的控制，而不是所见即所得的富文本格式导致的混乱。\n希望用相对不易损坏且可读性较高的代码式文档替代 .docx 式的黑箱存储。\n需要使用章节标号、定理系统等交叉引用功能。\n想用简洁的代码生成严谨美观的数学公式。\n就是感觉 LaTeX 排出来的东西很牛逼\n\n学习 LaTeX 需要了解它的历史，理解它的开发理念，理清 TeX/LaTeX 的历史进程，弄清 pdfLaTeX、XeLaTeX、LuaLaTeX 各自的特点，在 MikeTeX、TeXLive 两个发行版中做出选择，学习 BibTeX 引用管理格式，还有对排版知识的初步了解——知识体系可谓庞大。此外，不少 LaTeX 教学文档、各种宏包的手册本身就是由 LaTeX 生成的，这意味它们都是 PDF 格式，无法在互联网上得到很好的传播。但请不要忘记，它们是学习 LaTeX 的第一手资料。例如，CTAN 上的手册是学习各类宏包的第一途径，LaTeX 官网也提供了不少相对系统的 PDF 教程。当然，近年来网页渲染工具 Overleaf 的出现降低了环境配置的难度，Overleaf 的 LaTeX 教学文档也非常优秀。我还强烈推荐 一份其实很短的 LaTeX 入门文档 | 始终 这篇文章作为入门，作者是一位参与维护 CTeX 宏集的大佬，之前提到的 markdown 宏包他也写过一篇详细的介绍，详见上文引用中的链接。\n在互联网上碎片化的学习 LaTeX，一定要经常问自己——这功能是哪个宏包定义的？例如，关于交叉引用，\\label、\\ref、\\pageref 均为原生自带，\\eqref 是 amsmath 宏包定义的，而 \\autoref \\href \\url 均为 hyperref 宏包的命令，引入 hyperref 的目的主要是让文章里的交叉引用都变成 PDF 里可点击跳转的超链接；再例如，定理系统是 LaTeX 原生支持的，但 amsthm 提供了无标号版本的定理、设置 \\theoremstyle 的方式和自动添加 QED symbol 的 proof 环境。再次强调，不要错过宏包的 PDF 手册！阅读手册是整合碎片知识、查漏补缺的最佳途径。"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html#关于-ctex",
    "href": "posts/20221226-quarto-fantasia/index.html#关于-ctex",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "关于 CTeX",
    "text": "关于 CTeX\n此外，有必要对中文排版基础宏包 CTeX 做进一步说明。\n\n最初，Knuth 在设计开发 TeX 的时候没有考虑到多国文字支持，特别是对多字节的中日韩表意文字的支持。这使得 TeX 以至后来的 LaTeX 对中文的支持一直不是很好。即使在 CJK 宏包解决了中文字符处理的问题以后，中文用户使用 LaTeX 仍然要面对许多困难。这些困难里，以章节标题的中文化为最。由于中文和西文书写习惯的差异，用户很难使用标准文档类中的代码结构来表达中文标题。于是，用户不得不对标准文档类做较大的修改。除此之外，日期格式、首行缩进、中文字号和字距等细节问题，也需要精细的调校。我们设计 CTeX 宏集的目的之一就是解决这些 LaTeX 文档的汉化难题。\n另一方面，随着 TeX 引擎和 LaTeX 宏包的不断发展，LaTeX 的中文支持方式从早期的专用系统（如 CCT）发展为适用于不同引擎的多种方式。这些方式的适用情况和使用方式有不少细节上的差异，同时操作系统的不同、语言环境的不同等客观情况又进一步带来了更多的细节差异。我们设计 CTeX 宏集的另一个主要目的就是尽可能消除这些差异带来的影响，使用户能够以一个统一的接口来使用不同的中文支持方式，使得同一份文档能够在不同环境下交换使用。\n——CTeX 宏集手册 - 第 1 节：介绍\n\nCTeX 的基础使用，我仍然推荐上面始终的入门文档。LaTeX 中文字体配置基础指南 - 知乎对我的帮助也很大。如果打算进一步自定义样式建立自己的文档类，还得沉下心来研读手册。"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html#关于-pandoc",
    "href": "posts/20221226-quarto-fantasia/index.html#关于-pandoc",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "关于 Pandoc",
    "text": "关于 Pandoc\nPandoc 其实一直致力于扩展 Markdown 的语法使其适合学术写作。TUG 2020 — John MacFarlane — Pandoc for TeXnicians 的演讲几乎涵盖了所有值得关心的问题。\n我认为 Pandoc 已有能力成为下一代学术写作的终极解决方案。语法上，Markdown 简洁易读，语法天然与格式解耦（反例是 LaTeX），而 Pandoc’s Markdown 是 Markdown 方言的集大成者，交叉引用、文献引用、图表等 Markdown 原生痛点都有很好的支持，fenced syntax 甚至可以视为 LaTeX environment 的平替；技术上，Pandoc 已经是非常成熟的格式转换工具，而 Pandoc filter 好比 LaTeX 中的 documentclass 和 style 文件，事实上实现了 Markdown 中的“宏定义”。如社区进一步发展，大部分常用 filter 能像在 LaTeX 中引用 documentclass 一样轻松获取，我们就能真正告别格式的困扰，拥抱 Pandoc’s Markdown 治下的多格式学术写作。\n从这角度来看，Quarto 似乎更像是 Jupyter、Jekyll 和一堆 Pandoc filter 的混合物（笑）"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html#关于-quarto",
    "href": "posts/20221226-quarto-fantasia/index.html#关于-quarto",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "关于 Quarto",
    "text": "关于 Quarto\nQuarto 首个 Release 距今不到 2 年，是相当年轻的项目。开发 Quarto 的团队之前主要维护 R Markdown，Quarto 是他们跳出 R 语言生态圈，将成果扩展至更广阔生态圈（如 Python）的尝试，这也意味着项目尚存不尽人意之处。把它调理成满意的模样，还真得花不少功夫。甚至让笔者开了人生首个正经 issue\n\nSunQuarTeX\n使用 Quarto，我主要有两大需求——论文多格式输出和静态博客生成。两个需求相对独立，因此有必要将离线论文输出的功能单独抽象出来。折腾的结果就是 SunQuarTeX。Quarto 原生的 HTML 输出还不错，自带目录高亮还有引用提示，稍微改改就能用了。关于自定义，Quarto 使用 SCSS 作为 CSS 生成器，意味着可以直接通过修改变量或 @extend 完成大部分工作。参考以下文档：\n\nQuarto - HTML Theming\nQuarto - More About Quarto Themes\nquarto-cli 下的 /src/resources/formats/html/bootstrap/：内有 Quarto 的 SCSS 定义，目录下还有各种官方主题的 SCSS 文件，可作参照。Tip: 善用 Github 搜索功能！\n\n我这边的修改主要是把定理做成了 callout 的样式，另外给 proof 尾部加了 QED symbol。\n难绷的是 PDF，直接生成效果可谓一言难尽……还好，与 Pandoc 相似，Quarto 提供了设置 template 的功能，可使用稍加改动的 LaTeX 文件作为生成模板，从而完全控制文章 LaTeX 的生成方式，进而控制 PDF 输出的样式。可参考以下文档食用：\n\ncomplex thesis with quarto · Discussion #2543 · quarto-dev/quarto-cli · GitHub\nQuarto - Article Templates\n\n当然，这得在已有成熟 LaTeX 模板的前提下才能进行，所以还是得会 LaTeX（笑）。使用过程中笔者也发现生成的 LaTeX 的某些细节不太合理（如 Issue #3736，详见 SunQuarTeX 仓库 README），当然也无伤大雅，且等开发团队慢慢完善吧。\n\n\nBlog\n有了前面的基础，再搭博客也就容易了。以笔者一贯的风格，博客样式都是要操刀大改的（上一个甚至直接从零手撸了 XD），这次工作却意外的少。一方面考虑到毕竟不在 CS 专业，写那么多祖传代码之后维护也是麻烦事；另一方面嘛……\n\n这，谁写的这 darkly 这主题，绿不拉几的\n看一眼\n#00bc8c，啊这样\n草\n这样啊这样\n加个背景\n……\n？\n？？？\n好像还挺配的？\n——来自考试周还在摸鱼的 sun123zxy 的惊叹\n\nlight mode 的 flatly 也还不错，直接丢上去没改了。唯一的缺憾是 Issue #3705，按开发组成员的回复来看，短期内 light mode 和 dark mode 的相互分离还不能实现。\n此外，关于代码高亮的自定义方式，可参考以下要点：\n\nQuarto - HTML Code Blocks # Highlighting\nquarto-cli 下的 /src/resources/pandoc/highlight-styles/：内有官方样式文件，可作为模板。\n行内高亮不能在 .theme 中更改，可通过覆盖 SCSS 的 $code-color 设置。"
  },
  {
    "objectID": "posts/20221226-quarto-fantasia/index.html#画廊",
    "href": "posts/20221226-quarto-fantasia/index.html#画廊",
    "title": "Jekyll 2 Quarto: Academic Writing’s not All About PDF",
    "section": "画廊",
    "text": "画廊\n\n\n\n2022/12/26 上线前夕"
  },
  {
    "objectID": "posts/20190828-editor/index.html",
    "href": "posts/20190828-editor/index.html",
    "title": "[NOIP模拟]文本编辑器 题解",
    "section": "",
    "text": "bsoj5089 文本编辑器\n题意描述\n\n九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一些功能。 \n功能列表如下：\n\n功能名称        命令格式    说明\n&lt; (move left)   &lt; w w   为一个字符，“L”或“R”，表示左光标还是右光标（下同）。该命令将选定光标向左移动，如果已经是最左端则不移动。命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。\n&gt; (move right)  &gt; w w   同上。与&lt; 命令不同的是，该命令将光标向右移动。命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。\nI (insert)      I w c   同上。c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。该命令始终输出“T”。\nD (delete)      D w w   同上。代表删除该光标右侧的一个字符。命令执行成功时输出“T”，若光标右侧没有字符输出“F”。\nR (reverse) R           代表翻转左光标和右光标之间的字符。该命令只有左光标在右光标左侧时才能执行。（两光标重合时也不能执行）命令执行成功时输出“T”，否则输“F”。\nS (show)    S           代表显示当前处理的文本。该命令只输出文本，不输出“T”和“F”。\n开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。\n\n注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。\n\n输入格式\n\n第一行是初始时文本编辑器内容。\n\n第二行是一个正整数 N，N 表示操作次数。\n\n接下来有 N 行，每行有一个命令，命令格式如上方表格。\n\n输出格式\n\n对于每个命令，按上方表格要求执行并输出。\n\n样例输入\n\ngoodykc \n11 \nI R u \nI R l \n&gt; L \n&gt; L \n&gt; L \n&gt; L \nR \nD R \n&lt; R \nD R \nS\n\n样例输出\n\nT \nT \nT \nT \nT \nT \nT \nF \nT \nT \ngoodluck\n\n样例解释\n\n[goodykc] \n[goodykcu] \n[goodykcul] \ng[oodykcul] \ngo[odykcul] \ngoo[dykcul] \ngood[ykcul] \ngood[lucky] \ngood[lucky]（光标右边没有字符，失败删除） \ngood[luck]y \ngood[luck] \ngoodluck\n\n数据规模与约定\n\n对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作；\n另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 105，数据不包含翻转（Reverse）操作；\n另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 105，数据包含翻转（Reverse）操作；\n对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 106，输出文件大小 ≤ 20MB;\n没找到这道题的出处\n我不知道为啥有人用splay还有什么双端队列做这道题\n反正我考场一看这题就兴奋了\n这不直接双向链表暴搞吗\nReverse就直接这样接一下就没了\n\n\n\nrev\n\n\n不过这样将让双向链表无法判断左右方向，那就直接将双向链表变成无向的，指针记录真实的在左边的那个节点的编号，这样就像遍历树那样可以判方向了\n考场3kb 70pt，考后+2kb 加上了rev操作\n代码权当纪念，诸位看看笑笑就好\n反正我是已经看不懂了:p\n各种结构体引用三目运算符函数混乱毫无可读性的5kb代码\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\nusing namespace std;\nconst int INF=999999999;\n\nconst int MXN=8E6+5;\n\nstruct Node{\n    int v1,v2;\n    char c;\n}nd[MXN];int pN;\nstruct Pter{\n    int id,pre;\n    /*void Debug(){\n        cout&lt;&lt;\"Pter:\"&lt;&lt;id&lt;&lt;\"#\"&lt;&lt;pre&lt;&lt;endl;\n    }*/\n}p1,p2;\nPter Copy(Pter& A){\n    Pter B=(Pter){A.id,A.pre};\n    return B;\n}\nbool IsOK(Pter p){\n    if(p.id==0||(p.id==INF&&p.pre==INF)) return 0;\n    return 1;\n}\n\nchar str[MXN];int rpL,rpR;\nvoid Build(){\n    int sLen=strlen(str);pN=sLen;\n    for(int i=1;i&lt;sLen;i++) nd[i].v2=i+1;\n    for(int i=2;i&lt;=sLen;i++) nd[i].v1=i-1;\n    nd[1].v1=0;nd[sLen].v2=INF;\n    for(int i=1;i&lt;=sLen;i++) nd[i].c=str[i-1];\n    nd[0].v1=-INF,nd[0].v2=1;\n    p1.id=1;p1.pre=0;\n    p2.id=INF;p2.pre=sLen;\n    \n    rpL=1;rpR=strlen(str)+1;\n}\nPter Left(Pter& nw){\n    int le=nw.pre;\n    if(le==0) return (Pter){0,0};\n    int lele=(nd[le].v1!=nw.id)?nd[le].v1:nd[le].v2;\n    Pter p=(Pter){le,lele};\n    return p;\n}\nPter Right(Pter& nw){\n    int id=nw.id;if(id==INF) return (Pter){INF,INF};\n    int ri=(nd[id].v1==nw.pre)?nd[id].v2:nd[id].v1;\n    Pter p=(Pter){ri,id};\n    return p;\n}\nvoid Ins(Pter& nw,char c){\n    pN++;nd[pN].c=c;\n    int id=nw.id;\n    Pter le=Left(nw);\n    nd[pN].v1=le.id;nd[pN].v2=nw.id;\n    \n    int& leR=(nd[le.id].v1==id?nd[le.id].v1:nd[le.id].v2);\n    leR=pN;\n    \n    if(IsOK(Right(nw))){\n        int& nwL=(nd[id].v1==nw.pre?nd[id].v1:nd[id].v2);\n        nwL=pN;\n    }\n    nw.pre=pN;\n}\nbool Del(Pter& nw){\n    if(nw.id==INF){printf(\"F\");return 0;}\n    Pter le=Left(nw);\n    Pter ri=Right(nw);\n    \n    int& leR=(nd[le.id].v1==nw.id?nd[le.id].v1:nd[le.id].v2);\n    leR=ri.id;\n    \n    if(IsOK(Right(ri))){\n        int& riL=(nd[ri.id].v1==nw.id?nd[ri.id].v1:nd[ri.id].v2);\n        riL=le.id;\n    }\n    nw.id=ri.id;\n    nw.pre=le.id;\n    printf(\"T\");\n    return 1;\n}\nvoid Rev(){\n    Pter L=Copy(p1);\n    Pter LL=Left(L);\n    Pter RR=Copy(p2);\n    Pter R=Left(RR);\n    //cout&lt;&lt;L.id&lt;&lt;\",\"&lt;&lt;LL.id&lt;&lt;\"#\"&lt;&lt;R.id&lt;&lt;\",\"&lt;&lt;RR.id&lt;&lt;\"###\";\n    int& leleR=(nd[LL.id].v1==L.id?nd[LL.id].v1:nd[LL.id].v2);\n    leleR=R.id;\n    \n    int& leL  =(nd[L.id].v1==LL.id?nd[L.id].v1:nd[L.id].v2);\n    leL=RR.id;\n    \n    if(IsOK(Right(RR))){\n        int& ririL=(nd[RR.id].v1==R.id?nd[RR.id].v1:nd[RR.id].v2);\n        ririL=L.id;\n    }\n    int& riR  =(nd[R.id].v1==RR.id?nd[R.id].v1:nd[R.id].v2);\n    riR=LL.id;\n    \n    \n    p1.id=R.id;\n    p2.pre=L.id;\n}\nvoid Print(){\n    Pter p=(Pter){nd[0].v2,0};\n    while(IsOK(Right(p))){//p.Debug();\n        printf(\"%c\",nd[p.id].c);\n        p=Right(p);\n        \n    }\n}\n\nint main(){\n    scanf(\"%s\",str);\n    Build();\n    int qN;cin&gt;&gt;qN;\n    for(int i=1;i&lt;=qN;i++){\n        char typ[2];scanf(\"%s\",typ);\n        char wch[2],ccc[2];\n        switch(typ[0]){\n             case '&lt;':{//cout&lt;&lt;\"#\";\n                scanf(\"%s\",wch);Pter& p=(wch[0]=='L')?p1:p2;\n                Pter lp=Left(p);\n                if(!IsOK(lp)) printf(\"F\");\n                else{\n                    printf(\"T\");\n                    p=lp;\n                    ((wch[0]=='L')?rpL:rpR) --;\n                }\n                //p.Debug();\n                break;\n            }case '&gt;':{//cout&lt;&lt;\"V\";\n                scanf(\"%s\",wch);Pter& p=(wch[0]=='L')?p1:p2;\n                Pter rp=Right(p);\n                if(!IsOK(rp)) printf(\"F\");\n                else{\n                    printf(\"T\");\n                    p=rp;\n                    ((wch[0]=='L')?rpL:rpR) ++;\n                }\n                //p.Debug();\n                break;\n            }case 'I':{\n                scanf(\"%s\",wch);Pter& p=(wch[0]=='L')?p1:p2;\n                Pter& otr=(wch[0]=='L')?p2:p1;\n                int& ooo=(wch[0]=='L')?rpL:rpR;\n                int& ppp=(wch[0]=='L')?rpR:rpL;\n                scanf(\"%s\",ccc);char c=ccc[0];\n                int bomb=0;\n                if(p.id==otr.id&&p.pre==otr.pre) bomb=1;\n                Ins(p,c);\n                printf(\"T\");\n                if(bomb==1) otr.id=p.id,otr.pre=p.pre;\n                if(ooo&lt;=ppp) ppp++;\n                ooo++;\n                break;\n            }case 'D':{\n                scanf(\"%s\",wch);Pter& p=(wch[0]=='L')?p1:p2;\n                Pter& otr=(wch[0]=='L')?p2:p1;\n                int& ooo=(wch[0]=='L')?rpL:rpR;\n                int& ppp=(wch[0]=='L')?rpR:rpL;\n                int bomb=0;\n                if(p.id==otr.id&&p.pre==otr.pre) bomb=1;\n                else if(otr.pre==p.id) bomb=2;\n                bool isSuc=Del(p);\n                if(bomb==1) otr.id=p.id,otr.pre=p.pre;\n                else if(bomb==2) otr.pre=p.pre;\n                //p.Debug();otr.Debug();\n                if(isSuc){\n                    if(ooo&lt;ppp) ppp--;\n                }\n                break;\n            }case 'R':{\n                //printf(\"F\");\n                if(rpL&lt;rpR){\n                    Rev();\n                    printf(\"T\");\n                }else{\n                    printf(\"F\");\n                } \n                break;\n            }case 'S':{\n                Print();\n                break;\n            }\n        }\n        //cout&lt;&lt;p1.id&lt;&lt;','&lt;&lt;p1.pre&lt;&lt;\"|\"&lt;&lt;p2.id&lt;&lt;\",\"&lt;&lt;p2.pre&lt;&lt;endl;\n        //cout&lt;&lt;\"!\"&lt;&lt;rpL&lt;&lt;','&lt;&lt;rpR;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n/*\nab\n111\nR\nS\n\ngoodykc\n11\nI R u\nI R l\n&gt; L\n&gt; L\n&gt; L\n&gt; L\nR\nD R\n&lt; R\nD R\nS\n*/"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html",
    "href": "posts/20191117-csps2019travel/index.html",
    "title": "CSP-S2019游记",
    "section": "",
    "text": "初赛。\n感觉比去年水很多啊，出来人均90+的样子，咕分80+的我瑟瑟发抖\n所以CSP要比NOIP简单？ flag x1\n终测貌似比估分高了一点，但复赛线六十几也太离谱了吧？"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day--26",
    "href": "posts/20191117-csps2019travel/index.html#day--26",
    "title": "CSP-S2019游记",
    "section": "",
    "text": "初赛。\n感觉比去年水很多啊，出来人均90+的样子，咕分80+的我瑟瑟发抖\n所以CSP要比NOIP简单？ flag x1\n终测貌似比估分高了一点，但复赛线六十几也太离谱了吧？"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day--12",
    "href": "posts/20191117-csps2019travel/index.html#day--12",
    "title": "CSP-S2019游记",
    "section": "Day -12",
    "text": "Day -12\n停课了。\n学校给我们年级搞OI的单独腾出来一个机房用，卸sb自带软件装电脑装了一晚上\n似乎被分配到了绝佳摸鱼位？"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day--9",
    "href": "posts/20191117-csps2019travel/index.html#day--9",
    "title": "CSP-S2019游记",
    "section": "Day -9",
    "text": "Day -9\n毒瘤xinyue天天省选CSP-S模拟\n喂喂提高组有这么难吗 flag x2"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day--6",
    "href": "posts/20191117-csps2019travel/index.html#day--6",
    "title": "CSP-S2019游记",
    "section": "Day -6",
    "text": "Day -6\n完成成就：第一次线下联机打则\n机房存在的价值不就在于局域网吗\n格斗苦手不敢参战太久，大部分时间都在看LF咲夜吊打disangan233（"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day--4",
    "href": "posts/20191117-csps2019travel/index.html#day--4",
    "title": "CSP-S2019游记",
    "section": "Day -4",
    "text": "Day -4\n妖妖梦EX初通！\n激动的调到Extra Start发现并没有PH，，，\n好像还没有收完60张符卡不能解锁啊\n然后继续颓颓颓（\n跑题了\n“游”记"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day--2",
    "href": "posts/20191117-csps2019travel/index.html#day--2",
    "title": "CSP-S2019游记",
    "section": "Day -2",
    "text": "Day -2\n考前信心赛。\nt1水过马上去开t3然后看错题意，以为是个sb树上差分+倍增题就敲了，然后死活调不过大样例。寻思我过了小样例，不太可能是题意看错了吧，然后就硬钢2h无果，t2 sb换根dp水了个暴力就滚粗了…\n机房倒数第一，信心赛成功爆炸 :(\n有一个神奇的小插曲，考试的时候班主任（halfway）来给我们CSP-S壮行，一个彪形大汉一脚踹开大门就是一声：“同学们——”，身后是一群同样剽悍的其他竞赛的同学…\nFBI OPEN THE DOOR\n彩6既视感\n总之，剽悍的班主任发给我们每人一根士力架和一瓶样式独特的可口可乐，扬长而去…\n\n\n\n样式独特\n\n\n这可乐没啥味道啊跟白水一样"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day--1",
    "href": "posts/20191117-csps2019travel/index.html#day--1",
    "title": "CSP-S2019游记",
    "section": "Day -1",
    "text": "Day -1\n怎么你们人人都在制造恐慌啊都在复习些啥啊CSP考FFTNTT吗害人不浅啊你们这些神仙啊啊啊"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day-0",
    "href": "posts/20191117-csps2019travel/index.html#day-0",
    "title": "CSP-S2019游记",
    "section": "Day 0",
    "text": "Day 0\n\n上午\n开始还比较正常，然后jzp突然叫我们去帮着把电脑搬到CSP-S的考场去——\n蛤？？？\n回来气氛就变得沙雕起来，xinyue和jzp让我们到机房外的白板上签名留念\n\n\n\n签名墙\n\n\n也许有些人后天过后就见不到了，珍惜当下的时光吧…\n\n\n中午\n机房变网吧.jpg\n\n\n下午\n两点钟坐车去试机。\n随便敲了个线段树，居然把PushDown给忘掉了，有被菜到。左顾右盼一波，旁边有神仙10min切了LCT…\n害怕.jpg\n和吸取教训，p9t6g，Waper去看了初中老师，班主任让我们飞黄腾达了过后回去修理一下他们班现在跳的一批的信竞生？？？"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day-1",
    "href": "posts/20191117-csps2019travel/index.html#day-1",
    "title": "CSP-S2019游记",
    "section": "Day 1",
    "text": "Day 1\n差评，没有发面包（\n没错我考CSP就是冲着这个来的\n压缩包密码“认真思考”，分不清O和0输错了好多次\nt1瞪了10min切了\nt2看上去有点意思，想到了最基础的dp，然后发现要整体移动，但居然没有想出来怎么搞。换个思路想觉得可以只关心在\\(0\\)哪里的dp值，这样就可以不用dp，直接从每个点往上跳，把时间复杂度优化到与树高相关。然后又想了想，似乎可以倍增找断点然后主席树或者离线维护一个桶。自己感觉不太稳，就先水50pt去看t3了\nt3一股不可做的样子，，看暴力吧\n\\(n!\\)的10pt肯定能拿吧，链的数据也可以骗吧\n开始敲了\n诶这链怎么这么难写啊\n看了看数据范围突然想到退火，然后就弃掉了链开始敲敲敲\n调了好久好久，样例1 \\(T=1\\)正确率总是极低..\nt3爆0，我怕是没了啊\n回去测了t2的链的大样例 114514什么鬼 ，发现本地居然只跑了10s，然而好像并不能改变什么…\n剩下20min检查文件，安静的坐着胡思乱想\n话说这个t2大样例如此优秀，这个t3这么毒瘤，是不是今年的出题人都很年轻鸭？\n出了考场发现人均200+，有点小失落\nt1卡ull啊那我5分没了\nt2移位直接指针移位回溯复原就可以了啊，真就考场智商减半吗，，，\n我们这里的集训队爷好像都没做起t3，这啥神仙题啊\n这场的t3倒是让我发现退火并没有想象中的万能，总结了一些不太适合用退火的题型，学到了（\n嗯，一股省选气息\n不管，继续颓TH（"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#day-2",
    "href": "posts/20191117-csps2019travel/index.html#day-2",
    "title": "CSP-S2019游记",
    "section": "Day 2",
    "text": "Day 2\n差评，还是没有发面包（\n密码是“抓紧时间”。\n看着t1一脸懵，感觉连骗分都有点虚，就开了t2。随便想了个\\(O(n^3)\\)的区间划分dp，感觉还可以优化，然后开了t3。40pt的白送\\(O(n^2)\\)和15pt的链好像很好骗的样子，就开始写t3——\n结果链就给写崩了，调了整整30min…\n回头看t2，先写了\\(O(n^3)\\)的dp，然后发现决策好像是单调的，单调移动指针维护后缀min即可\\(O(n^2)\\)，写了会儿就过了大样例。\n又回头看t1，突然发现好像用沙雕五维dp就可以有64pt了，就rush了一波，竟然没怎么调就过了。\n还剩20min，估计差不多就这样了。\n观察了一下四周，右手边的老哥打开了画图画了只草泥马？？？\n三道暴力滚粗。\nt1比大众暴力少骗了二十分，t3没打二叉树，爆炸\nday2还是挺有区分度的，巨佬们估计考的不错吧"
  },
  {
    "objectID": "posts/20191117-csps2019travel/index.html#赛后",
    "href": "posts/20191117-csps2019travel/index.html#赛后",
    "title": "CSP-S2019游记",
    "section": "赛后",
    "text": "赛后\n花了20%的钱参加了一场NOI\n江西花了10%的钱参加了两场NOI\n听说今年的普及组挺简单的？\n\n赛后的某个星期天 记"
  },
  {
    "objectID": "posts/20230418-complexity/index.html",
    "href": "posts/20230418-complexity/index.html",
    "title": "一些数论算法的时间复杂度分析",
    "section": "",
    "text": "其实不少高等数学 / 数学分析教材在讲解无穷小的比较时已经相当严谨地介绍过大 O、小 O 记号，然而各种历史习惯记法的符号滥用（abuse of notation）[1] 直到现在都让笔者头疼. These notations seem to be innocent, but can be catastrophic without careful manipulation. 例如\n\n\n\n\n\n\n\nExample 1 (反例 1) \\[\nn = O(n^2) \\land n^2 = O(n^2) \\implies n = n^2\n\\]\n\n\n\n\nKnuth 在《具体数学》里举出的例子 [2]. “\\(=\\)” 隐含的对称性使其在 \\(g(x) = O(f(x))\\) 中格格不入. 事实上，将 \\(O(f(x))\\) 看作“阶不高于 \\(f(x)\\) 的所有函数的集合”是比“某个阶不高于 \\(f(x)\\) 的函数”更严谨的理解. 因此，本文将使用 \\(f(x) \\in O(g(x))\\) （有时也记为 \\(O(f(x)) \\subset O(g(x))\\)）的集合论符号代替传统的 \\(f(x) = O(g(x))\\) 记法.\n\n\n\n\n\n\n\nExample 2 (反例 2) \\[\nn^2 \\sin n \\in O(n^2) \\implies \\sum_{i=1}^n i^2 \\sin i \\in \\sum_{i=1}^n O(i^2) \\subset O\\left( \\sum_{i=1}^n i^2 \\right) \\subset O(n^3)\n\\] 或更一般的， \\[\ng(x) \\in O(f(x)) \\implies \\sum_{P(n,i)} g(i) \\in \\sum_{P(n,i)} O(f(i)) \\subset O \\left(\\sum_{P(n,i)} f(i) \\right)\n\\]\n\n\n\n\n没看出有啥问题，对吧？笔者在写作此文时犯了同样的错误. 请注意，大 O 记号的作用对象是函数，\\(f(i)\\) 是什么？它只是个函数值，是确定的数——这是因为 \\(i\\) 也是求和枚举中确定的数，而不是 \\(n\\) 这种真正代表变元的记号. 所以 \\(O(f(i))\\) 是什么？它什么也不是.\n这种错误的出现是在所难免的，我们太习惯用 \\(x\\)、\\(x^3 + 5 x^2 + x\\) 这种变元都不明确的记号来表示函数了[1]. 写成 \\(f(x)\\) 也不严谨，因为只有 \\(f\\) 才应代表函数本身，\\(f(x)\\) 只能是函数值. 这样我们就可以放心地写下 \\(O(f)\\)，不用担心把变元与确定值弄混了.\n然而大家还是喜欢写 \\(O(n^2)\\) 和 \\(O(e^{n^2})\\)，而不是奇怪的 \\(O(\\mathrm{id}^2)\\) 和 \\(O(\\mathrm{exp} \\circ {\\mathrm{id}^2})\\). 所以，我们大概只能沿用这种不太严谨的记号，并时刻提醒自己加倍小心了. （形如 \\(x \\mapsto e^{x^2}\\) 的 \\(\\lambda\\) 风格“匿名函数”记号可能更好？）\n但上述命题从结论上是正确的. 正确的推导过程应为 \\[\n\\sum_{P(n,i)} g(i) \\leq \\sum_{P(n,i)} C f(i) \\leq C \\sum_{P(n,i)} f(i) \\in O \\left(\\sum_{P(n,i)} f(i) \\right)\\\n\\] 第一步是直接由大 O 记号的定义得到的结果.\nWikipedia [3] 中有一张详尽的表格介绍了各种渐进符号的定义，OI Wiki [4] 上也有极好的讲解，尚不熟练的读者可以参考. 有兴趣仔细研究的读者可以参考《具体数学》第九章 [2]、Wikipedia 及其 reference（个人推荐 Knuth 关于 \\(O\\)、\\(\\Omega\\)、\\(\\Theta\\) 的短文 [5]）. 本文除用 “\\(\\in\\)” 和“\\(\\subset\\)”替代 “\\(=\\)” 外，完全使用 Knuth 提议的记号体系.\n\n\n\n调和级数的部分和 \\(H(n)\\) 定义为 \\[\nH(n) = \\sum_{i=1}^n \\frac 1 i\n\\] 通过一些与 \\(e\\) 有关的数列放缩可以证明 \\(\\lim_{n \\to \\infty} ( H(n) - \\log n ) = c\\)，其中 \\(c \\approx 0.577\\) 是 Euler 常数. 因此 \\(H(n) \\sim \\log n \\in \\Theta(\\log n)\\).\n\n\n\n\\(p\\) - 级数可视为调和级数的推广. 其部分和定义为 \\(P_p(n) = \\sum_{i=1}^n i^{-p}\\)．\\(p\\) - 级数具有如下性质：\n\n当 \\(p &gt; 1\\) 时，\\(p\\) - 级数收敛；\n当 \\(p = 1\\) 时，\\(p\\) - 级数是调和级数；\n当 \\(-\\infty &lt; p &lt; 1\\) 时，我们指出 \\(P_p(n) \\sim \\frac{1}{1-p} n^{1-p} \\in \\Theta(n^{1-p})\\)\n\n\\(-\\infty &lt; p &lt; 1\\) 时 \\(p\\) - 级数的渐进估计可以从连续幂函数积分的角度理解. 证明这渐进性，离散情况下，可对 \\(n^p\\) 差分后前缀和 + 二项式定理得到高次项系数，或可用离散微积分理论得到精确表示（参见《具体数学》[6]）；连续情况下，Lagrange 中值定理应为较简单的估计方法. 这里从略. 总之，我们得到： \\[\nP_p(n) \\in \\begin{cases}\n\\Theta(n^{1-p}) & p &lt; 1 \\\\\n\\Theta(\\log n) & p = 1 \\\\\n\\Theta(1) & p &gt; 1\n\\end{cases}\n\\]"
  },
  {
    "objectID": "posts/20230418-complexity/index.html#预备",
    "href": "posts/20230418-complexity/index.html#预备",
    "title": "一些数论算法的时间复杂度分析",
    "section": "",
    "text": "其实不少高等数学 / 数学分析教材在讲解无穷小的比较时已经相当严谨地介绍过大 O、小 O 记号，然而各种历史习惯记法的符号滥用（abuse of notation）[1] 直到现在都让笔者头疼. These notations seem to be innocent, but can be catastrophic without careful manipulation. 例如\n\n\n\n\n\n\n\nExample 1 (反例 1) \\[\nn = O(n^2) \\land n^2 = O(n^2) \\implies n = n^2\n\\]\n\n\n\n\nKnuth 在《具体数学》里举出的例子 [2]. “\\(=\\)” 隐含的对称性使其在 \\(g(x) = O(f(x))\\) 中格格不入. 事实上，将 \\(O(f(x))\\) 看作“阶不高于 \\(f(x)\\) 的所有函数的集合”是比“某个阶不高于 \\(f(x)\\) 的函数”更严谨的理解. 因此，本文将使用 \\(f(x) \\in O(g(x))\\) （有时也记为 \\(O(f(x)) \\subset O(g(x))\\)）的集合论符号代替传统的 \\(f(x) = O(g(x))\\) 记法.\n\n\n\n\n\n\n\nExample 2 (反例 2) \\[\nn^2 \\sin n \\in O(n^2) \\implies \\sum_{i=1}^n i^2 \\sin i \\in \\sum_{i=1}^n O(i^2) \\subset O\\left( \\sum_{i=1}^n i^2 \\right) \\subset O(n^3)\n\\] 或更一般的， \\[\ng(x) \\in O(f(x)) \\implies \\sum_{P(n,i)} g(i) \\in \\sum_{P(n,i)} O(f(i)) \\subset O \\left(\\sum_{P(n,i)} f(i) \\right)\n\\]\n\n\n\n\n没看出有啥问题，对吧？笔者在写作此文时犯了同样的错误. 请注意，大 O 记号的作用对象是函数，\\(f(i)\\) 是什么？它只是个函数值，是确定的数——这是因为 \\(i\\) 也是求和枚举中确定的数，而不是 \\(n\\) 这种真正代表变元的记号. 所以 \\(O(f(i))\\) 是什么？它什么也不是.\n这种错误的出现是在所难免的，我们太习惯用 \\(x\\)、\\(x^3 + 5 x^2 + x\\) 这种变元都不明确的记号来表示函数了[1]. 写成 \\(f(x)\\) 也不严谨，因为只有 \\(f\\) 才应代表函数本身，\\(f(x)\\) 只能是函数值. 这样我们就可以放心地写下 \\(O(f)\\)，不用担心把变元与确定值弄混了.\n然而大家还是喜欢写 \\(O(n^2)\\) 和 \\(O(e^{n^2})\\)，而不是奇怪的 \\(O(\\mathrm{id}^2)\\) 和 \\(O(\\mathrm{exp} \\circ {\\mathrm{id}^2})\\). 所以，我们大概只能沿用这种不太严谨的记号，并时刻提醒自己加倍小心了. （形如 \\(x \\mapsto e^{x^2}\\) 的 \\(\\lambda\\) 风格“匿名函数”记号可能更好？）\n但上述命题从结论上是正确的. 正确的推导过程应为 \\[\n\\sum_{P(n,i)} g(i) \\leq \\sum_{P(n,i)} C f(i) \\leq C \\sum_{P(n,i)} f(i) \\in O \\left(\\sum_{P(n,i)} f(i) \\right)\\\n\\] 第一步是直接由大 O 记号的定义得到的结果.\nWikipedia [3] 中有一张详尽的表格介绍了各种渐进符号的定义，OI Wiki [4] 上也有极好的讲解，尚不熟练的读者可以参考. 有兴趣仔细研究的读者可以参考《具体数学》第九章 [2]、Wikipedia 及其 reference（个人推荐 Knuth 关于 \\(O\\)、\\(\\Omega\\)、\\(\\Theta\\) 的短文 [5]）. 本文除用 “\\(\\in\\)” 和“\\(\\subset\\)”替代 “\\(=\\)” 外，完全使用 Knuth 提议的记号体系.\n\n\n\n调和级数的部分和 \\(H(n)\\) 定义为 \\[\nH(n) = \\sum_{i=1}^n \\frac 1 i\n\\] 通过一些与 \\(e\\) 有关的数列放缩可以证明 \\(\\lim_{n \\to \\infty} ( H(n) - \\log n ) = c\\)，其中 \\(c \\approx 0.577\\) 是 Euler 常数. 因此 \\(H(n) \\sim \\log n \\in \\Theta(\\log n)\\).\n\n\n\n\\(p\\) - 级数可视为调和级数的推广. 其部分和定义为 \\(P_p(n) = \\sum_{i=1}^n i^{-p}\\)．\\(p\\) - 级数具有如下性质：\n\n当 \\(p &gt; 1\\) 时，\\(p\\) - 级数收敛；\n当 \\(p = 1\\) 时，\\(p\\) - 级数是调和级数；\n当 \\(-\\infty &lt; p &lt; 1\\) 时，我们指出 \\(P_p(n) \\sim \\frac{1}{1-p} n^{1-p} \\in \\Theta(n^{1-p})\\)\n\n\\(-\\infty &lt; p &lt; 1\\) 时 \\(p\\) - 级数的渐进估计可以从连续幂函数积分的角度理解. 证明这渐进性，离散情况下，可对 \\(n^p\\) 差分后前缀和 + 二项式定理得到高次项系数，或可用离散微积分理论得到精确表示（参见《具体数学》[6]）；连续情况下，Lagrange 中值定理应为较简单的估计方法. 这里从略. 总之，我们得到： \\[\nP_p(n) \\in \\begin{cases}\n\\Theta(n^{1-p}) & p &lt; 1 \\\\\n\\Theta(\\log n) & p = 1 \\\\\n\\Theta(1) & p &gt; 1\n\\end{cases}\n\\]"
  },
  {
    "objectID": "posts/20230418-complexity/index.html#约数函数-sigma_zn",
    "href": "posts/20230418-complexity/index.html#约数函数-sigma_zn",
    "title": "一些数论算法的时间复杂度分析",
    "section": "1 约数函数 \\(\\sigma_z(n)\\)",
    "text": "1 约数函数 \\(\\sigma_z(n)\\)\n约数函数（Divisor Function，也可称为除数函数、因数函数）是与 \\(n\\) 的因子有关的一类函数，定义为 \\(\\sigma_z(n) = \\sum_{d \\mid n} d^z\\)．当 \\(z=0\\) 时，\\(\\sigma_0(n)\\) 被称为约数个数函数（number-of-divisors function），常被记为 \\(d(n)\\) 或 \\(\\tau(n)\\). 当 \\(z=1\\) 时，\\(\\sigma_1(n)\\) 被称为约数和函数（sum-of-divisors function），常直接记为 \\(\\sigma(n)\\).\n\n\n\n\n\n\n\nExample 3 估计 \\(\\sigma_0 (n)\\) 的渐进上界.\n\n\n\n\n也就是估计 \\(n\\) 的因子的数量. 一个广为人知的上界是 \\(2 \\sqrt n\\)，因为 \\(n\\) 的所有小于 \\(\\sqrt n\\) 的因子 \\(d\\) 均与另一因子 \\(\\frac n d\\) 一一对应.\n\nRemark. 事实上进一步可以证明 \\(\\sigma_0(n) \\in o(n^\\epsilon) \\quad \\forall \\epsilon &gt; 0\\)，或更精确的，\\(\\sigma_0(n) \\in O(n^{\\log 2 / \\log \\log n})\\) [7]．这一点说明，在实现与枚举因子有关的算法时，虽然仍会从 \\(1\\) 枚举至 \\(\\sqrt n\\) 探测因子，但真正参与计算的因子其实相当少．因此，这些算法的实际表现往往极大程度地优于按 \\(\\sigma_0(n) \\in O(\\sqrt n)\\) 估计的理论时间复杂度．\n\n\n\n\n\n\n\n\nExample 4 估计 \\(\\hat{\\sigma_0}(n) = \\sum_{i=1}^n \\sigma_0 (i)\\) 的渐进上界.\n\n\n\n\n即估计 \\(1\\) 到 \\(n\\) 中所有数因子个数的和. 这是一个形式上鲜为人知但其应用广为人知的例子. 变换求和顺序，容易得到 \\[\n\\hat{\\sigma_0}(n) = \\sum_{i=1}^n \\sigma_0 (i)\n= \\sum_{i=1}^n \\sum_{d \\mid i} 1\n= \\sum_{d=1}^n \\left\\lfloor \\frac n d \\right\\rfloor\n\\leq \\sum_{d=1}^n \\frac n d\n= n H(n) \\in O(n \\log n)\n\\]\n显然，这比 \\(O(n \\sqrt n)\\) 的平凡估计好上不少. 本例的思路不仅是埃氏筛（Sieve of Eratosthenes）的理论基础，也在杜教筛、快速 Mobius 变换、\\(\\gcd\\) 卷积 [8] 等处出现.\n进一步利用此技巧和 \\(p\\) - 级数的估计，我们甚至能在仔细研究 \\(\\sigma_z(n)\\) 前就得到其前缀和的渐进估计：\n\n\n\n\n\n\n\nExample 5 估计 \\(\\hat{\\sigma_z}(n) = \\sum_{i=1}^n \\sigma_z (i)\\) 的渐进上界.\n\n\n\n\n\\[\n\\begin{aligned}\n\\hat{\\sigma_z}(n)\n&= \\sum_{i=1}^n \\sigma_z (i)\n= \\sum_{i=1}^n \\sum_{d \\mid i} d^z\n= \\sum_{d=1}^n d^z \\left\\lfloor \\frac n d \\right\\rfloor \\\\\n&\\leq n \\sum_{d=1}^n d^{z-1}\n= n P_{1-z}(n)\n\\in \\begin{cases}\nO(n^{z+1}) & z &gt; 0 \\\\\nO(n \\log n) & z = 0 \\\\\nO(n) & z &lt; 0\n\\end{cases}\n\\end{aligned}\n\\]\n遗憾的是，对此前缀和做差分并不能得到 \\(\\sigma_z(n)\\) 的优秀估计.\n现在引入一个重要放缩技巧，其在后续估计中屡试不爽.\n\n\n\n\n\n\n\nProposition 1 \\[\n\\sum_{d \\mid n} f(d) \\leq \\sum_{i=1}^n f (\\left\\lfloor \\frac n i \\right\\rfloor)\n\\]\n\n\n\n\n右式比左式多算了 \\(i \\nmid n\\) 的项，因此命题是正确的. 但我们还可以做得更好：\n\n\n\n\n\n\n\nProposition 2 \\[\n\\sum_{d \\mid n} f(d) \\leq \\sum_{i=1}^{\\sqrt n} f(i) + f(\\left\\lfloor \\frac n i \\right\\rfloor)\n\\]\n\n\n\n\n\\(\\sqrt n\\) 分治. 我们其实已经在 Example 3 估计 \\(\\sigma_0(n)\\) 时用过此技巧了.\n\n\n\n\n\n\n\nExample 6 估计 \\(\\sigma_1 (n)\\) 的渐进上界.\n\n\n\n\n用 Proposition 1： \\[\n\\sigma_1 (n)\n= \\sum_{d \\mid n} d \\leq \\sum_{i=1}^n \\left\\lfloor \\frac n i \\right\\rfloor \\leq n H(n) \\in O(n \\log n)\n\\]\n可以证明用 Proposition 2 不会得到更优的结果.\n我们发现了一个有趣的事实：\\(\\sigma_1 (n)\\) 和 \\(\\hat{\\sigma_0}(n)\\) 的渐进上界均为 \\(O(n \\log n)\\).\n\n\n\n\n\n\n\nExample 7 估计 \\(\\sigma_z (n)\\) 的渐进上界.\n\n\n\n\n用 Proposition 2 和 \\(p\\) - 级数的性质： \\[\n\\begin{aligned}\n\\sigma_z (n)\n&= \\sum_{d \\mid n} d^z\n\\leq \\sum_{i=1}^{\\sqrt n} i^z + \\left\\lfloor \\frac n i \\right\\rfloor^z \\\\\n&\\leq \\begin{cases}\n\\displaystyle 2 \\sum_{i=1}^{\\sqrt n} \\left\\lfloor \\frac n i \\right\\rfloor^z \\leq 2 n^z \\sum_{i=1}^{\\sqrt n} i^{-z} & = 2 n^z P_z(\\sqrt n) & z \\geq 0\\\\\n\\displaystyle 2 \\sum_{i=1}^{\\sqrt n} i^z & = 2 P_{-z}(\\sqrt n)  & z &lt; 0\n\\end{cases} \\\\\n\\in & \\begin{cases}\n2 n^z O(1) & z &gt; 1 \\\\\n2 n O(\\log \\sqrt n) & z = 1 \\\\\n2 n^z O(n^{\\frac {1-z} 2}) & 0 \\leq z &lt; 1 \\\\\n2 O(n^{\\frac {1+z} 2}) & -1 &lt; z &lt; 0 \\\\\n2 O(\\log \\sqrt n) & z = -1 \\\\\n2 O(1) & z &lt; -1\n\\end{cases}\n= \\begin{cases}\nO(n^z) & z &gt; 1 \\\\\nO(n \\log n) & z = 1 \\\\\nO(n^{\\frac {1+z} 2}) & -1 &lt; z &lt; 1 \\\\\nO(\\log n) & z = -1 \\\\\nO(1) & z &lt; -1\n\\end{cases}\n\\end{aligned}\n\\]\n这是一个相当优秀的渐进上界. 值得关注的是：\n\n当 \\(z=0\\) 时，\\(\\sigma_0(n) \\in O(n^{\\frac 1 2})\\). 这与 Example 3 的结果一致.\n当 \\(z=\\frac 1 2\\) 时，\\(\\sigma_{\\frac 1 2}(n) \\in O(n^{\\frac 3 4})\\)，即 \\(\\sum_{d \\mid n} \\sqrt d \\in O(n^{\\frac 3 4})\\). 洛谷 P4980 Polya 定理模板题 [9] 的一种比较 trivial 的解法 [10] 的时间复杂度证明就来源于此. 我们之后还会在整除分块与杜教筛中见到它.\n\n另外，如果只使用 Proposition 1 ，\\(-1&lt;z&lt;1\\) 部分的渐进上界将只能估计至 \\(O(n)\\). 因此 Proposition 2 是更为优越的.\n约数函数更复杂的上限与渐进估计可参考 Wikipedia [7]."
  },
  {
    "objectID": "posts/20230418-complexity/index.html#整除分块",
    "href": "posts/20230418-complexity/index.html#整除分块",
    "title": "一些数论算法的时间复杂度分析",
    "section": "2 整除分块",
    "text": "2 整除分块\n也被称为数论分块. 求 \\[\n\\sum_{i=1}^n f(i) g(\\left\\lfloor \\frac n i \\right\\rfloor)\n\\] 我们按 \\(d = \\left\\lfloor \\frac n i \\right\\rfloor\\) 分块求和： \\[\n\\sum_{d} g(d) \\sum_{\\left\\lfloor \\frac n i \\right\\rfloor = d} f(i)\n\\] 可以证明，对一指定的 \\(d\\)，满足 \\(d = \\left\\lfloor \\frac n i \\right\\rfloor\\) 的 \\(i\\) 取遍一连续区间，故若 \\(f\\) 的前缀和能 \\(O(1)\\) 求出，块数量 \\(\\# \\left\\{ \\left\\lfloor \\frac n i \\right\\rfloor \\right\\}_{i=1}^n\\) 即该算法的时间复杂度. 注意到当 \\(i \\leq \\sqrt n\\) 时，\\(\\left\\lfloor \\frac n i \\right\\rfloor\\) 最多只有 \\(\\left\\lfloor \\sqrt n \\right\\rfloor\\) 种取值，而 \\(i \\geq \\sqrt n\\) 时，\\(1 \\leq \\left\\lfloor \\frac n i \\right\\rfloor \\leq \\sqrt n\\) 表明其也最多只有 \\(\\left\\lfloor \\sqrt n \\right\\rfloor\\) 种取值. 因此整除分块的时间复杂度 \\[\nT_1(n) = \\# \\left\\{ \\left\\lfloor \\frac n i \\right\\rfloor \\right\\}_{i=1}^n \\leq 2 \\sqrt n \\in O(\\sqrt n)\n\\]\n方便起见，后文记 \\(D(n) = \\left\\{ \\left\\lfloor \\frac n i \\right\\rfloor \\right\\}_{i=1}^n\\).\n\n2.1 整除分块嵌套\n将 Proposition 2 加强，我们有如下通用放缩：\n\n\n\n\n\n\n\nProposition 3 \\[\n\\sum_{d \\mid n} f(d) \\leq \\sum_{d \\in D(n)} f(d) \\leq \\sum_{i=1}^{\\sqrt n} f(i) + f(\\left\\lfloor \\frac n i \\right\\rfloor)\n\\]\n\n\n\n\nLHS 成立的关键在于 \\(\\{d: d \\mid n\\} \\subset D(n)\\)；而 RHS 的本质就是上述对整除分块块数量上界的估计.\n\nRemark. 整除分块的 \\(O(\\sqrt n)\\) 相当满，而枚举因子的 \\(\\sigma_0(n) \\in O(\\sqrt n)\\) 却相当不满．这一点在前面介绍 \\(\\sigma_0(n)\\) 时已经提到．\n\n注意到 Proposition 2 是 Example 7 证明的核心，而 Proposition 3 是 Proposition 2 的加强版，故仿造 Example 7 的证明，我们有\n\n\n\n\n\n\n\nExample 8 令 \\[\nS_z(n) = \\sum_{d \\in D(n)} d^z\n\\] 则前述 Example 7 中 \\(\\sigma_z(n)\\) 的上界与渐进上界也同样适用于 \\(S_z(n)\\).\n\n\n\n\n现在可以对嵌套整除分块 \\[\n\\sum_{i=1}^n f(i) \\sum_{j=1}^{\\left\\lfloor \\frac n i \\right\\rfloor} g(j) h(\\left\\lfloor \\frac n {ij} \\right\\rfloor)\n\\] 的时间复杂度 \\(T_2\\) 做出估计了. 对 Example 8 取 \\(z=\\frac 1 2\\)，立刻有 \\[\nT_2(n) = \\sum_{d \\in D(n)} T_1(d) \\leq 2 \\sum_{d \\in D(n)} \\sqrt d = 2 S_{\\frac 1 2}(n) \\leq 4 \\sqrt n P_{\\frac 1 2}(\\sqrt n) \\in O(n^{\\frac 3 4})\n\\]\n我们还可以进一步归纳. 假定 \\(\\forall m \\geq 0, \\quad \\exists z_m : 0 \\leq z_m &lt; 1, \\quad T_m(n) = O(n^{z_m})\\)，我们有 \\[\nT_{m+1}(n) = \\sum_{d \\in D(n)} T_m(d) \\leq C \\sum_{d \\in D(n)} n^{z_m} = C S_{z_m}(n) \\in O(n^{\\frac {1+z_m} 2})\n\\] 因此 \\(z_{m+1} = \\frac {1+z_m} 2\\). 边界条件 \\(z_0 = 0\\)，数列递推求得 \\(z_m = 1-2^{-m}\\)，检验满足条件. 因此 \\(m\\) 重嵌套整除分块的时间复杂度 \\[\nT_m(n) \\in O(n^{1- 2^{-m}})\n\\]"
  },
  {
    "objectID": "posts/20230418-complexity/index.html#杜教筛",
    "href": "posts/20230418-complexity/index.html#杜教筛",
    "title": "一些数论算法的时间复杂度分析",
    "section": "3 杜教筛",
    "text": "3 杜教筛\n杜教筛可以以低于线性的时间复杂度求解某些数论函数的前缀和. 其思路并不复杂. 设 \\(f\\) 为一数论函数，我们希望快速求得其前缀和 \\(\\hat f (n) = \\sum_{i=1}^n f(i)\\). 考虑数论函数 \\(g\\) 和 \\(h = g * f\\)， \\[\nh(n) = \\sum_{d \\mid n} g(d) f(\\frac n d)\n\\] 两端做前缀和得 \\[\n\\begin{aligned}\n\\hat h (n)\n&= \\sum_{i=1}^n h(i) \\\\\n&= \\sum_{i=1}^n \\sum_{d \\mid i} g(d) f(\\frac i d) \\\\\n&= \\sum_{d=1}^n g(d) \\sum_{i=1}^{\\left\\lfloor \\frac n d \\right\\rfloor} f(i) \\\\\n&= \\sum_{d=1}^n g(d) \\hat f (\\left\\lfloor \\frac n d \\right\\rfloor) \\\\\n&= g(1) \\hat f (n) + \\sum_{d=2}^n g(d) \\hat f (\\left\\lfloor \\frac n d \\right\\rfloor)\n\\end{aligned}\n\\] 因此 \\[\n\\hat f (n) = \\frac 1 {g(1)} \\left( \\hat h (n) - \\sum_{d=2}^n g(d) \\hat f (\\left\\lfloor \\frac n d \\right\\rfloor) \\right)\n\\] 故若 \\(g\\)、\\(h\\) 的前缀和可 \\(O(1)\\) 算得，根据上式整除分块即可递归地计算出 \\(f\\) 的前缀和.\n下面分析算法的复杂度. 注意到 \\[\n\\left\\lfloor \\frac{\\left\\lfloor \\frac n i \\right\\rfloor}{j} \\right\\rfloor = \\left\\lfloor \\frac{n}{ij} \\right\\rfloor\n\\] 故单轮递归涉及到的自变量均可表示为 \\(d = \\left\\lfloor \\frac n i \\right\\rfloor\\) 的形式. 一个 \\(\\hat f (d)\\) 做整除分块耗时 \\(T_1(d)\\)，若采用记忆化递归，由上节分析，算法总时间复杂度为 \\[\n\\sum_{d \\in D(n)} T_1(d) = T_2(n) \\in O(n^{\\frac 3 4})\n\\]\n但我们还可以做得更好——考虑先用 \\(O(K)\\) 的时间复杂度线性筛出前 \\(K\\) 个 \\(f(n)\\) 并求前缀和，则递归求解时，\\(d \\leq K\\) 的 \\(\\hat f(d)\\) 就无需再向下递归了. 为分析此类时间复杂度，对 Proposition 3 做最后一点扩展：\n\n\n\n\n\n\n\nProposition 4 \\[\n\\sum_{\\begin{gathered} d \\mid n \\\\ d &gt; K \\end{gathered}} f(d) \\leq \\sum_{\\begin{gathered} d \\in D(n) \\\\ d &gt; K \\end{gathered}} f(d) \\leq \\sum_{K &lt; i \\leq \\sqrt n} f(i) + \\sum_{1 \\leq i \\leq \\min{\\{ \\left\\lfloor \\frac n K \\right\\rfloor,\\sqrt n \\} }} f(\\left\\lfloor \\frac n i \\right\\rfloor)\n\\] 特别的，当 \\(K &gt; \\sqrt n\\) 时，有 \\[\n\\sum_{\\begin{gathered} d \\mid n \\\\ d &gt; K \\end{gathered}} f(d) \\leq \\sum_{\\begin{gathered} d \\in D(n) \\\\ d &gt; K \\end{gathered}} f(d) \\leq \\sum_{1 \\leq i \\leq \\left\\lfloor \\frac n K \\right\\rfloor} f(\\left\\lfloor \\frac n i \\right\\rfloor)\n\\]\n\n\n\n\n利用此估计，当 \\(K &gt; \\sqrt n\\) 时，算法在递归部分的时间复杂度估计降低为 \\[\n\\begin{aligned}\n\\mathrm{Du}_K(n) &=\n\\sum_{\\begin{gathered} d \\in D(n) \\\\ d &gt; K \\end{gathered}} T_1(d) \\\\\n&= \\sum_{1 \\leq i \\leq \\left\\lfloor \\frac n K \\right\\rfloor} T_1(\\left\\lfloor \\frac n i \\right\\rfloor) \\\\\n&\\leq \\sum_{1 \\leq i \\leq \\left\\lfloor \\frac n K \\right\\rfloor} C \\sqrt{\\frac n i} \\\\\n&= C \\sqrt n \\sum_{1 \\leq i \\leq \\left\\lfloor \\frac n K \\right\\rfloor} i^{-\\frac 1 2} \\\\\n&=  C \\sqrt n P_{\\frac 1 2}\\left(\\left\\lfloor \\frac n K \\right\\rfloor\\right) \\\\\n&\\in \\sqrt n O\\left( \\left(\\frac n K\\right)^{\\frac 1 2} \\right) \\\\\n&\\subset O(n K^{-\\frac 1 2})\n\\end{aligned}\n\\] 总时间复杂度 \\[\nO(K) + O(n K^{-\\frac 1 2})\n\\] 为最小化时间复杂度，取 \\(K = n^{\\frac 2 3}\\)，即得最优时间复杂度 \\(O(n^{\\frac 2 3})\\).\n这部分的时间复杂度证明主要参考了文章 [11]."
  },
  {
    "objectID": "posts/20230418-complexity/index.html#challenge",
    "href": "posts/20230418-complexity/index.html#challenge",
    "title": "一些数论算法的时间复杂度分析",
    "section": "4 Challenge",
    "text": "4 Challenge\n\n\n\n\n\n\n\nExample 9 对 \\(1\\) 到 \\(n\\) 间的无平方因子数计数. \\(n \\leq 10^{18}\\).\n参见蓝桥杯 2023 省赛 A 组 J 题《翻转硬币》[12] 或《完全平方数》[13].\n\n\n\n\n我们指出，无平方因子数有如下计数公式 \\[\nf(n) = \\sum_{i=1}^n \\mu^2 (i) = \\sum_{i=1}^{\\left\\lfloor \\sqrt n \\right\\rfloor} \\mu(i) \\left\\lfloor \\frac n {i^2} \\right\\rfloor\n\\]\n朴素实现复杂度为 \\(O(\\sqrt n)\\)，考虑对 \\(\\left\\lfloor \\frac n {i^2} \\right\\rfloor\\) 开发一种新的整除分块算法. 现在问题有三. 一是估计 \\[\n\\# D_2(n) = \\# \\left\\{ \\left\\lfloor \\frac n {i^2} \\right\\rfloor \\right\\}_{i=1}^{\\sqrt n}\n\\] 这并不困难，按 \\(i \\leq n^{\\frac 1 3}\\) 和 \\(i \\geq n^{\\frac 1 3}\\) 讨论即知其上界为 \\(O(n^{\\frac 1 3})\\).\n二是实现方案. 这里也直接给出：\nll sqrtN=sqrt(N);\nll ans=0;\nfor(ll l=1,r,d;l&lt;=sqrtN;l=r+1){\n    d=N/(l*l),r=sqrt(N/d);\n    ans+=(S_mu(r)-S_mu(l-1))*d;\n}\n最后是算法时间复杂度分析. 普通的 \\(\\left\\lfloor  \\frac n i \\right\\rfloor\\) 整除分块不会因杜教筛增加时间复杂度，但 \\(\\left\\lfloor  \\frac n {i^2} \\right\\rfloor\\) 则需要额外的讨论. 注意到该整除分块枚举中，需做杜教筛的数的集合为 \\[\n\\left\\{ \\left\\lfloor  \\left( \\left\\lfloor \\frac n d \\right\\rfloor \\right)^{\\frac 1 2}  \\right\\rfloor\\right\\}_{d \\in D_2 (n)}\n\\] 同样类似 Proposition 3 ，我们有\n\n\n\n\n\n\n\nProposition 5 \\[\n\\sum_{d^2 \\mid n} f(\\frac n {d^2}) \\leq \\sum_{d \\in D_2(n)} f(d) \\leq \\sum_{i=1}^{n^{\\frac 1 3}} f(i) + f(\\left\\lfloor \\frac n {i^2} \\right\\rfloor)\n\\]\n\n\n\n\n因此算法递归部分时间复杂度可估计为 \\[\n\\begin{aligned}\n\\sum_{d \\in D_2 (n)} \\mathrm{Du}_K \\left(\\left\\lfloor \\left( \\left\\lfloor \\frac n d \\right\\rfloor \\right)^{\\frac 1 2} \\right\\rfloor\\right)\n&\\leq \\sum_{d \\in D_2 (n)} C \\left\\lfloor \\left( \\left\\lfloor \\frac n d \\right\\rfloor \\right)^{\\frac 1 2} \\right\\rfloor K^{-\\frac 1 2} \\\\\n&\\leq C K^{-\\frac 1 2} \\left( \\sum_{i=1}^{n^{\\frac 1 3}} \\left( \\frac n {\\frac n {i^2}} \\right)^{\\frac 1 2} + \\sum_{i=1}^{n^{\\frac 1 3}} \\left( \\frac n i \\right)^{\\frac 1 2} \\right) \\\\\n&= C K^{-\\frac 1 2} \\left( \\sum_{i=1}^{n^{\\frac 1 3}} i + n^{\\frac 1 2} \\sum_{i=1}^{n^{\\frac 1 3}} i^{-\\frac 1 2} \\right) \\\\\n&\\in K^{-\\frac 1 2} \\left( O(n^{\\frac 2 3}) + n^{\\frac 1 2} O(n^{\\frac 1 6}) \\right) \\\\\n&\\subset O(n^{\\frac 2 3} K^{-\\frac 1 2})\n\\end{aligned}\n\\] 总时间复杂度为 \\[\nO(K) + O(n^{\\frac 2 3} K^{-\\frac 1 2})\n\\] 取 \\(K=n^{\\frac 4 9}\\)，得到最优时间复杂度 \\(O(n^{\\frac 4 9})\\). 代入 \\(n = 10^{18}\\)，量级约为 \\(10^8\\).\n这估计并不算优秀. 传言存在 \\(O(n^{\\frac 2 5})\\) 的估计，猜测大概优化了 \\(\\left\\{ \\left\\lfloor \\frac n i \\right\\rfloor \\right\\}_{i=1}^n\\) 和 \\(\\left\\{ \\left\\lfloor  \\left( \\left\\lfloor \\frac n d \\right\\rfloor \\right)^{\\frac 1 2}  \\right\\rfloor\\right\\}_{d \\in D_2 (n)}\\) 的重叠部分．关于这一估计，我们找到两篇参考文献，请参阅博客 [14] 和论文 [15]．"
  },
  {
    "objectID": "posts/20190922-muphi/index.html",
    "href": "posts/20190922-muphi/index.html",
    "title": "由 [SDOI2012]Longge的问题 探讨欧拉函数和莫比乌斯函数的一些性质和关联",
    "section": "",
    "text": "题目传送门：https://www.luogu.org/problem/P2303\n\n给定一个整数\\(n\\)，求\n\\[\n\\sum_{i=1}^n \\gcd(n,i)\n\\]\n\n蒟蒻随便yy了一下搞出来个\\(O(\\sqrt{n})\\)的算法 这题数据怎么这么水\n首先看到gcd我们就下意识的对它反演一波对吧\n\n\n\\[\n\\sum_{i=1}^n \\gcd(n,i) = \\sum_{d|n} \\varphi(d) \\frac{n}{d}\n\\]\n这里提供两种化法，得到的结果都是这个。\n\n\n根据欧拉函数和式\n\\[\nn = \\sum_{d|n} \\varphi(d)\n\\]\n暴力推导即可\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n \\gcd(n,i) &= \\sum_{i=1}^n \\sum_{d|\\gcd(n,i)} \\varphi(d) \\\\\n&= \\sum_{d|n} \\sum_{i=1}^{\\frac n d} \\varphi(d) \\\\\n&= \\sum_{d|n} \\varphi(d) \\frac n d\n\\end{aligned}\n\\]\n\n\n\n根据欧拉函数的定义式\n\\[\n\\varphi(n) = \\sum_{i=1}^n [\\gcd(n,i) = 1]\n\\]\nPS：\\(\\varphi(n)\\)表示\\(1\\)~\\(n-1\\)内与\\(n\\)互质的数，将和式上界提升到\\(n\\)不但不会影响正确性（\\(\\gcd(n,n) = n \\neq 1\\)），而且让\\(\\varphi(1)\\)不用特判。\n易得\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n \\gcd(n,i) &= \\sum_{d|n} d \\sum_{i=1}^n [\\gcd(n,i) = d] \\\\\n&= \\sum_{d|n} d \\sum_{i=1}^{\\frac n d} [\\gcd(\\frac n d,i) = 1] \\\\\n&= \\sum_{d|n} d \\varphi(\\frac n d) \\\\\n&= \\sum_{d|n} \\varphi(d) \\frac n d \\\\\n\\end{aligned}\n\\]\n这一步还是比较简单的。稍有基础的同学大概都会吧\n\n\n\n\n令\n\\[\ng(n) = \\sum_{i=1}^n \\gcd(n,i) = \\sum_{d|n} \\varphi(d) \\frac{n}{d}\n\\]\n我们希望求\\(g\\)的在\\(n\\)的函数值。容易发现右式是狄利克雷卷积\\(\\varphi * Id\\)，也就是说\\(g\\)也是积性函数。所以考虑质因数分解\\(n\\)，最后用积性累乘出来\n即\n\\[\ng(n) = g({p_1}^{c_1}) g({p_2}^{c_2}) ... g({p_n}^{c_n})\n\\]\n则只需求\\(g(p^c)\\)（这里省略下标）\n\\(p^c\\)的因数分别为\\(1\\)，\\(p\\)，\\(p^2\\)，…，\\(p^c\\)\n所以有\n\\[\n\\begin{aligned}\ng(p^c) &= \\sum_{i=0}^{c} \\varphi(p^i) \\frac{p^c}{p^i} \\\\\n&= \\sum_{i=0}^{c} \\varphi(p^i) p^{c-i}\n\\end{aligned}\n\\]\n\n\n考虑先弄出上式中\\(\\varphi(p^i)\\)的封闭形式，再带回原式看看\n根据欧拉函数通式\n\\[\n\\varphi(n) = n \\prod_{i=1}^k (1 - \\frac 1 {p_i})\n\\]\n（这个\\(\\pi\\)指的是分解质因数）\n易得\n\\[\n\\begin{aligned}\n\\varphi(p^c) &= p^c (1 - \\frac 1 p) \\\\\n&= p^c - p^{c-1}\n\\end{aligned}\n\\]\n注意这个式子需要在\\(c=0\\)时特判，因为\\(\\varphi(1) = 1\\)（\\(1\\)可以视作分解不出任何质因数）\n\n\n\n得到了\\(\\varphi(p^c)\\)，带回之前未推完的\\(g(p^c)\\)的式子，得\n\\[\n\\begin{aligned}\ng(p^c) &= \\sum_{i=0}^{c} \\varphi(p^i) p^{c-i} \\\\\n&= p^c + \\sum_{i=1}^{c} (p^i - p^{i-1}) p^{c-i} \\\\\n&= p^c + \\sum_{i=1}^{c} (p^c - p^{c-1}) \\\\\n&= p^c + c (p^c - p^{c-1}) \\\\\n&= (c+1)p^c - c \\ p^{c-1}\n\\end{aligned}\n\\]\n（中途对\\(i=0\\)进行了特殊讨论）（该式同样不适用于\\(c=0\\)的情况）\n然后积性合并起来就完了\n冷静分析一波时间复杂度。质因数分解消耗\\(O(\\sqrt n)\\)的时间复杂度，分解出不超过\\(O(log_2 n)\\)个\\(p^c\\)，每个\\(g(p^c)\\)的计算是\\(O(1)\\)的。所以总时间复杂度为\\(O(\\sqrt n)\\)\n\n\n\n\n非常简单的代码\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\n\nll p[1005],c[1005],g[1005];ll kN;\nvoid Div(ll n){\n    kN=0;\n    for(ll i=2;i*i&lt;=n;i++){\n        if(n%i==0){\n            kN++;p[kN]=i;\n            g[kN]=1;\n            ll e=0;while(n%i==0) e++,n/=i,g[kN]*=i;\n            c[kN]=e;\n        }\n    }\n    if(n!=1) kN++,p[kN]=n,c[kN]=1,g[kN]=n;\n}\nll N;\nint main(){\n    cin&gt;&gt;N;\n    Div(N);\n    ll pdt=1;\n    for(int i=1;i&lt;=kN;i++) pdt=pdt*((c[i]+1)*g[i]-c[i]*g[i]/p[i]);\n    cout&lt;&lt;pdt;\n    return 0;\n}\n这式子长得跟小粉兔菊苣的题解很像？"
  },
  {
    "objectID": "posts/20190922-muphi/index.html#本题题解",
    "href": "posts/20190922-muphi/index.html#本题题解",
    "title": "由 [SDOI2012]Longge的问题 探讨欧拉函数和莫比乌斯函数的一些性质和关联",
    "section": "",
    "text": "题目传送门：https://www.luogu.org/problem/P2303\n\n给定一个整数\\(n\\)，求\n\\[\n\\sum_{i=1}^n \\gcd(n,i)\n\\]\n\n蒟蒻随便yy了一下搞出来个\\(O(\\sqrt{n})\\)的算法 这题数据怎么这么水\n首先看到gcd我们就下意识的对它反演一波对吧\n\n\n\\[\n\\sum_{i=1}^n \\gcd(n,i) = \\sum_{d|n} \\varphi(d) \\frac{n}{d}\n\\]\n这里提供两种化法，得到的结果都是这个。\n\n\n根据欧拉函数和式\n\\[\nn = \\sum_{d|n} \\varphi(d)\n\\]\n暴力推导即可\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n \\gcd(n,i) &= \\sum_{i=1}^n \\sum_{d|\\gcd(n,i)} \\varphi(d) \\\\\n&= \\sum_{d|n} \\sum_{i=1}^{\\frac n d} \\varphi(d) \\\\\n&= \\sum_{d|n} \\varphi(d) \\frac n d\n\\end{aligned}\n\\]\n\n\n\n根据欧拉函数的定义式\n\\[\n\\varphi(n) = \\sum_{i=1}^n [\\gcd(n,i) = 1]\n\\]\nPS：\\(\\varphi(n)\\)表示\\(1\\)~\\(n-1\\)内与\\(n\\)互质的数，将和式上界提升到\\(n\\)不但不会影响正确性（\\(\\gcd(n,n) = n \\neq 1\\)），而且让\\(\\varphi(1)\\)不用特判。\n易得\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n \\gcd(n,i) &= \\sum_{d|n} d \\sum_{i=1}^n [\\gcd(n,i) = d] \\\\\n&= \\sum_{d|n} d \\sum_{i=1}^{\\frac n d} [\\gcd(\\frac n d,i) = 1] \\\\\n&= \\sum_{d|n} d \\varphi(\\frac n d) \\\\\n&= \\sum_{d|n} \\varphi(d) \\frac n d \\\\\n\\end{aligned}\n\\]\n这一步还是比较简单的。稍有基础的同学大概都会吧\n\n\n\n\n令\n\\[\ng(n) = \\sum_{i=1}^n \\gcd(n,i) = \\sum_{d|n} \\varphi(d) \\frac{n}{d}\n\\]\n我们希望求\\(g\\)的在\\(n\\)的函数值。容易发现右式是狄利克雷卷积\\(\\varphi * Id\\)，也就是说\\(g\\)也是积性函数。所以考虑质因数分解\\(n\\)，最后用积性累乘出来\n即\n\\[\ng(n) = g({p_1}^{c_1}) g({p_2}^{c_2}) ... g({p_n}^{c_n})\n\\]\n则只需求\\(g(p^c)\\)（这里省略下标）\n\\(p^c\\)的因数分别为\\(1\\)，\\(p\\)，\\(p^2\\)，…，\\(p^c\\)\n所以有\n\\[\n\\begin{aligned}\ng(p^c) &= \\sum_{i=0}^{c} \\varphi(p^i) \\frac{p^c}{p^i} \\\\\n&= \\sum_{i=0}^{c} \\varphi(p^i) p^{c-i}\n\\end{aligned}\n\\]\n\n\n考虑先弄出上式中\\(\\varphi(p^i)\\)的封闭形式，再带回原式看看\n根据欧拉函数通式\n\\[\n\\varphi(n) = n \\prod_{i=1}^k (1 - \\frac 1 {p_i})\n\\]\n（这个\\(\\pi\\)指的是分解质因数）\n易得\n\\[\n\\begin{aligned}\n\\varphi(p^c) &= p^c (1 - \\frac 1 p) \\\\\n&= p^c - p^{c-1}\n\\end{aligned}\n\\]\n注意这个式子需要在\\(c=0\\)时特判，因为\\(\\varphi(1) = 1\\)（\\(1\\)可以视作分解不出任何质因数）\n\n\n\n得到了\\(\\varphi(p^c)\\)，带回之前未推完的\\(g(p^c)\\)的式子，得\n\\[\n\\begin{aligned}\ng(p^c) &= \\sum_{i=0}^{c} \\varphi(p^i) p^{c-i} \\\\\n&= p^c + \\sum_{i=1}^{c} (p^i - p^{i-1}) p^{c-i} \\\\\n&= p^c + \\sum_{i=1}^{c} (p^c - p^{c-1}) \\\\\n&= p^c + c (p^c - p^{c-1}) \\\\\n&= (c+1)p^c - c \\ p^{c-1}\n\\end{aligned}\n\\]\n（中途对\\(i=0\\)进行了特殊讨论）（该式同样不适用于\\(c=0\\)的情况）\n然后积性合并起来就完了\n冷静分析一波时间复杂度。质因数分解消耗\\(O(\\sqrt n)\\)的时间复杂度，分解出不超过\\(O(log_2 n)\\)个\\(p^c\\)，每个\\(g(p^c)\\)的计算是\\(O(1)\\)的。所以总时间复杂度为\\(O(\\sqrt n)\\)\n\n\n\n\n非常简单的代码\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\n\nll p[1005],c[1005],g[1005];ll kN;\nvoid Div(ll n){\n    kN=0;\n    for(ll i=2;i*i&lt;=n;i++){\n        if(n%i==0){\n            kN++;p[kN]=i;\n            g[kN]=1;\n            ll e=0;while(n%i==0) e++,n/=i,g[kN]*=i;\n            c[kN]=e;\n        }\n    }\n    if(n!=1) kN++,p[kN]=n,c[kN]=1,g[kN]=n;\n}\nll N;\nint main(){\n    cin&gt;&gt;N;\n    Div(N);\n    ll pdt=1;\n    for(int i=1;i&lt;=kN;i++) pdt=pdt*((c[i]+1)*g[i]-c[i]*g[i]/p[i]);\n    cout&lt;&lt;pdt;\n    return 0;\n}\n这式子长得跟小粉兔菊苣的题解很像？"
  },
  {
    "objectID": "posts/20190922-muphi/index.html#更多思考",
    "href": "posts/20190922-muphi/index.html#更多思考",
    "title": "由 [SDOI2012]Longge的问题 探讨欧拉函数和莫比乌斯函数的一些性质和关联",
    "section": "更多思考",
    "text": "更多思考\n坐车时无聊在草稿纸上瞎搞出来的\n\n拓展到莫比乌斯函数\n第一步化完后，我们得到这样一个函数\n\\[\ng(n) = \\sum_{d|n} \\varphi(d) \\frac{n}{d}\n\\]\n然后我们用质因数分解弄出了一个求它单点函数值的方法\n可不可以把它拓展到莫比乌斯函数上呢？\n\\[\ng(n) = \\sum_{d|n} \\mu(d) \\frac{n}{d}\n\\]\n直接仿照上面化\\(\\varphi\\)的方法来\n根据莫比乌斯函数定义，易得\n\\[\n\\mu(p^c) = -[c=1]\n\\]\n同样需要特判\\(c=0\\)的情况\n带回得\n\\[\n\\begin{aligned}\ng(p^c) &= \\sum_{i=0}^{c} \\mu(p^i) p^{c-i} \\\\\n&= p^c + \\sum_{i=1}^{c} -[i=1] p^{c-i} \\\\\n&= p^c - p^{c-1}\n\\end{aligned}\n\\]\n（该式同样不适用于\\(c=0\\)的情况）\n挺简洁的对吧（\n\n\n小小的总结\n总结一下，首先我们发现要求的\\(g(n) = \\sum_{d|n} f(d) \\frac{n}{d}\\)是积性函数，所以考虑分解质因数，简化枚举因数的过程为\\(g(p^c) = \\sum_{i=0}^{c} f(p^i) p^{c-i}\\)。我们分别根据\\(\\varphi\\)和\\(\\mu\\)的特殊性质，化出了它们在\\(p^c\\)的函数值，然后代回化简得出\\(g(p^c)\\)的封闭形式，最后用积性合并起来，就得到了\\(g(n)\\)\n仔细思考一下\\(\\varphi\\)和\\(\\mu\\)的特殊性质。\n\\(\\varphi(p^i) = p^i - p^{i-1}\\)，而带回后与\\(p^{c-i}\\)刚好抵消掉了枚举的变量\\(i\\)，从而得出封闭形式。也就是说，\\(\\varphi\\)可以这么化是因为待求函数\\(g\\)比较特殊，它卷了个\\(Id\\)，\\(\\frac n d\\)发挥了抵消作用。\n\\(\\mu(p^c) = [c=1]\\)，只有在\\(c=0\\)或\\(c=1\\)时函数非\\(0\\)，而这也就把和式简化为仅将\\(i=0\\)和\\(i=1\\)两项相加。可见\\(\\mu\\)并没有用到\\(\\frac n d\\)的特殊性质，对于狄利克雷卷积是通用的，常用于分解质因数后的处理。比如这道题：洛谷P4464 [国家集训队]JZPKIL\n\n\n莫比乌斯函数与欧拉函数的相互关系\n第一步我们在做什么？\n\\[\n\\sum_{i=1}^n \\gcd(n,i) = \\sum_{d|n} \\varphi(d) \\frac{n}{d}\n\\]\n那我同样考虑把它变到莫比乌斯函数上。\n思考化该式时用到过的欧拉函数和式，联系到莫比乌斯函数的和式\n\\[\n[n=1] = \\sum_{d|n} \\mu(d)\n\\]\n猜想\n\\[\n\\sum_{i=1}^n [\\gcd(n,i)=1] = \\sum_{d|n} \\mu(d) \\frac{n}{d}\n\\]\n证明很容易。\n\\[\n\\begin{aligned}\n\\sum_{i=1}^n [\\gcd(n,i)=1] &= \\sum_{i=1}^n \\sum_{d|\\gcd(n,i)} \\mu(d) \\\\\n&= \\sum_{d|n} \\mu(d) \\frac n d \\\\\n\\end{aligned}\n\\]\n然后你仔细看看左式，这不就是欧拉函数的定义式吗\n于是我们找到了一个极其简洁地描述了\\(\\mu\\)和\\(\\varphi\\)关联的公式\n\\[\n\\varphi(n) = \\sum_{d|n} \\mu(d) \\frac{n}{d}\n\\]\n将本式简单变形就得到了一个更常见的表现形式\n\\[\n\\frac {\\varphi(n)} n  = \\sum_{d|n} \\frac{\\mu(d)}{d}\n\\]\n额，不过这式子好像也没啥用，至少我没见过要用这个的题\n\n\nupd 2019/11/04 用狄利克雷卷积证明\n突然发现上式可以用狄利克雷卷积非常容易的证明\n\\[\n\\begin{aligned}\nId &= \\varphi * I \\\\\nId * \\mu &= \\varphi * I * \\mu \\\\\n&= \\varphi * \\varepsilon \\\\\n&= \\varphi\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/20230217-rmg/index.html",
    "href": "posts/20230217-rmg/index.html",
    "title": "聊聊红石音乐",
    "section": "",
    "text": "咕极必肝，肝极必咕。\n本来是打算做完 Ancient Temple 和视频一起发出的，但现在看到这篇文章，说明下文随想里立下的 flag 已经被打脸了（\n咕的原因，一方面是因为现实生活太过充实有趣，即使红乐般的激昂也有黯淡之时；但更重要的，还是对第二次迭代的表现效果不满意。模子是 Foxtail Grass Studio 的专辑封面和《妖妖剑戟梦想》的白玉楼阶梯，但始终没能做出想要的效果。更好的想法？暂时也没有。\n半途而废很可惜，但糟蹋更可惜。或许暂时搁置、静待花开，会有更好的结果。\n写下随想与技术细节，封存于冷清的博客，是纪念，还是重启的依托？"
  },
  {
    "objectID": "posts/20230217-rmg/index.html#一点随想",
    "href": "posts/20230217-rmg/index.html#一点随想",
    "title": "聊聊红石音乐",
    "section": "一点随想",
    "text": "一点随想\n2022 年 8 月 17 日夜，Ancient Temple 完成过半，月色入户，欣然开摆。\n对，今天又是 8 月 17 日，是妖妖梦、风神录的发售日，也是某个枪毙节，还是某个新博客启用的周年纪念日——我又来写随想了。\n18 年华灯宴 1U_s 大佬一曲十七岁把我拉入红石音乐的大坑，到现在也有 4 年多了。随便聊聊感想，谈谈技术和非技术的各种话题。\n我玩红乐，或许“科技靠考古的自闭造轮手”是个不错的形容。不加红石群、不更新版本，没人带没人陪，Google + Minecraft Wiki 在手，自己瞎倒腾，其他看造化。风格是 18 年的远古遗风——realpiano + 命令方块 + WorldEdit 的前进式、贪吃蛇式、下落式红石音乐大行其道的年头。到后来，特效红石音乐开始流行，但我心中的红乐早已定型。\n我喜欢那个年代红石音乐特有的那种风格，那种朴素，但红石音乐完美融入场景的感觉。当年东方各作红石音乐全曲中就可见一斑——跟随红石信号一步步向前，如同听着 BGM 驾驶自机飞翔于道中，看版面缓缓向前伸展——STG 原作与 Minecraft 的奇妙融合让我着迷。我想做这样的红石音乐，我想做这样能化出心中幻想的红石音乐。\n想做？音乐你懂吗？建筑你会吗？\n不会，但可以学！\n那你还会什么？\n我是 OIer！我会编程！\n这就是后来近三年红乐自动化尝试的开端。倒也开始稍微认真点的学习 MIDI、乐理以及其他各种各样的东西。\n时间来到 20 年暑假。当时正好在玩 Python，偶然一搜，找到了 Raspberry Jam Mod 和 mido——前者把 https://www.minecraft.net/en-us/edition/pi 的 Python API 移植到 Java 版，后者提供在 Python 中处理 MIDI 文件的方法。\n诶，这就不可以开工了吗！\n肝能量发动，写了第一个能跑起来的脚本，随便丢了个正在做的第三版 Ancient Temple 进去听听——哎哟挺不错啊！\n生产力工具上线，整活得以开始。要说最想做的，那一定是妖妖梦五面道中。对，就是 《东方妖妖梦 ~ Ancient Temple》。如 ZUN 所说，那是使古老寺院的空气突然升温的曲子。樱花上飘，楼观斩下……那是原作带来的难以忘怀的幻想。\n但当时的我，没打算做，或者说有点不敢做。一方面，当然是 1U_s 大大的妖妖梦红乐曲集实在精彩，随手制作的五面道中已足以满足我自娱自乐的需求；二来也是对自己实力不太自信，怕做出自己也不太喜欢的作品。但 1U 的曲集毕竟是手工打造，两条音轨虽然意境极佳，但与原曲相比确也是捉襟见肘，而我手中的自动化可以极大程度地减轻工作量（虽然造轮子的过程没少花时间 (lll￢ω￢)）\n所以到头来还是想做——或者下次一定？\n那这次造啥呢？\n余光瞄到刚退坑不久的 Dancing Line——说是舞线，其实脑子里全是 Through the Fog 的场景。回去重打 TTF 风暴的时候，听着 90% 后疯狂的雷声，突然想到 Minecraft 可以 /weather rain 可以 /summon lightning_bolt，加之场景想要偷懒的话搞个单层水世界就行，倒是试水的不错选择。\n于是就开始试着扒谱。暑假结束，MIDI 是写好了，人却咕起来了。一咕就咕到了后一年的四月，忍不住了，爆肝三个周末整出来了。这个明显还是有很多问题的，首先曲子扒得就不太好，而且灯光一直到最后一小段才加上，另外前面下雨那段也太黑了。Sildur’s Vibrant Shader 的黑雷电问题也没解决，加上当时电脑太菜，Replaymod 录制还是挺难受的（不过预览模式倒是意外的贡献了个封面 XD），当然凑合能看。\n后来就又到暑假了，打算一口气把 RMG 这个烂摊子写好，于是大刀阔斧的重构了，命名为 redstone-music-generator，甚至还写了文档发了 Github，收获人生首 star & issue（\n或许是为了尝试 observer 的设计模式，亦或是太重视轮子的易用性，代码比较臃肿，过了几个月发现自己也很难看懂了。\n其实写脚本主要还是给自己创作使用啊，没必要考虑太多“别人的需求”。\n反思的结果就是新版的 redstone-music-generator 了，现暂存于原版本的 develop 分支下。这个版本再次重构，学习了某些命令行软件的做法，配置参数从之前在各个组件上的零散分布变为了单一配置文件的集中分布，显然提高了效率。\nAncient Temple 的 MIDI 也已经做到第五版了，这次以红乐的标准，大幅参考原曲 MIDI，期望能尽力还原出原作的表现。\n鼓起勇气脱离咕海的动力来源，还是喜欢这曲子吧。说到底还是想把它做了再养老。\n说起来，红石音乐到底应该怎样定义呢？之前 WorldEdit 的使用就已经引发过争议，那自动化搭建到底是红是黑？而在发声方面，是坚持音符盒的原教旨主义，还是命令方块的改良革新，甚至是更激进的 Midiout？\n\nup辛苦了，工作量能看出来。\n但是原谅我还是很难接受这种从mc映射到外部midi播放器的格式。我觉得这并不能称作红石音乐，因为不是在mc内部完成播放的。\n不过，用资源包和用接口，也不过只是内部调用和外部调用的区别罢了，也说不清…这是个哲学层次的问题。\n红石音乐最后到底会变成什么样我也不知道，而且这种发展的方向和趋势我也没办法也没有理由去阻止。\n我大概是，跟不上时代了吧…\n——【黑石音乐】aLIEz【接近完美的还原】_哔哩哔哩_bilibili 下 NJune六月 的评论\n\n或许每个人心中的红乐标准都有所不同……或许我们只能求同存异，力求百花齐放，不要走火入魔。但最近粒子特效红石音乐的发展又让我感到困惑——一点红石、音符盒甚至命令方块都不出现，真的算红乐吗？那些炫酷的粒子特效，真的属于 Minecraft 吗？\n只能交给时间回答了。我想，我能保证的，只是一颗全心投入、宁缺毋滥的创作心态；而我应该做的，是继续完成手头的作品。"
  },
  {
    "objectID": "posts/20230217-rmg/index.html#mc-指令相关",
    "href": "posts/20230217-rmg/index.html#mc-指令相关",
    "title": "聊聊红石音乐",
    "section": "MC 指令相关",
    "text": "MC 指令相关\n\nsetblock, dataValue, block state and data tag (nbt)\n\n扁平化前（1.12 及以前）\nsetblock &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;block&gt; [dataValue|state] [oldBlockHandling] [dataTag]\ndataValue 和 blockstate 在扁平化之前是方块状态的两种不同描述方式，dataValue 是实际存储时使用的 4 bit 数据。通常，blockstate 或 dataValue 用来描述方块的一些基本性质，比如朝向 facing、羊毛的颜色 color、中继器的延迟刻数 delay。\n具体写法例如：/setblock ~ ~ ~1 minecraft:unpowered_repeater delay=4,facing=east 设置一个延迟为 4 rt，面朝“东方”的红石中继器。（这里打上了引号，因为事实上红石中继器的 facing 代表的方向与信号传导的方向是相反的）\n又，其效果等同于 /setblock ~ ~ ~1 minecraft:unpowered_repeater 15。（dataValue = (delay - 1) * 4 + facing，facing=south|west|north|east 分别对应 0|1|2|3 。默认值是 north）\n再例如，/setblock ~ ~ ~1 minecraft:command_block facing=down 0 {Command:\"/time set 6000\"} 设置一个修改时间为正午的，面朝下方的命令方块。\n中间的 0 是用来占位的。\n查找某方块的 dataValue 和 blockstate 时可以翻阅 Minecraft Wiki 1.13 以前的历史版本（1.13 于 2018 年 6 月 18 日发布）\n\n\n扁平化后（1.13 及以后）\nsetblock &lt;pos&gt; &lt;block&gt; [destroy|keep|replace]\n其中 &lt;block&gt; 是 block_state， 具体的写法是 namespaced_ID[block_states=value]{data_tags:value}\n也就是说，原先的 block、block_state 和 dataTag 现在被统一整合入 block_state 里面，显然这更方便使用了。（然而作为考古学家，这好像也没法用上…）\n\n\n\nFallingSand or falling_block\n掉落方块实体。1.11 前它叫 FallingSand，1.11 及以后它叫 falling_block。\n1.12 及以前可用 /summon falling_block ~ ~ ~ {Block:minecraft:redstone_block,Time: 1} 召唤掉落的红石块。Time 参数设置最长掉落时间，实际上会与 30 秒取最大值，但如果留空则会马上消失。\n而 /summon falling_block ~ ~ ~ {Block:\"minecraft:wool\", Data: 14, Time:1} 可召唤掉落的红色羊毛。Data 标签自然与颜色对应了。\n1.13 后由于扁平化更新了 block_state 的概念，指令格式变为 /summon falling_block &lt;x&gt; &lt;y&gt; &lt;z&gt; {BlockState:{Name:&lt;Namespaced block ID&gt;,Properties:{&lt;blockstate_name&gt;:&lt;value&gt;}}}。\n参见：\n\nFalling Block – Minecraft Wiki\nTutorials/Falling blocks – Minecraft Wiki\nTutorials/Command NBT tags – Minecraft Wiki\n\n\n\n解决指令引号嵌套无法识别问题\n见 minecraft java edition - Why are my quotation marks causing an “unexpected token” error with this command? - Arqade，用 \\ 转义即可。"
  },
  {
    "objectID": "posts/20230217-rmg/index.html#mod资源包",
    "href": "posts/20230217-rmg/index.html#mod资源包",
    "title": "聊聊红石音乐",
    "section": "mod、资源包",
    "text": "mod、资源包\n注意此处提到的 mod 和资源包均只在其 1.12.2 对应版本下测试，不少功能在新版已经不需要 mod 了。\n\nWorldEdit\n建筑党老相识了，不细讲了，Google 一下你就知道。\n\nWorldEdit Documentation\n\n用的多的命令 copy、flip、rotate、paste、stack、set、replace。当然还有最要命的 undo 啦（\nschematic 系列指令也很好用（用来偷建筑）（逃）\n\n\nVoxelMap\n常见的小地图，用来传送挺方便的。也不细讲了。\n\n\nTickrateChanger\nTickrateChanger - Mods - Minecraft - CurseForge\ntickrate changer，就是字面意思嘛。改 tickrate 可以使游戏变快或变慢，从而实现精确调节 BPM。正常值 20。\n但是有个挺烦的问题是调了过后声音的频率也随之改变了，这样音高就发生变化了…有大佬知道怎么办吗？\n\n\nColored Redstone\nColored Redstone - Mods - Minecraft - CurseForge\n材质包编辑红石颜色失败后的替代品。具体细节有点忘了，只记得生成时 namespace 好像是 coloredredstone:colored_redstone_block，用 datavalue 来调颜色。（也忘了自己是怎么知道的了……好像是拆 jar 看的？）\n顺序大概是这样：\n\n\n\nInvisibLights\nInvisibLights - Mods - Minecraft - CurseForge\n材质包编辑发光材质失败后的替代品。字面义，作为隐形光源使用。\n\n\nrealpiano 资源包\n原出处已挂，有个下载站还有资源。\n发声命令 /execute @p ~ ~ ~ playsound lkrb.piano.p60fff voice @p ~ ~ ~\"，C5 = 60，音高 21 至 108，力度可选 ppp,pp,p,mp,mf,f,ff,fff。\n\n\nsoma 资源包\n这个老强了，按 MIDI 音源标准制作的全套音色，长短音都有。\n因为没怎么用就不细讲了。\n\n\n材质包编辑\n一开始是因为 SEUS v11.0 太黑看不清红石块，想找个方法让红石块自发光 。找了半天没找到的现成的，只好现学现做。\n关于如何获取作为参考的 Default 材质包，参考 Where can I find the default texture pack to edit? : Minecraft，直接把 1.12.2.jar 解压后里面的 assets 文件夹提到资源包里就可以用了，意外的方便啊（\n（其实 mod 的 jar 里面也有这个文件夹！）\n参考 Emissive Textures - OptiFine documentation，只需在材质包放置 /assets/minecraft/optifine/emissive.properties 和 /assets/minecraft/textures/blocks/redstone_block_e.png，emissive.properties 里写上 suffix.emissive=_e 就可以了。\n1.12 差不多也算是古董版本了，参考网上教程时还需注意版本差异。\n于是兴高采烈的准备用到掉落式红石钢琴上，发现——欸？光呢？？？\n于是发现了 Emissive textures not working for certain entities and items · Issue #1342 · sp614x/optifine · GitHub——woc，这不是 xwj 大佬吗？？？\n所以人家 18 年就把这些东西玩透了……只有红石音乐作者才能发现的 bug\n这个 Issue 至今 open，一下不知道怎么办了…只能暂时搁置。后来使用上文提到的 Colored Redstone 和 invisiblights 解决问题。\n此外，发现同一地点方块贴图始终一致，这说明随机种子由位置决定。但作为 Falling_block 生成时，全都只会用第一个贴图。"
  },
  {
    "objectID": "posts/20230217-rmg/index.html#mcpi-和-raspberryjammod-相关",
    "href": "posts/20230217-rmg/index.html#mcpi-和-raspberryjammod-相关",
    "title": "聊聊红石音乐",
    "section": "MCPI 和 RaspberryJamMod 相关",
    "text": "MCPI 和 RaspberryJamMod 相关\nRaspberryJamMod：把 Minecraft: Pi Edition 的 Python API 移植到 Java 版的一款 mod。\n\nGithub 库：GitHub - arpruss/raspberryjammod: Raspberry Jam Mod - a Mod Forge Minecraft mod implementing most of Raspberry Juice/Pi API\n官方指南：Python Coding for Minecraft : 18 Steps (with Pictures) - Instructables\nMinecraft: Pi Edition 的 API：Minecraft: Pi Edition API\n\n\nMCPI Block 类在 setBlock & setBlockWithNBT 中的使用\nBlock 类被封装成了包含三个元素 id:int, data:int, nbt:str 的“数组”，在 setBlock 和 setBlockWithNBT 中直接使用 Block 类会被 flatten() 或 floorFlatten() 函数“拍扁”成分散的参数。一个 Block 对象只可能被拍扁成 data, id 或 id, data, nbt，取决于该对象是否设置了 nbt （用 None 判断）。\n因此，需要自定义 data 时，不能使用 block 模块的预设方块。\nVec3 类也可被拍扁。\n例如：\n\nsetBlock(Vec3(0,0,0), 137, 2) 等同于 mc.setBlock(Vec3(0,0,0), Block(137, 2))\nsetBlockWithNBT(Vec3(0,0,0), 137, 2, '{Command:\"your command\"}') 等同于 setBlockWithNBT(Vec3(0,0,0), Block(137, 2), '{Command:\"your command\"}') 等同于 setBlockWithNBT(Vec3(0,0,0), Block(137, 2, '{Command:\"your command\"}'))\n\n需要注意的是， setBlock() 不能接受 nbt 参数或带 nbt 的 Block 对象，否则会报错。而 setBlockWithNBT() 则有无 nbt 皆可。\n\n\n关于 MCPI 与游戏内的坐标差\n见 Python + Minecraft Coordinates Trouble - Stack Overflow：\n\ngetPos, getTilePos, setPos and setTilePos all appear to be relative to the player’s spawn point at least in a single player world. I am going through trying to teleport my character but the coordinates I end up on are not the world’s coordinates but a coordinate relative to where my character would spawn.\n\n\nSo, either fix an offset of 66 blocks into the y-axis values, or manually set the world spawn to (0, 0, 0) with /setworldspawn."
  },
  {
    "objectID": "posts/20230217-rmg/index.html#自制轮子",
    "href": "posts/20230217-rmg/index.html#自制轮子",
    "title": "聊聊红石音乐",
    "section": "自制轮子",
    "text": "自制轮子\n\nredstone-music-generator（旧版）\n（这是重构旧版前再次阅读代码后的小报告）\n大概使用了 observer 的设计模式，写了类似 C# 中的 Event，Delegate 暂时还没有封装，稍微有点混乱。\n自己写了一些工具类，然后弄了个 MIDIHandler 预处理 MIDI 文件。\n整个生成在最上层由 RMG 类管，RMG 读取 MIDIHandler 的信息然后触发绑定在 RMG 上的各种 onNote()、onBeat() 函数（触发过程由封装的 Event 类实现）。通过设置 RMG 的成员变量可以设置例如要生成的音轨、起始终止拍等参数。\n然后各种插件都丢在了 observer.py 里。这些插件接受各种需要的信息（当前音符编号、音高等），一些是用于生成 Vec3 或 Block 的 XXXPosGen 和 XXXBlockGen（还没有给他们写基类，主要是现在还没封装 Delegate），另一些是包含 onNote()、onBeat()，用来绑在 RMG 上的插件。（注意绑在 RMG 上的是函数而不是插件本身！）每个插件都有自己的参数，插件之间也可以相互嵌套（例如 GroundedAdvancing 里面就套了个 SingleBlock）。插件存在的目的是为各个输出函数 onNote()、onBeat() 统一设置参数。（这里是否可以再改的函数式编程一点？）\n现在有一个问题就是 PosGen 和 BlockGen 分开了，有 Issue 提到想要自定义每个 Note 下放的 partBlock，像这样搞就很麻烦。\n应该有一个把 PosGen 和 BlockGen 合起来的方案，最好是能独立表示多个方块及其位置信息的一个整体。\n\n\nredstone-music-generator（新版）\nTODO（咕咕咕）\ntemp: /execute @p ~ ~ ~ playsound block.note.guitar voice @p ~ ~ ~"
  },
  {
    "objectID": "posts/20191221-crt/index.html",
    "href": "posts/20191221-crt/index.html",
    "title": "中国剩余定理（CRT）及其扩展（ExCRT）",
    "section": "",
    "text": "给定 \\(n\\) 个同余方程\n\\[\n\\left\\{\n\\begin{aligned}\nx &\\equiv a_1 \\pmod{m_1} \\\\\nx &\\equiv a_2 \\pmod{m_2} \\\\\n&... \\\\\nx &\\equiv a_n \\pmod{m_n}\n\\end{aligned}\n\\right.\n\\]\n\\(m_1, m_2 , ... , m_n\\) 两两互质\n令 \\(M = \\prod_{i=1}^{n} m_i\\) ，求 \\(x \\mod M\\)\n\n解决该问题的方法是构造。\n我们假定最终答案的形式是一个 \\(n\\) 个项的和式，对每个同余方程的构造反应在对应项的系数上。\n如果要对每一个项分别构造，就要求为每一项乘上一个合适的数，使得每项构造的系数对其他方程的结果没有影响。\n容易想到构造\n\\[\nM_i = \\frac{M}{m_i}\n\\]\n显然该数仅在模 \\(m_i\\) 时不为 \\(0\\) ，于是改变该项的系数将不会对其他方程造成影响。\n现在我们希望该项模 \\(m_i\\) 意义下是 \\(a_i\\) ，但上一次的构造残留下了一个 \\(M_i\\) 。简单粗暴的乘上 \\(M_i\\) 在模 \\(m_i\\) 意义下的逆元 \\(\\mathrm{inv}_{m_i}(M_i)\\) ，让该项在模 \\(m_i\\) 意义下变为 \\(1\\) ，然后乘上 \\(a_i\\) 就构造出来了。\n综上，答案为\n\\[\n\\sum_{i=1}^{n} M_i \\mathrm{inv}_{m_i}(M_i) a_i \\mod{M}\n\\]\n模数互质条件保证了 \\(M_i\\) 在模 \\(m_i\\) 意义下非 \\(0\\) ，进而保证了 \\(\\mathrm{inv}_{m_i}(M_i)\\) 的存在。\n\n\n\n大部分题的 \\(m_i\\) 都是质数，求逆元快速幂即可。\n对于一般的情况，上ExGCD就行。\n板题：洛谷P1495 曹冲养猪\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\n\nnamespace ExGcd{\n    ll x,y;\n    ll ExGcd(ll a,ll b){\n        ll ans;\n        if(a%b==0){\n            x=0;y=1;ans=b;\n        }else{\n            ans=ExGcd(b,a%b);\n            ll x1=x,y1=y;\n            x=y1;y=x1-a/b*y1;\n        }\n        return ans;\n    }\n    bool SolveEqu(ll a,ll b,ll c){\n        ll d=ExGcd(a,b);\n        if(c%d!=0) return 0;\n        x*=c/d;y*=c/d;\n        x=(x%b+b)%b;\n        y=(c-a*x)/b;\n        return 1;\n    }\n}\nll Inv(ll a,ll m){\n    ExGcd::SolveEqu(a,m,1);\n    return ExGcd::x;\n}\n\nconst ll CRTN=20;\nnamespace CRT{\n    ll N;\n    ll m[CRTN],a[CRTN];\n    ll Sol(){\n        ll ans=0,M=1;\n        for(ll i=1;i&lt;=N;i++) M*=m[i];\n        for(ll i=1;i&lt;=N;i++){\n            ll Mi=M/m[i];\n            ans=(ans+Mi*Inv(Mi,m[i])*a[i])%M;\n        }\n        return ans;\n    }\n}\nint main(){\n    using namespace CRT;\n    scanf(\"%lld\",&N);\n    for(ll i=1;i&lt;=N;i++)\n        scanf(\"%lld%lld\",&m[i],&a[i]);\n    printf(\"%lld\",Sol());\n    return 0;\n}"
  },
  {
    "objectID": "posts/20191221-crt/index.html#中国剩余定理-crt",
    "href": "posts/20191221-crt/index.html#中国剩余定理-crt",
    "title": "中国剩余定理（CRT）及其扩展（ExCRT）",
    "section": "",
    "text": "给定 \\(n\\) 个同余方程\n\\[\n\\left\\{\n\\begin{aligned}\nx &\\equiv a_1 \\pmod{m_1} \\\\\nx &\\equiv a_2 \\pmod{m_2} \\\\\n&... \\\\\nx &\\equiv a_n \\pmod{m_n}\n\\end{aligned}\n\\right.\n\\]\n\\(m_1, m_2 , ... , m_n\\) 两两互质\n令 \\(M = \\prod_{i=1}^{n} m_i\\) ，求 \\(x \\mod M\\)\n\n解决该问题的方法是构造。\n我们假定最终答案的形式是一个 \\(n\\) 个项的和式，对每个同余方程的构造反应在对应项的系数上。\n如果要对每一个项分别构造，就要求为每一项乘上一个合适的数，使得每项构造的系数对其他方程的结果没有影响。\n容易想到构造\n\\[\nM_i = \\frac{M}{m_i}\n\\]\n显然该数仅在模 \\(m_i\\) 时不为 \\(0\\) ，于是改变该项的系数将不会对其他方程造成影响。\n现在我们希望该项模 \\(m_i\\) 意义下是 \\(a_i\\) ，但上一次的构造残留下了一个 \\(M_i\\) 。简单粗暴的乘上 \\(M_i\\) 在模 \\(m_i\\) 意义下的逆元 \\(\\mathrm{inv}_{m_i}(M_i)\\) ，让该项在模 \\(m_i\\) 意义下变为 \\(1\\) ，然后乘上 \\(a_i\\) 就构造出来了。\n综上，答案为\n\\[\n\\sum_{i=1}^{n} M_i \\mathrm{inv}_{m_i}(M_i) a_i \\mod{M}\n\\]\n模数互质条件保证了 \\(M_i\\) 在模 \\(m_i\\) 意义下非 \\(0\\) ，进而保证了 \\(\\mathrm{inv}_{m_i}(M_i)\\) 的存在。\n\n\n\n大部分题的 \\(m_i\\) 都是质数，求逆元快速幂即可。\n对于一般的情况，上ExGCD就行。\n板题：洛谷P1495 曹冲养猪\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\n\nnamespace ExGcd{\n    ll x,y;\n    ll ExGcd(ll a,ll b){\n        ll ans;\n        if(a%b==0){\n            x=0;y=1;ans=b;\n        }else{\n            ans=ExGcd(b,a%b);\n            ll x1=x,y1=y;\n            x=y1;y=x1-a/b*y1;\n        }\n        return ans;\n    }\n    bool SolveEqu(ll a,ll b,ll c){\n        ll d=ExGcd(a,b);\n        if(c%d!=0) return 0;\n        x*=c/d;y*=c/d;\n        x=(x%b+b)%b;\n        y=(c-a*x)/b;\n        return 1;\n    }\n}\nll Inv(ll a,ll m){\n    ExGcd::SolveEqu(a,m,1);\n    return ExGcd::x;\n}\n\nconst ll CRTN=20;\nnamespace CRT{\n    ll N;\n    ll m[CRTN],a[CRTN];\n    ll Sol(){\n        ll ans=0,M=1;\n        for(ll i=1;i&lt;=N;i++) M*=m[i];\n        for(ll i=1;i&lt;=N;i++){\n            ll Mi=M/m[i];\n            ans=(ans+Mi*Inv(Mi,m[i])*a[i])%M;\n        }\n        return ans;\n    }\n}\nint main(){\n    using namespace CRT;\n    scanf(\"%lld\",&N);\n    for(ll i=1;i&lt;=N;i++)\n        scanf(\"%lld%lld\",&m[i],&a[i]);\n    printf(\"%lld\",Sol());\n    return 0;\n}"
  },
  {
    "objectID": "posts/20191221-crt/index.html#扩展中国剩余定理-excrt",
    "href": "posts/20191221-crt/index.html#扩展中国剩余定理-excrt",
    "title": "中国剩余定理（CRT）及其扩展（ExCRT）",
    "section": "扩展中国剩余定理 ExCRT",
    "text": "扩展中国剩余定理 ExCRT\nExCRT和CRT并没有什么关系，正如ExLucas和Lucas也没什么关系\n其实从纯推理的角度来看，ExCRT可能还要好想一点（\n\n推导\n问题同CRT，但是模数是任意的，并不要求互质。\n这时，我们就不能保证存在逆元了。那么如何解决该问题呢？\n考虑如何合并两个方程。如果我们找到了合并的方法，就能如法炮制将\\(n\\)个方程依次合并起来，得到答案。\n\\[\n\\left\\{\n\\begin{aligned}\nx &\\equiv a_1 \\pmod{m_1} \\\\\nx &\\equiv a_2 \\pmod{m_2}\n\\end{aligned}\n\\right.\n\\]\n去掉同余，化为不定方程\n\\[\n\\left\\{\n\\begin{aligned}\nx &= m_1 y_1 + a_1 \\\\\nx &= m_2 y_2 + a_2\n\\end{aligned}\n\\right.\n\\]\n于是得到\n\\[\nm_1 y_1 + a_1 = m_2 y_2 + a_2\n\\]\n只要找到一组满足该式的 \\(y_1\\) 和 \\(y_2\\) ，就能反算出 \\(x\\) ，实现合并。\n而我们得到的是一个二元一次不定方程，可以用ExGCD求解。\n化为标准式\n\\[\nm_1 y_1 - m_2 y_2 = a_2 - a_1\n\\]\n解就是了。由裴蜀定理，若 \\(\\gcd(m_1,m_2) |  a_2-a_1\\) 不成立，说明同余方程组无解。\n于是最后化得的合并式为\n\\[\nx \\equiv m_1 y_1 + a_1 \\pmod{\\mathrm{lcm}(m_1,m_2)}\n\\]\n\nUpdate 2020/12/02 关于合并后的模数\n之前没有讲清楚 \\(\\pmod{\\mathrm{lcm}(m_1,m_2)}\\) 是怎么来的，这里补充一笔。\n根据二元一次不定方程理论， \\(y_1\\) 的通解形式应为 \\(y_1 = y + k \\frac{m_2}{\\gcd(m_1,m_2)}\\) （ \\(y\\) 是某一个特解），此时带回得到 \\(x =k \\frac{m_1 m_2}{\\gcd(m_1,m_2)} + m_1 y + a_1\\) ，模上个 \\(\\mathrm{lcm}(m_1,m_2) = \\frac{m_1 m_2}{\\gcd(m_1,m_2)}\\) 就是最终的合并式了。\n\n\n\n实现\n唯一需要注意的地方是，本来解方程应该解 \\((m_1,-m_2,a_2-a_1)\\) ，但ExGCD不好处理负数，所以把 \\(- m_2\\) 改成了 \\(m_2\\) 。因为我们并不需要用到 \\(y_2\\) ，所以不会影响求解。\n板题：poj2891 Strange Way to Express Integers or 洛谷P4777 扩展中国剩余定理（EXCRT）\n会被卡乘法爆ll，懒得改\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\n\nnamespace ExGcd{\n    ll x,y;\n    ll ExGcd(ll a,ll b){\n        ll ans;\n        if(a%b==0){\n            x=0;y=1;ans=b;\n        }else{\n            ans=ExGcd(b,a%b);\n            ll x1=x,y1=y;\n            x=y1;y=x1-a/b*y1;\n        }\n        return ans;\n    }\n    bool SolveEqu(ll a,ll b,ll c){\n        ll d=ExGcd(a,b);\n        if(c%d!=0) return 0;\n        x*=c/d;y*=c/d;\n        x=(x%b+b)%b;\n        y=(c-a*x)/b;\n        return 1;\n    }\n}\nll Gcd(ll a,ll b){\n    if(a%b==0) return b;\n    return Gcd(b,a%b);\n}\nnamespace ExCRT{\n    ll a1,m1;\n    void Init(){\n        a1=0;m1=1;\n    }\n    void Expand(ll a2,ll m2){\n        ExGcd::SolveEqu(m1,m2,a2-a1);\n        ll y1=ExGcd::x;\n        ll mn=m1*m2/Gcd(m1,m2);\n        a1=(m1*y1+a1)%mn;\n        m1=mn;\n    }\n}\nint main(){\n    ll N;scanf(\"%lld\",&N);\n    ExCRT::Init();\n    for(ll i=1;i&lt;=N;i++){\n        ll a,m;scanf(\"%lld%lld\",&m,&a);\n        ExCRT::Expand(a,m);\n    }\n    printf(\"%lld\",ExCRT::a1);\n    return 0;\n}"
  },
  {
    "objectID": "posts/20220327-frustum/index.html",
    "href": "posts/20220327-frustum/index.html",
    "title": "从台体的体积公式谈起",
    "section": "",
    "text": "前些天做到一个猜圆台体两端电阻阻值公式的题，刚想积分乱搞时突然想起——台体不是有体积公式的吗…\n于是就有下面的内容了。\n台体本质上是锥体被一个平行与底面的平面所截而形成的几何体，所以可以把锥体补出来再研究。考虑从微积分的角度思考。设台体高度为 \\(h\\)，上、下底面面积分别为 \\(S_1, S_2\\)，上底面到锥体顶点的距离为 \\(x\\)。锥体的若干底面互相相似，而它们的的“半径”又与它们各自到锥体顶点的距离成正比，因此容易发现底面面积与该距离的平方成正比，即\n\\[\nk = \\frac{S_1}{x^2} = \\frac{S_2}{(x+h)^2}\n\\]\n这是在三维空间里的情况。可以类比的写出 \\(n\\) 维台体的式子：\n\\[\nk = \\frac{S_1}{x^{n-1}} = \\frac{S_2}{(x+h)^{n-1}}\n\\]\n（当然这里的 \\(S_1,S_2\\) 就是“超面积”了）\n进一步的，可以将超面积写成关于与顶点距离的函数形式：\n\\[\n\\begin{aligned}\nS_1 &= S(x) = k x^{n-1} \\\\\nS_2 &= S(x+h) = k (x+h)^{n-1}\n\\end{aligned}\n\\]\n而我们要求的“超体积”，就可以顺理成章的表示为面积函数 \\(S(x)\\) 在垂直轴线上的积分了\n\\[\nV = \\int_{x}^{x+h} S(x) \\mathrm d x = k \\int_{x}^{x+h} x^{n-1} \\mathrm d x = \\frac k n \\left( \\left(x+h \\right)^n - x^n \\right)\n\\]\n这就是用微积分求到的台体体积公式。\n那么问题来了——这种形式的台体体积公式和几何法得到的\n\n\\[\nV = \\frac{1}{3} h (S_1 + \\sqrt{S_1 S_2} + S_2)\n\\]\n\n有什么联系呢？\n随便玩一下吧，\\(\\frac 1 3\\) 毋庸置疑和三维有关，换成 \\(\\frac 1 n\\) 就好；后面那一坨挺对称的还蛮好看，写个求和符号让它更好看吧（\n于是猜测台体体积公式的 \\(n\\) 维扩展：\n\\[\nV = \\frac 1 n h \\sum_{i=0}^{n-1} S_1^{\\frac{i}{n-1}} S_2^{1-\\frac{i}{n-1}}\n\\]\n用 \\(S(x)\\) 函数的形式替换 \\(S_1, S_2\\)，得\n\\[\nV = \\frac k h \\sum_{i=0}^{n-1} x^i (x+h)^{n-1-i}\n\\]\n哎！与前面积分得出的台体体积公式比较，发现只需证明\n\\[\n(x+h)^n - x^n = h \\sum_{i=0}^{n-1} x^i (x+h)^{n-1-i}\n\\]\n试着证明一下吧。观察发现 \\(h\\) 可以拆成 \\((x+h)-x\\)，故右式可以写成\n\\[\n\\begin{aligned}\nh \\sum_{i=0}^{n-1} x^i (x+h)^{n-1-i} &= ((x+h)-x) \\sum_{i=0}^{n-1} x^i (x+h)^{n-1-i} \\\\\n&= (x+h) \\sum_{i=0}^{n-1} x^i (x+h)^{n-1-i} - x \\sum_{i=0}^{n-1} x^i (x+h)^{n-1-i} \\\\\n&= \\sum_{i=0}^{n-1} x^i (x+h)^{n-i} - \\sum_{i=1}^{n} x^i (x+h)^{n-i} \\\\\n&= (x+h)^n - x^n\n\\end{aligned}\n\\]\n得证。\n暂时不知道这个定理有什么具体的名字，知道的大佬请告诉我（\n所以这玩意有什么用呢？\n首先当然是证明（超）台体体积公式，这个上面已经提到。\n还有一个用途就是证明 \\(n \\in \\mathrm{N_+}\\) 的幂函数 \\(x^n\\) 的导数公式。\n\\[\n\\frac{\\mathrm d}{\\mathrm d x} x^n = \\lim_{h \\to 0} \\frac{(x+h)^n - x^n}{h} = \\lim_{h \\to 0} \\sum_{i=0}^{n-1} x^i (x+h)^{n-1-i} = n x^{n-1}\n\\]\n看上去很方便的来着呢。"
  },
  {
    "objectID": "posts/20200606-matrixmul/index.html",
    "href": "posts/20200606-matrixmul/index.html",
    "title": "关于矩阵乘法结合律的证明",
    "section": "",
    "text": "upd 2021/08/13:\n搬博客时随便一看发现当时完全是在扯淡——矩阵乘法哪来交换律啊我的天…\n已经修改了，误人子弟了真是抱歉…\n还有，为了简便证明过程只证明了方阵的结合律，一般矩阵的结合律证明与此相似。\n\n其实很naive…\n证明的主要意义在于说明两种矩阵运算如有分配律，则有矩阵乘法的结合律的性质。\n\n若有面向矩阵的二元运算 \\(\\oplus , \\otimes\\)​​，其中 \\(\\oplus\\)​ 满足交换律，并且有 \\(\\otimes\\)​ 对 \\(\\oplus\\)​​ 的左、右分配律，即 \\[\n\\begin{aligned}\na \\otimes ( b \\oplus c ) = a \\otimes b \\oplus a \\otimes c \\\\\n( b \\oplus c ) \\otimes a = b \\otimes a \\oplus c \\otimes a\n\\end{aligned}\n\\] 据此定义矩阵乘法 \\(A * B = C\\) ，即 \\[\nC_{i,j} = \\bigoplus  _{k=1}^n A_{i,k} \\otimes B_{k,j}\n\\] （ \\(A,B,C\\) 为矩阵，用 \\(A_{i,j}\\) 表示矩阵 \\(A\\) 中第 \\(i\\) 行第 \\(j\\) 列的元素）\n则矩阵乘法具有结合律： \\[\n(A*B)*C = A*(B*C)\n\\]\n\n证明：\n\\[\n\\begin{aligned}\n( ( A*B ) *C ) _{i,j}\n&= \\bigoplus_{k=1}^{n} (A*B)_{i,k} \\otimes C_{k,j} \\\\\n&= \\bigoplus_{k=1}^{n} (\\bigoplus_{l=1}^n A_{i,l} \\otimes B_{l,k}) \\otimes C_{k,j} \\\\\n&= \\bigoplus_{k=1}^{n} \\bigoplus_{l=1}^n A_{i,l} \\otimes B_{l,k} \\otimes C_{k,j}  \\quad &\\text{...分配律} \\\\\n&= \\bigoplus_{l=1}^{n} \\bigoplus_{k=1}^n A_{i,l} \\otimes B_{l,k} \\otimes C_{k,j}  \\quad &\\text{...交换律更换枚举} \\\\\n&= \\bigoplus_{l=1}^{n} A_{i,l} \\otimes ( \\bigoplus_{k=1}^n B_{l,k} \\otimes C_{k,j} )  \\quad &\\text{...分配律} \\\\\n&= \\bigoplus_{l=1}^{n} A_{i,l} \\otimes ({B*C})_{l,j} \\\\\n&= (A*(B*C))_{i,j}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/20221213-cover/index.html",
    "href": "posts/20221213-cover/index.html",
    "title": "有限覆盖定理与实数理论",
    "section": "",
    "text": "为更好的证明本题，先引入 Bolzano-Weierstrass 定理的一种等价表述.\n\n\n\n\n\n\n\nDefinition 1 (数列聚点) 对任意实数列 \\(\\{ x_n \\}\\)，若实数 \\(a\\) 满足：对 \\(a\\) 的任意小邻域 \\(U(a, \\varepsilon) = (a - \\varepsilon, a + \\varepsilon)\\)，都有无穷个 \\(x_n\\) 满足 \\(x_n \\in U(a, \\varepsilon)\\)，则称 \\(a\\) 是数列 \\(\\{ x_n \\}\\) 的一个聚点.\n\n\n\n\n请注意，这里我们没有使用建立在集合之上的标准的聚点定义. 对数列单独定义聚点，是考虑到数列允许重复的元素出现，如此定义更容易展开后面的讨论.\n\n\n\n\n\n\n\nTheorem 1 实数 \\(a\\) 是数列 \\(\\{ x_n \\} \\subset \\mathbb R\\) 的聚点的充要条件是：存在 \\(\\{ x_n \\}\\) 的一个收敛子列 \\(\\{ x_{n_k} \\}\\)，其极限为 \\(a\\).\n\n\n\n\n\nProof. 先证充分性. 用定义写开 \\(\\lim_{k \\to \\infty} \\{ x_{n_k} \\} = a\\)，就有 \\[\n(\\forall \\varepsilon &gt; 0)(\\exists K \\in \\mathbb N_+)(\\forall k &gt; K)(|x_{n_k} - a| &lt; \\varepsilon)\n\\] 故确有无穷项 \\(x_n\\) 落在任意小的 \\(U(a, \\varepsilon)\\) 中，即 \\(a\\) 是 \\(\\{ x_n \\}\\) 的一个聚点，该方向得证.\n下证必要性. 已知 \\(\\{ x_n \\}\\) 有一聚点 \\(a\\). 我们按如下方法构造子列 \\(\\{ x_{n_k} \\}\\)：\n\n当 \\(k=1\\)，取 \\(\\varepsilon_1 = 1\\)，因为 \\(a\\) 是 \\(E\\) 的一个聚点，\\(\\exists n_1 \\in \\mathbb N_+\\)，\\(|x_{n_1} - a| &lt; \\varepsilon\\).\n当 \\(k \\geqslant 2\\)，取 \\(\\varepsilon_k = \\frac 1 k\\)，因为 \\(a\\) 是 \\(E\\) 的一个聚点， \\(\\exists n_k &gt; n_{k-1}\\)，\\(|x_{n_k} - a| &lt; \\varepsilon\\).\n\n这样，我们构造出 \\(\\{ x_n \\}\\) 的一个子列 \\(\\{ x_{n_k} \\}\\) 满足 \\(|x_{n_k} - a| &lt; \\varepsilon_k = \\frac 1 k\\). 因此其收敛于 \\(a\\)，该方向得证.\n\n上述定理立刻证明了下定理与 Bolzano-Weierstrass 定理的等价性.\n\n\n\n\n\n\n\nTheorem 2 (数列聚点定理) 任意有界实数列 \\(\\{ x_n \\}\\) 至少有一个聚点.\n\n\n\n\n\n\n\n\n\n\n\nExample 1 利用有限覆盖定理证明 Bolzano-Weierstrass 定理.\n\n\n\n\n\nProof. 命题等价于用有限覆盖定理证明数列聚点定理. 用反证法. 假设一有界实数列 \\(\\{ x_n \\}\\) 不存在聚点，设其有上界 \\(L\\) 和下界 \\(l\\). 对任意 \\(a \\in [l,L]\\)，它都不是 \\(\\{ x_n \\}\\) 的聚点，因此总存在一个 \\(\\varepsilon(a) &gt; 0\\)，使得只有有限个 \\(x_n\\) 落入 \\(U(a, \\varepsilon(x_0))\\). 这样，构造开区间族 \\[\n\\mathscr{F} = \\{ U(a, \\varepsilon(a)) \\mid a \\in [l,L] \\}\n\\] 它显然是闭区间 \\([l,L]\\) 的一个开覆盖. 由有限覆盖定理，只需取其中有限个开区间就可以覆盖住 \\([l,L]\\)，因此覆盖 \\(\\{ x_n \\}\\) 也只需要有限个开区间. 然而由前述构造，每一个开区间中也只包含有限个 \\(x_n\\)，因此数列 \\(\\{ x_n \\}\\) 只有有限项——这显然是荒谬的. 故 \\(\\{ x_n \\}\\) 必有聚点，原命题得证."
  },
  {
    "objectID": "posts/20221213-cover/index.html#example-1",
    "href": "posts/20221213-cover/index.html#example-1",
    "title": "有限覆盖定理与实数理论",
    "section": "",
    "text": "为更好的证明本题，先引入 Bolzano-Weierstrass 定理的一种等价表述.\n\n\n\n\n\n\n\nDefinition 1 (数列聚点) 对任意实数列 \\(\\{ x_n \\}\\)，若实数 \\(a\\) 满足：对 \\(a\\) 的任意小邻域 \\(U(a, \\varepsilon) = (a - \\varepsilon, a + \\varepsilon)\\)，都有无穷个 \\(x_n\\) 满足 \\(x_n \\in U(a, \\varepsilon)\\)，则称 \\(a\\) 是数列 \\(\\{ x_n \\}\\) 的一个聚点.\n\n\n\n\n请注意，这里我们没有使用建立在集合之上的标准的聚点定义. 对数列单独定义聚点，是考虑到数列允许重复的元素出现，如此定义更容易展开后面的讨论.\n\n\n\n\n\n\n\nTheorem 1 实数 \\(a\\) 是数列 \\(\\{ x_n \\} \\subset \\mathbb R\\) 的聚点的充要条件是：存在 \\(\\{ x_n \\}\\) 的一个收敛子列 \\(\\{ x_{n_k} \\}\\)，其极限为 \\(a\\).\n\n\n\n\n\nProof. 先证充分性. 用定义写开 \\(\\lim_{k \\to \\infty} \\{ x_{n_k} \\} = a\\)，就有 \\[\n(\\forall \\varepsilon &gt; 0)(\\exists K \\in \\mathbb N_+)(\\forall k &gt; K)(|x_{n_k} - a| &lt; \\varepsilon)\n\\] 故确有无穷项 \\(x_n\\) 落在任意小的 \\(U(a, \\varepsilon)\\) 中，即 \\(a\\) 是 \\(\\{ x_n \\}\\) 的一个聚点，该方向得证.\n下证必要性. 已知 \\(\\{ x_n \\}\\) 有一聚点 \\(a\\). 我们按如下方法构造子列 \\(\\{ x_{n_k} \\}\\)：\n\n当 \\(k=1\\)，取 \\(\\varepsilon_1 = 1\\)，因为 \\(a\\) 是 \\(E\\) 的一个聚点，\\(\\exists n_1 \\in \\mathbb N_+\\)，\\(|x_{n_1} - a| &lt; \\varepsilon\\).\n当 \\(k \\geqslant 2\\)，取 \\(\\varepsilon_k = \\frac 1 k\\)，因为 \\(a\\) 是 \\(E\\) 的一个聚点， \\(\\exists n_k &gt; n_{k-1}\\)，\\(|x_{n_k} - a| &lt; \\varepsilon\\).\n\n这样，我们构造出 \\(\\{ x_n \\}\\) 的一个子列 \\(\\{ x_{n_k} \\}\\) 满足 \\(|x_{n_k} - a| &lt; \\varepsilon_k = \\frac 1 k\\). 因此其收敛于 \\(a\\)，该方向得证.\n\n上述定理立刻证明了下定理与 Bolzano-Weierstrass 定理的等价性.\n\n\n\n\n\n\n\nTheorem 2 (数列聚点定理) 任意有界实数列 \\(\\{ x_n \\}\\) 至少有一个聚点.\n\n\n\n\n\n\n\n\n\n\n\nExample 1 利用有限覆盖定理证明 Bolzano-Weierstrass 定理.\n\n\n\n\n\nProof. 命题等价于用有限覆盖定理证明数列聚点定理. 用反证法. 假设一有界实数列 \\(\\{ x_n \\}\\) 不存在聚点，设其有上界 \\(L\\) 和下界 \\(l\\). 对任意 \\(a \\in [l,L]\\)，它都不是 \\(\\{ x_n \\}\\) 的聚点，因此总存在一个 \\(\\varepsilon(a) &gt; 0\\)，使得只有有限个 \\(x_n\\) 落入 \\(U(a, \\varepsilon(x_0))\\). 这样，构造开区间族 \\[\n\\mathscr{F} = \\{ U(a, \\varepsilon(a)) \\mid a \\in [l,L] \\}\n\\] 它显然是闭区间 \\([l,L]\\) 的一个开覆盖. 由有限覆盖定理，只需取其中有限个开区间就可以覆盖住 \\([l,L]\\)，因此覆盖 \\(\\{ x_n \\}\\) 也只需要有限个开区间. 然而由前述构造，每一个开区间中也只包含有限个 \\(x_n\\)，因此数列 \\(\\{ x_n \\}\\) 只有有限项——这显然是荒谬的. 故 \\(\\{ x_n \\}\\) 必有聚点，原命题得证."
  },
  {
    "objectID": "posts/20221213-cover/index.html#example-2",
    "href": "posts/20221213-cover/index.html#example-2",
    "title": "有限覆盖定理与实数理论",
    "section": "Example 2",
    "text": "Example 2\n\n\n\n\n\n\n\nTheorem 3 (Lebesgue 覆盖定理) 设开区间族 \\(\\mathscr F\\) 是闭区间 \\([a, b]\\) 的一个开覆盖，则必存在 \\(\\sigma &gt; 0\\)，使得只要区间 \\(\\Omega \\subset [a, b]\\) 且 \\(\\Omega\\) 的长度 \\(|\\Omega| &lt; \\sigma\\)，就必有 \\(\\mathscr F\\) 中的一个开区间包含 \\(\\Omega\\). 其中 \\(\\sigma\\) 称为 Lebesgue 数.\n\n\n\n\n\nProof. 不妨只证 \\(\\Omega\\) 是闭区间这种最强的情况.\n用反证法. 假设命题不成立，则对任意 \\(\\sigma &gt; 0\\)，都存在一个长度小于 \\(\\sigma\\) 的闭区间 \\(\\Omega \\subset [a,b]\\)，它不被任何 \\(\\mathscr F\\) 中的开区间包含. 因此，对所有自然数 \\(n\\)，可取 \\(\\sigma_n = \\frac 1 n\\)，按上述方法就可构造出一列闭区间 \\[\\{ \\Omega_n \\} = \\{ [a_n, b_n] \\} \\subset [a,b]\\] 其中每一个闭区间都不被任何 \\(\\mathscr F\\) 中的开区间包含，且区间长度 \\(|\\Omega_n| &lt; \\sigma_n = \\frac 1 n\\)，即 \\(\\lim_{n \\to \\infty} |\\Omega_n| = 0\\).\n因为 \\(\\Omega_n \\subset [a,b]\\)，\\(\\{ a_n \\}\\) 有界，由 Bolzano-Weierstrass 定理，其存在一收敛子列 \\(\\{ a_{n_k} \\}\\)，设其极限为 \\(x_0\\)，极限保序性表明 \\(x_0 \\in [a,b]\\). 注意到 \\(b_{n_k} = a_{n_k} + |\\Omega_{n_k}|\\)，两端取 \\(k \\to \\infty\\) 即得 \\(\\lim_{k \\to \\infty} b_{n_k} = x_0\\). 综上，我们说明了 \\(\\{ \\Omega_{n_k} \\}\\) 收缩于 \\(x_0\\).\n但，因为 \\(\\mathscr F\\) 是闭区间 \\([a,b]\\) 的一个开覆盖，故总存在一个开区间 \\(I_{x_0} = (a_0, b_0) \\in \\mathscr F\\) 使得 \\(x_0 \\in I_{x_0}\\)，而 \\(\\{ \\Omega_{n_k} \\}\\) 又收缩于 \\(x_0\\)，故存在 \\(k \\in \\mathbb N\\)，\\(\\Omega_{n_k} \\subset I_{x_0} \\in \\mathscr F\\)，这与我们构造 \\(\\{ \\Omega_{n_k} \\}\\) 的方法矛盾. 故原命题成立.\n\n\nRemark. 证明过程与用 Bolzano-Weierstrass 定理证明闭区间一致连续性定理类似.\n\n\n\n\n\n\n\n\nExample 2 用 Lebesgue 覆盖定理证明有限覆盖定理.\n\n\n\n\n\nProof. 若 \\(\\sigma\\) 是覆盖 \\([a,b]\\) 的开覆盖 \\(\\mathscr F\\) 的勒贝格数，令 \\(N = \\lceil \\frac{2(b-a)}{\\sigma} \\rceil\\)，\\(L = \\frac {b-a}{N} \\leqslant \\frac \\sigma 2 &lt; \\sigma\\). 由 Lebesgue 覆盖定理，任意长度为 \\(L\\) 的 \\([a,b]\\) 内闭区间都包含于某个 \\(\\mathscr F\\) 中的开区间. 因此对 \\(n = 1,2,\\dots,N\\)，令 \\(\\Omega_n = \\left[ a + (n-1)L, a + nL \\right]\\)，总存在一个 \\(\\mathscr F\\) 中开区间 \\(I_n\\) 满足 \\(\\Omega_n \\subset I_n\\). 因为显然 \\(\\{ \\Omega_n \\}_{n=1}^N\\) 是 \\([a,b]\\) 的一个覆盖，故 \\(\\{ I_n \\}_{n=1}^N \\subset \\mathscr F\\) 也是 \\([a,b]\\) 的覆盖. 这样，我们就成功构造出了一个 \\(\\mathscr F\\) 的有限子覆盖 \\(\\{ I_n \\}_{n=1}^N\\)，命题得证.\n\n\nRemark. 在处理区间问题时，Lebsegue 覆盖定理很多时候比有限覆盖定理更好用. 例如处理闭区间一致连续性定理时，“落入两个有交点的相邻的这样的区间”[1]这种神乎其技的操作就可以省去了. （这种操作的严格叙述是：把单点连续性要求的区间半径改成 \\(2 \\delta_x\\)，但构造开覆盖还是用半径为 \\(\\delta_x\\) 的区间，这样可以有 \\(|x_2 - x| \\leqslant |x_2 - x_1| + |x_1 - x| \\leqslant \\delta_{m} + \\delta_{x} \\leqslant 2 \\delta_{x}\\)，能把两个点放在同一个区间内了. 详细可参考 https://www.zhihu.com/question/56393706/answer/298562084. 事实上，Lebesgue 覆盖定理也可以用类似的方法证明.）\n\n作为小结，下图展现了刚刚介绍的几个定理在整个实数完备性等价定理体系中的地位.\n\n\n\n\n\n\n\n\n\n有限覆盖定理\nLabesgue\n覆盖定理\n确界原理\n单调有界定理闭区间套定理\n(\n数列\n)\n聚点定理\nBolzano-Weierstrass\n定理\nCauchy\n收敛原理\n\n\n\n反证\n\n\n\n反证\n\n\n\n反证\n\n\n\n反证\n\n\n\n构造\n\n\n\n\n\n\n\n构造\n\n\n\n构造\n\n\n\n\n\n反证\n\n\n\n\n\n构造\n\n\n\n反证\n\n\n\n\n\nFigure 1: 实数完备性定理等价关系示意图"
  },
  {
    "objectID": "posts/20221213-cover/index.html#example-3",
    "href": "posts/20221213-cover/index.html#example-3",
    "title": "有限覆盖定理与实数理论",
    "section": "Example 3",
    "text": "Example 3\n\n\n\n\n\n\n\nTheorem 4 设数列 \\(\\{ x_n \\}\\) 有界，其上极限 \\(\\varlimsup_{n \\to \\infty} x_n = L\\)，下极限 \\(\\varliminf_{n \\to \\infty} x_n = l\\)，则 \\(L\\) 是 \\(\\{ x_n \\}\\) 的最大聚点，\\(l\\) 是 \\(\\{ x_n \\}\\) 的最小聚点.\n\n\n\n\n\nProof. Theorem 1 中，我们已经知道，一个数列的收敛子列的极限也是该数列的一个聚点. 结合上下极限的子列式定义即可证明上述定理.\n\n\n\n\n\n\n\n\nExample 3 设数列 \\(\\{ x_n \\}\\) 有界且 \\(\\lim_{n \\to \\infty}(x_{n+1} − x_n) = 0\\)，分别记 \\(\\{ x_n \\}\\) 的上下极限为 \\(L\\) 和 \\(l\\). 证明 \\([l, L]\\) 上的任意点可作为 \\(\\{ x_n \\}\\) 某个子列的极限.\n\n\n\n\n\nProof. 反证. 假设 \\([l, L]\\) 上有一点 \\(a\\) 不是任何 \\(\\{ x_n \\}\\) 的收敛子列的极限，则根据 Theorem 1，\\(a\\) 不是 \\(\\{ x_n \\}\\) 的聚点，即存在 \\(a\\) 的一个邻域 \\(U(a,\\varepsilon)\\)，使得只有有限个 \\(x_n\\) 落入该邻域，换句话说，存在某个 \\(N \\in \\mathbb N_+\\)，当 \\(n&gt;N\\) 时，就有 \\(x_n \\notin U(a,\\varepsilon)\\).\n又，考虑到 Theorem 4 表明上下极限 \\(L\\) 和 \\(l\\) 都是 \\(\\{ x_n \\}\\) 的聚点，\\(L,l \\notin U(a,\\varepsilon)\\) 显然成立，且第 \\(N\\) 项后的 \\(\\{ x_n \\}\\) 完全由满足 \\(x_n &gt; a+\\varepsilon\\) 和 \\(x_n &lt; a-\\varepsilon\\) 的两种 \\(x_n\\) 构成，且它们均有无穷多项. 这样，对于任意的 \\(M&gt;N\\)，总可以找到一个 \\(m &gt; M\\) 使得 \\(x_m\\) 和 \\(x_{m+1}\\) 分属 \\(U(a, \\varepsilon)\\) 的两侧，故 \\(|x_m - x_{m+1}| \\geqslant 2 \\varepsilon\\)，这就与条件 \\(\\lim_{n \\to \\infty}(x_{n+1} − x_n) = 0\\) 产生矛盾. 故不存在这样的 \\(a\\)，定理得证."
  },
  {
    "objectID": "posts/20221213-cover/index.html#acknowledgments",
    "href": "posts/20221213-cover/index.html#acknowledgments",
    "title": "有限覆盖定理与实数理论",
    "section": "Acknowledgments",
    "text": "Acknowledgments\n\n感谢史老师主持研讨课并指出讲稿的多处错误，特别是原来聚点定理的证明中数列元素可重的 bug. 史老师还提供了标准聚点定义的另一种叙述."
  },
  {
    "objectID": "posts/20230519-hilbert/index.html",
    "href": "posts/20230519-hilbert/index.html",
    "title": "Hilbert 曲线与集合势理论",
    "section": "",
    "text": "（我们所讨论的）曲线：定义域为 \\([0,1]\\) 的连续映射．\n\n\n\n（我们所讨论的）空间填充曲线的定义：连续满射 \\(f: [0,1] \\to [0,1]^2\\)．"
  },
  {
    "objectID": "posts/20230519-hilbert/index.html#空间填充曲线",
    "href": "posts/20230519-hilbert/index.html#空间填充曲线",
    "title": "Hilbert 曲线与集合势理论",
    "section": "",
    "text": "（我们所讨论的）曲线：定义域为 \\([0,1]\\) 的连续映射．\n\n\n\n（我们所讨论的）空间填充曲线的定义：连续满射 \\(f: [0,1] \\to [0,1]^2\\)．"
  },
  {
    "objectID": "posts/20230519-hilbert/index.html#hilbert-曲线",
    "href": "posts/20230519-hilbert/index.html#hilbert-曲线",
    "title": "Hilbert 曲线与集合势理论",
    "section": "2 Hilbert 曲线",
    "text": "2 Hilbert 曲线\n\n2.1 \\(n\\) 阶伪 Hilbert 曲线 \\(H_n(t)\\)\n理解一：将 \\([0,1]^2\\) 等分成 \\(2^n \\times 2^n\\) 个小方块，按特定顺序将每个小方块的中心点用直线连接起来．这顺序是递归构造的．\n理解二：构造 \\(n\\) 阶伪 Hilbert 曲线时，将所研究的方块区域四等分．左下角填入左上-右下翻转的 \\(n-1\\) 阶伪 Hilbert 曲线；左上、右上角填入未翻转的 \\(n-1\\) 阶伪 Hilbert 曲线；右下角填入左下-右上翻转的 \\(n-1\\) 阶伪 Hilbert 曲线．最后用三条直线连接各小方块内曲线的起止点．\n\n\n\n\n\n\n\nExercise 1 \\(n\\) 阶伪 Hilbert 曲线的长度 \\(\\operatorname{len}H_n = 2^n - 2^{-n}\\)．\n\n\n\n\n\nSolution (递推). 由伪 Hilbert 曲线的递归定义得 \\[\n\\operatorname{len}H_n = 2 \\operatorname{len}H_{n-1} + \\frac 3 {2^n}\n\\] 边界为 \\(\\operatorname{len}H_0 = 0\\)．求解该递推式即可．\n\n\nSolution (直观). 注意到 \\(n\\) 阶伪 Hilbert 曲线将区间分为 \\(2^n \\times 2^n = 4^n\\) 个小方块，除首尾方块，其余小方块内的曲线长度均为小方块边长 \\(2^n\\)．因此 \\[\n\\operatorname{len}H_n = 4^{-n} \\cdot 2^{-n} - 2 \\cdot \\frac {2^{-n}}{2} = 2^n - 2^{-n}\n\\]\n\n式中 “\\(- 2^{-n}\\)” 部分并不讨人喜爱．我们考虑水平或垂直地延长首尾方块曲线至任意边界，这样曲线长度 \\(\\operatorname{len}H_n = 2^n\\) 就恒成立了．我们在后文的讨论中使用这一改进．\n\n\n2.2 Hilbert 曲线 \\(H(t)\\)\n真正的 Hilbert 曲线是由 \\(n\\) 阶伪 Hilbert 曲线取逐点极限得到的．\n\\[\nH(t) = \\lim_{n \\to \\infty} H_n(t)\n\\]\n\n\n\n\n\n\n\nTheorem 1 (良定义性) 伪 Hilbert 曲线一致收敛（因此也是逐点收敛的）．\n\n\n\n\n\nProof. 对一给定的 \\(t \\in [0,1]\\)，设其落在区间 \\(\\left[ k 4^{-n_0}, (k+1) 4^{-n_0} \\right]\\)，则对任意 \\(n \\geq n_0\\)，\\(H_n(t)\\) 均落在 \\(H_{n_0}(t)\\) 所确定的边长为 \\(2^{-n}\\) 的小闭方块内，即 \\(\\| H_{n}(t) - H_{n_0}(t) \\|_\\infty \\leq 2^{-n}\\)．由 Cauchy 收敛原理即得其一致收敛性．\n\n\n\n\n\n\n\n\nTheorem 2 (满射性) Hilbert 曲线是 \\([0,1] \\to [0,1]^2\\) 的满射．\n\n\n\n\n\nProof. 对一给定的 \\((x,y) \\in [0,1]^2\\)，将所研究的闭方块区域四等分，任取一 \\((x,y)\\) 所在小闭方块作为下一个研究的闭方块．如此进行下去，构造出一列框住 \\((x,y)\\) 的收缩的闭方块套．闭方块套里的每一个半径为 \\(2^{-n}\\) 的闭方块都对应着 \\([0,1]\\) 上长 \\(4^{-n}\\) 的一个闭区间，这些区间同样构成了 \\([0,1]\\) 上的一个闭区间套．由闭区间套原理，这列闭区间套确定了一个实数 \\(t \\in [0,1]\\)，它就是使得 \\(f(t) = (x,y)\\) 的一个解．\n\n\nRemark. 需要注意的是，当 \\((x,y)\\) 落在某两个闭方块的公共边界上时，证明中我们任取其中一个闭方块继续讨论．因此，选择不同闭方块将可能使我们得到不同的 \\(t\\) 值，这是 Hilbert 曲线不是单射的原因之一．\n\n\n\n\n\n\n\n\nTheorem 3 (连续性) Hilbert 曲线在其定义域内连续．\n\n\n\n\n\nProof. 对一给定的 \\(t \\in [0,1]\\)，考虑 \\(H(t)\\) 任意取定的 \\(\\varepsilon\\) 邻域 \\(U_{\\varepsilon}(H(t)) = \\{ (x,y) : \\| H(t) - (x,y) \\|_{\\infty} &lt; \\varepsilon \\}\\)，取 \\(n_0 = \\log_2 \\varepsilon - 2\\)，即可使第 \\(n_0\\) 阶伪 Hillbert 曲线划分出的各闭方块边长为\\(2^{-n_0} &lt; \\frac \\varepsilon 2\\)．设此时 \\(t\\) 落在闭区间 \\(I = \\left[ k 4^{-n_0}, (k+1) 4^{-n_0} \\right]\\)（如在边界，则任取），其对应闭方块 \\(J = H(I)\\)．由于 \\(I\\) 已经是 \\(t\\) 的一个（单侧）邻域，为证明 \\(H(t)\\) 在点 \\(t\\) 的连续性，下面只需证 \\(J \\subset U_\\varepsilon(H(t))\\)．由于我们构造的 \\(n_0\\) 使闭方块 \\(J\\) 的边长为 \\(2^{-n_0} &lt; \\frac \\varepsilon 2\\)，\\(H(t)\\) 与这闭方块中任意点 \\((x,y)\\) 的距离 \\[\n\\| H(t) - (x,y) \\|_{\\infty} \\leq \\frac \\varepsilon 2 &lt; \\varepsilon\n\\] 故 \\(J \\subset U_\\varepsilon(H(t))\\)．\n\n\n\n\n\n\n\n\nExercise 2 Hilbert 曲线是不可求长的．\n\n\n\n\n对一般的曲线而言，逐点收敛于曲线 \\(f\\) 的曲线族 \\(f_n\\) 的长度的极限 \\(\\lim_{n \\to \\infty} \\operatorname{len}f_n\\) 与 \\(f\\) 的长度 \\(\\operatorname{len}f\\) 并不一定相同．这一事实有一简单有力的实例验证：用锯齿状曲线逼近圆．\n因此，直接取 Exercise 1 的极限并不可行．根据曲线长度的定义，只有构造出一族直接由 \\(H(t)\\) 上点构成的近似曲线，我们才能从这族曲线长度的极限中得到 Hilbert 曲线的正确长度．\n\nProof. 考虑划分 \\(P_{n} : t_k = k 4^{-{n}} \\pod{k = 0, 1, \\dots, 4^{n}}\\)，将 \\(H(t_k)\\) 依次用折线连接，就得到了《Space-filling curves》2.6 节[1]讨论的 Hilbert 曲线的 \\(n\\) 阶近似多边形曲线 \\(P_n(t)\\)（Approximating polygon for the Hilbert curve）．我们指出，与 \\(n\\) 阶伪 Hilbert 曲线相同，\\(n\\) 阶 Hilbert 近似多边形曲线仍然可以类似的由递归方法得到，遍历 \\(2^n \\times 2^n\\) 个小方块，且平均每个小方块内的曲线长度为 \\(2^{-n}\\)．因此，\\(n\\) 阶 Hilbert 近似多边形曲线的长度 \\(\\operatorname{len}P_n(t) = (2^n \\times 2^n) \\cdot 2^{-n} = 2^n\\)．由于该数列没有上界，故我们说明了 Hilbert 曲线的不可求长性．\n\n\n\n2.3 全平面填充\n环绕填充并连接相邻曲线即可．\n\n\n2.4 四进制小数表示\n\\(n\\) 阶伪 Hilbert 曲线对 \\([0,1]\\) 区间的划分操作可被一一对应地记为 \\(n\\) 位四进制小数，从而为 \\([0,1]\\) 上被划分出的区间和对应的 \\([0,1]^2\\) 上的方块赋予了一种简洁的表示方法．但由于递归构造时左下、右下角涉及翻转操作，为每个实数 \\(t\\)（无限位规范四进制小数）写出其平面对应点 \\(H(t)\\) 的非递归封闭形式表达稍显复杂．《Space-filling curves》[1]的 2.3 节给出了基于复数和四进制小数的精确表示．\n\n\n2.5 小结\n\nHilbert 曲线确实遍历了 \\([0,1]^2\\) 区域的所有点.\nHilbert 曲线是满射, 但不是单射，所以不是从线段到正方形区域的双射．\n\\([0,1]^2 \\to [0,1]\\) 的单射（甚至双射）？集合势理论．\n（补充）空间填充曲线必自交，即不能是单射．（Pf：否则与 \\([0,1]^2\\) 同胚，这显然荒谬．）（证明同胚逆映射连续需用拓扑定理：any continuous bijection from a compact space onto a Hausdorff space is a homeomorphism）\n（补充）不自交但有面积的曲线：Osgood 曲线．但它不是空间填充曲线．"
  },
  {
    "objectID": "posts/20230519-hilbert/index.html#集合势理论",
    "href": "posts/20230519-hilbert/index.html#集合势理论",
    "title": "Hilbert 曲线与集合势理论",
    "section": "3 集合势理论",
    "text": "3 集合势理论\n\n3.1 集合的势\n\n等势，劣势于，优势于．\n“劣势于”是集合上的序关系：自反性、反对称性（Bernstein 定理）、传递性．\n事实上更是全序关系，证明需用到选择公理．\n\n\n\n3.2 有限集、可列集与无限集\n\n有限集，可列集，无限集．\n无限集的充要条件：与某一真子集等势（Dedekind 定义）．\n充分性：归纳取出可列集，该部分映射到后继形成双射．\n必要性：即有限集不与任何其真子集等势．冗长，证明略．\n无限集并有限或可列集仍与原无限集等势．\n\n\\[\n\\mathbb N^2 \\approx \\mathbb N\n\\]\n本质：可列个可列集的并还是可列集；可列集的有限次笛卡尔积仍是可列集．\n\n\n3.3 从可列到不可列\n\\[\n\\mathbb R \\not \\approx \\mathbb N\n\\]\n写成小数，对角线法．\n规范小数（规定其均为无限小数），规范二进制小数．\n\\[\n2^{\\mathbb N} \\approx \\mathbb R\n\\]\n核心在于不规范小数是可列集．\n\\[\n{\\mathbb R}^2 \\approx \\mathbb R\n\\]\n小数穿插构造法．需要注意的是，构造的 \\((0,1)^2 \\to (0,1)\\) 的单射不是满射 \\[\nc = 0.303030\\dots \\implies a = 0.333\\dots, b= 0.000\\dots\n\\] 此外，它也不是连续映射 \\[\n\\begin{aligned}\na=0.3333\\dots, b=0.4999\\dots &\\implies c=0.343939\\dots \\\\\na=0.3333\\dots, b=0.5000\\dots &\\implies c=0.353030\\dots\n\\end{aligned}\n\\] 其对应的 \\([0,1] \\to [0,1]^2\\) 的非单的满射（如构造出的小数不规范，则将其规范化）亦不连续． \\[\n\\begin{aligned}\nc = 0.4999\\dots &\\implies a = 0.4999\\dots, b=0.9999\n\\dots \\\\\nc = 0.5000\\dots &\\implies a = 0.5000\\dots, b=0.0000\\dots\n\\end{aligned}\n\\]\nFun fact: \\({\\mathbb R}^2 \\approx \\left(2^{\\mathbb N}\\right)^{2} \\approx 2^{\\left({\\mathbb N \\times 2} \\right)} \\approx 2^{\\mathbb N} \\approx \\mathbb R\\)（基数理论）\n\n\n3.4 小结\n\nHilbert 曲线：\\(\\mathbb R \\to {\\mathbb R}^2\\) 的连续满射．\n集合势理论：\\({\\mathbb R}^2 \\to {\\mathbb R}\\) 的不连续单（双）射．"
  },
  {
    "objectID": "posts/20230519-hilbert/index.html#comments",
    "href": "posts/20230519-hilbert/index.html#comments",
    "title": "Hilbert 曲线与集合势理论",
    "section": "Comments",
    "text": "Comments\n\n\n希尔伯特曲线及性质的形式化理解 - zzdyyy[2]\n本文脉络的主要参考．\nWhy does the Hilbert curve fill the whole square? - Math StackExchange[3]\n提供了收敛性的较严谨证明．\n希尔伯特曲线：无限数学怎样应用于有限世界 - 3Blue1Brown[4]\n优秀的可视化．\nSpace-filling curve - Wikipedia[5]\n《集合论基础教程》张峰、陶然[6]\n\n扩展阅读：\n\n《Space-filling curves》Hans Sagan[1]\n回顾了空间填充曲线发展历史；用形式化的语言刻画了 Hilbert 曲线，见文内引用．"
  },
  {
    "objectID": "posts/20230519-hilbert/index.html#acknowledgements",
    "href": "posts/20230519-hilbert/index.html#acknowledgements",
    "title": "Hilbert 曲线与集合势理论",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\n感谢吕老师组织研讨课．本次研讨课与宁同学一同准备并主要由后者主讲，在讨论和展示过程中收获颇丰．"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html",
    "href": "posts/20201206-gcdconv/index.html",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "",
    "text": "比赛用题面、题解、标程和数据生成器均已挂在 git@github.com:sun123zxy/gcdconv.git 上。"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#problem",
    "href": "posts/20201206-gcdconv/index.html#problem",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "Problem",
    "text": "Problem\n\nGCD卷积 (gcdconv.cpp/.in/.out) (1s,512MB)\nDescription\n定义一种新的卷积 —— GCD卷积，其接受两个长度为 \\(n\\) 的序列 \\(f,g\\) ，依据下式生成长度为 \\(n\\) 的序列 \\(h\\) ： \\[\nh_k = \\sum_{\\gcd(i,j) = k} f_i g_j\n\\] 现给定序列 \\(f,g\\) ，求各 \\(h_i\\) 对 \\(998244353\\) 取模后的值。\nInput\n第一行输入一个正整数 \\(n\\) ，表示 \\(f,g\\) 的长度。\n第二行输入 \\(n\\) 个整数 \\(f_i\\) 。\n第三行输入 \\(n\\) 个整数 \\(g_i\\) 。\nOutput\n为减少输出量，只需输出1个整数，表示各 \\(h_i\\) 对 \\(998244353\\) 取模后的异或和。\nSample 1\nSample 1 Input\n3\n5 1 4\n2 3 3\nSample 1 Output\n78\nSample 1 Explanation \\[\n\\begin{aligned}\nh_1 &= f_1 ( g_1 + g_2 + g_3 ) + g_1 (f_2 + f_3) + f_2 g_3 + f_3 g_2 = 65 \\\\\nh_2 &= f_2 g_2 = 3 \\\\\nh_3 &= f_3 g_3 = 12\n\\end{aligned}\n\\]\n\\[\n65 \\oplus 3 \\oplus 12 = 78\n\\]\nSample 2\nSample 2 Input\n4\n7 1 8 0\n6 2 9 1\nSample 2 Output\n158\nSample 2 Explanation \\[\n\\begin{aligned}\nh_1 &= 213 \\\\\nh_2 &= 3 \\\\\nh_3 &= 72 \\\\\nh_4 &= 0\n\\end{aligned}\n\\]\n\\[\n213 \\oplus 3 \\oplus 72 \\oplus 0 = 158\n\\]\nSample 3\n见 sample 目录下 gcdconv3.in/.ans 。\nConstraints\n对20%的数据，\\(1 \\le n \\le 2000\\) 。\n对100%的数据， \\(1 \\le n \\le 4 \\times 10^5\\) ， \\(0 \\le f_i, g_i \\le 998244352\\) 。\nHints\n时限在std的1.5倍左右。std没有卡常，数据有一定梯度，请放心食用。\nSource\nsun123zxy"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#section",
    "href": "posts/20201206-gcdconv/index.html#section",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "???",
    "text": "???\n\n样例2比较暴力。"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#记号说明",
    "href": "posts/20201206-gcdconv/index.html#记号说明",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "记号说明",
    "text": "记号说明\n默认诸如 \\(n,d,i,j,k\\) 的下标变量的最大值为题目中的给出的序列长度，并把序列更换为数论函数来表示。\n注意本题解中的 \\(n\\) 通常是一个变量，和题目中定义的序列长度 \\(n\\) 不同。\n另外，用 \\(\\circ\\) 代表 \\(\\gcd\\) 卷积，即 \\[\nh(n) = (f \\circ g)(n) = \\sum_{\\gcd(i,j) = n} f(i) g(j)\n\\]"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#solution",
    "href": "posts/20201206-gcdconv/index.html#solution",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "Solution",
    "text": "Solution\n我们按照快速傅里叶变换（FFT）、快速莫比乌斯变换（FMT）解决卷积的思路来解决该问题——构造一种变换来满足卷积定理：\n\\[\n\\hat f(n) \\hat g(n) = \\widehat {(f \\circ g)}(n)\n\\] \\(\\hat f\\) 即对函数 \\(f\\) 进行该变换后得到的函数。\n通过一些敏锐的直觉，我们能感受到 \\(\\gcd\\) 和枚举约数或者倍数有一些关系。\n容易想到构造出一种变换，称之为“倍数和变换”： \\[\n\\hat f(n) = \\sum_{n|d} f(d)\n\\] 并根据莫比乌斯反演得到它的逆变换 \\[\nf(n) = \\sum_{n|d} \\mu(\\frac n d) \\hat f(d)\n\\] （这实际上是标准莫比乌斯反演的另一种形式，详见后文 Further Thoughts ）\n这个变换对 \\(\\gcd\\) 卷积满足卷积定理，证明如下。\n首先，写出 \\(\\gcd\\) 卷积 \\[\nh(k) = (f \\circ g)(k) = \\sum_{i,j} [\\gcd(i,j)=k] f(i) g(j)\n\\] 左右两边做倍数和变换： \\[\n\\begin{aligned}\n\\hat h(n) &= \\sum_{n|k} \\sum_{i,j} [\\gcd(i,j)=k] f(i) g(j) \\\\\n&= \\sum_{i,j} \\left( \\sum_{n|k} [\\gcd(i,j)=k] \\right) f(i) g(j) \\quad \\\\\n&= \\sum_{i,j} [n|i][n|j] f(i) g(j) \\quad \\\\\n&= \\sum_{n|i} f(i) \\sum_{n|j} g(j) \\quad \\\\\n&= \\hat f(n) \\hat g(n)\n\\end{aligned}\n\\] 得证。上述证明的核心在于 \\(\\sum_{n|k} [\\gcd(i,j)=k] = [n|i] [n|j]\\) 。\n于是，先对 \\(f,g\\) 做倍数和变换，然后直接 \\(O(n)\\) 点值相乘，再逆变换回来，就能得到 \\(f \\circ g\\) 。\n那么剩下的问题在于如何快速做倍数和变换及其逆变换。这是非常simple的，直接暴力就好了。复杂度为 \\(O(n H(n))\\) ，其中调和级数 \\(H(n)= \\sum_{k=1}^{n} \\frac 1 k\\) ，有 \\(\\lim_{n \\to \\infty} H(n) = \\ln(n) + c\\) 。欧拉常数 \\(c \\approx 0.57721566490153286060651209\\) 。\n可以称之为“快速倍数和变换”。\n总时间复杂度约为 \\(O(n \\ln n)\\) 。"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#code",
    "href": "posts/20201206-gcdconv/index.html#code",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "Code",
    "text": "Code\n/*\ngcd卷积 (gcdconv) std\nby sun123zxy \n*/\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\n\nll Rd(){\n    ll ans=0;bool fh=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9'){if(c=='-') fh=1; c=getchar();}\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    if(fh) ans=-ans;\n    return ans;\n}\n\nconst ll MOD=998244353;\n#define _ %MOD\nll PMod(ll x){\n    if(x&lt;0) return x+MOD;\n    else if(x&gt;=MOD) return x-MOD;\n    else return x;\n}\n\nconst ll MXN=5E5+5;\nll P[MXN],mu[MXN];ll pN;\nbool notP[MXN];\nvoid LinearSieve(ll n){\n    notP[1]=1;for(ll i=2;i&lt;=n;i++) notP[i]=0;\n    P[1]=0;mu[1]=1;\n    pN=0;\n    for(ll i=2;i&lt;=n;i++){\n        if(!notP[i]){\n            P[++pN]=i;\n            mu[i]=-1;\n        }\n        for(ll j=1;i*P[j]&lt;=n;j++){\n            notP[i*P[j]]=1;\n            if(i%P[j]==0){\n                mu[i*P[j]]=0;\n                break;\n            }\n            mu[i*P[j]]=mu[i]*mu[P[j]];\n        }\n    }\n}\n\nclass Poly{public:\n    ll& operator [] (ll idx){return cof[idx];}\n    ll n;vector&lt;ll&gt; cof;\n    Poly(){}\n    Poly(ll n){Resize(n);}\n    void Resize(ll n){\n        this-&gt;n = n;\n        cof.resize(n+1,0);\n    }\n};\nnamespace PC{//PolyCalc\n    void FMT(Poly& A,ll typ){\n        ll n=A.n;\n        Poly B(n);\n        for(ll i=1;i&lt;=n;i++){\n            for(ll j=1;i*j&lt;=n;j++){\n                ll t=A[i*j];if(typ==-1) t=t*mu[j]_;\n                B[i]=PMod(B[i]+t);\n            }\n        }\n        A=B;\n    }\n    Poly GcdConv(Poly A,Poly B){\n        ll n=min(A.n,B.n); \n        Poly C(n);\n        FMT(A,1);FMT(B,1);\n        for(ll i=1;i&lt;=n;i++) C[i]=A[i]*B[i]_;\n        FMT(C,-1);\n        return C;\n    }\n}\n\nll N;\n\nint main(){\n    freopen(\"gcdconv.in\",\"r\",stdin);\n    freopen(\"gcdconv_std.out\",\"w\",stdout);\n    N=Rd();\n    LinearSieve(N);\n    Poly A(N),B(N);\n    for(ll i=1;i&lt;=N;i++) A[i]=Rd();\n    for(ll i=1;i&lt;=N;i++) B[i]=Rd();\n    Poly C=PC::GcdConv(A,B);\n    ll ans=0;\n    for(ll i=1;i&lt;=N;i++) ans^=C[i];\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#further-thoughts",
    "href": "posts/20201206-gcdconv/index.html#further-thoughts",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "Further Thoughts",
    "text": "Further Thoughts\n本题用到的是莫比乌斯反演的一种变形 \\[\ng(n) = \\sum_{n|d} f(n) \\iff f(d) = \\sum_{n|d} \\mu(\\frac n d) g(d)\n\\] 原版莫比乌斯反演长这样 \\[\ng(n) = \\sum_{d|n} f(n) \\iff f(d) = \\sum_{d|n} \\mu(\\frac n d) g(d)\n\\] 若把题目改成 \\(\\mathrm{lcm}\\) 卷积，即 \\[\nh_k = \\sum_{\\mathrm{lcm}(i,j) = k} f_i g_j\n\\] 用到的就是原版莫比乌斯反演。相应的构造一个“约数和变换”即可解决。而约数和变换可以用“快速约数和变换”（实际上就是个埃筛）实现，有兴趣的同学可以试试。"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#further-further-thoughts-update-20201028",
    "href": "posts/20201206-gcdconv/index.html#further-further-thoughts-update-20201028",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "Further Further Thoughts (update 2020/10/28)",
    "text": "Further Further Thoughts (update 2020/10/28)\n我们来探讨一些更加接近本质的东西。\n普通卷积（多项式乘法）、集合并/交卷积、还有 \\(\\mathrm{lcm}\\) / \\(\\gcd\\) 卷积，这三个问题我们是如何解决的？\n关键在于——我们分别构造出了离散傅里叶变换、子集和/超集和变换（莫比乌斯变换）和约数和/倍数和变换来满足卷积定理。\n而这三个变换的共性在哪里呢？\n他们都是偏序集上的具有优美性质的广义反演。\n\n离散傅里叶变换用的是单位根反演——其偏序集是定义在自然数集上的小于等于关系；\n子集和/超集和变换用的是容斥原理——其偏序集是定义在集合上的包含关系；\n而约数和/倍数和变换则运用了莫比乌斯反演——其偏序集是定义在自然数集上的整除关系。\n\n反演的意义就在于——它为将原来的“系数”转化为“点值”， \\(O(n)\\) 乘起来后又转回“系数”提供了可能。而这三个特殊的反演之所以优美，就是因为我们发现了他们的“快速 (Fast) ”变换方式，让我们能通过这个Trick，免去了 \\(O(n^2)\\) 的暴力运算。\n还有更重要的一点——子集和/超集和变换与约数和/倍数和变换有着更加紧密的联系——这也是笔者由集合的FMT想到约数和变换的关键所在——以全体素数为基底可以张成一个包含全体正整数的“素数空间”（其良定义依赖于整数惟一分解定理）。\n约数和变换就是“素数空间”中的高维前缀和，对应着“集合空间”中的子集和变换。换句话说，子集和变换、约数和变换分别是莫比乌斯变换在“素数空间”、“集合空间”的具体体现，它们的本质都是高维前缀和。\n如果理解到上面这一点，就不难发现集合并卷积和 \\(\\mathrm{lcm}\\) 卷积的共性了——他们都把数放到了对两个输入元素各维度坐标取 \\(\\max\\) 后的位置；而集合交卷积和 \\(\\gcd\\) 卷积则是取 \\(\\min\\) 。\n综上所述，有了上面的认识，可以说 \\(\\gcd\\) 卷积的发现是非常自然的。"
  },
  {
    "objectID": "posts/20201206-gcdconv/index.html#后记-致谢",
    "href": "posts/20201206-gcdconv/index.html#后记-致谢",
    "title": "原创OI题目 GCD卷积 Problem and Solution",
    "section": "后记 & 致谢",
    "text": "后记 & 致谢\nIdea是在语文课上摸出来的，Solution是在随后的数学课上想出来的\n很早以前就觉得FMT和莫比乌斯反演有些说不清道不明的关系，出这道题也让笔者对其理解更加深入了。\n其实早有大佬对 \\(\\mathrm{lcm}\\) / \\(\\gcd\\) 卷积展开过研究。Google一波可以发现国外数学社区有这方面的讨论，最晚2013年arXiv上就有讨论其性质的论文了（笔者驽钝，确实无力理解，感兴趣的大佬可以直接Google “GCD Convolution”了解）。只可惜如此自然而美妙的 \\(\\gcd\\) 卷积，竟然没有随着那篇集合幂级数的论文引入国内，让笔者感到有些遗憾。\n总之，这道题深入的考察对FFT、FMT原理的理解以及对 \\(\\gcd\\) 、莫比乌斯反演的敏锐直觉，是不可多得的数论好题（\n下面是战术感谢环节。\n感谢keke学长为我们教授集合幂级数。\n感谢TbYangZ、diong神、changruinian2020几位神仙的点拨。\nAnd you…\n\n——sun123zxy\n\n\nSep. 2020 初稿完成\n\n\nNov. 2020 最后更新\n\nNext Phantasm…"
  },
  {
    "objectID": "posts/20191209-paint/index.html",
    "href": "posts/20191209-paint/index.html",
    "title": "涂色游戏 题解",
    "section": "",
    "text": "bsoj6412 没找到出处。。。\n题意简述：给一颗树，一次操作定义为随机选择一个点，染掉该点和它周围一圈的点，问期望多少次染黑所有点。\n这是道好题啊！全面考察了容斥、反演、期望和dp，有许多值得注意的细节。"
  },
  {
    "objectID": "posts/20191209-paint/index.html#s-1",
    "href": "posts/20191209-paint/index.html#s-1",
    "title": "涂色游戏 题解",
    "section": "一、做法1（容斥/二项式反演+dp）",
    "text": "一、做法1（容斥/二项式反演+dp）\n\n1.1 化式子\n首先肯定第一个想到的式子就是\n\\[\nAns = \\sum_{i=1}^{\\infty} i *  P(在染第i次时刚好黑完)\n\\]\n这是根据期望的定义直接得到的。\n然后发现这个\\(i\\)实在是非常的恶心，因为它居然和无穷有关。但既然是一个合法的期望题，这个\\(i\\)必然可以找到某种转化的手段把它弄成一个能算的且收敛的东西，比如等比数列级数之类的。\n于是这里有一个套路化法 \\[\n\\sum_{i=1}^{\\infty} i *  P(x=i) = \\sum_{i=0}^{\\infty} P(x&gt;i)\n\\]\n（\\(P(A)\\)代表事件\\(A\\)发生的概率）\n就是改了改枚举的方式，随便想一想应该能够明白了吧（\n总之，根据上式我们就可以得到 \\[\nAns = \\sum_{i=0}^{\\infty} P(染i次未黑完)\n\\]\n我们成功把\\(i\\)丢到了\\(P\\)里面去。但是我们还是没有办法求这个东西。\n发现虽然选点可以进行无数次，但是最多只会选有限个点，许多选点是重复的。用实际选择的点的个数，我们可以在不可计算的无限和可计算的有限之间搭上一座桥梁。我们考虑将上面的\\(P\\)进行一个拆分，得到 \\[\nAns = \\sum_{i=0}^{\\infty} \\sum_{k=0}^{n} P(选i次恰好选中某k个点) * N(k个点未黑完整棵树)\n\\]\n\\(N(A)\\)代表事件\\(A\\)的方案数\n注意式子中“某”的含义。可以这样理解这个式子：\n我钦定了某\\(k\\)个点\n首先我想知道：进行\\(i\\)次随机选择，选中且只选中这\\(k\\)个点的概率\n然后再判断这\\(k\\)个点是否能让整棵树黑完。如果不能，则将这部分概率计入。\n将所有可能钦定的情况合起来就是\\(N\\)，而选择的概率实际上和树形结构无关，选中任意\\(k\\)个点的概率都是一样的，所以直接乘起来即可。\n好，理解了上式，我们来仔细研究\\(P\\)和\\(N\\)到底是什么。\n\n\n1.2 容斥/二项式反演\n首先研究\\(P\\)。首先如果恰好选中某\\(k\\)个点，那么必然先得保证这\\(i\\)次都不能选中其他的点。概率是 \\[\n(\\frac{k}{n})^i\n\\]\n但这样计算显然是有问题的。因为可能出现有点一次都没有被选中的情况，而这不满足我们“恰好选中”的要求。换句话说，我们只能计算\\(P(|被选中的点| \\le p)\\)。而实际上，我们需要的是 \\(P(|选中的点集| = p)\\)。\n容易想到容斥掉它。\n考虑枚举一次都没有被选中的点，经过仔细思考，我们能够艰难的得到 \\[\nP(选i次恰好选中某k个点) = \\sum_{p=0}^k C_k^p (-1)^p (\\frac{k-p}{n})^i\n\\]\n我无力解释这个式子…各位自己尝试理解一下吧…\n把某个点一次都没有被选中画成一个圆圈，用Venn图的形式可能有助于理解。\n虽然难以理解…不过好在可以用二项式反演推导。 \\[\nf(n) = \\sum_{k=0}^n C_n^k g(k) \\iff g(n) = \\sum_{k=0}^n C_n^k (-1)^k f(n-k)\n\\]\n套入本题 \\[\ng_i(k) = P(选i次恰好选中某k个点)\n\\]\n\\[\nf_i(k) = (\\frac{k}{n})^i\n\\]\n这样就好懂多了，，\n不管怎么说，我们终于搞到了\\(P\\)表达式，而且这个表达式里\\(i\\)是指数！带回原式说不定可以用等比级数干掉它。\n\n\n1.3 回到答案式\n为方便书写，令\\(a_k = N(k个点未黑完整棵树)\\) \\[\n\\begin{aligned}\nAns &= \\sum_{i=0}^{\\infty} \\sum_{k=0}^{n} a_k \\sum_{p=0}^k C_k^p (-1)^p (\\frac{k-p}{n})^i \\\\\n    &= \\sum_{k=0}^{n} a_k \\sum_{p=0}^k C_k^p (-1)^{k-p} \\sum_{i=0}^{\\infty} (\\frac{p}{n})^i \\\\\n\\end{aligned}\n\\]\n由于当\\(|q| &lt; 1\\)时，有 \\[\n\\begin{aligned}\n\\sum_{i=0}^{\\infty} q^i &= \\lim_{n \\to \\infty} \\frac{q^{n+1}-1}{q-1} \\\\\n&= \\frac{1}{1-q}\n\\end{aligned}\n\\]\n故 \\[\nAns = \\sum_{k=0}^{n} a_k \\sum_{p=0}^k C_k^p (-1)^{k-p} \\frac{n}{n-p}\n\\]\n（当\\(k=p=n\\)时，由于上一步转化要求\\(|q|&lt;1\\)，而此时\\(|q|=1\\)，会出现级数发散的情况。但发现\\(a_n\\)显然一定等于\\(0\\)，所以直接不算\\(k=n\\)的情况即可）\n直接枚举是\\(O(n^2)\\)的，现在我们只需要求出每一个\\(a_k = N(k个点未黑完整棵树)\\)\n\n\n1.4 树形dp\n首先可以做一步简单容斥简化问题\n\\[\nN(k个点未黑完整棵树) = C_n^k - N(k个点黑完整棵树)\n\\]\n求\\(N(k个点黑完整棵树)\\)，很容易想到树上背包\n实际上就是在树上分配选点，也就是一个背包，而方案数背包的实质是卷积，所以就是用树形dp维护卷积合并。\n开始写状态。\n\\(f[u][0/1][0/1]\\)表示只考虑以\\(u\\)为根的子树，父亲是否被选择，自己是否被选择的方案数。（可能有更简单的状态表示，但我觉得这种更好想更靠谱）\n随便写写就有转移方程了。\n\\[\nf[u][0][0] = f[u][1][0] - \\prod_v f[v][0][0]\n\\]\n没有父亲援助，自己也不选，只能靠儿子。儿子节点只需要有一个选就可以养活自己。也就是儿子随便乱选减去儿子一个都不选的情况。 \\[\nf[u][0][1] = I * \\prod_v (f[v][1][0] + f[v][1][1])\n\\]\n自己选了，上下随便。 \\[\nf[u][1][0] = \\prod_v ( f[v][0][0] + f[v][0][1] )\n\\]\n父亲选了，自己不选，下面随便。 \\[\nf[u][1][1] = f[u][0][1]\n\\]\n自己选了，上下随便。\n照着dp即可。 \\[\nN(k个点黑完整棵树) = f[root][0][0][k]+f[root][0][1][k]\n\\]\n顺着之前倒着带回去行了。\n\n\n1.5 时间复杂度\n\n1.5.1 答案式\n显然是\\(O(n^2)\\)的。\n\n\n1.5.2 树形dp\n一次卷积\\(O(n ^ 2)\\)，会向上合并\\(O(n)\\)次…\n诶？这不是\\(O(n^3)\\)的吗？\n实则不然。\n设\\(sz[u]\\)为以\\(u\\)为根的子树大小。显然可能涉及的卷积长度\\(len \\le sz[u]\\)\n于是考虑每个节点\\(u\\)下的所有儿子\\(v\\)合并起来的耗时。 \\[\n\\sum_{v_1 \\not= v_2} sz[v_1] *sz[v_2] = sz[u]^2 - \\sum_v sz[v]^2 \\\\\n\\]\n后面减去的和式，将抵消掉所有儿子节点产生的时间复杂度！\n所以真正的复杂度是\\(O(n^2)\\)\n妙啊\n这里提供另一道题 loj6289 花朵 ，其部分分解法也是这种方式证明时间复杂度\n还要优化的话，可以用NTT来做卷积，还可以用堆来实现从小到大合并减少浪费的时间，类似分治NTT。但都只是常数级优化。\n\n\n\n1.6 总结\n爆拆期望得无穷级数，尝试去掉无穷，套路化法将\\(i\\)化入\\(P\\)。\n拆掉\\(P\\)在无穷与有限间建立联系，分别处理\\(P\\)和\\(N\\)。\n\\(P\\)可容斥得出，带回原式用等比级数干掉无穷的\\(i\\)\n\\(N\\)用树上背包可解，仔细推转移即可\n\n\n1.7 Code\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\ntypedef long long ll;\nusing namespace std;\n\nll Rd(){\n    ll ans=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9') c=getchar();\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    return ans;\n}\n\nconst ll MOD=998244353;\nll QPow(ll x,ll up){\n    x=(x+MOD)%MOD;\n    ll ans=1;\n    while(up)\n        if(up%2==0) x=x*x%MOD,up/=2;\n        else ans=ans*x%MOD,up--;\n    return ans;\n}\nll Inv(ll x){\n    return QPow(x,MOD-2);\n}\n\nconst ll PTN=1005;\nll N;\nll fac[PTN],facInv[PTN];\nvoid FacInit(){\n    fac[0]=1;for(ll i=1;i&lt;=N;i++) fac[i]=fac[i-1]*i%MOD;\n    facInv[N]=Inv(fac[N]);for(ll i=N-1;i&gt;=1;i--) facInv[i]=facInv[i+1]*(i+1)%MOD;\n    facInv[0]=1;\n}\nll C(ll n,ll m){\n    if(n&lt;m) return 0;\n    return fac[n]*facInv[m]%MOD*facInv[n-m]%MOD;\n}\n\nstruct Edge{\n    ll u,v;ll nxt;\n}edge[PTN*2];\nll graM,last[PTN];\nvoid GraphInit(){graM=0;for(ll i=0;i&lt;PTN;i++) last[i]=0;}\nvoid AddBscEdge(ll u,ll v){\n    edge[++graM]=(Edge){u,v,last[u]};\n    last[u]=graM;\n}\nvoid AddDbEdge(ll u,ll v){\n    AddBscEdge(u,v);AddBscEdge(v,u);\n}\n\nclass Func{public:\n    ll sav[PTN];ll len;\n    Func(){}\n    Func(ll len){\n        this-&gt;len=len;\n        for(ll i=0;i&lt;=len;i++) sav[i]=0;\n    }\n    void Resize(ll nwLen){\n        for(ll i=len+1;i&lt;=nwLen;i++) sav[i]=0;\n        len=nwLen;\n    }\n    ll& operator [] (ll idx){return sav[idx];}\n    /*void Debug(){\n        cout&lt;&lt;len&lt;&lt;\":\";\n        for(ll i=0;i&lt;=len;i++) cout&lt;&lt;sav[i]&lt;&lt;\",\";cout&lt;&lt;endl;\n    }*/\n};\nFunc operator + (Func A,Func B){\n    Func C(max(A.len,B.len));\n    A.Resize(C.len);B.Resize(C.len);\n    for(ll i=0;i&lt;=C.len;i++) C[i]=A[i]+B[i]%MOD;\n    return C;\n}\nFunc operator - (Func A,Func B){\n    Func C(max(A.len,B.len));\n    A.Resize(C.len);B.Resize(C.len);\n    for(ll i=0;i&lt;=C.len;i++) C[i]=A[i]-B[i]%MOD;\n    return C;\n}\nFunc operator * (Func A,Func B){\n    Func C(A.len+B.len);\n    for(ll i=0;i&lt;=A.len;i++)\n        for(ll j=0;j&lt;=B.len;j++)\n            C[i+j]=(C[i+j]+A[i]*B[j])%MOD;\n    return C;\n}\nFunc I(){\n    Func A(1);A[1]=1;return A;\n}\nFunc E(){\n    Func A(0);A[0]=1;return A;\n}\nFunc f[PTN][2][2];\nvoid FDFS(ll u,ll father){\n    Func s00,s00_01,s10_11;\n    s00=s00_01=s10_11=E();\n    for(ll i=last[u];i!=0;i=edge[i].nxt){\n        ll v=edge[i].v;if(v==father) continue;\n        FDFS(v,u);\n        s00=s00*f[v][0][0];\n        s00_01=s00_01*(f[v][0][0]+f[v][0][1]);\n        s10_11=s10_11*(f[v][1][0]+f[v][1][1]);\n    }\n    f[u][0][0]=s00_01-s00;\n    f[u][0][1]=I()*s10_11;\n    f[u][1][0]=s00_01;\n    f[u][1][1]=I()*s10_11;\n}\nll A[PTN];\nvoid Solve(){\n    FDFS(1,0);\n    for(ll k=0;k&lt;=N;k++) A[k]=(C(N,k)-(f[1][0][0][k]+f[1][0][1][k])%MOD+MOD)%MOD;\n    ll Ans=0;\n    for(ll k=0;k&lt;N;k++){//注意&lt;N \n        ll t=0;\n        for(ll p=0;p&lt;=k;p++){\n            ll alpha;\n            if((k-p)%2==0) alpha=1;\n            else alpha=(-1+MOD)%MOD;\n            t=(t+C(k,p)*alpha%MOD*N%MOD*Inv(N-p)%MOD)%MOD;\n        }\n        t=t*A[k]%MOD;\n        Ans=(Ans+t)%MOD;\n    }\n    cout&lt;&lt;Ans;\n}\nint main(){\n    N=Rd();FacInit();\n    GraphInit();\n    for(ll i=1;i&lt;N;i++){\n        ll u=Rd(),v=Rd();\n        AddDbEdge(u,v);\n    }\n    Solve();\n    return 0;\n}"
  },
  {
    "objectID": "posts/20191209-paint/index.html#s-2",
    "href": "posts/20191209-paint/index.html#s-2",
    "title": "涂色游戏 题解",
    "section": "二、做法2（minmax容斥+dp）",
    "text": "二、做法2（minmax容斥+dp）\n\n2.1 minmax容斥\nminmax容斥标准式： \\[\n\\max(S) = \\sum_{T \\subseteq S \\\\ T \\not= \\varnothing} (-1)^{|T|-1} \\min(T)\n\\]\n由于期望具有线性性，它可以拓展到期望： \\[\nE(\\max(S)) = \\sum_{T \\subseteq S \\\\ T \\not= \\varnothing} (-1)^{|T|-1} E(\\min(T))\n\\]\n然后把这个式子映射到本题中来。（下文把操作了多少次称为“时间”）\n\\(S\\)就是整棵树。集合中的元素可以看做每一个点第一次被染成黑色的时间，于是\\(\\max(S)\\)就表示染黑集合\\(S\\)中所有点的耗时；\\(\\min(S)\\)表示至少染黑集合\\(S\\)中的某一个点的耗时。\n套上期望后：\\(E(\\max(S))\\)表示染黑集合中所有点的期望耗时，也就是本题所要求的答案；\\(E(\\min(T))\\)表示至少染黑集合中的某一个点的期望耗时。\n捋一下思路，由于期望不满足\\(E(\\max(S)) = \\max_{x \\in S} E(x)\\)，无法直接遍历求\\(\\max\\)。但是因为期望具有线性性，可以借助minmax容斥来达到目的。 （这是一类套路题型）\n\n\n2.2 处理 \\(E(\\min(T))\\)\n于是思考\\(E(\\min(T))\\)是否容易求得。容易列出： \\[\nE(\\min(T)) = \\frac{|U_T|}{n} + (1 - \\frac{|U_T|}{n})(1 + E(\\min(T)))\n\\]\n其中\\(|U_T|\\)表示选择后能让\\(T\\)中某个节点变黑的点的集合。\n解得 \\[\nE(\\min(T)) = \\frac{n}{|U_T|}\n\\]\n补充一点，显然\\(S\\)、\\(T\\)、\\(U_T\\)有这样的关系 \\[\nT \\subseteq U_T \\subseteq S\n\\]\n将表达式带入原式中 \\[\nE(\\max(S)) = \\sum_{T \\subseteq S \\\\ T \\not= \\varnothing} (-1)^{|T|-1} \\frac{n}{|U_T|}\n\\]\n枚举子集是复杂度的瓶颈。不过发现枚举中许多项的\\(|U_T|\\)都是相同的，考虑把它单独拿出来枚举。 \\[\nE(\\max(S)) = \\sum_{u=1}^n \\frac{n}{u} \\sum_{T \\subseteq S \\\\ T \\not= \\varnothing \\\\ |U_T|=u} (-1)^{|T|-1}\n\\]\n也就是说，现在我们只需快速求得 \\[\n\\sum_{T \\subseteq S \\\\ T \\not= \\varnothing \\\\ |U_T|=u} (-1)^{|T|-1}\n\\]\n思考这式子的意义。其实它就是一个带上了容斥系数的所有\\(T\\)的方案数之和，也就是\\(|T|\\)为奇的方案数减去\\(|T|\\)为偶的方案数。\n尝试通过树形dp解决\n\n\n2.3 树形dp\n首先简单考虑一下所需的状态。考虑以某个点为根的子树，我们需要记录\\(|U_T|\\)，这是我们上面枚举的基础；\\(|T|\\)是容斥系数，我们需要记录它的奇偶性。\n可以想到转移大概的形式是在\\(U_T\\)上的卷积。\n\n2.3.1 状态压缩\n首先有一个小Trick，可以压掉记录\\(|T|\\)奇偶性这一维 \\[\n\\sum_{T \\subseteq S \\\\ T \\not= \\varnothing \\\\ |U_T|=u} (-1)^{|T|-1} = - \\sum_{T \\subseteq S \\\\ T \\not= \\varnothing \\\\ |U_T|=u} (-1)^{|T|}\n\\]\n根据上式，我们在dp时求\\(|T|\\)为偶的方案数减去\\(|T|\\)为奇的方案数，最后计算答案时乘上个\\(-1\\)即可。\n这么做的原因是可以压缩掉记录\\(|T|\\)奇偶性这一维。\n\n2.3.1.1 对于转移\n比如有两个对象\\(A=(x_1,y_1)\\)，\\(B(x_2,y_2)\\)需要合并为\\(C\\)（第1个参数表示\\(|T|\\)为偶的方案数，第2个参数表示\\(|T|\\)为奇的方案数） \\[\nC = (x_1 x_2 + y_1 y_2, x_1 y_2 + x_2 y_1)\n\\]\n如果将对象改写为单个变量记录：\\(A=x_1 - y_1\\)，\\(B = x_2 - y_2\\) \\[\n\\begin{aligned}\nC &= x_1 x_2 + y_1 y_2 - (x_1 y_2 + x_2 y_1) \\\\\n&= (x_1 - y_1) (x_2 - y_2) \\\\\n&= A B\n\\end{aligned}\n\\]\n而对象的值就是我们所求的（考虑容斥系数的方案数）。成功压缩。\n如果不做上面那一个Trick的转化，压缩状态需要 正*正=负 和 负*负=正，而这显然是不成立的。\n\n\n2.3.1.2 对于新增\n如果所有情况的\\(T\\)内新增一个节点，原来\\(|T|\\)为奇的变为偶，原来为偶的变为奇。\n如果不压缩，操作应该是交换\\(x\\)和\\(y\\)\n如果压缩，只需对dp值乘上\\(-1\\)即可\n\n\n\n2.3.2 设置状态并处理转移\n我们的dp实际上是用背包分配\\(|U_T|\\)。\n状态压缩后，剩下的主要问题在于合并时\\(|U_T|\\)、\\(|T|\\)发生的变化对dp值造成的影响，而这变化与当前点\\(u\\)到底属于哪个集合密切相关。\n由于转移情况复杂，而背包的本质是卷积，所以用封装性良好的卷积实现。\n令\\(f[u][d=0/1/2]\\)表示仅考虑\\(S\\)是\\(u\\)为根的子树时，以\\(x\\)为下标的列表 \\[\n\\{\\sum_{T \\subseteq S \\\\ T \\not= \\varnothing \\\\ |U_T|=x \\\\ u \\in Q_d} (-1)^{|T|} \\Large | \\normalsize \\ x \\in [0,|S|]\\}\n\\]\n\\(Q_d\\)是对\\(u\\)的限制，具体为\n\\(Q_0\\)：\\(u \\in S\\)且\\(u \\not \\in U_T\\)\n\\(Q_1\\)：\\(u \\in U_T\\)且\\(u \\not \\in T\\)\n\\(Q_2\\)：\\(u \\in T\\)\n定义\\(I\\)，\\(I[1]=1\\)​，其余皆为\\(0\\)，结合卷积可以表示向\\(U_T\\)内新增一个点。\n我们开始处理转移。 \\[\nf[u][0] = \\prod_{v} f[v][0] + f[v][1]\n\\]\n意思是若\\(u\\)不在\\(U_T\\)里，则它的所有儿子一定不能在\\(T\\)里。 \\[\nf[u][1] = \\left( \\left( \\prod_v f[v][0] + f[v][1] +f[v][2] \\right) - f[u][0] \\right) * I\n\\]\n若\\(u\\)在\\(U_T\\)内而\\(u\\)不在\\(T\\)内，则\\(u\\)的儿子中至少有一个是\\(T\\)中的点。这可以转化为所有情况的答案减去所有儿子都不在\\(T\\)中的答案。最后卷上\\(I\\)为\\(U_T\\)新增\\(u\\)。 \\[\nf[u][2] = - \\left( I * \\prod_v \\left( f[v][0] * I + f[v][1] + f[v][2] \\right) \\right)\n\\]\n若\\(u\\)在\\(T\\)内，那些本来不在\\(U_T\\)内的\\(u\\)的儿子现在就应该属于\\(U_T\\)了。然后既然\\(u\\)属于\\(T\\)，那么\\(u\\)也属于\\(U_T\\)，卷上\\(I\\)为\\(U_T\\)新增\\(u\\)。最后，由于\\(T\\)新增了个点，也就是说所有项的容斥系数\\(+1\\)，整体变号即可。\n最后算答案，参考早前化出的答案式即可。\n\n\n\n2.4 时间复杂度\n答案式部分显然\\(O(n)\\)\n树形dp卷积的时间复杂度为\\(O(n^2)\\)，见做法1对dp的时间复杂度证明。\n\n\n2.5 总结\n首先我们发现这道题适用于minmax容斥的套路，于是将难求的\\(E(max(S))\\)转化到容易求的\\(E(min(T))\\)。\n然后我们再想办法优化枚举子集，发现\\(U_T\\)是一个关键的变量，于是将其提出来单独枚举，问题转化为求带有容斥系数的方案数。\n回头观察题面发现是树状结构，必然有其特殊性质，于是猜想用树形dp解决。讨论合并时\\(U_T\\)和\\(T\\)是如何变化的，能够列出转移方程式。在中间想到了压缩状态，简化了dp。\n\n\n2.6 Code\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef long long ll;\nll Rd(){\n    ll ans=0;char c=getchar();\n    while(c&lt;'0'||c&gt;'9') c=getchar();\n    while(c&gt;='0'&&c&lt;='9') ans=ans*10+c-'0',c=getchar();\n    return ans;\n}\n\nconst ll MOD=998244353;\nll QPow(ll x,ll up){\n    x=(x+MOD)%MOD;\n    ll ans=1;\n    while(up)\n        if(up%2==0) x=x*x%MOD,up/=2;\n        else ans=ans*x%MOD,up--;\n    return ans;\n}\nll Inv(ll x){\n    return QPow(x,MOD-2);\n}\n\nconst ll PTN=1E3+5;\nstruct Edge{\n    ll u,v;ll nxt;\n}edge[PTN*2];\nll N,graM,last[PTN];\nvoid GraphInit(){graM=0;for(ll i=0;i&lt;PTN;i++) last[i]=0;}\nvoid AddBscEdge(ll u,ll v){\n    edge[++graM]=(Edge){u,v,last[u]};\n    last[u]=graM;\n}\nvoid AddDbEdge(ll u,ll v){\n    AddBscEdge(u,v);AddBscEdge(v,u);\n}\n\nclass Func{public:\n    ll sav[PTN];\n    ll len;\n    ll& operator [] (ll idx){return sav[idx];}\n    Func(){}\n    Func(ll len){\n        this-&gt;len=len;\n        for(ll i=0;i&lt;=len;i++) sav[i]=0;\n    }\n    void Expand(ll nwLen){\n        for(ll i=len+1;i&lt;=nwLen;i++) sav[i]=0;\n        len=nwLen;\n    }\n    Func operator - (){\n        Func B;B.len=len;\n        for(ll i=0;i&lt;=len;i++) B[i]=(-sav[i]+MOD)%MOD;\n        return B;\n    }\n    /*void Debug(){\n        cout&lt;&lt;len&lt;&lt;\":\";\n        for(ll i=0;i&lt;=len;i++) cout&lt;&lt;sav[i]&lt;&lt;',';cout&lt;&lt;endl;\n    }*/\n};\nFunc E(){\n    Func A(0);A[0]=1;\n    return A;\n}\nFunc I(){\n    Func A(1);A[1]=1;\n    return A;\n}\nFunc operator + (Func A,Func B){\n    Func C(max(A.len,B.len));\n    A.Expand(C.len);B.Expand(C.len);\n    for(ll i=0;i&lt;=C.len;i++) C[i]=(A[i]+B[i])%MOD;\n    return C;\n}\nFunc operator - (Func A,Func B){\n    Func C(max(A.len,B.len));\n    A.Expand(C.len);B.Expand(C.len);\n    for(ll i=0;i&lt;=C.len;i++) C[i]=(A[i]-B[i]+MOD)%MOD;\n    return C;\n}\nFunc operator * (Func A,Func B){\n    Func C(A.len+B.len);\n    for(ll i=0;i&lt;=A.len;i++)\n        for(ll j=0;j&lt;=B.len;j++)\n            C[i+j]=(C[i+j]+A[i]*B[j])%MOD;\n    return C;\n}\n\nFunc f[PTN][3];\nvoid DFS(ll u,ll fa){\n    f[u][0]=f[u][1]=f[u][2]=E();\n    for(ll i=last[u];i!=0;i=edge[i].nxt){\n        ll v=edge[i].v;if(v==fa) continue;\n        DFS(v,u);\n        f[u][0]=f[u][0]*(f[v][0]    +f[v][1]);\n        f[u][1]=f[u][1]*(f[v][0]    +f[v][1]+f[v][2]);\n        f[u][2]=f[u][2]*(f[v][0]*I()+f[v][1]+f[v][2]);\n    }\n    f[u][1]=(f[u][1]-f[u][0])*I();\n    f[u][2]=-(f[u][2]*I());\n}\nvoid Solve(){\n    DFS(1,0);\n    ll Ans=0;\n    for(ll i=1;i&lt;=N;i++){//注意从1开始，因为minmax容斥不包含空集 \n        Ans=(Ans+N*Inv(i)%MOD*(f[1][0][i]+f[1][1][i]+f[1][2][i]))%MOD;\n    }\n    cout&lt;&lt;(-Ans+MOD)%MOD;\n}\nint main(){\n    N=Rd();\n    GraphInit();\n    for(ll i=1;i&lt;N;i++){\n        ll u=Rd(),v=Rd();\n        AddDbEdge(u,v);\n    }\n    Solve();\n    return 0;\n}"
  },
  {
    "objectID": "posts/20191209-paint/index.html#s-3",
    "href": "posts/20191209-paint/index.html#s-3",
    "title": "涂色游戏 题解",
    "section": "三、总结",
    "text": "三、总结\n这道题简直人类智慧（\n解题思路很具有参考价值，实为一道期望好题！\n上周末看到这道题，因为全网都找不到出处也没题解，硬是对着一张题解截图（解法1）和先比我写出来的Waper爷的代码（解法2）杠出来了\n我现在感觉我整个人都升华了.jpg"
  }
]