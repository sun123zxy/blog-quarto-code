{
  "hash": "bfb5b9b984f3ba168f355c56437c4689",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"算法 & 数学碎碎念\"\nabstract: \"现场赛公式模板库，亦可作为小而精的总结性学习材料参考．无需单独成文或暂不完善的内容会放在这里．\"\nauthor: \"sun123zxy\"\ndate: \"2023/06/21\"\ndate-modified: \"2025/02/21\"\nlang: zh\n\ncategories:\n  - algorithm\n  - math\n  - combinatorics\n\nnumber-sections: true\n\nseriousness: dedicated\n\nformat:\n  html: default\n  pdf:\n    toc: true\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\newcommand{\\floor}[1]{\\left\\lfloor #1 \\right\\rfloor}\n\\newcommand{\\ceil}[1]{\\left\\lceil #1 \\right\\rceil}\n\\newcommand{\\inv}{\\operatorname{inv}}\n\\newcommand{\\lcm}{\\operatorname{lcm}}\n\\newcommand{\\id}{\\operatorname{id}}\n\\newcommand{\\card}{\\operatorname{card}}\n\\newcommand{\\diff}{\\operatorname{d}\\!}\n\\renewcommand{\\vec}{\\boldsymbol}\n\n前半部分主要为公式、推导、证明等速成提纲，大部分实现、模板、表格放在文末．\n\n## 数论\n\n### ExGCD\n\n:::{#thm-exgcd}\n\n## ExGCD\n\n给定线性方程组 $ax+by=\\gcd(a,b)$，其解可递归地由下式求得\n$$\na y_1 + b \\left( x_1 - \\floor{\\frac a b} y_1 \\right) = \\gcd(b, a \\bmod b)\n$$\n其中 $x_1, y_1$ 是 $b x + (a \\bmod b) y = \\gcd(b, a \\bmod b)$ 的一组解．\n:::\n\n### CRT\n\n:::{#thm-crt}\n\n## CRT\n\n给定 $n$ 个同余方程\n$$\nx \\equiv a_i \\pmod{m_i} \\pod{i = 1, \\dots, n}\n$$\n\n其中各 $m_i$ 两两互质，则上式等价于\n$$\nx \\equiv \\sum_{i=1}^n a_i M_i \\inv_{m_i}(M_i) \\pmod M\n$$\n其中 $M = \\prod_{i=1}^n m_i$，$M_i = \\frac{M}{m_i}$．\n:::\n\n::: {.remark}\n\n$$\nM_i \\inv_{m_i}(M_i) \\mod m_j = [i = j]\n$$\n:::\n\n#### ExCRT\n\n对一般的情况，考虑合并两个同余方程．给定 $2$ 个同余方程\n$$\n\\left\\{\n\\begin{aligned}\n  x &\\equiv a_1 \\pmod{m_1} \\\\\n  x &\\equiv a_2 \\pmod{m_2}\n\\end{aligned}\n\\right.\n$$\n考虑化为不定方程形式\n$$\n\\begin{aligned}\n  x = k_1 m_1 + a_1 \\\\\n  x = k_2 m_2 + a_2\n\\end{aligned}\n$$\n合并得到\n$$\nk_1 m_1 + a_1 = k_2 m_2 + a_2\n$$\n即\n$$\nk_1 m_1 - k_2 m_2 = a_2 - a_1\n$$\n此即关于 $k_1, k_2$ 的不定方程．若 $\\gcd(m_1, m_2) \\mid a_2 - a_1$，则可应用 ExGCD 求得方程的一组解，带回即得\n$$\nx \\equiv k_1 m_1 + a_1 \\pmod{\\lcm(m_1, m_2)}\n$$\n否则同余方程组无解．\n\n:::{.remark}\n若一组同余方程两两可合并，则全部均可合并．当判断大规模同余方程组是否有解时可能用到．\n:::\n\n### BSGS\n\n求 $a^x \\equiv b \\pmod{m}$ 的一个特解，其中 $\\gcd(a,m) = 1$．\n\n实质是非常暴力的根号分治．根据 Euler 定理，只需检测连续 $\\varphi(m)$ 个 $x$ 就可判定是否有解．令 $x = q \\ceil{\\sqrt m} -r$，其中 $q,r \\in [1,\\ceil{\\sqrt m}]$，于是 $x \\in [0,\\ceil{\\sqrt m}^2)$．代入原方程移项即得 $a^{q \\ceil{\\sqrt m}} \\equiv b a^r \\pmod{m}$，右边使用 `map` 提前存下即可．时间复杂度 $O(\\sqrt m)$．\n\n### Miller-Rabin【TODO】\n\n### Pollard-Rho【TODO】\n\n### 原根、Euler 定理等\n\n见 [FFT/NTT 讲稿](/posts/20230928-dft/)．\n\n### Lucas 定理\n\n::: {#thm-nt-lucas}\n\n## Lucas 定理\n\n$$\n\\binom{n}{m} \\equiv \\prod_{i} \\binom{n_i}{m_i} \\equiv \\binom{\\floor{n/p}}{\\floor{m/p}} \\binom{n \\bmod p}{n \\bmod p} \\pmod p\n$$\n\n其中 $p$ 是质数，$n_i$ 和 $m_i$ 是 $n$ 和 $m$ 的 $p$ 进制表示下的各数位．\n:::\n\n证明的要点有二：一是 $\\binom {p^i} m \\bmod {p} = [m = 0 \\land m = p^i]$，即 $(1+x)^{p^i} \\equiv 1 + x^{p^i} \\pmod p$；二是 Vandermonde 卷积按 $p$ 进制拆分．生成函数食用风味更佳．\n\n参考：\n\n- [Lucas's theorem - Wikipedia](https://en.wikipedia.org/wiki/Lucas%27s_theorem)\n- [卢卡斯定理 - OI Wiki](https://oi-wiki.org/math/number-theory/lucas/)\n\n### Legendre 公式和 Kummer 定理\n\n::: {#thm-nt-legendre}\n\n## Legendre 公式\n\n$$\n\\nu_p (n!) = \\sum_{i=1}^{+\\infty} \\floor{\\frac n {p^i}} = \\frac{n-S_p(n)}{p-1}\n$$\n\n其中 $p$ 是质数，$S_p(n)$ 是 $n$ 在 $p$ 进制下各数位数字之和．$\\nu_p (n!)$ 为 $n!$ 中质因子 $p$ 的含量，即所谓的 $p$-adic valuation of $n!$．\n:::\n\n左侧显然，按和式统计贡献即证．对于右侧，\n$$\n\\begin{aligned}\n\\sum_{i=1}^{+\\infty} \\floor{\\frac n {p^i}} &= \\sum_{i=1}^{+\\infty} \\sum_{k=0}^{+\\infty} n_{k+i} p^k \\\\\n&= \\sum_{j=1}^{+\\infty} n_j \\sum_{k=0}^{j-1} p^k \\\\\n&= \\sum_{j=1}^{+\\infty} n_j \\frac{p^j-1}{p-1} \\\\\n&= \\frac 1 {p-1} \\left(\\sum_{j=1}^{+\\infty} n_j p^j - \\sum_{j=1}^{+\\infty} n_j\\right) \\\\\n&= \\frac 1 {p-1} \\left(\\sum_{j=0}^{+\\infty} n_j p^j - \\sum_{j=0}^{+\\infty} n_j\\right) \\\\\n&= \\frac {n - S_p(n)}{p-1}\n\\end{aligned}\n$$\n\n::: {#thm-nt-kummer}\n\n## Kummer 定理\n\n$\\binom {a+b} a$ 中质因子 $p$ 的含量等于 $p$ 进制下加法 $a+b$ 发生的进位次数，也可表示为\n$$\n\\nu_p \\left( \\binom {a+b}{a} \\right) = \\frac{S_p(a)+S_p(b)-S_p(a+b)}{p-1}\n$$\n:::\n\n大力使用 [@thm-nt-legendre] 考察 $\\binom {a+b}{a}$ 的含 $p$ 量：\n$$\n\\begin{aligned}\n\\nu_p \\left( \\binom {a+b}{a} \\right) &= \\nu_p((a+b)!) - \\nu_p(a!) - \\nu_p(b!) \\\\\n&= \\sum_{k=1}^\\infty \\left( \\floor{\\frac {a+b}{p^k}} - \\floor{\\frac {a}{p^k}} - \\floor{\\frac {b}{p^k}} \\right)\n\\end{aligned}\n$$\n该公式恰好对 $a+b$ 在 $p$ 进制计算过程中每一位发生的进位进行了求和．定理的 $S_p$ 形式容易通过 [@thm-nt-legendre] 的另一形式得到．\n\n研究该定理 $a+b = p^m$ 的特例．用下降阶乘幂形式考虑二项式系数中 $k$ 递增的过程，注意到 $\\nu_p (p^m-k) = \\nu_p(k)$，可以发现分子新增的 $n-k+1$ 和分母新增的 $k$ 恰好错一位，于是\n$$\n\\nu_p \\left( \\binom {p^m} k \\right) = m - \\nu_p (k),\\quad k = 1,2,\\dots,p^m\n$$\n\n作为 Kummer 定理和上述特殊情况的推论，我们有\n$$\n\\gcd_{k=1}^{n-1} \\binom{n}{k} = \\begin{cases}\np & n = p^m \\\\\n1 & \\text{otherwise}\n\\end{cases}\n$$\n其中 $p$ 是某一质数．这符合 Kummer 定理的直观描述．得到 $p^m$ 的加法必然会出现进位，在加法 $p^{m-1} + (p-1) p^{m-1}$ 时达到最小进位次数 $1$；否则在任一质数进制 $p$ 下，都可以取加法 $\\operatorname{lowbit}_p (n) + (n - \\operatorname{lowbit}_p (n))$ 使得不发生进位．\n\n参考：\n\n- [Legendre's formula - Wikipedia](https://en.wikipedia.org/wiki/Legendre%27s_formula)\n- [Kummer's theorem - Wikipedia](https://en.wiokipedia.org/wiki/Kummer%27s_theorem)\n\n### 扩展 Euler 定理\n\n$$\na^b \\equiv a^{b \\bmod \\varphi(m) + \\varphi(m)} \\pmod{m}\n$$\n\n进入循环所需步骤其实很少，一定小于 $\\varphi(m)$．（疑似量级在 $\\log m$ 以下，存疑，见 FFT 讲稿）\n\n### Lagrange 定理\n\n::: {#thm-nt-lagrange}\n\n## Lagrange 定理\n\n设 $p$ 是质数，$A(x) \\in \\mathbb Z_p[x]$．同余方程 $A(x) \\equiv 0 \\pmod p$ 只有至多 $\\operatorname{deg} A(x)$ 个模 $p$ 意义下不同的整数解，除非这多项式的系数在模 $p$ 意义下全为零．\n:::\n\n这是域上的多项式理论在模 $p$ 整数域上的应用．\n\n### Wilson 定理\n\n::: {#thm-nt-wilson}\n\n## Wilson 定理\n\n对质数 $p$，\n$$\n(p-1)! \\equiv -1 \\pmod p\n$$\n:::\n\n$p=2$ 容易特判证明．现在只考虑 $p$ 是奇质数的情况．\n\n$(p-1)!$ 中，互为逆元的数相互抵消，仅剩下逆元为自身的数 $\\pm 1$，立得上述定理．\n\n另一种证法注意到 $x^{p-1} - 1 = \\prod_{k=1}^{p-1} (x-k)$．这是因为 Fermat 小定理指出 $1$ 至 $p-1$ 的所有数的 $p-1$ 次幂均为 $1$，而 Lagrange 定理又保证了多项式点值到系数映射的唯一性．随后代入 $x=0$ 立得结论．\n\n参见 [Wilson's theorem - Wikipedia](https://en.wikipedia.org/wiki/Wilson%27s_theorem)．\n\n### 线性预处理\n\n#### 线性求逆元\n\n现欲求出 $a$ 模质数 $p$ 意义下的逆元 $a^{-1}$．用 $a$ 对 $p$ 做带余除法，$p=qa+r$，于是 $-qa \\equiv r \\pmod p$．两侧同时乘 $r$ 的逆元 $r^{-1}$ 得 $-q r^{-1} a \\equiv 1 \\pmod p$，故\n$$\na^{-1} = - q r^{-1} = - \\floor{\\frac p a} \\cdot (p \\bmod a)^{-1}\n$$\n\n#### 线性阶乘逆\n\n$$\n\\frac 1 {n!} = (n+1) \\cdot \\frac 1 {(n+1)!}\n$$\n\n## 积性函数\n\n### 整除分块\n\n```c++\nll ans=0;\nfor(ll l=1,r,d;l<=N;l=r+1){\n    d=N/l, r=N/d;\n    ans+=(S_mu(r)-S_mu(l-1))*d;\n}\n```\n\n此 $O(\\sqrt n)$ 较满，极大劣于因子个数的 $O(\\sqrt n)$．\n\n另有变种枚举 $\\floor{\\frac n {d^2}}$ 的整除分块如下，复杂度为 $O(n^{1/3})$．\n\n```c++\nll ans=0;\nfor(ll l=1,r,d;l*l<=N;l=r+1){\n    d=N/(l*l),r=sqrt(N/d);\n    ans+=(S_mu(r)-S_mu(l-1))*d;\n}\n```\n\n#### 上取整整除分块\n\n```c++\nll cdiv(ll a,ll b){ //ceil(a/b)\n\treturn (a<0||a%b==0)?a/b:a/b+1;\n}\nll ans=0;\nfor(ll l,r=N,d;r>=1;r=l-1){\n    d=cdiv(N,r), l=cdiv(N,d);\n    ans+=(S_mu(r)-S_mu(l-1))*d;\n}\n```\n\n### 杜教筛\n\n设 $f$ 为一数论函数，我们希望快速求得其前缀和 $\\hat f (n) = \\sum_{i=1}^n f(i)$. 考虑数论函数 $g$ 和 $h = g * f$，\n$$\nh(n) = \\sum_{d \\mid n} g(d) f(\\frac n d)\n$$\n两端做前缀和得\n$$\n\\begin{aligned}\n\\hat h (n)\n&= \\sum_{i=1}^n h(i) \\\\\n&= \\sum_{i=1}^n \\sum_{d \\mid i} g(d) f(\\frac i d) \\\\\n&= \\sum_{d=1}^n g(d) \\sum_{i=1}^{\\floor{\\frac n d}} f(i) \\\\\n&= \\sum_{d=1}^n g(d) \\hat f (\\floor{\\frac n d}) \\\\\n&= g(1) \\hat f (n) + \\sum_{d=2}^n g(d) \\hat f (\\floor{\\frac n d})\n\\end{aligned}\n$$\n因此\n$$\n\\hat f (n) = \\frac 1 {g(1)} \\left( \\hat h (n) - \\sum_{d=2}^n g(d) \\hat f (\\floor{\\frac n d}) \\right)\n$$\n\n故若 $g$、$h$ 的前缀和可 $O(1)$ 算得，根据上式整除分块即可递归地计算出 $f$ 的前缀和．预处理前 $O(n^{2/3})$ 项并记忆化得到的时间复杂度为 $O(n^{2/3})$．外层整除分块不会增加时间复杂度．\n\n关于时间复杂度证明可参考 [sun123zxy’s blog - OI 数论中的上界估计与时间复杂度证明 # 杜教筛](/posts/20230418-complexity/#%E6%9D%9C%E6%95%99%E7%AD%9B)．\n\n$$\n\\begin{gathered}\nf = \\mu, g = I, h = \\varepsilon \\\\\nf = \\varphi, g = I, h = \\id \\\\\nf = \\id^k \\mu, g = \\id^k, h = \\varepsilon \\\\\nf = \\id^k \\varphi, g = \\id^k, h = \\id^{k+1}\n\\end{gathered}\n$$\n\n:::{.remark}\n\n杜教筛的这种化法事实上也是 Eratosthenes 筛法的应用．一般的我们有\n$$\n\\sum_{d=1}^n f(d) \\hat g( \\floor{\\frac n d} ) = \\sum_{i=1}^n \\sum_{d \\mid i} f(d) g(\\frac i d) = \\sum_{i=1}^n \\sum_{d \\mid i} f(\\frac i d) g(d)   = \\sum_{d=1}^n g(d) \\hat f( \\floor{\\frac n d} )\n$$\n:::\n\n```c++\nunordered_map<ll,ll> s_mu;\nll S_mu(ll n){\n\tif(n<=MXG){\n\t\treturn mu[n]; // already accumulated\n\t}else if(s_mu.count(n)){\n\t\treturn s_mu[n];\n\t}\n\tll ans=0;\n\tfor(ll l=2,r,d;l<=n;l=r+1){\n\t\td=n/l,r=n/d;\n\t\tans+=S_mu(d)*(r-l+1);\n\t}\n\treturn s_mu[n]=1-ans;\n}\n```\n\n### 杂式\n\n无平方因子数计数：\n$$\n\\sum_{i=1}^n \\mu^2(i) = \\sum_{i=1}^{\\floor{\\sqrt n}} \\mu(i) \\floor{\\frac n {i^2}}\n$$\n\n[约数个数函数的一个性质](/posts/20200220-factor/)：\n\n$$\nd(ab) = \\sum_{x|a} \\sum_{y|b} [\\gcd (x,y) = 1]\n$$\n\n$$\nd(abc) = \\sum_{x|a} \\sum_{y|b} \\sum_{z|c} [\\gcd (x,y) = 1] [\\gcd (y,z) = 1] [\\gcd (x,z) =1]\n$$\n\n广义约数个数函数性质扩展：\n\n$$\n\\sigma_k (ab) = \\sum_{x|a} \\sum_{y|b} [\\gcd(x,y)=1] (x \\frac{b}{y})^k = \\sum_{x|a} \\sum_{y|b} [\\gcd(x,\\frac{b}{y})=1] (x y)^k\n$$\n\n$$\n\\sigma_k (abc) = \\sum_{x|a} \\sum_{y|b} \\sum_{z|c} [\\gcd(x,\\frac{b}{y})=1] [\\gcd(y,\\frac{c}{z})=1] [\\gcd(x, \\frac{c}{z}=1)] (x y z)^k\n$$\n\n## 组合\n\n### 容斥 / 二项式反演\n\n#### 形式一\n\n容斥原理的第一种形式给出了“子集和变换”的逆变换．\n\n::: {#thm-inex-first-set}\n\n## 容斥原理，形式一，集合\n\n$$\ng(S) = \\sum_{T \\subset S} f(T) \\iff f(S) = \\sum_{T \\subset S} (-1)^{|S| - |T|} g(T)\n$$\n:::\n\n证明的关键是 $\\sum_{k=0}^n \\binom n k (-1)^k = (1-1)^n = [n=0]$．\n\n::: {#thm-inex-first-binomial}\n\n## 容斥原理，形式一，二项式反演\n\n$$\ng(n) = \\sum_{k=0}^n \\binom n k f(k) \\iff f(n) = \\sum_{k=0}^n (-1)^{n-k} \\binom n k g(k)\n$$\n\n若设 $F(x)$ 和 $G(x)$ 分别为 $f(n)$ 和 $g(n)$ 的指数生成函数（EGF），则结论可等价地表示为\n\n$$\nG(x) = e^x F(x) \\iff F(x) = e^{-x} G(x)\n$$\n:::\n\n生成函数的形式使我们可在 $O(n \\log n)$ 的优秀时间复杂度之内在 $f(n)$ 和 $g(n)$ 间做出变换．\n\n#### 形式二\n\n形式一的补集形式，给出了全集 $U$ 下“超集和变换”的逆变换．\n\n::: {#thm-inex-second-set}\n\n## 容斥原理，形式二，集合\n\n$$\ng(S) = \\sum_{S \\subset T \\subset U} f(T) \\iff f(S) = \\sum_{S \\subset T \\subset U} (-1)^{|T| - |S|} g(T)\n$$\n:::\n\n::: {#thm-inex-second-binomal}\n\n## 容斥原理，形式二，二项式反演\n$$\ng(n) = \\sum_{k=0}^{N-n} \\binom {N-n} k f(n+k) \\iff f(n) = \\sum_{k=0}^{N-n} (-1)^k \\binom {N-n} k g(n+k)\n$$\n:::\n\n#### 应用\n\n:::{#exm-inex-extraordinary}\n\n## 不太常见的“容斥原理”\n\n满足全部性质的元素数量可容斥地通过下式计算\n$$\n\\begin{aligned}\n\\card \\left( \\bigcap_{i \\in U} A_i \\right) &= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\card \\left( A - \\bigcup_{i \\in U-S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\card \\left( \\bigcup_{i \\in S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{i_1 < \\dots < i_k} \\card \\left( A_{i_1} \\cup \\dots \\cup A_{i_k} \\right)\n\\end{aligned}\n$$\n其中 $A$ 代表全集，$A_i$ 代表满足第 $i$ 个性质的元素构成的集合，$U$ 是非空有限的性质指标集．\n:::\n\n:::{.proof}\n令 $f(S)$ 为恰好只满足 $S$ 中各性质的元素数量，$g(S)$ 为至多只满足 $S$ 中各性质的元素数量，即\n$$\n\\begin{gathered}\nf(S) := \\card \\left( \\left( A \\cap \\bigcap_{i \\in S} A_i \\right) - \\bigcup_{i \\in U-S} A_i \\right) \\\\\ng(S) := \\card \\left( A - \\bigcup_{i \\in U-S} A_i \\right)\n= \\card \\left(A - \\bigcup_{i \\in U} A_i \\right) + \\card \\left( \\bigcup_{i \\in S} A_i \\right)\n\\end{gathered}\n$$\n取 $S=U$ 代入 [@thm-inex-first-set] 右侧就得到结论第一行的等式．继续化简\n$$\n\\begin{aligned}\n\\card \\left( \\bigcap_{i \\in U} A_i \\right) &= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\card \\left( A - \\bigcup_{i \\in U-S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\left( \\card \\left(A - \\bigcup_{i \\in U} A_i \\right) + \\card \\left( \\bigcup_{i \\in S} A_i \\right) \\right) \\\\\n&= \\card \\left(A - \\bigcup_{i \\in U} A_i \\right) \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\binom{|U|}{k} + \\sum_{k=0}^{|U|} (-1)^{|U|-k} \\sum_{|S|=k} \\card \\left( \\bigcup_{i \\in S} A_i \\right)\n\\end{aligned}\n$$\n注意到\n$$\n\\sum_{k=0}^{|U|} (-1)^{|U|-k} \\binom{|U|}{k} = [|U| = 0]\n$$\n而 $U \\neq \\varnothing$，故上式左项为 $0$，即得结论式第二行．\n:::\n\n:::{#exm-inex-ordinary-out}\n\n## 有点常见的“容斥原理”\n\n不满足任何性质的元素数量可容斥地通过下式计算\n$$\n\\begin{aligned}\n\\card \\left( A - \\bigcup_{i \\in U} A_i \\right)\n&= \\sum_{k=0}^{|U|} (-1)^k \\sum_{|S| = k} \\card \\left( A \\cap \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\card A + \\sum_{k=1}^{|U|} (-1)^k \\sum_{|S| = k} \\card \\left( \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\card A + \\sum_{k=1}^{|U|} (-1)^k \\sum_{i_1 < \\dots < i_k} \\card \\left( A_{i_1} \\cap \\dots \\cap A_{i_k} \\right)\n\\end{aligned}\n$$\n其中 $A$ 代表全集，$A_i$ 代表满足第 $i$ 个性质的元素构成的集合，$U$ 是非空有限的性质指标集．\n:::\n\n:::{.proof}\n令 $f(S)$ 为恰好只满足 $S$ 中各性质的元素数量，$g(S)$ 为至少满足 $S$ 中各性质的元素数量，即\n$$\n\\begin{gathered}\nf(S) := \\card \\left( \\left( A \\cap \\bigcap_{i \\in S} A_i \\right) - \\bigcup_{i \\in U-S} A_i \\right) \\\\\ng(S) := \\card \\left( A \\cap \\bigcap_{i \\in S} A_i \\right)\n= \\begin{cases}\n\\card A & S = \\varnothing \\\\\n\\card \\left( \\bigcap_{i \\in S} A_i \\right) & \\text{otherwise}\n\\end{cases}\n\\end{gathered}\n$$\n取 $S=\\varnothing$ 代入 [@thm-inex-second-set] 右侧就得到结论．\n:::\n\n:::{#exr-inex-shuffle}\n\n## 错排\n\n计算 $n$ 元错排的数量．\n:::\n\n:::{.solution}\n设 $A_i$ 表示第 $i$ 个位置配对正确的置换构成的集合．直接应用 [@exm-inex-ordinary-out] 立得\n\n$$\n\\begin{aligned}\n\\card \\left( A - \\bigcup_{i \\in U} A_i \\right) &= \\sum_{k=0}^{|U|} (-1)^k \\sum_{|S| = k} \\card \\left( A \\cap \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\sum_{k=0}^{|U|} (-1)^k \\binom n k (n-k)! \\\\\n&= n! \\sum_{k=0}^{|U|} (-1)^k \\frac 1 {k!} \\sim \\frac{n!}{e}\n\\end{aligned}\n$$\n:::\n\n这说明随机取一排列，其错排的概率趋近于 $\\frac 1 e$．\n\n:::{#exm-inex-ordinary-in}\n\n## 常见的“容斥原理”\n\n满足至少 $1$ 个性质的元素数量可容斥地通过下式计算\n$$\n\\begin{aligned}\n\\card \\left( \\bigcup_{i \\in U} A_i \\right)\n&= \\sum_{k=1}^{|U|} (-1)^{k-1} \\sum_{|S| = k} \\card \\left( \\bigcap_{i \\in S} A_i \\right) \\\\\n&= \\sum_{k=1}^{|U|} (-1)^{k-1} \\sum_{i_1 < \\dots < i_k} \\card \\left( A_{i_1} \\cap \\dots \\cap A_{i_k} \\right)\n\\end{aligned}\n$$\n其中 $A_i$ 代表满足第 $i$ 个性质的元素构成的集合，$i \\in U$．\n:::\n\n:::{.proof}\n对 [@exm-inex-ordinary-out] 做简单移项即得．\n:::\n\n### 球盒问题\n\n组合数学的万恶之源．\n\n:::{.column-screen-inset}\n\n| ID | $n$ balls | $r$ boxes | allow empty? | recurrence / closed-form | generating functions | notes |\n|:-:|:-:|:-:|:-:|:--:|:--:|:----:|\n| $${1,1,0}$$ | Labeled \t| Labeled \t\t| MAY empty | $$r^n$$ | $$\\begin{aligned}\\mathrm{EGF}_r(x) &= (e^{x})^r = e^{rx} \\\\ \\mathrm{OGF}_r(x) &= \\frac{1}{1-rx}\\end{aligned}$$ | # $[n] \\to [r]$ mappings |\n| $${1,1,1}$$ | Labeled \t| Labeled \t\t| NON empty | $$r! {n \\brace r} = \\sum_{k=0}^r (-1)^{r-k} \\binom r k k^n$$ | $$\\begin{aligned} \\mathrm{EGF}_r(x)&=(e^x - 1)^r \\\\ \\mathrm{EGF}_n(x) &= e^{-x} \\sum_{r=0}^{+\\infty} r^n \\frac{x^r}{r!} \\end{aligned}$$ | # $[n] \\to [r]$ surjections |\n| $${1,1/\\Sigma,1}$$ | Labeled | Labeled; $r$-disabled | NON empty | $$\\sum_{k=0}^n k! {n \\brace k}$$ | $$\\mathrm{EGF}_r(x)=\\frac{1}{2-e^x} = \\frac{1}{1-(e^x-1)}$$ | ordered Bell number; # weak orderings / ordered set partitions on $[n]$ |\n| $${1,0,0}$$ | Labeled \t| UNLabeled \t| NON empty\t | $$\\sum_{k=0}^r {n \\brace k}$$ | $$\\mathrm{EGF}_r(x) = \\sum_{k=0}^r \\frac {(e^x - 1)^k}{k!}$$ | |\n| $${1,0,1}$$ | Labeled \t| UNLabeled \t| NON empty | $$\\begin{aligned} {n \\brace r} &= \\sum_{k=0}^r \\frac{k^n}{k!} \\cdot \\frac{(-1)^{r-k}}{(r-k)!} \\\\ {n+1 \\brace r} &= r {n \\brace r} + {n \\brace r-1} \\end{aligned}$$ | $$\\begin{aligned} \\mathrm{EGF}_r(x) &= \\frac{(e^x - 1)^r}{r!} \\\\ \\mathrm{OGF}_n(x) &= e^{-x} \\sum_{r=0}^{+\\infty} r^n \\frac{x^r}{r!} \\\\ \\sum_{n=1}^\\infty {n+r \\brace r} x^n &= \\prod_{k=1}^r \\frac 1 {1-kx} \\\\ \\sum_{n=1}^\\infty {n \\brace r} x^{\\underline{r}} &= x^n \\end{aligned}$$ | Stirling number of the second kind |\n| $${1,0/\\Sigma,1}$$ | labeled | UNLabeled; $r$-disabled | NON empty | $$\\begin{aligned} B(n) &= \\sum_{k=0}^n {n \\brace k} \\\\ B(n+1) &= \\sum_{k=0}^n \\binom n k B(k) \\end{aligned}$$ | $$\\mathrm{EGF}(x)=e^{e^x - 1}$$ | Bell number; # equivialent relations / set partitions on $[n]$ |\n| $${0,1,0}$$ | UNLabeled \t| Labeled \t| MAY empty | $$\\binom{n+r-1}{r-1}$$ | $$\\mathrm{OGF_r}(x) = \\left(\\frac 1 {1-x}\\right)^r$$ | $r$ 元不定方程非负整数解个数 |\n| $${0,1,1}$$ | UNLabeled \t| Labeled \t| NON empty | $$\\binom{n-1}{r-1}$$ | $$\\begin{aligned} \\mathrm{OGF_r}(x) &= \\left(\\frac x {1-x}\\right)^r \\\\ &= x^r \\left(\\frac 1 {1-x}\\right)^r \\end{aligned}$$ | $r$ 元 $n$ 次单项式构型数 |\n| $${0,1/\\Sigma,1}$$ | UNLabeled | Labeled; $r$-disabled\t| NON empty | $$a(n)=\\begin{cases}1 & n=0 \\\\ 2^{n-1} & n\\geq 1 \\end{cases}$$ | $$\\mathrm{OGF}(x) = 1+\\frac{x}{1-2x} = \\frac{1}{1-\\frac{x}{1-x}}$$ | 考虑“是否向前拼接”的 $n-1$ 个选择 |\n| $${0,0,0}$$ | UNLabeled \t| UNLabeled \t| MAY empty | $$\\sum_{k=0}^r p(n,k)$$ | $$\\mathrm{OGF}_r(x)=\\prod_{k=1}^r \\frac{1}{1-x^k}$$ | $r$ 元 $n$ 次单项对称多项式（monomial symmetric polynomial）构型数 |\n| $${0,0,1}$$ | UNLabeled \t| UNLabeled \t| NON empty | $$p(n,r)=p(n-1,r-1)+p(n-r,r)$$ | | $r$ 部分拆数 |\n| $${0,0/\\Sigma,1}$$ | UNLabeled | UNLabeled; $r$-disabled\t| NON empty | $$\\begin{aligned} p(n) &= \\sum_{\\substack{k \\in \\mathbb Z}} (-1)^k p_{n-k(3k-1)/2} \\\\ &= p_{n-1} + p_{n-2} - p_{n-5} - p_{n-7} + \\dots \\end{aligned}$$ | $$\\begin{aligned} \\mathrm{OGF}(x)&=\\prod_{k=1}^{+\\infty} \\frac 1 {1-x^k} \\\\ &= \\left( \\sum_{k \\in \\mathbb Z} (-1)^k x^{k(3k-1)/2} \\right)^{-1} \\end{aligned}$$ | partition function（分拆数）; # partitions of $n$; $n$ 元（含）以上 $n$ 次单项对称多项式构型数 |\n:::\n\n以后我们约定：\n\n- 形如 $\\mathrm{BB_{1,1,0}}$ 的记号表示代号 $1,1,0$ 对应球盒问题的方案数；\n- 形如 $\\mathrm{EGF}_n^{1,1,0}(x)$ 代表代号 $1,1,0$ 对应 $n$ 球球盒问题的指数生成函数；\n- 形如 $\\mathrm{EGF}_r^{1,1,0}(x)$ 代表代号 $1,1,0$ 对应 $r$ 球球盒问题的指数生成函数；\n- 普通生成函数 $\\mathrm{OGF}_r^{1,1,0}(x)$ 同理．\n\n在不至混淆的情况下，也可省略下标或上标上的代号．\n\n#### 通用性质\n\n::: {#prp-bb-sigma}\n\n## 非空盒数量不限制\n\n$$\n\\begin{gathered}\n\\mathrm{BB}_{*,*/\\Sigma,1}(n) = \\sum_{k=0}^n \\mathrm{BB}_{*,*,1}(n,k) \\\\\n\\mathrm{EGF}^{*,*/\\Sigma,1}(x) = \\sum_{k=0}^{+\\infty} \\mathrm{EGF}_{r=k}^{*,*,1}(x)\n\\end{gathered}\n$$\n:::\n\n::: {#prp-bb-x10-x11}\n\n## 有标号盒空置\n\n$$\n\\begin{gathered}\n\\mathrm{BB}_{*,1,0}(n,r) = \\sum_{k=0}^r \\binom r k \\mathrm{BB}_{*,1,1}(n,k) \\\\\n\\mathrm{EGF}_n^{*,1,0}(x) = e^x \\mathrm{EGF}_n^{*,1,1}(x)\n\\end{gathered}\n$$\n:::\n对有标号盒的二项式反演．在 $1,1,0$-球盒问题中，上式体现为第二类 Stirling 数的通项公式；在 $0,1,0$-球盒问题中，上式体现为 Vandermonde 卷积．\n\n::: {#prp-bb-x00-x01}\n\n## 无标号盒空置\n\n$$\n\\begin{gathered}\n\\mathrm{BB}_{*,0,0}(n,r) = \\sum_{k=0}^r \\mathrm{BB}_{*,0,1}(n,k) \\\\\n\\mathrm{OGF}_n^{*,0,0}(x) = \\frac 1 {1-x} \\mathrm{OGF}_n^{*,0,1}(x)\n\\end{gathered}\n$$\n:::\n对无标号盒，直接求和即可．\n\n### 第二类 Stirling 数\n\n第二类 Stirling 数的组合定义即 $1,0,1$-球盒问题的方案数 $\\mathrm{BB}_{1,0,1}(n,r) = {n \\brace r}$，亦作将 $n$ 个元素划分入 $r$ 个集合的方案数． \n\n#### 递推\n\n由组合意义，考虑在已有 $n$ 个球时加入新球，此时面临将其放入原有的 $r$ 个集合或新开辟一个集合的两种选择，由此得递推式\n$$\n{n+1 \\brace r} = r {n \\brace r} + {n \\brace r-1}\n$$\n边界在\n$$\n{n \\brace 0} = [n = 0],\\quad {n \\brace n} = 1\n$$\n\n#### 第二类 Striling 数同行计算：$\\mathrm{OGF}_n^{1,0,1}(x)$ 或 $\\mathrm{EGF}_n^{1,1,1}(x)$\n\n来考虑用两种方法得到 $1,1,1$-球盒问题的方案数．\n\n我们的第一种方法注意到，上述问题的方案数恰好是 $1,0,1$-球盒问题方案数 $r!$ 倍——这是对后者的盒进行标号的结果．我们得到\n$$\n\\mathrm{BB}_{1,1,1}(n,r) = r! \\mathrm{BB}_{1,0,1}(n,r) = r! {n \\brace r}\n$$\n\n第二种方法考虑用容斥非空盒的方法与 $1,1,0$-球盒问题 $\\mathrm{BB}_{1,1,0}(n,r) = r^n$ 建立联系．我们有\n$$\n\\mathrm{BB}_{1,1,0}(n,r) = \\sum_{k=0}^r \\binom r k \\mathrm{BB}_{1,1,1}(n,k)\n$$\n即\n$$\nr^n = \\sum_{k=0}^r \\binom r k k! {n \\brace k}\n$$\n二项式反演即得\n$$\nr! {n \\brace r} = \\sum_{k=0}^r (-1)^{r-k} \\binom r k k^n\n$$\n即\n$$\n{n \\brace r} = \\sum_{k=0}^r \\frac{(-1)^{r-k} k^n}{k! (r-k)!} = \\sum_{k=0}^r \\frac{k^n}{k!} \\cdot \\frac{(-1)^{r-k}}{(r-k)!}\n$$\n这正是第二类 Stirling 数的通项公式．注意到其具有卷积的形式，由此可快速计算出同一行的第二类 Stirling 数．事实上，二项式反演的生成函数形式已向我们道尽一切\n$$\n\\mathrm{OGF}_n^{1,0,1}(x) = \\mathrm{EGF}_n^{1,1,1}(x) = e^{-x} \\mathrm{EGF}_n^{1,1,0}(x) = e^{-x} \\sum_{k=0}^{+\\infty} k^n \\frac{x^k}{k!}\n$$\n\n#### 第二类 Striling 数同列计算：$\\mathrm{EGF}_r^{1,0,1}(x)$，$\\mathrm{EGF}_r^{1,1,0}(x)$ 与 $\\mathrm{EGF}^{1,0/\\Sigma,1}(x)$\n\n为快速计算同一列的第二类 Stirling 数，考虑用生成函数的思路构造 $1,1,0$-球盒问题和 $1,0,1$-球盒问题的方案数．前者将大小为 $n$ 的有标号集合划分为 $r$ 个有标号等价类，这相当于有序拼接 $r$ 个非空有标号集合；后者则是前者除掉 $r!$ 消序的版本．写成生成函数即\n$$\n\\begin{aligned}\n\\mathrm{EGF}_r^{1,1,0}(x) &= (e^x - 1)^r \\\\\n\\mathrm{EGF}_r^{1,0,1}(x) &= \\frac{(e^x - 1)^r}{r!}\n\\end{aligned}\n$${#eq-egf-110-101}\n\n#### Bell 数\n\nBell 数 $B(n)$ 的组合定义即 $1,0/\\Sigma,1$-球盒问题的方案数 $\\mathrm{BB}_{1,0/\\Sigma,1}$，亦可描述为 $n$ 元集合上等价关系（划分）的数量．\n\n注意到 $1,0,1$-球盒问题和 $1,0/\\Sigma,1$-球盒问题的关系\n$$\n\\mathrm{BB}_{1,0/\\Sigma,1}(n) = \\sum_{r=0}^{n} \\mathrm{BB}_{1,0,1}(n,r) = \\sum_{r=0}^{+\\infty} \\mathrm{BB}_{1,0,1}(n,r)\n$$\n我们首先有\n$$\nB(n) = \\sum_{r=0}^n {n \\brace r}\n$$\n其次，根据 [@eq-egf-110-101] 写出此关系的 EGF 形式就有\n$$\n\\mathrm{EGF}^{1,0/\\Sigma,1}(x) = \\sum_{r=0}^{+\\infty} \\mathrm{EGF}_r^{1,0,1}(x) = \\sum_{r=0}^{+\\infty} \\frac{(e^x - 1)^r}{r!} = e^{e^x - 1}\n$$\n我们得到 Bell 数的可用于快速计算的 EGF．\n\n:::{.remark}\n有标号集合的无序划分是指数型生成函数的一类重要应用．例如，有标号连通图计数可视为对有标号一般图的无序划分，故有标号连通图的 EGF $G(x)$ 和有标号一般图的 EGF $F(x)$ 间有着 $e^{G(x)} = F(x)$ 的关系．\n:::\n\nBell 数还有递推形式\n$$\nB(n+1) = \\sum_{k=0}^n \\binom n k B(k)\n$$\n边界 $B(0)=1$．组合的解释是，枚举第 $n+1$ 个元素被放入的集合的大小，再对除该集合之外的元素进行划分．从指数生成函数的角度来看，设 $B(n)$ 的 EGF 为 $F(x)$，由 EGF 的移位性质和二项式反演的 EGF 形式，上式等价于 $F'(x) = e^x F(x)$，解此微分方程也能得到 Bell 数的生成函数．\n\n#### 第一类 Stirling 数、Stirling 数与阶乘幂【TODO】\n\n更多参考：\n\n- [Stirling number - Wikipedia](https://en.wikipedia.org/wiki/Stirling_number)\n- [斯特林数 - OI Wiki](https://oi-wiki.org/math/combinatorics/stirling/)\n\n### 分拆数【TODO】\n\n关于 $k$ 部分拆数，\n\n> By taking conjugates, the number $p_k(n)$ of partitions of $n$ into exactly $k$ parts is equal to the number of partitions of $n$ in which the largest part has size $k$.\n\n- [Partition (number theory) - Wikipedia](https://en.wikipedia.org/wiki/Partition_(number_theory))\n- [分拆数 - OI Wiki](https://oi-wiki.org/math/combinatorics/partition/)\n- [组合数学（2）分拆数 - 知乎](https://zhuanlan.zhihu.com/p/530925142)\n\n### 背包计数 \n\n通式：\n$$\n\\prod_{i=1}^n (1+ s_i x^{v_i})^{m_i} = \\exp \\sum_{i=1}^n m_i \\ln (1 + s_i x^{v_i}) = \\exp \\sum_{i=1}^n m_i \\sum_{k=1}^{+\\infty} (-1)^{k-1} \\frac {s_i^k}{k} x^{k v_i} \n$$\n其中 $v_i$ 互不相同（相同者体现在 $m_i$ 上）．后者可以埃筛调和级数计算贡献 + 多项式 $\\exp$ 地在 $O(t \\log t)$（这里的 $t$ 指我们所关心的体积上限）内快速计算．\n\n下面问题的 OGF 都可化归至通式，从而 $O(t \\log t)$ 地得到计算．\n\n设有 $n$ 种可区分的物品，体积分别为 $v_i$．当每种物品只有一件时，方案数 OGF 为\n$$\n\\prod_{i=1}^n (1+ x^{v_i})\n$$\n当每种物品有无限件时，方案数 OGF 为\n$$\n\\prod_{i=1}^n (1+ x^{v_i} + x^{2 v_i} + \\dots) = \\prod_{i=1}^n (1 - x^{v_i})^{-1}\n$$\n当每种物品分别有 $c_i$ 件时，方案数 OGF 为\n$$\n\\prod_{i=1}^n (1+ x^{v_i} + x^{2 v_i} + \\dots + x^{c_i v_i}) = \\prod_{i=1}^n \\frac{1 - x^{(c_i+1) v_i}}{1 - x^{v_i}} = \\prod_{i=1}^n (1 - x^{(c_i+1) v_i}) \\prod_{i=1}^n (1 - x^{v_i})^{-1}\n$$\n\nex：普通的最优化背包也有卷积视角的理解，见 [Knapsack, Subset Sum and the (max,+) Convolution - Codeforces](https://codeforces.com/blog/entry/98663)．\n\n### 各种图计数\n\n#### 有（无）标号有（无）根树计数【TODO】\n\n#### 有标号 DAG 计数\n\n$$\nf_n=\\sum_{i=1}^n(-1)^{i+1}\\binom{n}{i}2^{i(n-i)}f_{n-i}\n$$\n思路是对 DAG 的入度为零的点做容斥．进一步推导可拆出卷积形式，再用类似分治 FFT 的生成函数方法可得封闭形式．\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Directed_acyclic_graph#Combinatorial_enumeration)\n- [OEIS](https://oeis.org/A003024)\n- [OI-Wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/#dag-%E8%AE%A1%E6%95%B0)\n- [cjyyb 题解](https://www.cnblogs.com/cjyyb/p/10134575.html)\n\n#### 有标号偏序图计数\n\n问得好，但这是个著名的 open problem．各种类型的偏序图计数参考 [Partially ordered set - Wikipedia # Number of partial orders](https://en.wikipedia.org/wiki/Partially_ordered_set#Number_of_partial_orders)．\n\n-   [Stack Exchange](https://math.stackexchange.com/questions/2677986/how-many-partial-orders-can-be-defined-on-varnothing-and-a-finite-set)\n-   [OEIS](https://oeis.org/A001035)\n-   [Erné, M., Stege, K. Counting finite posets and topologies. Order 8, 247–265 (1991)](https://doi.org/10.1007/BF00383446)（内有研究历史综述）\n\n#### 有标号连通图计数\n\n标准的有标号无序划分．EGF 是有标号一般图计数 EGF 的 $\\ln$．\n\n#### 竞赛图\n\n强连通的竞赛图一定存在 Hamilton 回路（归纳证明）；无环的竞赛图是全序图．两者结合可推出竞赛图一定存在 Hamilton 路径．同时，强连通竞赛图中存在所有大小的环路．\n\n#### 有标号划分为 $k$ 个全序图\n\nLah 数\n$$\nL(n,k) = \\frac{n!}{k!} \\binom{n-1}{k-1}\n$$\n思路是先 $n!$ 排个大序，再无标号球入非空有标号桶，再除 $k!$ 给桶消序．\n\n生成函数的思路是，考虑非空全序计数的 EGF 为 $\\frac 1 {1-x} - 1 = \\frac x {1-x}$，$k$ 次有序拼接再消序即得\n$$\n\\sum _{n\\geq k}L(n,k){\\frac {x^{n}}{n!}}={\\frac {1}{k!}}\\left({\\frac {x}{1-x}}\\right)^{k}\n$$\n\n更多信息参考 Wikipedia．\n\n#### 特殊 DAG 的拓扑序计数（有根树 / Young Tableaux）\n\n对一般 DAG 上拓扑序计数，其本质上是偏序上线性扩张的计数问题，这被证明是 #P-complete 的问题（总之就是很困难）．\n\n- [How many topological orderings exist for a graph? - Mathematics Stack Exchange](https://math.stackexchange.com/questions/814177/how-many-topological-orderings-exist-for-a-graph)\n- [Topological sorting - Wikipedia # Relation to partial orders](https://en.wikipedia.org/wiki/Topological_sorting#Relation_to_partial_orders)\n- [Linear extension - Wikipedia](https://en.wikipedia.org/wiki/Linear_extension)\n\n一些具有较好性质的 DAG 的拓扑序计数问题具有较好的封闭形式．\n\n##### 有根树\n\n对于外向树：\n$$\n\\frac{n!}{\\prod_{u \\in V} \\operatorname{size}(u)}\n$$\n其中 $V$ 是所有节点的集合，$n$ 是树大小，$\\operatorname{size}(u)$ 是以 $u$ 为根的子树大小． \n\n这里提供若干种理解或证明方法．\n\n- 树形 DP 风格的归纳证明是可以的．\n\n- 下面的链接中提供了一个有趣的组合理解．考虑依深度由叶到根递归，每次确定当前节点 $u$ 对应子树内的相对顺序．在尚未要求 $u$ 满足拓扑序（在其子树内排位第一）时，由于 $u$ 的各子节点 $v$ 对应子树内的相对顺序已经确定，故事实上只需确定 $u$ 在其对应子树内的相对排位——这恰有 $\\operatorname{size}(u)$ 种选择——故除掉此数消序以确保 $u$ 在其子树内排位第一．\n\n  [[Insight] Number of Topological Orderings of a Directed Tree - Codeforces](https://codeforces.com/blog/entry/75627)\n\n- 简化上述组合理解后得到的概率风格证明：每个节点在其对应子树中排位第一的概率恰为 $1/\\operatorname{size}(u)$，而这些事件相互独立．\n\n题目常见要求对每个节点作为根节点求出方案数，换根 DP 即可．\n\n注意到每个合法的外向树拓扑序 reverse 后立刻与内向树拓扑序形成一一对应，故内向树拓扑序计数与外向树相同．\n\n##### Young tableaux\n\n特定形状 Young tableau 的计数问题也是 DAG 拓扑序计数的一个特例．对形状为 $\\lambda$（一个整数分拆）的全体 Young tableau 计数，我们有著名的钩长公式（hook length formula）：\n$$\n\\frac{n!}{\\prod_{(i,j) \\in \\lambda} h_\\lambda (i,j)}\n$$\n简单而并不平凡，且与有根树拓扑序计数相似的公式似乎意味着类似的组合解释——其被称为 [Knuth's heuristic argument](https://en.wikipedia.org/wiki/Hook_length_formula#Knuth's_heuristic_argument)．可惜在 Young tableau 中，相对顺序的确定并不相互独立，故更严谨的论证还需多费些口舌（详见 Wikipedia）．\n\n:::{#fig-young-tableaux-counting}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```{tikz}\n\\begin{tikzpicture}\n\t\\draw[draw=black, fill=red, ultra thick, solid] (0.00,0.00) rectangle (1.00,-1.00);\n\t\\draw[draw=black, fill=orange, ultra thick, solid] (1.00,0.00) rectangle (2.00,-1.00);\n\t\\draw[draw=black, fill=orange, ultra thick, solid] (2.00,0.00) rectangle (3.00,-1.00);\n\t\\draw[draw=black, fill=orange, ultra thick, solid] (3.00,0.00) rectangle (4.00,-1.00);\n\t\\draw[draw=black, fill=orange, ultra thick, solid] (0.00,-1.00) rectangle (1.00,-2.00);\n\t\\draw[draw=black, fill=yellow, ultra thick, solid] (1.00,-1.00) rectangle (2.00,-2.00);\n\t\\draw[draw=black, fill=yellow, ultra thick, solid] (2.00,-1.00) rectangle (3.00,-2.00);\n\t\\draw[draw=black, fill=orange, ultra thick, solid] (0.00,-2.00) rectangle (1.00,-3.00);\n\t\\draw[draw=black, fill=yellow, ultra thick, solid] (1.00,-2.00) rectangle (2.00,-3.00);\n\t\\draw[draw=teal, ultra thick, dashed] (0.09,-1.09) -- (0.09,-2.90);\n\t\\draw[draw=teal, ultra thick, dashed] (0.09,-2.90) -- (1.91,-2.90);\n\t\\draw[draw=teal, ultra thick, dashed] (1.91,-2.90) -- (1.92,-1.88);\n\t\\draw[draw=teal, ultra thick, dashed] (1.92,-1.88) -- (2.89,-1.88);\n\t\\draw[draw=teal, ultra thick, dashed] (2.89,-1.88) -- (2.90,-1.10);\n\t\\draw[draw=teal, ultra thick, dashed] (2.90,-1.10) -- (0.10,-1.09);\n\t\\draw[draw=blue, ultra thick, dashed] (1.07,-0.10) -- (1.08,-2.83);\n\t\\draw[draw=blue, ultra thick, dashed] (1.08,-2.83) -- (1.86,-2.83);\n\t\\draw[draw=blue, ultra thick, dashed] (1.86,-2.84) -- (1.87,-1.83);\n\t\\draw[draw=blue, ultra thick, dashed] (1.87,-1.83) -- (2.84,-1.84);\n\t\\draw[draw=blue, ultra thick, dashed] (2.84,-1.84) -- (2.85,-0.94);\n\t\\draw[draw=blue, ultra thick, dashed] (2.85,-0.94) -- (3.94,-0.95);\n\t\\draw[draw=blue, ultra thick, dashed] (3.94,-0.95) -- (3.94,-0.06);\n\t\\draw[draw=blue, ultra thick, dashed] (3.94,-0.06) -- (1.07,-0.07);\n\t\\draw[draw=blue, ultra thick, dashed] (5.34,-2.80) -- (5.68,-2.80);\n\t\\draw[draw=teal, ultra thick, dashed] (5.34,-2.22) -- (5.68,-2.22);\n\t\\draw[draw=black, fill=yellow, ultra thick, solid] (5.62,-1.75) rectangle (5.33,-1.48);\n\t\\draw[draw=black, fill=orange, ultra thick, solid] (5.61,-1.15) rectangle (5.33,-0.87);\n\t\\draw[draw=black, fill=red, ultra thick, solid] (5.60,-0.58) rectangle (5.32,-0.29);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhook length formula 的组合直觉\n:::\n\n#### 无向图的色多项式（chromatic polynomial）和无环定向（acyclic orientations）\n\n色多项式是对图的 $k$-colorings 的数量在 $k=0,1,\\dots,n$ 进行 Lagrange 插值后得到的多项式．$k>n$ 的 $k$-colorings 的数量也可通过在色多项式的 $x=k$ 处求值得到．这一证明主要依赖所谓的 deletion–contraction 递推关系式．\n\n对一般的图而言，色多项式的大部分系数和求值问题都是 “NP” 相关的，但在一些特殊的图上有好的形式：\n\n- 完全图 $K_n$：$x^{\\underline{n}}$（下降阶乘幂）\n- 无边图 $\\overline K_n$：$x^n$\n- 链 / 树：$P_n$：$x(x-1)^{n-1}$\n- 环：$(x-1)^n + (-1)^n (x-1)$\n\n多个连通分量拼接时，色多项式满足乘法性．\n\n关于图的无环定向的方案数，Richard Stanley 在一篇 1973 年的论文中证明其恰为图的色多项式在 $-1$ 处的取值．\n\n- [Chromatic Polynomial - from Wolfram MathWorld](https://mathworld.wolfram.com/ChromaticPolynomial.html)\n- [Chromatic polynomial - Wikipedia](https://en.wikipedia.org/wiki/Chromatic_polynomial)\n- [Orientation (graph theory) - Wikipedia](https://en.wikipedia.org/wiki/Orientation_(graph_theory))\n- Stanley, R. P. \"Acyclic Orientations of Graphs.\" Disc. Math. 5, 171-178, 1973.\n\n### 矩阵树定理\n\n#### 无向图的情形\n\n对无向图，度数矩阵 $D = \\operatorname{diag} \\{ \\operatorname{deg}(i) \\}$，邻接矩阵 $A$ 定义为\n$$\nA_{i,j} = \\begin{cases}\n0 & i=j \\\\\ne(i,j) & i \\neq j\n\\end{cases}\n$$\n其中 $e(i,j)$ 表示点 $i$ 到点 $j$ 的边的数量（对无向图，$e(i,j) = e(j,i)$）．\n\n定义 Laplace 矩阵（Kirchhoff 矩阵）$L=D-A$．\n\nLaplace 矩阵有性质 $L= B B^T$，其中关联矩阵 $B$ 按如下方式定义\n$$\nB_{i,j} = \\begin{cases}\n1 & \\text{node $i$ is the ID-smaller endpoint of edge $j$} \\\\\n-1 & \\text{node $i$ is the ID-larger endpoint of edge $j$} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n\n这里 $1$ 与 $-1$ 的引入完成了一种对边的“手动定向”，其用途将在后文介绍．\n\n:::{#thm-mattree-nondirected}\n\n## 矩阵树定理，无向图\n\n$n$ 点无向图的生成树的个数与该图的 Laplace 矩阵 $L$ 的任意主子式的值相等．其也与 $L$ 所有 $n-1$ 个非零特征值乘积的 $\\frac 1 n$ 倍相等．\n:::\n\nLaplace 矩阵同行的代数余子式均相等（这性质由行和为 $0$ 得到），因此去掉任意一行一列均可得到正确的无向图生成树计数．此外，由于 $L = B B^T$ 至少半正定，$L$ 的所有特征值非负．\n\n证明的要点在于对 $L = B B^T$ 的某个主子式（一般选择去掉第一行第一列）应用 Cauchy-Binet 公式，随后说明行列式的组合意义中，环的情况一定相互抵消．关于特征值的结论可从特征多项式、各 $n-1$ 阶主子式与韦达定理的关系中得到（依此方法能进一步得到有关 $k$ - 生成森林的一些结论）．\n\n事实上，去掉第 $i$ 行第 $i$ 列，即是统计以 $i$ 为根的根向生成树的数量．先前定义关联矩阵 $B$ 时“手动定向”，是为了使换向过程中环的情况相互抵消，只留下树的唯一一种情况．当然，因为是无向图，这里树的朝向和根的具体位置并不重要．\n\n#### 有向图的情形\n\n对有向图，我们明确统计的对象为根向（或叶向）生成树的数量．根向树形图与出度 Laplace 矩阵相关，$L^{out} = D^{out} - A$，其中 $D^{out}$ 是出度矩阵．\n\n为体现有向图的要求，出度 Laplace 矩阵对应的关联矩阵需要一些修改．令矩阵 $B$ 满足\n$$\nB_{i,j} = \\begin{cases}\n1 & \\text{node $i$ is the head of edge $j$} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n矩阵 $C$ 满足\n$$\nC_{i,j} = \\begin{cases}\n1 & \\text{node $i$ is the head of edge $j$} \\\\\n-1 & \\text{node $i$ is the tail of edge $j$} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n则出度 Laplace 矩阵满足性质 $L^{out} = B C^T$．我们构造的矩阵 $B$ 体现了对出边方向的要求，在此基础上矩阵 $C$ 进一步完成了“手动定向”的工作．\n\n:::{#thm-mattree-rootwise}\n\n## 矩阵树定理，根向树形图\n\n$n$ 点有向图以 $i$ 为根的生成根向树形图的数量与该图出度 Laplace 矩阵 $L^{out}$ 去掉第 $i$ 行第 $i$ 列的 $n-1$ 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 $L^{out}$ 的所有 $n-1$ 个非零特征值的乘积相等．\n:::\n\n由于 $L^{out}$ 的行和仍为 $0$，其同行代数余子式仍然相等．\n\n关于叶向树形图，我们有类似的结论：\n\n:::{#thm-mattree-leafwise}\n\n## 矩阵树定理，叶向树形图\n\n$n$ 点有向图以 $i$ 为根的生成叶向树形图的数量与该图入度 Laplace 矩阵 $L^{in}$ 去掉第 $i$ 行第 $i$ 列的 $n-1$ 阶主子式的值相等．该有向图的所有生成根向树形图的数量也与 $L^{in}$ 的所有 $n-1$ 个非零特征值的乘积相等．\n:::\n\n由于 $L^{in}$ 的列和（而非行和）为 $0$，其同列（而非同行）代数余子式均相等．\n\n更多内容，参考\n\n- [Laplacian matrix - Wikipedia](https://en.wikipedia.org/wiki/Laplacian_matrix)\n- [矩阵树定理 - OI Wiki](https://oi-wiki.org/graph/matrix-tree/)\n- [Kirchhoff's theorem - Wikipedia](https://en.wikipedia.org/wiki/Kirchhoff's_theorem)\n\n### Polya 计数\n\n:::{#thm-burnside}\n\n## Burnside\n\n$$\n\\begin{aligned}\n等价类计数 &= \\frac{1}{|G|}\\sum_{f \\in G} |C(f)|\n\\end{aligned}\n$$\n其中 $G$ 是等价操作群，$C(f)$ 是操作 $f$ 下的不动点集合．\n:::\n\n### 杂数选提\n\n#### Catalan 数\n\n$$\nC_n = \\binom{2n}{n} - \\binom{2n}{n+1} = \\frac 1 {n+1} \\binom{2n}{n} = \\prod_{k=2}^n \\frac{n+k}{k}\n$$\n\nSegner's recurrence relation:\n$$\nC_0 = 1;\\quad C_{n+1} = \\sum_{i=0}^n C_i C_{n-i} \n$$\n\nOGF:\n$$\nA(z) = 1 + z A^2(z) \\implies A(z) = \\frac{1-\\sqrt{1-4z}}{2z}\n$$\n\n注意下面组合意义间的前后逻辑顺序．\n\n- number of full binary tree with $n$ interior nodes / $n+1$ leaves / $2n+1$ nodes\n\n  在数内点意义下可以导出 Catalan 数的生成函数．\n\n- number of ways of associating $n$ binary operators / parenthesizing $n+1$ factors completely\n\n- number of proper parenthesis sequences with $n$ pairs of parentheses\n\n  【TODO】暂时不知道怎么从上面推过来的．另一种理解是长度为 $n$ 的出栈序列的数量．\n\n- number of ordered trees with $n+1$ vertices\n\n  最外层要补一对括号．\n\n- number of binary trees with $n$ vertices\n\n  by left-child right-sibling encoding of ordered trees. 最后删去只有左儿子的根．\n\n  该组合意义可以导出 Catalan 数的生成函数．\n\nCatalan 数的组合意义并不止如此几种．cf. [Wikipedia](https://en.wikipedia.org/wiki/Catalan_number)\n\n### 代数组合【TODO】\n\n#### $q$-analog\n\n#### 有限域上的线性空间\n\n#### 有限群构型计数\n\n## 多项式\n\n此部分详细介绍请移步 [FFT/NTT 讲稿](/posts/20230928-dft/)．\n\n### 通用\n\n### FFT / FNTT / 卷积\n\n- DFT：（本原）单位根构造 $\\omega_n = e^{\\frac {2 \\pi}{n}i}$．\n\n- NTT：$P=998244353 = 7 \\times 17 \\times 2^{23} + 1$，$\\mathrm{PR} = 3$ 是它的一个原根．（本原）单位根构造 $\\omega_{n} = \\mathrm{PR}^{\\frac{P-1}{n}} \\bmod P$．\n\n- $P=1004535809 = 479 \\times 2^{21} + 1$，$\\mathrm{PR} = 3$ \n\n- $P=469762049 = 7 \\times 2^{26}+1$，$\\mathrm{PR} = 3$\n\n考虑将待变换多项式\n$$\nA(x) = \\sum_{k=0}^{2n-1} a_k x^k\n$$\n奇偶分项为两个多项式\n$$\nA(x) = A_0 (x^2) + x A_1(x^2)\n$$\n其中\n$$\n\\begin{aligned}\nA_0 (x) &= \\sum_{k=0}^{n-1} a_{2k} x^k \\\\\nA_1 (x) &= \\sum_{k=0}^{n-1} a_{2k+1} x^k\n\\end{aligned}\n$$\n代入 $x = \\omega_{2n}^k \\pod{k = 0,\\dots, 2n-1}$，用单位根消去 / 折半性质（$\\omega_{2n}^{2k} = \\omega_n^k$）\n$$\nA(\\omega_{2n}^k) = A_0 (\\omega_{n}^k) + \\omega_{2n}^k A_1 (\\omega_{n}^k)\n$$\n用 $\\omega_{2n}^{n+k} = - \\omega_{2n}^k$\n$$\n\\begin{aligned}\nA(\\omega_{2n}^k) &= A_0 (\\omega_n^k) + \\omega_{2n}^k A_1 (\\omega_n^k) \\\\\nA(\\omega_{2n}^{n+k}) &= A_0 (\\omega_n^k) - \\omega_{2n}^k A_1(\\omega_n^k) \n\\end{aligned}\n\\pod{k = 0, \\dots, n-1}\n$$\n即得 FFT/FNTT 递归算法．用单位根求和性质\n$$\n\\frac 1 n \\sum_{k=0}^{n-1} \\omega^{ik} = [i \\mid n]\n$$\n可知 DFT/NTT 变换矩阵 $F = \\begin{pmatrix}\\omega_{n}^{ij}\\end{pmatrix}_{(i,j) \\in n \\times n}$ 满足 $F F^H = F^H F = n I_n$，故 $F^{-1} = \\frac 1 n F^H = \\begin{pmatrix} \\frac 1 n \\omega_{n}^{-ij}\\end{pmatrix}_{(i,j) \\in n \\times n}$，此即 DFT/NTT 逆变换矩阵．\n\n#### 蝶形运算与迭代算法\n\n为使用迭代算法，需要快速得到递归算法向下深入过程中 $\\{ a_n \\}$ 置换后的最终结果．观察知该置换是位逆序置换，可按如下方法线性求出．\n\n```c++\nrev[0]=0; for(ll i=1;i<(1<<n);i++) rev[i]=(rev[i>>1]>>1)+((i&1)<<(n-1));\n```\n\n### 多项式方程求解（Newton 迭代法）【TODO】\n\n给定一多项式 $A(x)$，求解满足 $A(B(x)) = 0 \\pmod{x^n}$ 的多项式 $B(x)$．\n\n显然 $B(x)$ 只有前 $n$ 项有效．目前我们尚不清楚解的存在性、唯一性等性质，但注意到\n$$\nA(B(x)) = 0 \\pmod{x^{2n}} \\implies A(B(x)) = 0 \\pmod{x^n}\n$$\n故考虑递推求解．首先，边界条件 $A(b_0) = 0$ 需要单独求解．在确定某一 $b_0$ 的基础上，我们开始递推．考虑已经获得 $A(B(x)) = 0 \\pmod{x^n}$ 的一个解 $B(x) = B_0(x)$，下面尝试得到方程 $A(B(x)) = 0 \\pmod{x^{2n}}$ 的解．\n\n将待求解方程 $A(B(x)) = 0 \\pmod{x^{2n}}$ 左式多项式 $A$ 在 $B_0$ 处 Taylor 展开\n$$\n\\begin{split}\nA(B(x)) = A(B_0(x)) &+ A'(B_0(x)) (B(x)-B_0(x)) \\\\ &+ \\frac{A''(B_0(x))}{2!} (B(x)-B_0(x))^2 + \\dots\n= 0 \\pmod{x^{2n}}\n\\end{split}\n$$\n**假若** $B(x)-B_0(x) = 0 \\pmod{x^n}$，那么模 $x^{2n}$ 意义下二次方以上的项可以舍去，上式等价于\n$$\nA(B_0(x)) + A'(B_0(x)) (B(x)-B_0(x)) = 0 \\pmod{x^{2n}}\n$$\n移项即可解出待求 $B(x)$\n$$\nB(x) =  B_0(x) - \\frac{A(B_0(x))}{A'(B_0(x))} \\pmod{x^{2n}}\n$$\n这里要求 $A'(B_0(x))$ 需在 $x^{2n}$ 意义下可逆，即\n$$\n\\begin{split}\n[x^0] A'(B_0(x)) = [x^0] A'(b_0) &= \\sum_{k=0}^\\infty \\left( [x^k] A' \\right) b_0^k \\\\\n&= \\sum_{k=0}^\\infty (k+1) a_{k+1} b_0^k \\neq 0 \\pmod{x^{2n}}\n\\end{split}\n$$\n注意到 $B(x) - B_0(x) = -\\frac{A(B_0(x))}{A'(B_0(x))} = 0 \\pmod{x^{n}}$，故满足上述“假若”的解存在且唯一．然而，若不要求这一“假若”成立，则每步迭代解的唯一性无法得到保证．考虑到边界条件 $b_0$ 的解亦不一定唯一，故一般的 Newton 迭代法解唯一性的讨论较为复杂．当然，上述推导至少为我们提供了一种寻找特解的方法．\n\nNewton 迭代法作为通用求解框架，可涵盖几乎所有多项式初等运算．【TODO】\n\n### 多项式求逆\n\n给定一多项式 $A(x)$，求解满足 $A(x) B(x) = 1 \\pmod{x^{n}}$ 的多项式 $B(x)$．\n\n多项式逆元存在的充分必要条件是其常数项非零（这是因为边界条件 $b_0 = \\frac 1 {a_0}$），若存在则在模意义下一定唯一．这结论可直接由下述求解方法得到．不失一般性，我们只研究 $A(x)$ 的次数为奇数 $2n-1$ 的情况．设\n$$\n\\begin{aligned}\nA(x) &= A_0(x) + x^n A_1(x) \\\\\nB(x) &= B_0(x) + x^n B_1(x)\n\\end{aligned}\n$$\n下述两种方法均递归地在已知\n$$\nA(x) B_0(x) = A_0(x) B_0(x) = 1 \\pmod{x^n}\n$$\n的基础上求解 $A(x)$ 的逆元．时间复杂度均为\n$$\nT(n) = T(\\frac n 2) + O(n \\log n) = O(n \\log n)\n$$\n\n以下简记 $A(x)$ 为 $A$，其它多项式同理．\n\n#### 倍增法一（原创）\n\n$$\n\\begin{aligned}\n& A B = 1 \\pmod{x^{2n}} \\\\\n\\iff& (A_0 + x^n A_1)(B_0 + x^n B_1) = 1 \\pmod{x^{2n}} \\\\\n\\iff& x^n(A_1 B_0 + A_0 B_1) + A_0 B_0 = 1 \\pmod{x^{2n}} \\\\\n\\iff& A_1 B_0 + A_0 B_1 + \\floor{\\frac{A_0 B_0}{x^n}} = 0 \\pmod{x^{n}} \\\\\n\\iff&  A_0 B_1 = -\\floor{\\frac{A_0 B_0}{x^n}} - A_1 B_0 \\pmod{x^{n}} \\\\\n\\iff&  B_1 = - B_0 \\left( \\floor{\\frac{A_0 B_0}{x^n}} + A_1 B_0 \\right) \\pmod{x^{n}}\n\\end{aligned}\n$$\n\n常数偏大，这里就不放代码了．\n\n#### 倍增法二\n\n注意到\n$$\n\\begin{cases}\nA B_0 = 1 \\pmod{x^n} \\\\\nA B = 1 \\pmod{x^n}\n\\end{cases} \\implies A (B-B_0) = 0 \\pmod{x^n}\n$$\n由于 $A$ 的常数项非零，故\n$$\nB-B_0 = 0 \\pmod{x^n}\n$$\n（这证明了逆元在不同模数下的前缀保持一致）\n\n两边平方得\n$$\nB^2 - 2 B B_0 + B_0^2 = 0 \\pmod{x^{2n}}\n$$\n两侧同乘 $A$ 并移项得\n$$\nB = 2 B_0 - A B_0^2 \\pmod{x^{2n}}\n$$\n\n### 多项式开方【TODO】\n\n和多项式求逆类似的推导可得递推方程\n$$\nB = \\frac 1 2 \\left(\\frac A {B_0} + B_0 \\right) \\pmod{x^{2n}}\n$$\n有一些和 Newton 法一样麻烦的边界条件讨论，也会出现复杂的多解情况．$a_0 = 1$ 时 $b_0 = \\pm 1$，按 $b_0 = 1$ 的实现如下．\n\n亦可 $\\sqrt A = \\exp \\left( \\frac 1 2 \\ln A \\right)$，此法可处理多项式任意幂指数运算．\n\n### 多项式 $\\ln$\n\n给定一多项式 $A(x)$，求解满足 $B(x) = \\ln A(x) \\pmod{x^{n}}$ 的多项式 $B(x)$．\n\n次数为 $+\\infty$ 的多项式 $\\ln$ 存在的充分必要条件为其常数项非零（这是因为边界条件 $b_0 = \\ln a_0$），同样一旦存在则唯一．注意到仅整数 $a_0=1$ 时，$\\ln a_0$ 可取得整数，故合理的 $a_0$ 只能是 $1$．另一种解释参见[多项式初等函数 - OI Wiki # 多项式对数函数 & 指数函数](https://oi-wiki.org/math/poly/elementary-func/#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0--%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0)．\n\n推导是容易的．方程两侧同时求导得\n$$\nB'(x) = \\frac{A'(x)}{A(x)} \\pmod{x^{n-1}}\n$$\n两侧再积分得\n$$\nB(x) = \\int \\frac{A'(x)}{A(x)} \\diff x + C \\pmod{x^{n}}\n$$\n其中 $C= \\ln a_0$．多项式求逆、求导、积分即可．时间复杂度 $O(n \\log n)$．\n\n### 多项式 $\\exp$【TODO】\n\nNewton 迭代法可推出\n$$\nB = B(1 - \\ln B_0 + A) \\pmod{x^{2n}}\n$$\n时间复杂度\n$$\nT(n) = T(\\frac n 2) + O(n \\log n) = O(n \\log n)\n$$\n\n存在的充要条件是 $a_0=0$．唯一性证明暂不明确．\n\n### 多项式快速幂\n\n普通的多项式快速幂实现当然是 $O(n \\log n \\log k)$ 的．下面介绍基于指对数性质的 $O(n \\log n)$ 求法．\n\n对常数项 $a_0=1$ 的 $n-1$ 次多项式 $A(x)$，\n$$\nA^k(x) = e^{k \\ln A(x)}\n$$\n\n我们指出，在系数对质数 $p$ 取模的意义下，当我们关心的多项式长度 $n \\leq p$ 时，有\n$$\nA^p(x) \\equiv a_0 \\equiv 1 \\pmod p\n$$\n这是因为\n$$\n(a+b)^p \\equiv a^p + b^p \\pmod p\n$$\n故\n$$\nA^p(x) = (a_0 + x A_1 (x))^p \\equiv a_0^p + x^p A_1^p(x) \\pmod p\n$$\n由费马小定理，$a_0^p = a_0$，而 $n \\leq p$ 表明 $x^p A_1^p(x)$ 一项可被忽略，故上述结论得到证明．这些讨论可用于处理幂指数 $k \\geq p$ 的情况．\n\n一般的，当常数项非 $1$ 时，为满足多项式 $\\ln$ 的要求，设多项式 $A(x)$ 的最低次项为 $a_t x^t$，则\n$$\nA^k(x) = (a_t x^t)^k \\left( \\frac{A(x)}{a_t x^t} \\right)^k\n$$\n右侧的多项式常数项归一，故可再应用上述方法计算．\n\n关于多项式，更代数的内容参考 [Formal power series - Wikipedia](https://en.wikipedia.org/wiki/Formal_power_series)\n\n## 集合幂级数【TODO】\n\n## 矩阵\n\n### 矩阵乘法\n\n普通的 $O(n^3)$ 实现．\n\n### 矩阵快速幂\n\n普通的 $O(n^3 \\log k)$ 实现．\n\n### 行列式\n\n普通的实现是使用逆元进行高斯消元，可用于域上的线性空间．若求解逆元的时间复杂度为 $O(\\log p)$，则时间复杂度为 $O(n^3+ n^2 \\log p)$．\n\n这里给出另一种做法．该做法在消去时使用辗转相除法，可用于任意 Euclid 整环（Euclidean domain，有带余除法的无零因子的交换幺环）上的模（环上的线性空间），且时间复杂度不会增加．一个常见的应用是模 $m$ 整数环 $\\mathbb Z_m$ 上的行列式求值，其中 $m$ 不是质数．\n\n消去各目标行第 $c$ 列元素时，以第 $c$ 行的 $a_{c,c}$ 为除数与目标行的第 $c$ 列元素辗转相除，最终使 $a_{c,c}$ 变为 $0$，再做一次行交换将其换至目标行，就完成了一次行消去过程．注意到当 $a_{c,c}$ 非零时，一次行消去操作结束后 $a_{c,c}$ 单调不增，且过程中 $a_{c,c}$ 不会从非零变为零，故辗转相除带来的 $\\log p$ 次额外操作开销被分摊到整轮对第 $c$ 列的消去过程中，因此时间复杂度仍为 $O(n^3+ n^2 \\log p)$．\n\n## 字符串 / 自动机\n\n基于 DFA 理论，[OI-Wiki](https://oi-wiki.org/string/automaton/) 上有对 KMP / AC 自动机，SAM / GSAM 和 PAM 简明扼要的概括．[OI-Wiki](https://oi-wiki.org/string/sam/) 的后缀自动机讲解亦值得参考．\n\n## 图论【TODO】\n\n### 最短路\n\n### 强连通分量\n\n### 网络流\n\n## 杂项\n\n### 表\n\n#### 质数表\n\n```default\n1e2     1e3     1e4       1e5       1e6\n101 \t\t1009 \t\t10007 \t\t100003 \t\t1000003\n\n1e7       1e8         1e9         1e10        1e11 \t\t\t\n10000019 \t100000007 \t1000000007 \t10000000019 100000000003\n\n1e12          1e13            1e14            1e15\n1000000000039\t10000000000037 \t100000000000031 1000000000000037\n\n1e16              1e17                1e18\n10000000000000061\t100000000000000003 \t1000000000000000003\n```\n\n#### 典列\n\n```default\nindex         0   1   2   3   4   5   6   7   8     9     10\nCatalan       1   1   2   5   14  42  132 429 1430  4862  16796\nBell          1   1   2   5   15  52  203 877 4140  21147 115975\npartition     1   1   2   3   5   7   11  15  22    30    42\ngroup         0   1   1   1   2   1   2   1   5     2     2\n```\n\n```default\nbinomial\nx   0   1   2   3   4   5\n0 | 1\n1 | 1   1\n2 | 1   2   1\n3 | 1   3   3   1\n4 | 1   4   6   4   1\n5 | 1   5   10  10  5  1\n\nStirling I\nx   0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     1   1\n3 |     2   3   1\n4 |     6   11  6   1\n5 |     24  50  355 10  1\n\nStirling II\nx   0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     1   1\n3 |     1   3   1\n4 |     1   7   6   1\n5 |     1   15  25  10  1\n\nLah\nx   0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     2   1\n3 |     6   6   1\n4 |     24  36  12  1\n5 |     120 240 120 20  1\n\nk-partition\n    0   1   2   3   4   5\n0 | 1\n1 |     1\n2 |     1   1\n3 |     1   1   1\n4 |     1   2   1   1\n5 |     1   2   2   1   1\n```\n\n### 对拍\n\n#### Windows Batch\n\n```batch\n:loop\n    gen.exe>dat.in\n    my.exe<dat.in>my.out\n    std.exe<dat.in>std.out\n    fc my.out std.out\n    if not errorlevel 1 goto loop\npause\n```\n\n#### Linux Shell\n\n```sh\nwhile true; do\n\t./gen>dat.in\n\t./std<dat.in>std.out\n\t./my<dat.in>my.out\n\tif diff std.out my.out; then\n\t\tprintf OK\n\telse\n\t\tprintf DIFF\n\t\texit 0\n\tfi\ndone\n```\n\n### 模板\n\n见 [model.cpp](code/model.cpp), [model_temp.cpp](code/model_temp.cpp)．\n\n#### model.cpp\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\n\n// --- read ---\ntemplate<typename T=ll>\nT rd(){ // for bigint read\n    T ans=0; bool sgn=0; char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-') sgn=1; c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+T{c-'0'};c=getchar();}\n    if(sgn) ans=-ans;\n    return ans;\n}\n\n// --- variable mod ---\nconst int MOD=998244353,PR=3;\n#define pmod_m(x,mod) ((x)<(mod)?(x):(x)-(mod))\n#define nmod_m(x,mod) ((x)<0?(x)+(mod):(x))\n#define hmod_m(x,mod) nmod_m((x)%(mod),(mod)) // slow!\n#define pmod(x) pmod_m(x,MOD)\n#define nmod(x) nmod_m(x,MOD)\n#define hmod(x) hmod_m(x,MOD)\ntemplate<typename T=int,typename U=ll>\nT qpow(U x,ll up,T mod){\n    x=hmod_m(x,mod); T ans=1; \n    for(;up;up>>=1,x=U(x)*x%mod) if(up&1) ans=U(ans)*x%mod;\n    return ans;\n}\ntemplate<typename T=int,typename U=ll>\nll inv(T x,T mod){return qpow<T,U>(x,mod-2);} // assume mod prime\n\n// --- Number Theory ---\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nll lcm(ll a,ll b){return a*b/gcd(a,b);}\ntuple<ll,ll,ll> exgcd(ll a,ll b){ // capable of +/- integers\n    if(b==0) return {1,0,a};\n    ll x1,y1,d; tie(x1,y1,d)=exgcd(b,a%b);\n    return {y1,x1-(a/b)*y1,d};\n}\nll inv(ll a,ll m){\n    ll x,y,d; tie(x,y,d)=exgcd(a,m);\n    return d==1?hmod_m(x,m):0;\n}\ntuple<ll,ll,bool> solve_equ(ll a,ll b,ll c){ // return solution with min non-negative x\n    ll x,y,d; tie(x,y,d)=exgcd(a,b);\n    if(d==0) return {0,0,c==0}; // !!!\n    if(c%d!=0) return {0,0,false};\n    x*=c/d; y*=c/d; ll dx=b/d,dy=-a/d;\n    if(dx<0) dx=-dx,dy=-dy; // ensure dx positive\n    ll t=(hmod_m(x,dx)-x)/dx; x+=t*dx; y+=t*dy;\n    return {x,y,true};\n}\n// CAUTION __int128\npair<ll,ll> excrt(pair<ll,ll> p1,pair<ll,ll> p2){ // merge (a1,m1) (a2,m2)\n    ll a1,m1,a2,m2; tie(a1,m1)=p1; tie(a2,m2)=p2;\n    ll x,y; bool ok; tie(x,y,ok)=solve_equ(m1,m2,a2-a1);\n    if(!ok) return {0,0};\n    ll l=lcm(m1,m2); return {hmod_m(x*m1+a1,l),l};\n}\nll bsgs(ll a,ll b,ll m){ // solve a^x=b mod m, gcd(a,m)=1\n    unordered_map<ll,bool> mp; ll sqrtM=ceil(sqrt(m));\n    ll cur=1;\n    for(ll r=1;r<=sqrtM;r++){\n        cur=cur*a%m;\n        mp[b*cur%m]=r;\n    }\n    ll nw=cur;\n    for(ll q=1;q<=sqrtM;q++){\n        if(mp[nw]) return q*sqrtM-mp[nw];\n        nw=nw*cur%m;\n    }\n    return -1;\n}\n// --- CAUTION uncensored / __int128 / rand() ---\nbool is_prime(ll n){ // miller rabin\n    if(n<=2||n%2==0) return n==2;\n    ll u=n-1,t=0; while(u%2==0) u/=2,t++;\n    ll test_time=10; while(test_time--){\n        ll a=rand()%(n-2)+2,v=qpow<ll,__int128>(a,u,n);\n        if(v==1) continue;\n        bool ok=0;\n        for(ll s=0;s<t;s++){\n            if(v==n-1){ok=1;break;}\n            v=__int128(v)*v%n;\n        } if(!ok) return false;\n    } return true;\n}\n// --- CAUTION uncensored __int128 rand() ---\nll pollard_rho(ll n) {\n    auto f=[&](ll x,ll c)->ll{return (__int128(x)*x+c)%n;};\n    ll c=rand()%(n-1)+1;\n    ll t=f(0,c);\n    ll r=f(f(0,c),c);\n    while (t!=r) {\n        ll d=gcd(abs(t-r),n);\n        if(d>1) return d;\n        t=f(t,c);\n        r=f(f(r,c),c);\n    } return n;\n} ll get_factor(ll n){\n    if(n==1||is_prime(n)) return 0;\n    if(n==4) return 2;\n    ll d=n; while(d==n) d=pollard_rho(n);\n    return d;\n}\nvoid _prime_test(){\n    srand(time(0));\n    ll N=rd();\n    cout<<(is_prime(N)?\"YES\":\"NO\")<<\" \"<<get_factor(N);\n}\n\n// --- constant mod, can be modified to be variable ---\ntemplate<typename T,typename U>\nclass ModInt{public:\n    static inline ModInt uroot(T n){return qpow(ModInt(PR),(MOD-1)/n);}\n\n    T dat; ModInt():dat{0}{}\n    ModInt(initializer_list<T> lst):dat{*lst.begin()}{} // for mod-free number, use this\n    ModInt(U dat):dat{T(hmod(dat))}{} // implicit conversion, slow!\n    explicit operator T const(){return dat;}\n    friend ostream& operator << (ostream &out,const ModInt& mi){out<<mi.dat; return out;}\n    // negative number version\n    // friend ostream& operator << (ostream &out,const ModInt& mi){out<<(mi.dat+mi.dat<MOD?mi.dat:mi.dat-MOD)<<\" \"; return out;}\n    friend ModInt operator + (const ModInt a,const ModInt b){return {pmod(a.dat+b.dat)};}\n    friend ModInt operator - (const ModInt a){return {nmod(-a.dat)};}\n    friend ModInt operator - (const ModInt a,const ModInt b){return {nmod(a.dat-b.dat)};}\n    friend ModInt operator * (const ModInt a,const ModInt b){return {T(U{a.dat}*b.dat%MOD)};}\n    friend ModInt operator / (const ModInt a,const ModInt b){return {a.dat/b.dat};} // Euclidean division\n    friend ModInt operator % (const ModInt a,const ModInt b){return {a.dat%b.dat};} // Euclidean division\n    friend ModInt qpow(ModInt x,ll up){\n        ModInt ans=1; for(;up;up>>=1,x=x*x) if(up&1) ans=ans*x; return ans;\n    } friend inline ModInt inv(ModInt a){return {qpow(a,MOD-2)};} // assume MOD is prime\n    void operator += (const ModInt other){*this=*this+other;}\n    void operator -= (const ModInt other){*this=*this-other;}\n    void operator *= (const ModInt other){*this=*this*other;}\n    void operator /= (const ModInt other){*this=*this/other;}\n    void operator %= (const ModInt other){*this=*this%other;}\n    friend bool operator == (const ModInt a,const ModInt b){return a.dat==b.dat;}\n    friend bool operator != (const ModInt a,const ModInt b){return a.dat!=b.dat;}\n};\ntypedef ModInt<int,ll> MI;\n\n// --- linear init ---\nvector<MI> fac,facinv,inv_s;\nvoid linear_init(int n){\n    fac.resize(n+1); facinv.resize(n+1); inv_s.resize(n+1);\n    inv_s[1]=1; for(int i=1;i<=n;i++) inv_s[i]=-(MOD/i)*inv_s[MOD%i];\n    fac[0]=1; for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i;\n    facinv[n]=inv(MI(fac[n])); for(int i=n-1;i>=0;i--) facinv[i]=facinv[i+1]*(i+1);\n}\n\n// --- polynomial ---\nint log2ceil(int n){int cnt=0; for(int t=1;t<n;t<<=1) cnt++; return cnt;}\nvector<int> rev;\nvoid spawn_rev(int n){ // n=log2ceil(N)\n    rev.resize(1<<n); rev[0]=0;\n    for(int i=1;i<(1<<n);i++) rev[i]=(rev[i>>1]>>1)+((i&1)<<(n-1));\n}\nclass Poly : public vector<MI>{ public:\n    using vector<MI>::vector;\n    inline int len() const {return size();} // to avoid strange glitches caused by size_t\n    Poly subpoly(int l,int r) const { // [l,r), zero padded (support negative number)\n        Poly B; for(int i=l;i<r;i++) B.push_back(i>=0&&i<len()?at(i):0); return B;\n    }\n    friend ostream& operator << (ostream &out,const Poly& A){for(int i=0;i<A.len();i++) out<<A[i]<<' '; return out;}\n    friend Poly operator + (Poly A,const Poly& B){\n        int n=max(A.len(),B.len()); A.resize(n);\n        for(int i=0;i<n;i++) A[i]+=i<B.len()?B[i]:0; return A;\n    }\n    friend Poly operator - (Poly A){for(int i=0;i<A.len();i++) A[i]=-A[i]; return A;}\n    friend Poly operator - (const Poly& A,const Poly &B){return A+(-B);}\n    friend Poly operator * (Poly A,MI c){for(int i=0;i<A.len();i++) A[i]=A[i]*c; return A;}\n    void DFT(int typ){ // to be called by opt() only (with proper length and rev array)\n        int n=len();\n        for(int i=0;i<n;i++) if(i<rev[i]) std::swap(at(i),at(rev[i]));\n        for(int hf=1;hf<n;hf<<=1){\n            MI w=MI::uroot(hf<<1); if(typ==-1) w=inv(w);\n            for(int i=0;i<n;i+=hf<<1){\n                MI wk=1;\n                for(int k=0;k<hf;k++){\n                    MI x=at(i+k),y=wk*at(i+hf+k);\n                    at(i+k)=x+y; at(i+hf+k)=x-y;\n                    wk*=w;\n                }\n            }\n        }\n        if(typ==-1){MI inv_n=inv(MI{n}); for(int i=0;i<n;i++) at(i)=at(i)*inv_n;}\n    }\n    friend Poly opt(Poly A,Poly B,int len,function<MI(MI a,MI b)> func){\n        int n=log2ceil(len); spawn_rev(n); n=1<<n;\n        A.resize(n); A.DFT(n); B.resize(n); B.DFT(n);\n        Poly C(n); for(ll i=0;i<n;i++) C[i]=func(A[i],B[i]);\n        C.DFT(-1); C.resize(len); return C;\n    }\n    friend Poly operator * (const Poly& A,const Poly& B){\n        return opt(A,B,A.len()+B.len()-1,[](MI a,MI b){return a*b;});\n    }\n    friend Poly inv(const Poly &A){\n        int n=A.len(); Poly B={inv(A[0])};\n        for(int hf=1;hf<n;hf<<=1){\n            B=opt(A.subpoly(0,hf*2),B,hf*4,[](MI a,MI b){return (2-a*b)*b;});\n            B.resize(hf*2);\n        } B.resize(n); return B;\n    }\n    friend Poly sqrt(const Poly &A){\n        int n=A.len(); Poly B={1}; // assume a_0 = 1 and b_0 positive\n        for(int hf=1;hf<n;hf<<=1){\n            B=(A.subpoly(0,2*hf)*inv(B.subpoly(0,2*hf))+B)*inv(MI{2});\n            B.resize(hf*2);\n        } B.resize(n); return B;\n    }\n    friend Poly drv(Poly A){ // derivative\n        for(int i=0;i<A.len();i++) A[i]=(i+1)*A[i+1];\n        A.pop_back(); return A;\n    }\n    friend Poly itg(Poly A,MI c){ // integral\n        A.push_back(0); for(int i=A.len()-1;i>=1;i--) A[i]=A[i-1]*inv(MI{i});\n        A[0]=c; return A;\n    }\n    friend inline Poly ln(const Poly &A){\n        return itg((drv(A)*inv(A)).subpoly(0,A.len()-1),0/*log(A[0])*/);\n    }\n    friend Poly exp(const Poly &A){\n        int n=A.len(); Poly B={1/*exp(A[0])*/};\n        for(int hf=1;hf<n;hf<<=1){\n            B=B*(Poly{1}-ln(B.subpoly(0,hf*2))+A.subpoly(0,hf*2)); B.resize(hf*2);\n        } B.resize(n);\n        return B;\n    }\n    friend inline Poly qpow(const Poly &A,MI up){return exp(ln(A)*up);} // assume a_0 = 1\n    \n    static void _test(){\n        ll N=rd()+1,M=rd()+1;\n        Poly A(N),B(M);\n        for(ll i=0;i<N;i++) A[i]=rd();\n        for(ll i=0;i<M;i++) B[i]=rd();\n        Poly C=A*B; cout<<C;\n        /*ll N=rd(); Poly A(N);\n        for(ll i=0;i<N;i++) A[i]=rd();\n        A=inv(A); cout<<A;*/\n    }\n};\nnamespace divntt{\n    Poly A,B,C;\n    void divntt(ll l,ll r){ // capable of non-negative [l,r), \"i<j\" order\n        if(l+1==r) return;\n        ll mid=(l+r)/2;\n        Poly T=A.subpoly(l,mid)*B.subpoly(mid,r);\n        for(ll k=0;k<T.len()&&l+mid+k<C.len();k++){ // CAUTION: time complexity\n            C[l+mid+k]+=T[k];\n        }\n        divntt(l,mid); divntt(mid,r);\n    }\n}\n\n// --- matrix ---\nclass Matrix : public vector<MI>{public:\n    static Matrix I(int n){\n        Matrix A(n,n); for(int i=0;i<n;i++) A(i,i)=1;\n        return A;\n    }\n    int row,col;\n    template<typename... Args>\n    Matrix(int row,int col,Args... args) : row{row},col{col},vector<MI>(row*col,args...){}\n    Matrix(int row,int col,initializer_list<MI> lst) : row{row},col{col},vector<MI>(lst){}\n    MI& at(int i,int j){return vector<MI>::at(i*col+j);}\n    MI cat(int i,int j)const{return *(cbegin()+i*col+j);}\n    MI& operator () (int i,int j){return at(i,j);}\n    Matrix submat(int sr,int sc,int tr,int tc){\n        Matrix A(tr-sr,tc-sc,{});\n        for(int i=sr;i<tr;i++) for(int j=sc;j<tc;j++) A(i-sr,j-sc)=at(i,j);\n        return A;\n    }\n    friend ostream& operator << (ostream &out,const Matrix& A){\n        for(int i=0;i<A.row;i++){for(int j=0;j<A.col;j++) cout<<A.cat(i,j)<<' ';cout<<'\\n';} return out;\n    }\n\n    friend Matrix operator * (const Matrix &A,const Matrix &B){\n        Matrix C(A.row,B.col); if(A.col!=B.row) return Matrix(0,0);\n        for(int i=0;i<A.row;i++)\n            for(int j=0;j<B.col;j++)\n                for(int k=0;k<A.col;k++)\n                    C(i,j)+=A.cat(i,k)*B.cat(k,j);\n        return C;\n    }\n    friend Matrix qpow(Matrix X,ll up){\n        Matrix A=Matrix::I(X.row); if(X.row!=X.col) return Matrix(0,0);\n        for(;up;up>>=1,X=X*X) if(up&1) A=A*X; return A;\n    }\n    bool stair(){ // row reduce to upper stair matrix, return swap time % 2. capable of any ring\n        bool swp=0;\n        for(int c=0,p=0;c<min(row,col);c++){\n            auto swpl=[&](int a,int b){\n                swp^=1; for(int k=c;k<col;k++) std::swap(at(a,k),at(b,k));\n            };\n            for(int r=p+1;r<row;r++){\n                while(at(p,c)!=0){\n                    MI factor=at(r,c)/at(p,c);\n                    for(int k=c;k<col;k++) at(r,k)-=at(p,k)*factor;\n                    swpl(p,r);\n                } swpl(p,r);\n            } if(at(p,c)!=0) p++;\n        } return swp;\n    }\n    friend MI det(Matrix A){\n        int n=A.row; if(A.row!=A.col) return 0;\n        bool opt=A.stair();\n        MI ans=1; for(int c=0;c<n;c++) ans*=A(c,c);\n        return opt?-ans:ans;\n    }\n    friend int rk(Matrix A){ // rank (confuse with std::rank)\n        A.stair();\n        for(int r=A.row-1;r>=0;r--)\n            for(int c=0;c<A.col;c++)\n                if(A(r,c)!=0) return r+1;\n        return 0; \n    }\n\n    static void _test(){\n        ll N=rd(),M=rd(); Matrix A(N,M,{});\n        for(ll i=0;i<N;i++) for(ll j=0;j<M;j++) A.push_back(rd());\n        A.stair(); cout<<A;\n    }\n};\n\n// --- automata ---\ntemplate <int PTN,int STRN,int CHAR,char OFFSET>\nclass ACAutomation{public: // id: 0 is null, 1 is start\n    struct Vtx{\n        int fail;\n        array<int,CHAR> ch;\n    }vtx[PTN];\n    int last[STRN];\n    int vn,sn;\n    ACAutomation(){\n        sn=0; vn=0; vtx[++vn]={0};\n        for(int c=0;c<CHAR;c++) vtx[0].ch[c]=1;\n    }\n    void insert(string s){\n        int p=1;\n        for(char c : s){ c-=OFFSET;\n            if(!vtx[p].ch[c]) vtx[p].ch[c]=++vn;\n            p=vtx[p].ch[c];\n        } last[++sn]=p;\n    }\n    void buildFail(){\n        queue<int> que; que.push(1);\n        while(!que.empty()){\n            int p=que.front(),f=vtx[p].fail; que.pop();\n            for(int c=0;c<CHAR;c++){ int q=vtx[p].ch[c];\n                if(q) vtx[q].fail=vtx[f].ch[c],que.push(q);\n                else vtx[p].ch[c]=vtx[f].ch[c];\n            }\n        }\n    }\n    // below: subject to problem Lugou P5357\n    int cnt[PTN];\n    void match(string s){\n        for(int i=1;i<=vn;i++) cnt[i]=0;\n        int p=1;\n        for(char c : s){ c-=OFFSET;\n            p=vtx[p].ch[c];\n            cnt[p]++;\n        }\n    }\n    vector<int> edge[PTN];\n    void buildTree(){ // fail tree\n        for(int u=1;u<=vn;u++) edge[u].clear();\n        for(int u=2;u<=vn;u++) edge[vtx[u].fail].push_back(u);\n        function<void(int)> dfs=[&](int u){\n            for(int v : edge[u]) dfs(v),cnt[u]+=cnt[v];\n        }; dfs(1);\n    }\n    void answer(){\n        for(int i=1;i<=sn;i++) cout<<cnt[last[i]]<<'\\n';\n    }\n};\ntypedef ACAutomation<int(1E6+5),int(1E6+5),26,'a'> ACAM;\n\ntemplate<int PTN> // 2 * length of string suffices\nclass SuffixAutomation{public: // id: 0 is null, 1 is start\n    struct Vtx{\n        int fa,len; bool real;\n        map<char,int> ch; // feel free to modify to array<int,26>\n    }vtx[PTN];\n    int n,last;\n    SuffixAutomation(){n=last=0; vtx[++n]={0,0,true}; last=n;}\n    void insert(char c){\n        int p=last,cur=++n; vtx[cur]={0,vtx[last].len+1,true};\n        for(;p&&!vtx[p].ch[c];p=vtx[p].fa) vtx[p].ch[c]=cur;\n        int q=vtx[p].ch[c];\n        if(!p) vtx[cur].fa=1;\n        else if(vtx[q].len==vtx[p].len+1) vtx[cur].fa=q;\n        else{ // vtx[q].len>vtx[p].len+1, partition needed\n            vtx[++n]=vtx[q]; vtx[n].real=false; vtx[n].len=vtx[p].len+1;\n            for(;p&&vtx[p].ch[c]==q;p=vtx[p].fa) vtx[p].ch[c]=n;\n            vtx[cur].fa=vtx[q].fa=n;\n        }\n        last=cur;\n    }\n    ll LCSWith(string s){ // as an example of matching\n        ll p=1; ll ans=0,cnt=0;\n        for(char c : s){\n            if(vtx[p].ch[c]) cnt++;\n            else{\n                for(;p&&!vtx[p].ch[c];p=vtx[p].fa);\n                cnt=p?vtx[p].len+1:0;\n            } ans=max(ans,cnt);\n            p=p?vtx[p].ch[c]:1;\n        } return ans;\n    }\n    // below: subject to problem Luogu P3804\n    vector<int> edge[PTN]; int sz[PTN];\n    void buildTree(){\n        for(int u=1;u<=n;u++) edge[u].clear();\n        for(int u=2;u<=n;u++) edge[vtx[u].fa].push_back(u);\n        function<void(int)> dfs=[&](int u){\n            sz[u]=vtx[u].real;\n            for(int v : edge[u]) dfs(v),sz[u]+=sz[v];\n        }; dfs(1);\n    }\n    ll answer(){\n        ll ans=0;\n        for(ll u=1;u<=n;u++) if(sz[u]>1) ans=max(ans,1LL*sz[u]*vtx[u].len);\n        return ans; \n    }\n};\ntypedef SuffixAutomation<int(2E6+5)> SAM;\n\ntemplate <int PTN>\nclass PalindromicAutomation{public: // id: 1 is odd root, 0 is even root (as fallback)\n    struct Vtx{\n        int fail,len;\n        map<char,int> ch; // feel free to modify to array<int,26>\n    }vtx[PTN];\n    int vn,sn,last; char s[PTN];\n    int cnt[PTN]; // subject to problem Luogu P5496\n    PalindromicAutomation(){\n        vn=1; vtx[0]={1,0}; vtx[1]={0,-1}; // fail[even]=odd, fail[odd]=even\n        last=0; sn=0;\n    }\n    int getValid(int p){ // even is never valid, odd is always valid\n        for(;s[sn-vtx[p].len-1]!=s[sn];p=vtx[p].fail);\n        return p;\n    }\n    void insert(char c){\n        s[++sn]=c; int p=getValid(last); \n        if(!vtx[p].ch[c]){\n            int f=getValid(vtx[p].fail); // when p=odd, fail[p]=even, then f is still odd\n            vtx[++vn]={vtx[f].ch[c],vtx[p].len+2}; // len[odd]=-1 useful here\n                                                   // vtx[f].ch[c]=0 only happens when p=odd\n                                                   // for s[sn-vtx[p].len-1..sn] is already a palindrome\n            vtx[p].ch[c]=vn;\n            cnt[vn]=cnt[vtx[vn].fail]+1; // subject...\n        } last=vtx[p].ch[c];\n        cout<<cnt[last]<<\" \"; // subject...\n    }\n};\ntypedef PalindromicAutomation<int(1E6+5)> PAM;\n\nvoid entry(){\n    \n}\nint main(){\n    //freopen(\"t1.in\",\"r\",stdin);\n    //freopen(\"t1.out\",\"w\",stdout);\n    //ll T=rd(); while(T--){\n        entry();\n    //}\n    return 0;\n}\n\n```\n\n#### model_temp.cpp\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// --- CAUTION uncensored ---\nnamespace MaxFlow{\n    const int INF=999999999;\n    const int PTN=20005,EDN=400005;\n    struct Edge{\n        int u,v,w;int nxt;\n    }edge[EDN];\n    int graN,graM,last[PTN];\n    void GraphInit(){graM=0;for(int i=0;i<PTN;i++) last[i]=0;}\n    void AddBscEdge(int u,int v,int w){\n        edge[++graM]=(Edge){u,v,w,last[u]};\n        last[u]=graM;\n    }\n    void AddNetEdge(int u,int v,int w){\n        AddBscEdge(u,v,w);AddBscEdge(v,u,0);\n    }\n    int Un(int x){if(x%2==0) return x-1;else return x+1;}\n\n    int ST,ED;int dis[PTN],gap[PTN],cur[PTN];\n    bool bomb;\n    int Send(int u,int ret){\n        if(u==ED) return ret;\n        int gone=0;\n        for(int& i=cur[u];i!=0;i=edge[i].nxt){\n            int v=edge[i].v,w=edge[i].w;\n            if(w==0||dis[u]-1!=dis[v]) continue;\n            int tmp=Send(v,min(ret,w));\n            edge[i].w-=tmp;\n            edge[Un(i)].w+=tmp;\n            ret-=tmp;gone+=tmp;\n            if(ret==0||bomb) return gone;\n        }\n        if(--gap[dis[u]]==0) bomb=1;\n        gap[++dis[u]]++;\n        return gone;\n    }\n    int ISAP(int st,int ed){\n        ST=st;ED=ed;\n        for(int i=1;i<=graN;i++) dis[i]=0,gap[i]=0;\n        gap[0]=graN;\n        bomb=0;int mxFlow=0;\n        while(!bomb){\n            for(int i=1;i<=graN;i++) cur[i]=last[i];\n            mxFlow+=Send(ST,INF);\n        }\n        return mxFlow;\n    }\n}\nnamespace CostFlow{\n    const int INF=999999999;\n    const int PTN=10005,EDN=200005;\n    struct Edge{\n        int u,v,w,c;int nxt;\n    }edge[EDN];\n    int graN,graM,last[PTN];\n    void GraphInit(){graM=0;for(int i=0;i<PTN;i++) last[i]=0;}\n    void AddBscEdge(int u,int v,int w,int c){\n        edge[++graM]=(Edge){u,v,w,c,last[u]};\n        last[u]=graM;\n    }\n    void AddNetEdge(int u,int v,int w,int c){\n        AddBscEdge(u,v,w,c);AddBscEdge(v,u,0,-c);\n    }\n    int Un(int x){if(x%2==0) return x-1;else return x+1;}\n\n    int mxFlow,miCost,ST,ED;\n    int dis[PTN],isQ[PTN],pre[PTN];\n    int Q[10*PTN],hd,tl;\n    bool SPFA(){\n        for(int i=1;i<=graN;i++) dis[i]=INF,isQ[i]=0;\n        hd=1;tl=0;\n        dis[ST]=0;isQ[ST]=1;Q[++tl]=ST;\n        while(hd<=tl){\n            int u=Q[hd++];isQ[u]=0;\n            for(int i=last[u];i!=0;i=edge[i].nxt){\n                int v=edge[i].v,w=edge[i].w,c=edge[i].c;\n                if(w==0) continue;\n                if(dis[v]>dis[u]+c){\n                    dis[v]=dis[u]+c;pre[v]=i;\n                    if(!isQ[v]){\n                        isQ[v]=1;\n                        Q[++tl]=v;\n                    }\n                }\n            }\n        }\n        if(dis[ED]>=INF) return 0;\n        return 1;\n    }\n    void Adjust(){\n        int dlt=INF;\n        for(int v=ED;v!=ST;v=edge[pre[v]].u)\n            dlt=min(dlt,edge[pre[v]].w);\n        for(int v=ED;v!=ST;v=edge[pre[v]].u){\n            edge[pre[v]].w-=dlt;\n            edge[Un(pre[v])].w+=dlt;\n        }\n        mxFlow+=dlt;miCost+=dlt*dis[ED];\n    }\n    void EK(int st,int ed){\n        ST=st,ED=ed;\n        mxFlow=miCost=0;\n        while(SPFA()) Adjust();\n    }\n}\nnamespace Tarjan{\n    const ll PTN=1E6+5,EDN=2E6+5;\n    ll N;\n    struct Edge{ll u,v;bool w;ll nxt;};\n    Edge edge[EDN];\n\tll graM,last[PTN];\n\tvoid GraphInit(){graM=0;for(ll i=0;i<PTN;i++) last[i]=0;}\n\tvoid AddBscEdge(ll u,ll v,bool w){\n\t    edge[++graM]=(Edge){u,v,w,last[u]};\n\t    last[u]=graM;\n\t}\n    ll bel[PTN],cN,rps[PTN]; //belong, number of components, representative vertax of the component\n    ll dfn[PTN],low[PTN],dN;\n    ll stk[PTN],tp;bool isI[PTN];\n    void Tarjan(ll u){\n\t    dfn[u]=low[u]=++dN;\n\t    stk[++tp]=u;isI[u]=1;\n\t    for(ll i=last[u];i!=0;i=edge[i].nxt){\n\t\t    ll v=edge[i].v;\n\t\t    if(isI[v]){\n\t\t\t    low[u]=min(low[u],dfn[v]);\n\t\t    }else if(!dfn[v]){\n\t\t\t    Tarjan(v);\n\t\t\t    low[u]=min(low[u],low[v]);\n\t\t    }\n\t    }\n\t    if(dfn[u]==low[u]){\n\t\t    rps[++cN]=u;ll t;\n\t\t    do{\n\t    \t\tt=stk[tp--];\n    \t\t\tisI[t]=0;bel[t]=cN;\n    \t\t}while(t!=u);\n    \t}\n    }\n}\n\n```\n\n",
    "supporting": [
      "index_files\\figure-pdf"
    ],
    "filters": []
  }
}